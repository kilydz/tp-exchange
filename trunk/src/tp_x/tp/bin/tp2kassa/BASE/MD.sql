/******************************************************************************/
/***          Generated by IBExpert 2009.03.23 22.12.2011 20:06:54          ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

CREATE DATABASE '192.168.133.55:/BASE/FB_KASSA.GDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 4096
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION DAYWEEK
    CSTRING(10)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'VimasDayWeek' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION DECODE5
    CSTRING(2),
    CSTRING(2),
    DOUBLE PRECISION,
    CSTRING(2),
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'VimasDecode5' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION DNVL
    DOUBLE PRECISION BY DESCRIPTOR,
    DOUBLE PRECISION BY DESCRIPTOR
    RETURNS DOUBLE PRECISION BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION GETSTRPARSER
    DOUBLE PRECISION
    RETURNS CSTRING(255)
    ENTRY_POINT 'GetStrParser' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION INSTR
    CSTRING(256),
    CSTRING(256)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'VimasInstr' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION INVL
    INTEGER BY DESCRIPTOR,
    INTEGER BY DESCRIPTOR
    RETURNS INTEGER BY DESCRIPTOR
    ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';


DECLARE EXTERNAL FUNCTION MD5_HASH
    CSTRING(32767)
    RETURNS CSTRING(33)
    ENTRY_POINT 'MD5_HASH' MODULE_NAME 'my_udf';


DECLARE EXTERNAL FUNCTION MOD1
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'VimasMod' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION MY_FIND_WORD_IDX
    CSTRING(50),
    CSTRING(512),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'FIND_WORD_START_WORD' MODULE_NAME 'my_udf';


DECLARE EXTERNAL FUNCTION RTRIM
    CSTRING(80)
    RETURNS CSTRING(80) FREE_IT
    ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION RUN_SHELL
    CSTRING(4196),
    CSTRING(4196),
    INTEGER
    RETURNS CSTRING(32767)
    ENTRY_POINT 'RUN_SHELL' MODULE_NAME 'my_udf';


DECLARE EXTERNAL FUNCTION SELFTRUNC
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT 'VimasSelfTrunc' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION STRLEN
    CSTRING(32767)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf';


DECLARE EXTERNAL FUNCTION SUBSTR
    CSTRING(256),
    SMALLINT,
    SMALLINT
    RETURNS CSTRING(256)
    ENTRY_POINT 'VimasSubstr' MODULE_NAME 'udfvimas';


DECLARE EXTERNAL FUNCTION TICKCOUNT

    RETURNS INTEGER BY VALUE
    ENTRY_POINT 'TICKCOUNT' MODULE_NAME 'my_udf';




/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_APP_ERRORS_ID;
SET GENERATOR GEN_APP_ERRORS_ID TO 0;

CREATE GENERATOR GEN_CATALOG_ITEM;
SET GENERATOR GEN_CATALOG_ITEM TO 11;

CREATE GENERATOR GEN_CODE_AUDIT;
SET GENERATOR GEN_CODE_AUDIT TO 164869;

CREATE GENERATOR GEN_CODE_CALCULATION;
SET GENERATOR GEN_CODE_CALCULATION TO 170853;

CREATE GENERATOR GEN_CODE_ZREPORT;
SET GENERATOR GEN_CODE_ZREPORT TO 640;

CREATE GENERATOR GEN_CODE_ZREPORT_REC;
SET GENERATOR GEN_CODE_ZREPORT_REC TO 3780;

CREATE GENERATOR GEN_MY_WORD_ID;
SET GENERATOR GEN_MY_WORD_ID TO 1201861;

CREATE GENERATOR GEN_NUMBER_CALCULATION;
SET GENERATOR GEN_NUMBER_CALCULATION TO 170853;

CREATE GENERATOR GEN_NUMBER_TAX_INVOICE;
SET GENERATOR GEN_NUMBER_TAX_INVOICE TO 0;

CREATE GENERATOR GEN_NUM_CHECK_CREDIT;
SET GENERATOR GEN_NUM_CHECK_CREDIT TO 0;

CREATE GENERATOR GEN_RETURN_ID;
SET GENERATOR GEN_RETURN_ID TO 98;

CREATE GENERATOR GETCODECASSAOPERATION;
SET GENERATOR GETCODECASSAOPERATION TO 1419;

CREATE GENERATOR GETCODEORDER;
SET GENERATOR GETCODEORDER TO 164141;

CREATE GENERATOR GETNUMBERORDER;
SET GENERATOR GETNUMBERORDER TO 164141;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION CANT_RETURN_WARES 'Неможливо повернути цей товар. Так як він відсутній у видатковій накладній.';

CREATE EXCEPTION CHECKTRANSFER 'Операцию выполнить невозможно. Заказ уже передан на сервер';

CREATE EXCEPTION WARESNOTFOUND 'Не найден товар';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE ADDGROUPINGWHENWRITECALC (
    INTCODEWARES INTEGER,
    INTCHECKOPTION INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ADDWARESTOORDER (
    INTCODEORDER INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1),
    REALVAT NUMERIC(7,4),
    INTRECNO INTEGER,
    INTADDGROUPING INTEGER,
    CHTYPEORDER CHAR(2),
    NDISCOUNTPOSITION DOUBLE PRECISION,
    DATEORDER DATE)
RETURNS (
    RESULT INTEGER,
    INTCODEPROBLEMINVOICE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE ADDWARESTORETURN (
    INTCODERETURN INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(7,4),
    INTADDGROUPING INTEGER,
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CANEDITORDER (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CANYOUGETDOIT (
    KAK CHAR(1),
    DOC CHAR(2),
    CODEDOC INTEGER,
    TYPEDOC CHAR(2),
    HOW CHAR(1),
    TABNAME VARCHAR(30),
    OPER CHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CHECKCLOSESHIFT (
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CHECKINDICATIVE (
    NPRICE DOUBLE PRECISION,
    DINDICATIVEBEGINDATE DATE,
    DINDICATIVEENDDATE DATE,
    NINDICATIVEMINPRICE DOUBLE PRECISION,
    NINDICATIVEMAXPRICE DOUBLE PRECISION,
    CHINDICATIVEACTIVE CHAR(1),
    INTINDICATIVECODECURRENCY INTEGER,
    INTCODECURRENCY INTEGER,
    INTCODESUBGROUP INTEGER)
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CHECKLASTCHECK (
    IDWORKPLACE INTEGER,
    CODEWAREHOUSE INTEGER,
    INTCODEDOCUMENT INTEGER,
    CHTYPEDOCUMENT CHAR(1))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CHECKSPECPROPOSITIONTIME (
    INTCATSPECPROPOSITION INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE CHECKUSERACCESS (
    USERNAME VARCHAR(30),
    SERIALNUMBERFP VARCHAR(50))
RETURNS (
    USERPASSWORD VARCHAR(50),
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE COMPARE_ORDERS
RETURNS (
    CODE_ORDER INTEGER,
    SUM_ORDER NUMERIC(18,2),
    COUNT_WARES INTEGER,
    CODE_ORDER_DUBLE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE DELETERETURN (
    INTCODERETURN INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE EXISTUNITDIVISIONAL (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FILLCAPTIONORDER (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER,
    INTCODESUBGROUP INTEGER,
    CHTYPEPAYMENT CHAR(2),
    INTCODEMANAGER INTEGER,
    INTIDCASHREGISTER INTEGER,
    REALDISCOUNT NUMERIC(9,6),
    REALPERPP NUMERIC(5,2),
    DATEPAYMENT DATE,
    CHDESCRIPTION VARCHAR(250),
    INTCODEEND INTEGER,
    INTCODEORDERCACHE INTEGER,
    INTNUMBERORDERCACHE INTEGER,
    INTUSERCHANGECACHE INTEGER,
    DATEDATECHANGECACHE TIMESTAMP,
    INTINDICATION INTEGER,
    CHTYPEVAT CHAR(2),
    DATEORDER DATE,
    CHCREDITCARD CHAR(1),
    CHTYPEORDER CHAR(2),
    INTPRIORITY INTEGER,
    INTCODEDELIVERY INTEGER,
    INTCODEADDITIONSIGN INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FILLCAPTIONRETURN (
    INTCODESUBGROUP INTEGER,
    DATERETURN DATE,
    INTNUMBERCHECK INTEGER,
    DATECHECK TIMESTAMP,
    CHTYPEVAT CHAR(2),
    IDWORKPLACE INTEGER,
    INTCODEADDSIGN INTEGER,
    CHDESCRIPTION VARCHAR(250),
    CHTYPEPAYMENT CHAR(2),
    IDWORKPLACESALE INTEGER,
    CHSERIALNUMBERSALE VARCHAR(30),
    CHMODELSALE VARCHAR(50))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICECHANGEDATEORDER (
    INTCODECALCULATION INTEGER,
    DATEORDER DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE FRONTOFFICECHECKFRACTIONALNUM (
    REALVALUE DOUBLE PRECISION)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICEDELETEORDER (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICEEXISTUNITDIVISIONAL (
    INTCODEWARES INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICEEXISTUNITLOCKING (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICEWRITEORDER (
    INTCODEORDER INTEGER,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    DATEORDER DATE,
    DATETAKE DATE,
    CHCREDITCARD CHAR(1),
    CHNUMBERSLIP VARCHAR(30),
    INTCODECREDITCARD INTEGER,
    CHDESCRIPTIONCREDITCARD VARCHAR(255),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
RETURNS (
    RESULT INTEGER,
    CHCODESOUTINVOICE VARCHAR(30),
    CHCODESCALCULATION VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE FRONTOFFICEWRITERECEIPT (
    INTCODECALCULATION INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50),
    NOTCHECK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE GET_BARCODE_PARAMS
RETURNS (
    FIRST_CHAR_CODE INTEGER,
    LAST_CHAR_CODE INTEGER,
    FIRST_CHAR_WEIGHT INTEGER,
    LAST_CHAR_WEIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_DATASET_PARAM_ATTRIBS (
    ALEVEL_ID INTEGER,
    AREPORT_ID INTEGER,
    APARAM_NAME VARCHAR(100))
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_FULL_REPORTNAME (
    AREPORT_ID INTEGER)
RETURNS (
    FULL_NAME VARCHAR(500))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_NUMBERS_CHECK (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT VARCHAR(150))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_REPORT_TEMPLATE_ATTRIBS (
    ALEVEL_ID INTEGER,
    ATEMPLATE_ID INTEGER)
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    AMASTER_VALUE VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GET_REPORT_VARIABLE_ATTRIBS (
    ALEVEL_ID INTEGER,
    AREPORT_ID INTEGER,
    AVARIABLE_NAME VARCHAR(100))
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETADDGROUPINGSTR (
    INTADDGROUPING INTEGER)
RETURNS (
    RESULT VARCHAR(8))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETBARCODECLIENTSIZE
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCLIENTINFO (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER)
RETURNS (
    NAME VARCHAR(212),
    BAR_CODE DOUBLE PRECISION,
    VARIANT_PAYMENT CHAR(2),
    IMPOCITION VARCHAR(15),
    AGREE_NUMBER VARCHAR(20),
    PHONE VARCHAR(111),
    ADDRESS VARCHAR(70),
    NAME_FOR_PRINT VARCHAR(250),
    INDEX_MAIL VARCHAR(10),
    CODE_CITY INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCLIENTWITHATTRIB (
    INTLOCATE INTEGER,
    INTLOCATEOPTIONS INTEGER)
RETURNS (
    RESULT INTEGER,
    INTCODEDEALER INTEGER,
    INTCODEPRIVAT INTEGER,
    INTCODECLIENT INTEGER,
    INTCODEMANAGER INTEGER,
    INTMAXENDPAYMENT INTEGER,
    REALDISCOUNT FLOAT,
    REALPERCENT FLOAT,
    CHCOURSE CHAR(2),
    CHRECALCORDER CHAR(2),
    CHVARIANTPAYMENT CHAR(2),
    CHTYPEDISCOUNT CHAR(2),
    INTACTIVECONTRACT INTEGER,
    CHTYPECLIENT CHAR(1),
    CHNAMECLIENT VARCHAR(212),
    NBARCODE DOUBLE PRECISION,
    CHABRDEALER VARCHAR(8),
    CHDISCOUNTPOSITION CHAR(2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODEDATABASE
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODESUBGROUPUSERLOGON (
    CHNAMEUSER VARCHAR(30))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODEUNITBASISORDEFAULT (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODEUNITDEFAULTOFWARES (
    INTCODEWARES INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODEUSER
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCODEUSERGLOBAL
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETCOEFFICIENT (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT FLOAT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETFULLSUMCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETINFXREPORT (
    IDWORKPLACE INTEGER)
RETURNS (
    CHECKCOUNT INTEGER,
    BEGINCHECK INTEGER,
    LASTCHECK INTEGER,
    BEGINCASSA NUMERIC(15,2),
    CURRENTCASSA NUMERIC(15,2),
    RESULT TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETNAMEWARESRECEIPT (
    CHBARCODE VARCHAR(30),
    INTCODEWARES INTEGER,
    CHNAMEWARES VARCHAR(100))
RETURNS (
    RESULT VARCHAR(300))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETNDSCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETNDSINNER (
    INTCODEWARES INTEGER,
    INTCHECKOPTION INTEGER)
RETURNS (
    RESULT NUMERIC(5,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETNUMORDERFROMCODEORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETONOFFOPTIONS (
    CHTYPE VARCHAR(2),
    CHVARIETY VARCHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETONOFFOPTIONSOFUSER (
    CHTYPE VARCHAR(2),
    CHVARIETY VARCHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETPRICE (
    INTCODEWARES INTEGER,
    INTCODESUBGROUP INTEGER,
    INTCODEUNIT INTEGER,
    INTCODECURRENCYPRICE INTEGER,
    NPRICE DOUBLE PRECISION,
    INTCODECURRENCY INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETPRICEDEALERWARESCUR (
    INTCODEWARES INTEGER,
    INTCODESUBGROUP INTEGER,
    INTCODEDEALER INTEGER,
    INTCODEUNIT INTEGER,
    INTCODECURRENCY INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    INTCODECURRENCYPRICE INTEGER,
    RMARKUP NUMERIC(8,2),
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETPRICEDEALERWARESPRN (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER,
    INTCODEDEALER INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETPRICEWARES (
    INTCODEWARES INTEGER,
    NQUANTITY NUMERIC(15,3),
    INTCODEUNIT INTEGER,
    INTCODEDEALER INTEGER,
    INTCODESUBGROUP INTEGER,
    CHTYPEVAT CHAR(2),
    NDISCOUNT FLOAT,
    INTACTIVECONTRACT INTEGER,
    INTCODECLIENT INTEGER,
    NDISCOUNTPOSITIONIN FLOAT,
    REALVAT NUMERIC(5,2))
RETURNS (
    RESULT INTEGER,
    NDISCOUNTPOSITION FLOAT,
    NPRICE DOUBLE PRECISION,
    NPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETRETURNWARES (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER,
    CHTYPEVAT CHAR(2),
    CHUNIT CHAR(1),
    NUMBERCHECK VARCHAR(30),
    DATECHECK DATE)
RETURNS (
    RESULT INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    RPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(5,2),
    INTADDGROUPING INTEGER,
    CHNAMEUNIT CHAR(4),
    CHNAMEWARES VARCHAR(100),
    CHCODEBARWARES VARCHAR(30),
    CHARTICLWARES VARCHAR(30),
    DATETIMECHECK TIMESTAMP,
    CHNAMECLIENT VARCHAR(212),
    INTCODEORDER INTEGER,
    QTYRETURN NUMERIC(16,3),
    CHTYPEPAYMENT CHAR(2),
    CHSERIALNUMBER VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSTATECALCULATION (
    INTCODEEND INTEGER)
RETURNS (
    STATE_CALCULATION CHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSTATEORDER (
    INTCODEORDER INTEGER,
    INTCODEEND INTEGER)
RETURNS (
    STATE_ORDER CHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSTATUSTRANSFERSTRING (
    CHTYPEDOCUMENT CHAR(1),
    INTCODEDOCUMENT INTEGER)
RETURNS (
    RESULT VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSUMCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSUMCHECKFROMLASTZREPORT (
    CHNUMBERCASHREGISTER VARCHAR(50),
    CODEWAREHOUSE INTEGER)
RETURNS (
    RESULT NUMERIC(15,2),
    RSUMCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RSUMCARD NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSUMORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSUMORDERCATALOGCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETSUMRETURNCACHE (
    INTCODERETURN INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETUSERID
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE GETWARESWITHPRICE (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER,
    INTCODEDEALER INTEGER,
    INTCODESUBGROUP INTEGER,
    CHUNIT CHAR(1),
    CHTYPEDISCOUNT CHAR(1),
    CHRECALCCOURSE CHAR(1),
    REALQUANTITY NUMERIC(16,3),
    REALDISCOUNT FLOAT,
    INTACTIVECONTRACT INTEGER,
    INTCODECLIENT INTEGER,
    CHDISCOUNTPOSITION CHAR(1),
    CHTYPEVAT CHAR(2),
    INTEXISTWARES INTEGER,
    INTCODEUNITIN INTEGER,
    NDISCOUNTPOSITIONIN FLOAT)
RETURNS (
    RESULT INTEGER,
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    CHNAMEUNIT VARCHAR(4),
    CHNAMEWARES VARCHAR(100),
    CHCODEBARWARES VARCHAR(30),
    CHARTICLWARES VARCHAR(30),
    REALVAT NUMERIC(5,2),
    REALPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1),
    INTADDGROUPING INTEGER,
    NEXISTWARES INTEGER,
    NDISCOUNTPOSITION FLOAT,
    PRICE_IN DOUBLE PRECISION,
    UNIT_IN INTEGER,
    RQTY_IN NUMERIC(16,3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE INH_OK (
    C_CODE INTEGER)
RETURNS (
    P_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE INITPARAMETERS (
    USERNAME VARCHAR(30),
    ID_WORKPLACE INTEGER)
RETURNS (
    CASHNAME VARCHAR(50),
    CASHPASSWORD VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE LOCATEWARES (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER)
RETURNS (
    RESULT INTEGER,
    INTCODEUNIT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE MY_FROM_WARES_GROUPED_ID (
    WORD_01 VARCHAR(50),
    WORD_02 VARCHAR(50),
    WORD_03 VARCHAR(50),
    WORD_04 VARCHAR(50),
    WORD_05 VARCHAR(50),
    WORD_06 VARCHAR(50),
    WORD_07 VARCHAR(50),
    WORD_08 VARCHAR(50),
    WORD_09 VARCHAR(50),
    WORD_10 VARCHAR(50),
    WORD_11 VARCHAR(50),
    WORD_12 VARCHAR(50),
    WORD_COUNT INTEGER)
RETURNS (
    IDD INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE MY_FROM_WARES_SUBSTR (
    WORD_BIG VARCHAR(50),
    WORD_01 VARCHAR(50),
    WORD_02 VARCHAR(50),
    WORD_03 VARCHAR(50),
    WORD_04 VARCHAR(50),
    WORD_05 VARCHAR(50),
    WORD_06 VARCHAR(50),
    WORD_07 VARCHAR(50),
    WORD_08 VARCHAR(50),
    WORD_09 VARCHAR(50),
    WORD_10 VARCHAR(50),
    WORD_11 VARCHAR(50),
    WORD_12 VARCHAR(50),
    WORD_COUNT INTEGER)
RETURNS (
    WORD_IDX INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE MY_FROM_WARES_WORD (
    WORDS VARCHAR(50))
RETURNS (
    CODE_WARES INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE MY_INITPARAMETERS (
    USERNAME VARCHAR(30),
    ID_WORKPLACE INTEGER)
RETURNS (
    CASHNAME VARCHAR(50),
    CASHPASSWORD VARCHAR(50),
    NEED_TO_RUN_INIT_IF0 INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE MY_INTO_WARES_WORD (
    CODE_WARES INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE MY_INTO_WARES_WORD_INSERT (
    CODE_WARES INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE MY_MICRO_PROC (
    "VALUE" DOUBLE PRECISION,
    TEXT VARCHAR(100),
    NUMBER INTEGER,
    ACTIONZ INTEGER)
RETURNS (
    MICRO_PROC_RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_ADDWARESTORETURN (
    INTCODERETURN INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(7,4),
    INTADDGROUPING INTEGER,
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_FRONTOFFICEWRITEORDER (
    INTCODEORDER INTEGER,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    DATEORDER DATE,
    DATETAKE DATE,
    CHCREDITCARD CHAR(1),
    CHNUMBERSLIP VARCHAR(30),
    INTCODECREDITCARD INTEGER,
    CHDESCRIPTIONCREDITCARD VARCHAR(255),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
RETURNS (
    INTCODECALCULATION INTEGER,
    RESULT INTEGER,
    CHCODESOUTINVOICE VARCHAR(30),
    CHCODESCALCULATION VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_FRONTOFFICEWRITERECEIPT (
    INTCODEORDER INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50),
    NOTCHECK INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE NEW_GET_NUMBERS_CHECK (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT VARCHAR(150),
    CODEORDER_IN INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_GETCLIENTINFO (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER)
RETURNS (
    CODECLIENT_IN INTEGER,
    NAME VARCHAR(212),
    BAR_CODE DOUBLE PRECISION,
    VARIANT_PAYMENT CHAR(2),
    IMPOCITION VARCHAR(15),
    AGREE_NUMBER VARCHAR(20),
    PHONE VARCHAR(111),
    ADDRESS VARCHAR(70),
    NAME_FOR_PRINT VARCHAR(250),
    INDEX_MAIL VARCHAR(10),
    CODE_CITY INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_GETSTATEORDER (
    INTCODEORDER INTEGER,
    INTCODEEND INTEGER)
RETURNS (
    STATE_ORDER CHAR(1),
    CODEORDER_IN INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_GETSUMORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2),
    CODEORDER_IN INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_WRITEOPERATION (
    CHNUMBERCASHREGISTER VARCHAR(50),
    TYPEOPER INTEGER,
    INTCODEREASON INTEGER,
    CODECASHIER INTEGER,
    RSUMMA NUMERIC(15,2),
    CODEWAREHOUSE INTEGER,
    DESCRIPTION VARCHAR(255),
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE NEW_WRITEZREPORT (
    INTCODEZREPORT INTEGER,
    Z_ZVIT_NUM INTEGER,
    CHNUMBERCASHREGISTER VARCHAR(50),
    RSUMREPORT NUMERIC(15,2),
    RSUMREPORTCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2),
    CHDATEREPORT TIMESTAMP,
    CODEWAREHOUSE INTEGER,
    RSUMCARD NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE OPTS_GET_BOOL_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE OPTS_GET_REAL_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE OPTS_GET_VCHAR_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT VARCHAR(254))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_FR_SYNC (
    PASS_SERVER_TP VARCHAR(10),
    USER_SERVER_TP VARCHAR(10),
    SERVER_TP VARCHAR(255),
    KASSA_ID INTEGER)
RETURNS (
    EX_PARAM INTEGER,
    DOC_COUNT INTEGER,
    OMSG VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE REFRESH_QUALITY_CHECK (
    TP_CONNECT_STRING VARCHAR(255))
RETURNS (
    CODE_WAREZ INTEGER,
    PRICE_TP DOUBLE PRECISION,
    PRICE_LOCAL DOUBLE PRECISION,
    PRICE_TP_TIMESTAMP TIMESTAMP,
    CODE_UNITZ INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE REFRESH_SERVICE (
    PASS_SERVER_TP VARCHAR(10),
    USER_SERVER_TP VARCHAR(10),
    SERVER_TP VARCHAR(255),
    KASSA_ID INTEGER)
RETURNS (
    EX_PARAM INTEGER,
    DOC_COUNT INTEGER,
    OMSG VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SAVEAPPERRORS (
    CHAPPSOURCE INTEGER,
    INTORANUMERROR INTEGER,
    CHORAMSGERROR VARCHAR(254),
    CHMSGERROR VARCHAR(2000),
    INTAPPIDRECORD_1 INTEGER,
    INTAPPIDRECORD_2 INTEGER,
    INTAPPIDRECORD_3 INTEGER,
    INTAPPIDRECORD_4 INTEGER,
    INTAPPIDRECORD_5 INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TEST_REFRESH_SERVICE_TP
RETURNS (
    REFRESH_TYPE_OK VARCHAR(1),
    WORK_TIME_OUT INTEGER,
    DOC_COUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE UPDATEOPTIONS (
    CHOPTIONS VARCHAR(255),
    CHTYPEOPTIONS CHAR(2),
    CHVARIETYOPTIONS CHAR(2),
    CHCHECKOPTIONS CHAR(2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE UPDREPOSITQUERY (
    CHNAMEGRID VARCHAR(50),
    CHNAMEDATASET VARCHAR(50),
    CHWHEREOLD VARCHAR(3000),
    CHWHEREFULL VARCHAR(3000),
    CHFULL VARCHAR(4000),
    FADD CHAR(1))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE V_WARES_ORDER_FOR_RETURN (
    INTCODEORDER INTEGER,
    INTCODEWARES INTEGER,
    COEF FLOAT)
RETURNS (
    CODE_ORDER INTEGER,
    CODE_WARES INTEGER,
    QUANTITY_IN_BASIS_RET NUMERIC(16,3),
    CODE_UNIT INTEGER,
    COEFFICIENT NUMERIC(18,6),
    ORD NUMERIC(18,6))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE V_WARESRECEIPTORDER (
    CODE_ORDERS INTEGER)
RETURNS (
    CODE_ORDER INTEGER,
    VAT NUMERIC(7,4),
    ADD_GROUPING INTEGER,
    CODE_WARES INTEGER,
    CODE_UNIT INTEGER,
    ARTICL VARCHAR(30),
    BAR_CODE VARCHAR(30),
    REC_NO INTEGER,
    NAME_WARES_RECEIPT VARCHAR(50),
    NAME_WARES VARCHAR(100),
    NAME_WARES_STR_1 VARCHAR(33),
    NAME_WARES_STR_2 VARCHAR(33),
    NAME_WARES_STR_3 VARCHAR(33),
    C_NAME_UNIT_INV CHAR(4),
    PRICE DOUBLE PRECISION,
    PRICEWITHVAT NUMERIC(15,2),
    PRICE_CATALOG DOUBLE PRECISION,
    PRICE_CATALOG_WITHVAT NUMERIC(15,2),
    SUMQUANTITY NUMERIC(16,3),
    SUMPRICE DOUBLE PRECISION,
    SUMPRICEWITHVAT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE V_WARESRECEIPTRETURN (
    CODE_RETURNS INTEGER)
RETURNS (
    CODE_RETURN INTEGER,
    VAT NUMERIC(7,4),
    ADD_GROUPING INTEGER,
    CODE_WARES INTEGER,
    CODE_UNIT INTEGER,
    ARTICL VARCHAR(30),
    BAR_CODE VARCHAR(30),
    NAME_WARES_RECEIPT VARCHAR(50),
    NAME_WARES VARCHAR(100),
    NAME_WARES_STR_1 VARCHAR(33),
    NAME_WARES_STR_2 VARCHAR(33),
    NAME_WARES_STR_3 VARCHAR(33),
    C_NAME_UNIT_INV CHAR(4),
    PRICE DOUBLE PRECISION,
    PRICEWITHVAT NUMERIC(15,2),
    SUMQUANTITY NUMERIC(16,3),
    SUMPRICE DOUBLE PRECISION,
    SUMPRICEWITHVAT NUMERIC(15,5))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WRITEOPERATION (
    CHNUMBERCASHREGISTER VARCHAR(50),
    TYPEOPER INTEGER,
    INTCODEREASON INTEGER,
    CODECASHIER INTEGER,
    RSUMMA NUMERIC(15,2),
    CODEWAREHOUSE INTEGER,
    DESCRIPTION VARCHAR(255),
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WRITEOUTINVOICE (
    INTCODEORDER INTEGER,
    DATEOUTINVOICE DATE,
    DATETAKE DATE,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WRITERETURNRECEIPT (
    INTCODERETURN INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WRITESHIFTLOG (
    IDWORKPLACE INTEGER,
    CODEPRIVAT INTEGER,
    CHTYPE VARCHAR(2),
    CHVIEW VARCHAR(2))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WRITEZREPORT (
    CHNUMBERCASHREGISTER VARCHAR(50),
    RSUMREPORT NUMERIC(15,2),
    RSUMREPORTCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2),
    CHDATEREPORT TIMESTAMP,
    CODEWAREHOUSE INTEGER,
    RSUMCARD NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WRITEZREPORT_TAX (
    CODE_REPORT_IN INTEGER,
    Z_ZVIT_NUM INTEGER,
    CHNUMBERCASHREGISTER VARCHAR(50),
    CODE_OPERATION INTEGER,
    ZVIT_SUM_A DOUBLE PRECISION,
    ZVIT_SUM_B DOUBLE PRECISION,
    ZVIT_SUM_V DOUBLE PRECISION,
    ZVIT_SUM_G DOUBLE PRECISION,
    ZVIT_SUM_D DOUBLE PRECISION,
    ZVIT_SUM_E DOUBLE PRECISION)
RETURNS (
    INTCODENUMBERCASH INTEGER,
    CODE_REPORT INTEGER)
AS
BEGIN
  SUSPEND;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE A_ACTION (
    CODE_ACTION      INTEGER NOT NULL,
    CODE_FRAGMENT    INTEGER NOT NULL,
    EVENT_ID         CHAR(2) NOT NULL,
    NAME_ACTION      VARCHAR(254) NOT NULL COLLATE PXW_CYRL,
    HANDLE_MODULE    INTEGER,
    NUMBER_CHECK     VARCHAR(30),
    CODE_DOCUMENT    INTEGER,
    CODE_WARES       INTEGER,
    CODE_CLIENT      INTEGER,
    QUANTITY         NUMERIC(16,3),
    CODE_UNIT        INTEGER,
    PRICE            DOUBLE PRECISION,
    SUM_WITH_VAT     NUMERIC(15,2),
    DATE_CHANGE      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    USER_CHANGE      INTEGER NOT NULL,
    STATUS_TRANSFER  CHAR(1) DEFAULT '0' NOT NULL
);

CREATE TABLE A_CALC_CASH_REGISTER_CACHE (
    CODE_CALCULATION      INTEGER,
    NUMBER_RECEIPT        VARCHAR(30),
    DATE_RECEIPT          TIMESTAMP,
    ONLY_DATE_RECEIPT     DATE,
    NUMBER_CASHIER        VARCHAR(30),
    NUMBER_CASH_REGISTER  VARCHAR(30),
    MODEL_CASH_REGISTER   VARCHAR(50),
    USER_CHANGE           INTEGER,
    DATE_CHANGE           TIMESTAMP,
    A_USER_CHANGE         INTEGER,
    A_DATE_CHANGE         TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION           CHAR(3),
    A_NEW_OLD             CHAR(3)
);

CREATE TABLE A_CALCULATION_CACHE (
    CODE_ORDER          INTEGER,
    CODE_CALCULATION    INTEGER,
    CODE_SUBGROUP       INTEGER,
    CODE_FIRM           INTEGER,
    NUMBER_CALCULATION  INTEGER,
    DATE_CALCULATION    DATE,
    VAT                 NUMERIC(9,4),
    ADD_GROUPING        INTEGER,
    STATE_PAY           CHAR(1),
    NUMBER_TAX_INVOICE  INTEGER,
    DATE_OUT_INVOICE    DATE,
    DATE_TAKE           DATE,
    STATUS_TRANSFER     CHAR(1),
    A_USER_CHANGE       INTEGER,
    A_DATE_CHANGE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION         CHAR(3),
    A_NEW_OLD           CHAR(3)
);

CREATE TABLE A_CALCULATION_CREDIT_CARD_CACHE (
    CODE_CALCULATION  INTEGER,
    CODE_CREDIT_CARD  INTEGER,
    NUMBER_SLIP       VARCHAR(30),
    DESCRIPTION       VARCHAR(255),
    A_USER_CHANGE     INTEGER,
    A_DATE_CHANGE     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION       CHAR(3),
    A_NEW_OLD         CHAR(3)
);

CREATE TABLE A_CASSA_OPERATION (
    CODE_OPERATION      INTEGER,
    NUMBER_OPERATION    INTEGER,
    DATE_OPERATION      DATE,
    CODE_CASH_REGISTER  INTEGER,
    TYPE_OPERATION      CHAR(1),
    CODE_REASON         INTEGER,
    CODE_PRIVAT         INTEGER,
    SUMMA               NUMERIC(15,2),
    STATUS_TRANSFER     CHAR(1),
    A_USER_CHANGE       INTEGER,
    A_DATE_CHANGE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION         CHAR(3),
    A_NEW_OLD           CHAR(3)
);

CREATE TABLE A_ORDER_CLIENT_CACHE (
    CODE_ORDER          INTEGER,
    CODE_SUBGROUP       INTEGER,
    NUMBER_ORDER        INTEGER,
    DATE_ORDER          DATE,
    VARIETY_ORDER       CHAR(2),
    TYPE_ORDER          CHAR(2),
    TYPE_PAYMENT        CHAR(2),
    TYPE_VAT            CHAR(2),
    CODE_CLIENT         INTEGER,
    TYPE_CLIENT         CHAR(2),
    DATE_PAYMENT        DATE,
    CODE_DEALER         INTEGER,
    DISCOUNT            NUMERIC(9,6),
    PER_PP              NUMERIC(15,2),
    CODE_MANAGER        INTEGER,
    ID_WORKPLACE        INTEGER,
    CODE_END            INTEGER,
    INDICATION          INTEGER,
    PRIORITY            INTEGER,
    CODE_ADDITION_SIGN  INTEGER,
    DESCRIPTION         VARCHAR(250),
    USER_CHANGE         INTEGER,
    DATE_CHANGE         TIMESTAMP,
    A_USER_CHANGE       INTEGER,
    A_DATE_CHANGE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION         CHAR(3),
    A_NEW_OLD           CHAR(3)
);

CREATE TABLE A_RETURN_CACHE (
    CODE_RETURN                INTEGER,
    CODE_SUBGROUP              INTEGER,
    DATE_RETURN                DATE,
    NUMBER_CHECK               INTEGER,
    DATE_CHECK                 TIMESTAMP,
    TYPE_VAT                   CHAR(2),
    ID_WORKPLACE               INTEGER,
    CODE_FIRM                  INTEGER,
    CODE_WAREHOUSE             INTEGER,
    CODE_ADDITION_SIGN         INTEGER,
    TYPE_PAYMENT               CHAR(2),
    STATUS_TRANSFER            CHAR(1),
    ID_WORKPLACE_SALE          INTEGER,
    NUMBER_CASH_REGISTER_SALE  VARCHAR(30),
    MODEL_CASH_REGISTER_SALE   VARCHAR(30),
    DESCRIPTION                VARCHAR(250),
    USER_CHANGE                INTEGER,
    DATE_CHANGE                TIMESTAMP,
    A_USER_CHANGE              INTEGER,
    A_DATE_CHANGE              TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION                CHAR(3),
    A_NEW_OLD                  CHAR(3)
);

CREATE TABLE A_RETURN_REGISTER_CACHE (
    CODE_RETURN           INTEGER,
    NUMBER_RECEIPT        VARCHAR(30),
    DATE_RECEIPT          TIMESTAMP,
    NUMBER_CASHIER        VARCHAR(30),
    NUMBER_CASH_REGISTER  VARCHAR(30),
    MODEL_CASH_REGISTER   VARCHAR(50),
    USER_CHANGE           INTEGER,
    DATE_CHANGE           TIMESTAMP,
    A_USER_CHANGE         INTEGER,
    A_DATE_CHANGE         TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION           CHAR(3),
    A_NEW_OLD             CHAR(3)
);

CREATE TABLE A_SPA_EVENTS_AUDIT (
    EVENT_ID          CHAR(2),
    EVENT_NAME        VARCHAR(70),
    DATE_AUDIT        TIMESTAMP,
    FLAG_AUDIT        CHAR(1),
    DESCRIPTION       VARCHAR(255),
    A_DATE_OPERATION  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_USER_CHANGE     INTEGER,
    A_OPERATION       CHAR(3),
    A_NEW_OLD         CHAR(3)
);

CREATE TABLE A_WARES (
    CODE_WARES          INTEGER NOT NULL,
    UPD_STATUS          CHAR(3) NOT NULL,
    NAME_WARES_RECEIPT  VARCHAR(50),
    NAME_WARES          VARCHAR(100),
    DATE_INSERT         TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE A_WARES_ORDER_CACHE (
    CODE_ORDER             INTEGER,
    CODE_WARES             INTEGER,
    QUANTITY               NUMERIC(15,3),
    CODE_UNIT              INTEGER,
    PRICE                  DOUBLE PRECISION,
    PRICE_CATALOG          DOUBLE PRECISION,
    VAT                    NUMERIC(9,4),
    PRICE_SCHEMA           VARCHAR(255),
    DEALER_PRICEPROP       CHAR(1),
    REC_NO                 INTEGER,
    USER_CHANGE            INTEGER,
    DATE_CHANGE            TIMESTAMP,
    ADD_GROUPING           INTEGER,
    DISCOUNT               FLOAT,
    QUANTITY_IN_BASIS_RET  NUMERIC(15,3),
    A_USER_CHANGE          INTEGER,
    A_DATE_CHANGE          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION            CHAR(3),
    A_NEW_OLD              CHAR(3)
);

CREATE TABLE A_WARES_RETURN_CACHE (
    CODE_RETURN    INTEGER,
    CODE_WARES     INTEGER,
    PRICE          DOUBLE PRECISION,
    QUANTITY       NUMERIC(15,3),
    CODE_UNIT      INTEGER,
    VAT            NUMERIC(9,4),
    ADD_GROUPING   INTEGER,
    CODE_ORDER     INTEGER,
    A_USER_CHANGE  INTEGER,
    A_DATE_CHANGE  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    A_OPERATION    CHAR(3),
    A_NEW_OLD      CHAR(3)
);

CREATE TABLE ACCOUNT_CLIENT (
    CODE_CLIENT                 INTEGER NOT NULL,
    CODE_CURRENCY               INTEGER NOT NULL,
    CODE_FIRM_COMPANY           INTEGER NOT NULL,
    TYPE_CLIENT                 CHAR(2),
    ACCOUNT                     FLOAT,
    ACCOUNT_CASH                FLOAT,
    ACCOUNT_REUSABLE_CONTAINER  FLOAT,
    DML_DATETIME                TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE ADDITION_SIGN (
    CODE_ADDITION_SIGN  INTEGER NOT NULL,
    PART_ADDITION_SIGN  CHAR(2),
    NAME                VARCHAR(70) COLLATE PXW_CYRL,
    DESCRIPTION         VARCHAR(256),
    SIGN_ACTIVITY       CHAR(1),
    DML_DATETIME        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE ADDITION_UNIT (
    CODE_UNIT            INTEGER NOT NULL,
    CODE_WARES           INTEGER NOT NULL,
    COEFFICIENT          NUMERIC(16,6),
    DEFAULT_UNIT         CHAR(1),
    SIGN_ACTIVITY        CHAR(1),
    BAR_CODE             VARCHAR(30),
    CHECK_FIND_BAR_CODE  CHAR(1),
    DESCRIPTION          VARCHAR(255),
    SIGN_LOCKING         CHAR(1),
    WEIGHT               NUMERIC(16,3),
    WIDTH                NUMERIC(16,3),
    HEIGHT               NUMERIC(16,3),
    LENGT_               NUMERIC(16,3),
    REPORT_UNIT          CHAR(1),
    DML_DATETIME         TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE APP_ERRORS (
    CODE_ERROR       INTEGER NOT NULL,
    APP_SOURCE       INTEGER,
    APP_ID_RECORD_1  INTEGER,
    APP_ID_RECORD_2  INTEGER,
    APP_ID_RECORD_3  INTEGER,
    APP_ID_RECORD_4  INTEGER,
    APP_ID_RECORD_5  INTEGER,
    ORA_NUM_ERROR    INTEGER,
    ORA_MSG_ERROR    VARCHAR(254),
    MSG_ERROR        VARCHAR(2000),
    DATE_ERROR       TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    USER_ERROR       INTEGER
);

CREATE TABLE APPLICATION_OPTIONS (
    TYPE_OPTIONS            CHAR(2) NOT NULL,
    VARIETY_OPTIONS         CHAR(2) NOT NULL,
    CHECK_OPTIONS           CHAR(2),
    ID_APPLICATION_OPTIONS  INTEGER,
    OPTIONS                 VARCHAR(255),
    DESCRIPTION             VARCHAR(255)
);

CREATE TABLE APPLICATION_OPTIONS_USER (
    CODE_PRIVAT             INTEGER NOT NULL,
    TYPE_OPTIONS            CHAR(2) NOT NULL,
    VARIETY_OPTIONS         CHAR(2) NOT NULL,
    CHECK_OPTIONS           CHAR(2),
    ID_APPLICATION_OPTIONS  INTEGER,
    OPTIONS                 VARCHAR(255)
);

CREATE TABLE ATTRIB (
    CODE_ATTRIB                INTEGER NOT NULL,
    CODE_CUR_NAC               INTEGER,
    CODE_LDB                   INTEGER,
    CODE_SUBGROUP              INTEGER,
    CODE_SHOP                  INTEGER,
    CODE_CLIENT                INTEGER,
    BAR_CODE_CLIENT_SIZE       INTEGER,
    COMPANY_PROBLEM_INVOICE    INTEGER,
    WAREHOUSE_PROBLEM_INVOICE  INTEGER,
    CODE_DEALER_ROZ            INTEGER,
    PATH_BOX                   VARCHAR(127),
    BEGIN_NIGHT_TIME           CHAR(8),
    END_NIGHT_TIME             CHAR(8),
    BEGIN_CASSA                NUMERIC(15,2) DEFAULT 0,
    CASSA                      NUMERIC(15,2) DEFAULT 0,
    CASSA_CREDIT               NUMERIC(15,2) DEFAULT 0,
    CASSA_CARD                 NUMERIC(15,2) DEFAULT 0,
    NEXT_NUMBER_CHECK          INTEGER DEFAULT 1,
    CODE_EXTERNAL_DEVICE       INTEGER,
    SHOP_SERVER                CHAR(1) DEFAULT 'N',
    SHOP_SERVER_BASE           VARCHAR(250),
    "VERSION"                  VARCHAR(20),
    ORACLE_USER                VARCHAR(30) DEFAULT 'JOBORACLE',
    ORACLE_PSWD                VARCHAR(30) DEFAULT 'NRScYfZ/tvcv',
    DATE_BEGIN_SHIFT           TIMESTAMP,
    DATE_END_SHIFT             TIMESTAMP,
    SMTP_HOST                  VARCHAR(30),
    SMTP_PORT                  INTEGER,
    MAIL_ADDRESS               VARCHAR(255),
    ACTION_COUNTER             INTEGER DEFAULT 0,
    ACTION_PRIZE               INTEGER DEFAULT 0,
    ACTION_SUMMA               NUMERIC(15,2) DEFAULT 0,
    ACTION_TYPE                CHAR(2),
    PREFIX                     VARCHAR(20),
    NAME_SHOP                  VARCHAR(70),
    SECURITY_KEY               VARCHAR(1000)
);

CREATE TABLE CALC_CASH_REGISTER_CACHE (
    CODE_CALCULATION      INTEGER NOT NULL,
    NUMBER_RECEIPT        VARCHAR(30),
    DATE_RECEIPT          TIMESTAMP,
    ONLY_DATE_RECEIPT     DATE,
    NUMBER_CASHIER        VARCHAR(30),
    NUMBER_CASH_REGISTER  VARCHAR(30),
    MODEL_CASH_REGISTER   VARCHAR(50),
    USER_CHANGE           INTEGER,
    DATE_CHANGE           TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE CALCULATION_CACHE (
    CODE_ORDER          INTEGER NOT NULL,
    CODE_CALCULATION    INTEGER NOT NULL,
    CODE_SUBGROUP       INTEGER NOT NULL,
    CODE_FIRM           INTEGER NOT NULL,
    NUMBER_CALCULATION  INTEGER NOT NULL,
    DATE_CALCULATION    DATE NOT NULL,
    VAT                 NUMERIC(9,4) NOT NULL,
    ADD_GROUPING        INTEGER DEFAULT 0 NOT NULL,
    STATE_PAY           CHAR(1) DEFAULT '2' NOT NULL,
    NUMBER_TAX_INVOICE  INTEGER,
    DATE_OUT_INVOICE    DATE,
    DATE_TAKE           DATE,
    STATUS_TRANSFER     CHAR(1) DEFAULT '0' NOT NULL,
    DATE_CHANGE         TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CALCULATION_CREDIT_CARD_CACHE (
    CODE_CALCULATION  INTEGER NOT NULL,
    CODE_CREDIT_CARD  INTEGER NOT NULL,
    NUMBER_SLIP       VARCHAR(30),
    DESCRIPTION       VARCHAR(255) COLLATE PXW_CYRL
);

CREATE TABLE CASH_REGISTER_REPORT (
    CODE_CASH_REGISTER_REPORT    INTEGER NOT NULL,
    CODE_SUBGROUP                INTEGER NOT NULL,
    CODE_FIRM_COMPANY            INTEGER NOT NULL,
    CODE_WAREHOUSE               INTEGER NOT NULL,
    NUMBER_CASH_REGISTER_REPORT  INTEGER NOT NULL,
    TIME_CASH_REGISTER_REPORT    TIMESTAMP NOT NULL,
    SUM_CASH_REGISTER_REPORT     NUMERIC(15,2) NOT NULL,
    SUM_READY_MONEY              NUMERIC(15,2) NOT NULL,
    SUM_READY_CREDIT             NUMERIC(15,2),
    RETURN_SUM_CASH              NUMERIC(15,2),
    RETURN_SUM_READY_MONEY       NUMERIC(15,2),
    RETURN_SUM_READY_CREDIT      NUMERIC(15,2),
    SERVICEINPUT                 NUMERIC(15,2),
    SERVICEOUTPUT                NUMERIC(15,2),
    STATUS_TRANSFER              CHAR(1) DEFAULT '0' NOT NULL,
    USER_CHANGE                  INTEGER NOT NULL,
    DATE_CHANGE                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CASSA                        NUMERIC(15,2) DEFAULT 0,
    CASSA_CREDIT                 NUMERIC(15,2) DEFAULT 0,
    CASSA_CARD                   NUMERIC(15,2) DEFAULT 0,
    SUM_READY_CARD               NUMERIC(15,2) DEFAULT 0,
    RETURN_SUM_READY_CARD        NUMERIC(15,2) DEFAULT 0,
    Z_ZVIT_NUMBER                INTEGER
);

CREATE TABLE CASH_SHIFT_LOG (
    CODE_SUBGROUP        INTEGER NOT NULL,
    DATE_CASH_SHIFT_LOG  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ID_WORKPLACE         INTEGER NOT NULL,
    CODE_FIRM_COMPANY    INTEGER NOT NULL,
    CODE_WAREHOUSE       INTEGER NOT NULL,
    CODE_PRIVAT          INTEGER NOT NULL,
    TYPE_CASH_SHIFT_LOG  CHAR(2) NOT NULL,
    VIEW_CASH_SHIFT_LOG  CHAR(2) NOT NULL,
    STATUS_TRANSFER      CHAR(1) DEFAULT '0' NOT NULL,
    CASSA                NUMERIC(15,2) DEFAULT 0
);

CREATE TABLE CASSA_OPERATION (
    CODE_OPERATION      INTEGER NOT NULL,
    NUMBER_OPERATION    INTEGER NOT NULL,
    DATE_OPERATION      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CODE_CASH_REGISTER  INTEGER NOT NULL,
    TYPE_OPERATION      CHAR(1) NOT NULL,
    CODE_REASON         INTEGER NOT NULL,
    CODE_PRIVAT         INTEGER NOT NULL,
    SUMMA               NUMERIC(15,2) NOT NULL,
    STATUS_TRANSFER     CHAR(1) DEFAULT '0' NOT NULL
);

CREATE TABLE CHOSEN_GROUP_WARES (
    CODE_GROUP         INTEGER NOT NULL,
    CODE_PARENT_GROUP  INTEGER,
    TYPE_CHOICE        CHAR(2) NOT NULL,
    USER_CHANGE        INTEGER,
    DATE_CHANGE        TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DML_DATETIME       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CITY (
    CODE_CITY     INTEGER NOT NULL,
    CODE_COUNTRY  INTEGER,
    CODE_REGION   INTEGER,
    NAME_CITY     VARCHAR(70),
    PHONE_CODE    VARCHAR(70),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CONCERN_F_CLIENT (
    CODE_CONCERN   INTEGER NOT NULL,
    CODE_FIRM      INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER NOT NULL,
    SIGN_ACTIVITY  CHAR(1),
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CONCERN_P_CLIENT (
    CODE_CONCERN   INTEGER NOT NULL,
    CODE_PRIVAT    INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER NOT NULL,
    SIGN_ACTIVITY  CHAR(1),
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CONTRACT (
    CODE_CONTRACT       INTEGER NOT NULL,
    CODE_SUBGROUP       INTEGER,
    NUMBER_CONTRACT     INTEGER,
    DATE_CONTRACT       DATE,
    DATE_END_CONTRACT   DATE,
    DATE_COUNT_ALL      DATE,
    TYPE_CLIENT         CHAR(2),
    CODE_CLIENT         INTEGER,
    TYPE_CONTRACT       CHAR(2),
    STATE_CONTRACT      CHAR(2),
    CODE_ADDITION_SIGN  INTEGER,
    FIX_PRICE           CHAR(2),
    SIGN_ACTIVITY       CHAR(2),
    TYPE_PAYMENT        CHAR(2),
    PRIORITY            INTEGER,
    DML_DATETIME        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CREDIT_CARD (
    CODE_CREDIT_CARD  INTEGER NOT NULL,
    NAME_CREDIT_CARD  VARCHAR(100) COLLATE PXW_CYRL,
    SIGN_ACTIVITY     CHAR(1),
    DML_DATETIME      TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE CURRENT_INIT (
    CODE_INIT                  INTEGER NOT NULL,
    CODE_PRIVAT                INTEGER,
    USER_NAME                  VARCHAR(30),
    CODE_PROFILE               INTEGER,
    NOT_VAT                    INTEGER,
    CHECK_INDICATIVE           INTEGER,
    CODE_DEALER_PRINT_INVOICE  INTEGER,
    CASH_USER_NAME             VARCHAR(50),
    CASH_PASSWORD              VARCHAR(50),
    ID_WORKPLACE               INTEGER
);

CREATE TABLE DEALER (
    CODE_DEALER        INTEGER NOT NULL,
    CODE_SUBGROUP      INTEGER NOT NULL,
    NAME_DEALER        VARCHAR(70) COLLATE PXW_CYRL,
    ABR_DEALER         VARCHAR(8) COLLATE PXW_CYRL,
    SUM_DEALER         NUMERIC(15,2),
    CODE_CURRENCY      INTEGER,
    MARKUP             NUMERIC(8,2),
    EXPORT_CD          CHAR(1),
    PRINT              CHAR(1),
    REPORT             CHAR(1),
    PRINT_LABEL_PRICE  CHAR(1),
    INS_DEFAULT        CHAR(1),
    DML_DATETIME       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE DEALER_COMPLIANCE (
    CODE_DEALER_CENTER  INTEGER NOT NULL,
    CODE_DEALER         INTEGER NOT NULL
);

CREATE TABLE DEPARTMENT (
    CODE_DEPARTMENT    INTEGER NOT NULL,
    CODE_SUBGROUP      INTEGER,
    NUMBER_DEPARTMENT  INTEGER,
    NAME_DEPARTMENT    VARCHAR(100),
    SIGN_ACTIVITY      CHAR(1),
    DML_DATETIME       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE DISCOUNT_CARD (
    CODE_DISCOUNT_CARD        INTEGER NOT NULL,
    CODE_SUBGROUP             INTEGER,
    NAME_DISCOUNT_CARD        VARCHAR(50),
    PERCENT_DISCOUNT_CARD     NUMERIC(5,2),
    SUM_DISCOUNT_CARD         NUMERIC(15,2),
    SIGN_ACTIVITY             CHAR(1),
    CODE_DISCOUNT_CARD_GROUP  INTEGER,
    FIXED_DISCOUNT            CHAR(1),
    PERIOD_OF_VALIDITY        INTEGER,
    DML_DATETIME              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE DISCOUNT_CARD_FOR_TIME (
    RECORD_ID           INTEGER NOT NULL,
    CODE_DISCOUNT_CARD  INTEGER,
    CODE_SUBGROUP       INTEGER,
    DAY_BEGIN           CHAR(1),
    TIME_BEGIN          CHAR(5),
    TIME_END            CHAR(5),
    DML_DATETIME        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE DISCOUNT_CLIENT_OF_BRAND (
    CODE_CLIENT    INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER NOT NULL,
    TYPE_CLIENT    CHAR(1),
    CODE_BRAND     INTEGER NOT NULL,
    DISCOUNT       NUMERIC(5,2),
    SIGN_ACTIVITY  CHAR(1),
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE DISCOUNT_CLIENT_OF_GROUP (
    CODE_CLIENT    INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER NOT NULL,
    TYPE_CLIENT    CHAR(1),
    CODE_GROUP     INTEGER NOT NULL,
    DISCOUNT       NUMERIC(5,2),
    SIGN_ACTIVITY  CHAR(1),
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE F_CLIENT (
    CODE_FIRM             INTEGER NOT NULL,
    CODE_SUBGROUP         INTEGER NOT NULL,
    CODE_TRIDE_REGION     INTEGER,
    VARIANT_PAYMENT       CHAR(2),
    MAX_END_PAYMENT       INTEGER,
    MAX_DEBT              NUMERIC(15,2),
    PER_PP                NUMERIC(15,2),
    DISCOUNT              NUMERIC(9,6),
    CHECK_SPEC_DISCOUNT   CHAR(2),
    RECALC_ORDER          CHAR(2),
    RECALC_COURSE         CHAR(2),
    CODE_CURRENCY         INTEGER,
    ID_CLIENT             VARCHAR(30),
    CODE_DEALER           INTEGER,
    SIGN_ACTIVITY         CHAR(1),
    CODE_PRIVAT           INTEGER,
    PRICE_NOTLESS_SPRICE  CHAR(2),
    MIN_PRICE_SPRICE      CHAR(2),
    NOT_SPRICE            CHAR(2),
    DISCOUNT_POSITION     CHAR(2),
    CONTROL_MIN_PERCENT   CHAR(2),
    CODE_DISCOUNT_CARD    INTEGER,
    DML_DATETIME          TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE FIRMS (
    CODE_FIRM                INTEGER NOT NULL,
    CODE_ZIP                 VARCHAR(20),
    IMPOCITION               VARCHAR(15),
    AGREE_NUMBER             VARCHAR(20),
    NAME                     VARCHAR(70) NOT NULL COLLATE PXW_CYRL,
    CODE_CITY                INTEGER DEFAULT -1,
    ADDRESS                  VARCHAR(70) COLLATE PXW_CYRL,
    PHONE                    VARCHAR(50),
    FAX                      VARCHAR(50),
    TELEX                    VARCHAR(50),
    ACCOUNT                  VARCHAR(40),
    CURRENCY_ACCOUNT         VARCHAR(40),
    CODE_BANK                INTEGER,
    CODE_CURRENCY_ACCOUNT    INTEGER,
    MAIL                     VARCHAR(50),
    SIGN_ACTIVITY            CHAR(1),
    FLAG_CHECK               CHAR(1),
    BAR_CODE                 DOUBLE PRECISION,
    DATE_ANIMATION_BAR_CODE  DATE,
    CODE_PARENT_FIRM         INTEGER,
    INDEX_MAIL               VARCHAR(10),
    ADDRESS_LOCATION         VARCHAR(70) COLLATE PXW_CYRL,
    NAME_FOR_PRINT           VARCHAR(250) COLLATE PXW_CYRL,
    TAX_PAYER_VAT            CHAR(1),
    DML_DATETIME             TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE GROUP_WARES (
    CODE_GROUP_WARES         INTEGER NOT NULL,
    CODE_PARENT_GROUP_WARES  INTEGER,
    NAME                     VARCHAR(70) COLLATE PXW_CYRL,
    SIGN_ACTIVITY            CHAR(1),
    NIK_NAME_GROUP_WARES     VARCHAR(30) COLLATE PXW_CYRL,
    DML_DATETIME             TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE HOT_KEY_RESERVE (
    ID_MENU       INTEGER NOT NULL,
    CODE_SHOP     INTEGER NOT NULL,
    MENU_NAME     VARCHAR(255),
    HOT_KEY       VARCHAR(30),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE HOT_KEY_WARES (
    HOT_KEY     VARCHAR(30) NOT NULL,
    CODE_WARES  INTEGER NOT NULL
);

CREATE TABLE KASSA_UPDATE_LOGZ (
    TABLE_ID      INTEGER NOT NULL,
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    TIMEELAPSED   INTEGER
);

CREATE TABLE MANAGER (
    CODE_TRIDE_REGION  INTEGER NOT NULL,
    CODE_PRIVAT        INTEGER NOT NULL,
    CODE_MANAGER       VARCHAR(30),
    SIGN_ACTIVITY      CHAR(1),
    DML_DATETIME       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE MY_STATE_ALL (
    PART_STATE_NUMBER  INTEGER NOT NULL,
    ABR_STATE          CHAR(2) NOT NULL,
    STATE              VARCHAR(40),
    SING_ACTIVITY      CHAR(1),
    DESCRIPTION        VARCHAR(250),
    PARENT_STATE       VARCHAR(40)
);

CREATE TABLE MY_TEMP_ORDER (
    NUMBER_COPY               INTEGER NOT NULL,
    CODE_CLIENT               INTEGER NOT NULL,
    CODE_WARES                INTEGER NOT NULL,
    QUANTITY                  NUMERIC(16,3) NOT NULL,
    CODE_UNIT                 INTEGER NOT NULL,
    DISCOUNT_POSITION         FLOAT DEFAULT 0,
    DATE_INSERT               TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    PRICE                     DOUBLE PRECISION,
    PRICE_CATALOG             DOUBLE PRECISION,
    CHPRICESCHEMA             VARCHAR(100),
    CHECKTYPE                 INTEGER NOT NULL,
    NUMBER_CHECK              INTEGER,
    CURRENT_UNIT_COEFFICIENT  DOUBLE PRECISION,
    PRICE_UNIT_COEFFICIENT    DOUBLE PRECISION,
    QUANTITY_IN_BASIS         DOUBLE PRECISION,
    CODE_ORDER_FOR_RETURN     INTEGER,
    CHABRPRICESCHEMA          CHAR(1)
);

CREATE TABLE MY_WARES_WORD (
    ID               INTEGER NOT NULL,
    CODE_WARES       INTEGER,
    WARES_WORD       VARCHAR(50) COLLATE WIN1251_UA,
    NAME_ORDERB_IDX  BIGINT
);

CREATE TABLE OPTS_ITEM_VALUES (
    CODE_SUBJECT  INTEGER NOT NULL,
    CODE_ITEM     INTEGER NOT NULL,
    VALUE1        VARCHAR(254),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE OPTS_OPTION_ITEMS (
    CODE_ITEM      INTEGER NOT NULL,
    CODE_OPTION    INTEGER,
    ITEM_NUMBER    INTEGER,
    ITEM_TYPE      CHAR(4),
    NAME           VARCHAR(254),
    CAPTION        VARCHAR(254),
    DESCRIPTION    VARCHAR(254),
    DEFAULT_VALUE  VARCHAR(254)
);

CREATE TABLE ORDER_CLIENT_CACHE (
    CODE_ORDER          INTEGER NOT NULL,
    CODE_SUBGROUP       INTEGER NOT NULL,
    NUMBER_ORDER        INTEGER NOT NULL,
    DATE_ORDER          DATE NOT NULL,
    VARIETY_ORDER       CHAR(2) NOT NULL,
    TYPE_ORDER          CHAR(2) NOT NULL,
    TYPE_PAYMENT        CHAR(2) NOT NULL,
    TYPE_VAT            CHAR(2) NOT NULL,
    CODE_CLIENT         INTEGER NOT NULL,
    TYPE_CLIENT         CHAR(2) NOT NULL,
    DATE_PAYMENT        DATE NOT NULL,
    CODE_DEALER         INTEGER NOT NULL,
    DISCOUNT            NUMERIC(9,6) NOT NULL,
    PER_PP              NUMERIC(15,2) NOT NULL,
    CODE_MANAGER        INTEGER NOT NULL,
    ID_WORKPLACE        INTEGER NOT NULL,
    CODE_END            INTEGER NOT NULL,
    INDICATION          INTEGER NOT NULL,
    PRIORITY            INTEGER,
    CODE_ADDITION_SIGN  INTEGER,
    DESCRIPTION         VARCHAR(250),
    USER_CHANGE         INTEGER NOT NULL,
    DATE_CHANGE         TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE P_CLIENT (
    CODE_PRIVAT           INTEGER NOT NULL,
    CODE_SUBGROUP         INTEGER NOT NULL,
    CODE_TRIDE_REGION     INTEGER,
    VARIANT_PAYMENT       CHAR(2),
    MAX_END_PAYMENT       INTEGER,
    MAX_DEBT              NUMERIC(15,2),
    PER_PP                NUMERIC(15,2),
    DISCOUNT              NUMERIC(9,6),
    CHECK_SPEC_DISCOUNT   CHAR(2),
    RECALC_ORDER          CHAR(2),
    RECALC_COURSE         CHAR(2),
    CODE_CURRENCY         INTEGER,
    ID_CLIENT             VARCHAR(30),
    CODE_DEALER           INTEGER,
    SIGN_ACTIVITY         CHAR(1),
    PRICE_NOTLESS_SPRICE  CHAR(2),
    MIN_PRICE_SPRICE      CHAR(2),
    NOT_SPRICE            CHAR(2),
    DISCOUNT_POSITION     CHAR(2),
    CONTROL_MIN_PERCENT   CHAR(2),
    CODE_DISCOUNT_CARD    INTEGER,
    DML_DATETIME          TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE POWER_OF_ATTORNEY (
    CODE_ORDER              INTEGER NOT NULL,
    SER_POWER_OF_ATTORNEY   CHAR(3),
    NUM_POWER_OF_ATTORNEY   VARCHAR(20),
    DATE_POWER_OF_ATTORNEY  DATE NOT NULL,
    NSP_POWER_OF_ATTORNEY   VARCHAR(200) NOT NULL
);

CREATE TABLE PRICE_DEALER (
    CODE_WARES                   INTEGER NOT NULL,
    CODE_DEALER                  INTEGER NOT NULL,
    CODE_SUBGROUP                INTEGER NOT NULL,
    PRICE_DEALER                 DOUBLE PRECISION NOT NULL,
    CODE_CURRENCY                INTEGER NOT NULL,
    MARKUP                       NUMERIC(8,2) NOT NULL,
    FIXED_ID                     INTEGER,
    FIXED_PRICE                  CHAR(2),
    FIXED_BEGIN_DATE             DATE,
    FIXED_END_DATE               DATE,
    INDICATIVE_ACTIVE            CHAR(2),
    INDICATIVE_ID                INTEGER,
    INDICATIVE_MIN_PRICE         DOUBLE PRECISION,
    INDICATIVE_MAX_PRICE         DOUBLE PRECISION,
    INDICATIVE_CODE_CURRENCY     INTEGER,
    INDICATIVE_BEGIN_DATE        DATE,
    INDICATIVE_END_DATE          DATE,
    DISREGARD_PRICE_PROPOCITION  CHAR(2),
    DML_DATETIME                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE PRICE_PROPOCITION (
    CODE_PRICE_PROPOCITION    INTEGER NOT NULL,
    CODE_WARES                INTEGER,
    CODE_SUBGROUP             INTEGER,
    CAT_SPECPROPOSITION_ID    INTEGER,
    CUBIC                     NUMERIC(15,3),
    MARKUP                    NUMERIC(8,2),
    PRICE_PROPOCITION         DOUBLE PRECISION,
    CODE_CURRENCY             INTEGER,
    FIXED_ID                  INTEGER,
    FIXED_PRICE               CHAR(2),
    FIXED_BEGIN_DATE          DATE,
    FIXED_END_DATE            DATE,
    INDICATIVE_ACTIVE         CHAR(2),
    INDICATIVE_ID             INTEGER,
    INDICATIVE_MIN_PRICE      DOUBLE PRECISION,
    INDICATIVE_MAX_PRICE      DOUBLE PRECISION,
    INDICATIVE_CODE_CURRENCY  INTEGER,
    INDICATIVE_BEGIN_DATE     DATE,
    INDICATIVE_END_DATE       DATE,
    DML_DATETIME              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE PRIVAT (
    CODE_PRIVAT              INTEGER NOT NULL,
    SURNAME                  VARCHAR(70) COLLATE PXW_CYRL,
    NAME                     VARCHAR(70) COLLATE PXW_CYRL,
    PATRONYMIC               VARCHAR(70) COLLATE PXW_CYRL,
    DOCUMENT                 VARCHAR(120) COLLATE PXW_CYRL,
    IMPOCITION               VARCHAR(15),
    AGREE_NUMBER             VARCHAR(20),
    CODE_CITY                INTEGER DEFAULT -1,
    ADDRESS                  VARCHAR(70) COLLATE PXW_CYRL,
    HOUSE_PHONE              VARCHAR(20),
    WORK_PHONE               VARCHAR(20),
    CODE_CURRENCY_ACCOUNT    INTEGER,
    MAIL                     VARCHAR(70),
    SIGN_ACTIVITY            CHAR(1),
    FLAG_CHECK               CHAR(1),
    BAR_CODE                 DOUBLE PRECISION,
    DATE_ANIMATION_BAR_CODE  DATE,
    INDEX_MAIL               VARCHAR(10),
    NAME_FOR_PRINT           VARCHAR(250) COLLATE PXW_CYRL,
    TAX_PAYER_VAT            CHAR(1),
    DML_DATETIME             TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE REGISTER_CASH_REGISTER (
    CODE_REGISTER_CASH_REGISTER  INTEGER NOT NULL,
    CODE_SUBGROUP                INTEGER,
    CODE_COMPANY                 INTEGER,
    NUMBER_CASH_REGISTER         INTEGER,
    SERIAL_NUMBER_CASH_REGISTER  VARCHAR(50),
    MODEL_CASH_REGISTER          VARCHAR(50),
    DML_DATETIME                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE REPOSIT (
    NAMECALC     VARCHAR(30) NOT NULL,
    QUERY        VARCHAR(2000),
    KEYFIELD     VARCHAR(30),
    ADD_FLAG     CHAR(1),
    NAME_RECORD  VARCHAR(255),
    FIXED        INTEGER
);

CREATE TABLE REPOSIT_QUERY (
    ID_USER       INTEGER NOT NULL,
    NAME_GRID     VARCHAR(50) NOT NULL,
    NAME_DATASET  VARCHAR(50) NOT NULL,
    NAME_CONFIG   VARCHAR(240),
    WHERE_OLD     VARCHAR(3000),
    WHERE_FULL    VARCHAR(3000),
    FULLL         VARCHAR(4000)
);

CREATE TABLE REPOSITORY_FILTER_CFG (
    ID_USER       INTEGER NOT NULL,
    NAME_GRID     VARCHAR(50) NOT NULL,
    NAME_DATASET  VARCHAR(50) NOT NULL,
    NAME_CONFIG   VARCHAR(240) NOT NULL,
    WHERE_OLD     VARCHAR(4000),
    WHERE_FULL    VARCHAR(4000)
);

CREATE TABLE REPOSITORY_XLREP (
    ID_USER             INTEGER NOT NULL,
    NAME_MODULE         VARCHAR(20) NOT NULL,
    NAME_GRID           VARCHAR(50) NOT NULL,
    NAME_DATASET        VARCHAR(50) NOT NULL,
    REPORT_TEMPLATE     BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    REPORT_TITLE        VARCHAR(240),
    REPORT_WITH_NUMBER  CHAR(1),
    NAME_CONFIG         VARCHAR(240),
    OPTIONS             VARCHAR(4000)
);

CREATE TABLE REPOSITORY_XLREP_CFG (
    ID_USER             INTEGER NOT NULL,
    NAME_MODULE         VARCHAR(20) NOT NULL,
    NAME_GRID           VARCHAR(50) NOT NULL,
    NAME_DATASET        VARCHAR(50) NOT NULL,
    NAME_CONFIG         VARCHAR(240) NOT NULL,
    REPORT_TEMPLATE     BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    REPORT_TITLE        VARCHAR(240),
    REPORT_WITH_NUMBER  CHAR(1),
    OPTIONS             VARCHAR(4000)
);

CREATE TABLE RETURN_CACHE (
    CODE_RETURN                INTEGER NOT NULL,
    CODE_SUBGROUP              INTEGER NOT NULL,
    DATE_RETURN                DATE NOT NULL,
    NUMBER_CHECK               INTEGER DEFAULT 0 NOT NULL,
    DATE_CHECK                 TIMESTAMP,
    TYPE_VAT                   CHAR(2) NOT NULL,
    ID_WORKPLACE               INTEGER NOT NULL,
    CODE_FIRM                  INTEGER NOT NULL,
    CODE_WAREHOUSE             INTEGER NOT NULL,
    CODE_ADDITION_SIGN         INTEGER DEFAULT -17 NOT NULL,
    TYPE_PAYMENT               CHAR(2) DEFAULT 'N' NOT NULL,
    STATUS_TRANSFER            CHAR(1) DEFAULT '3' NOT NULL,
    ID_WORKPLACE_SALE          INTEGER,
    NUMBER_CASH_REGISTER_SALE  VARCHAR(30),
    MODEL_CASH_REGISTER_SALE   VARCHAR(30),
    DESCRIPTION                VARCHAR(250) COLLATE PXW_CYRL,
    USER_CHANGE                INTEGER NOT NULL,
    DATE_CHANGE                TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE RETURN_REGISTER_CACHE (
    CODE_RETURN           INTEGER NOT NULL,
    NUMBER_RECEIPT        VARCHAR(30),
    DATE_RECEIPT          TIMESTAMP,
    NUMBER_CASHIER        VARCHAR(30),
    NUMBER_CASH_REGISTER  VARCHAR(30),
    MODEL_CASH_REGISTER   VARCHAR(50),
    USER_CHANGE           INTEGER,
    DATE_CHANGE           TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE SHOP_CLIENT_FOR_FRONTOFFICE (
    SHOP_CLIENT_FOR_FRONTOFFICE_ID  INTEGER NOT NULL,
    CODE_SHOP                       INTEGER NOT NULL,
    CODE_CLIENT                     INTEGER NOT NULL,
    CODE_SUBGROUP                   INTEGER,
    DAY_BEGIN                       CHAR(1) NOT NULL,
    DAY_END                         CHAR(1) NOT NULL,
    TIME_BEGIN                      CHAR(5) NOT NULL,
    TIME_END                        CHAR(5) NOT NULL,
    DML_DATETIME                    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_CLIENT_FROM_SUM_ORDER (
    CODE_SHOP      INTEGER NOT NULL,
    CODE_CLIENT    INTEGER NOT NULL,
    SUM_ORDER      NUMERIC(15,2),
    SIGN_ACTIVITY  CHAR(1),
    CODE_SUBGROUP  INTEGER,
    CODE_PRIVAT    INTEGER,
    CODE_FIRM      INTEGER,
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_DEALER (
    CODE_SHOP                 INTEGER NOT NULL,
    CODE_DEALER               INTEGER NOT NULL,
    DISCOUNT                  CHAR(1),
    SHOP_DEALER_PRINT_SECOND  CHAR(1),
    ID_LEVEL                  INTEGER,
    DML_DATETIME              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_DEPARTMENT_WARES (
    CODE_WARES          INTEGER NOT NULL,
    CODE_DEPARTMENT     INTEGER NOT NULL,
    CODE_SHOP           INTEGER,
    NUMBER_WARES_SCALE  INTEGER,
    WEIGHT_TARE         FLOAT,
    NUMBER_TARE         INTEGER,
    SHELF_LIFE          INTEGER,
    CONST_SHELF_LIFE    INTEGER,
    LABEL_FORMAT        CHAR(2),
    SEND_TO_SCALE       CHAR(1),
    DML_DATETIME        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_DEPARTMENT_WORKPLACE (
    ID_WORKPLACE     INTEGER NOT NULL,
    CODE_DEPARTMENT  INTEGER NOT NULL,
    CODE_SHOP        INTEGER NOT NULL,
    ACCESSIBLE       CHAR(1),
    DML_DATETIME     TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_DISCOUNT (
    CODE_DISCOUNT  INTEGER NOT NULL,
    CODE_SHOP      INTEGER NOT NULL,
    DISCOUNT       NUMERIC(7,4),
    SIGN_ACTIVITY  CHAR(1),
    DML_DATETIME   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_PRICE_SUPPLIER (
    CODE_WARES      INTEGER NOT NULL,
    CODE_SUPPLIER   INTEGER NOT NULL,
    CODE_SHOP       INTEGER,
    PRICE           DOUBLE PRECISION,
    QUANTITY        NUMERIC(16,3),
    CODE_CURRENCY   INTEGER,
    NUMBER_INVOICE  INTEGER,
    DATE_INVOICE    TIMESTAMP,
    DATE_CHANGE     TIMESTAMP,
    DML_DATETIME    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SHOP_SPECPROPOSITION_TIME (
    SHOP_SPECPROPOSITION_TIME_ID  INTEGER NOT NULL,
    CODE_SHOP                     INTEGER,
    CAT_SPECPROPOSITION_ID        INTEGER,
    DAY_BEGIN                     CHAR(1),
    DAY_END                       CHAR(1),
    TIME_BEGIN                    CHAR(5),
    TIME_END                      CHAR(5),
    DML_DATETIME                  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_ACCESS_ACTIONS (
    CODE_PROFILE  INTEGER NOT NULL,
    CODE_ACTION   CHAR(2) NOT NULL,
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_ACCESS_OBJECTS (
    CODE_PROFILE  INTEGER NOT NULL,
    TYPE_OBJECT   CHAR(2) NOT NULL,
    CODE_OBJECT   INTEGER NOT NULL,
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_ACCESS_SECURITY (
    CODE_PROFILE  INTEGER NOT NULL,
    CODE_OBJECT   INTEGER NOT NULL,
    ACCESS_FLAG   CHAR(2),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_EVENTS_AUDIT (
    EVENT_ID      CHAR(2) NOT NULL,
    EVENT_NAME    VARCHAR(70),
    DATE_AUDIT    TIMESTAMP,
    FLAG_AUDIT    CHAR(1),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_INSPECTOR (
    CODE_INSPECTOR  INTEGER NOT NULL,
    TYPE_INSPECTOR  CHAR(2),
    NAME_INSPECTOR  VARCHAR(100) COLLATE PXW_CYRL,
    SIGN_ACTIVITY   CHAR(2),
    PARAMS          VARCHAR(500),
    DML_DATETIME    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_PROFILES (
    CODE_PROFILE  INTEGER NOT NULL,
    NAME_PROFILE  VARCHAR(70),
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_SECURITY_LIST (
    CODE_OBJECT         INTEGER NOT NULL,
    CODE_PARENT_OBJECT  INTEGER,
    NAME_OBJECT         VARCHAR(100),
    REAL_NAME_OBJECT    VARCHAR(50),
    TYPE_OBJECT         CHAR(1),
    DML_DATETIME        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_USER_CASHDESKS (
    CODE_SPOSUSER                INTEGER NOT NULL,
    CODE_REGISTER_CASH_REGISTER  INTEGER NOT NULL,
    DML_DATETIME                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE SPA_USERS (
    CODE_SPOSUSER  INTEGER NOT NULL,
    USER_NAME      VARCHAR(30) COLLATE PXW_CYRL,
    SIGN_ACTIVITY  CHAR(1),
    DATE_BEGIN     DATE,
    DATE_END       DATE,
    CODE_PRIVAT    INTEGER NOT NULL,
    PSWD           VARCHAR(128) NOT NULL,
    CODE_PROFILE   INTEGER,
    CODE_SHOP      INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER
);

CREATE TABLE SPA_USERS_TEST (
    CODE_SPOSUSER  INTEGER NOT NULL,
    USER_NAME      VARCHAR(30),
    SIGN_ACTIVITY  CHAR(1),
    DATE_BEGIN     DATE,
    DATE_END       DATE,
    CODE_PRIVAT    INTEGER NOT NULL,
    PSWD           VARCHAR(128) NOT NULL,
    CODE_PROFILE   INTEGER,
    CODE_SHOP      INTEGER NOT NULL,
    CODE_SUBGROUP  INTEGER
);

CREATE TABLE SQL_ERROR_LOG (
    TIMEZ            TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    SQL_ERROR        VARCHAR(1024) COLLATE WIN1251_UA,
    STATUS_TRANSFER  CHAR(1) DEFAULT '0' COLLATE WIN1251_UA,
    WORKPLACE_ID     INTEGER
);

CREATE TABLE STATE_ALL (
    PART_STATE          INTEGER NOT NULL,
    ABR_STATE           CHAR(2) NOT NULL,
    STATE               VARCHAR(40) COLLATE PXW_CYRL,
    SIGN_ACTIVITY       CHAR(1),
    DESCRIPTION         VARCHAR(250),
    PART_STATE_PARENTS  INTEGER
);

CREATE TABLE T$CHECK_BODY (
    CODE      VARCHAR(30),
    ITEMNAME  VARCHAR(250),
    QUANTITY  VARCHAR(30),
    PRICE     VARCHAR(30),
    UNIT      VARCHAR(30),
    VAT       VARCHAR(30)
);

CREATE TABLE T$CHECK_FOOTER (
    TYPE_PAYMENT   CHAR(2),
    SUM_ENTRY      NUMERIC(15,2),
    CHECK_FOOTER1  VARCHAR(250),
    CHECK_FOOTER2  VARCHAR(250),
    CHECK_FOOTER3  VARCHAR(250),
    CHECK_FOOTER4  VARCHAR(250),
    CHECK_FOOTER5  VARCHAR(250),
    CHECK_FOOTER6  VARCHAR(250),
    CHECK_FOOTER7  VARCHAR(250)
);

CREATE TABLE T$CHECK_HEADER (
    CHECK_NUMBER         VARCHAR(30),
    CHECK_DATE           TIMESTAMP,
    CHECK_NUMBER_RETURN  VARCHAR(30),
    CHECK_DATE_RETURN    TIMESTAMP,
    CHECK_HEADER1        VARCHAR(250),
    CHECK_HEADER2        VARCHAR(250),
    CHECK_HEADER3        VARCHAR(250),
    CHECK_HEADER4        VARCHAR(250),
    CHECK_HEADER5        VARCHAR(250),
    CHECK_HEADER6        VARCHAR(250),
    CHECK_HEADER7        VARCHAR(250)
);

CREATE TABLE T$SERVICE_INPUTOUTPUT (
    AMOUNT  NUMERIC(15,2)
);

CREATE TABLE T$SERVICE_ZREPORT (
    DATE_BEGIN  TIMESTAMP,
    DATE_END    TIMESTAMP
);

CREATE TABLE TEMP_ORDER (
    NUMBER_COPY        INTEGER NOT NULL,
    CODE_CLIENT        INTEGER NOT NULL,
    CODE_WARES         INTEGER NOT NULL,
    QUANTITY           NUMERIC(16,3) NOT NULL,
    CODE_UNIT          INTEGER NOT NULL,
    DISCOUNT_POSITION  FLOAT DEFAULT 0,
    DATE_INSERT        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE TEST_DELETE_BY_IDX_TABLE (
    IDX     INTEGER,
    PARENT  INTEGER
);

CREATE TABLE TEST_TIMETOREFRESH (
    CODE_SHOP                    INTEGER,
    LAST_TIME_TO_REFRESH         TIMESTAMP,
    NEXT_TIME_TO_REFRESH         TIMESTAMP,
    REFRESH_INTERVAL_IN_SECONDS  INTEGER,
    NEXT_REFRESH_IS_ACTIVE       CHAR(1),
    LAST_WRITED_DOC_COUNT        INTEGER,
    LAST_WORK_TIME_OUT           INTEGER,
    LAST_SQL_ERROR_TEXT          VARCHAR(1024),
    REFRESH_TYPE                 CHAR(1)
);

CREATE TABLE UNIT_DIMENSION (
    CODE_UNIT                      INTEGER NOT NULL,
    NAME_UNIT                      VARCHAR(70) COLLATE PXW_CYRL,
    ABR_UNIT                       CHAR(4) COLLATE PXW_CYRL,
    SIGN_ACTIVITY                  CHAR(1),
    DESCRIPTION                    VARCHAR(250),
    SIGN_DIVISIONAL                CHAR(1),
    REUSABLE_CONTAINER             CHAR(1),
    CODE_WARES_REUSABLE_CONTAINER  INTEGER,
    DML_DATETIME                   TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE V_SPA_EVENTS_MONITOR (
    CODE_SHOP             INTEGER NOT NULL,
    CODE_COMPLIANCE       INTEGER NOT NULL,
    EVENT_ID              CHAR(2),
    CODE_INSPECTOR        INTEGER,
    INSPECTOR_EVENT_ID    VARCHAR(15) NOT NULL COLLATE PXW_CYRL,
    INSPECTOR_EVENT_NAME  VARCHAR(255) COLLATE PXW_CYRL,
    PRIORITY              INTEGER,
    ADDITION_PARAMS       VARCHAR(255),
    DML_DATETIME          TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE VER_INFO (
    MOD_NAME         VARCHAR(50),
    MOD_VERSION      INTEGER,
    MOD_DESCRIPTION  VARCHAR(50)
);

CREATE TABLE VRO_REPORT_DATASET_PARAMS (
    PARAM_ID           INTEGER NOT NULL,
    DATASET_ID         INTEGER,
    PARAM_NAME         VARCHAR(100),
    PARAM_TYPE         INTEGER,
    PARAM_INPUT        INTEGER,
    PARAM_QUERY        VARCHAR(30),
    DEFAULT_VALUE      VARCHAR(100),
    MASTER_FIELD       VARCHAR(100),
    MASTER_FIELD_DESC  VARCHAR(100),
    PARAM_DESC         VARCHAR(100)
);

CREATE TABLE VRO_REPORT_DATASETS (
    DATASET_ID           INTEGER NOT NULL,
    REPORT_ID            INTEGER,
    DATASET_NAME         VARCHAR(100),
    DATASET_DESC         VARCHAR(1000),
    DATASET_QUERY        BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    MASTER_DATASET_NAME  VARCHAR(100)
);

CREATE TABLE VRO_REPORT_LINK_PARAMS (
    PARAM_ID      INTEGER NOT NULL,
    LEVEL_ID      INTEGER,
    MASTER_FIELD  VARCHAR(100)
);

CREATE TABLE VRO_REPORT_LINK_TEMPLATES (
    TEMPLATE_ID   INTEGER NOT NULL,
    LEVEL_ID      INTEGER,
    MASTER_FIELD  VARCHAR(100),
    MASTER_VALUE  VARCHAR(100)
);

CREATE TABLE VRO_REPORT_LINK_VARIABLES (
    VARIABLE_ID   INTEGER NOT NULL,
    LEVEL_ID      INTEGER,
    MASTER_FIELD  VARCHAR(100)
);

CREATE TABLE VRO_REPORT_TEMPLATES (
    TEMPLATE_ID        INTEGER NOT NULL,
    REPORT_ID          INTEGER,
    TEMPLATE_NAME      VARCHAR(100),
    TEMPLATE_DEFAULT   CHAR(1),
    MASTER_FIELD       VARCHAR(100),
    MASTER_VALUE       VARCHAR(100),
    MASTER_FIELD_DESC  VARCHAR(100),
    MASTER_VALUE_DESC  VARCHAR(100),
    TEMPLATE_DATA      BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    TEMPLATE_DESC      VARCHAR(100)
);

CREATE TABLE VRO_REPORT_VARIABLES (
    VARIABLE_ID        INTEGER NOT NULL,
    REPORT_ID          INTEGER,
    VARIABLE_NAME      VARCHAR(100),
    VARIABLE_TYPE      INTEGER,
    VARIABLE_INPUT     INTEGER,
    VARIABLE_QUERY     VARCHAR(30),
    DEFAULT_VALUE      VARCHAR(100),
    MASTER_FIELD       VARCHAR(100),
    MASTER_FIELD_DESC  VARCHAR(100),
    VARIABLE_DESC      VARCHAR(100)
);

CREATE TABLE VRO_REPORTS (
    REPORT_ID            INTEGER NOT NULL,
    CATEGORY_ID          INTEGER,
    PARENT_ID            INTEGER,
    REPORT_NAME          VARCHAR(100),
    REPORT_TYPE          VARCHAR(2),
    TEMPLATE_SELECTION   INTEGER,
    PRINT_FOR_SELECTION  INTEGER,
    REPORT_NUMBER        INTEGER,
    DESCRIPTION          VARCHAR(4000)
);

CREATE TABLE WARES (
    CODE_WARES                 INTEGER NOT NULL,
    CODE_GROUP                 INTEGER NOT NULL,
    DATA_WARES                 DATE,
    NAME_WARES                 VARCHAR(100) COLLATE PXW_CYRL,
    ARTICL                     VARCHAR(30),
    CODE_BRAND                 INTEGER,
    NAME_WARES_BRAND           VARCHAR(100) COLLATE PXW_CYRL,
    ARTICL_WARES_BRAND         VARCHAR(30) COLLATE PXW_CYRL,
    CODE_UNIT                  INTEGER,
    MIN_QUANTITY               NUMERIC(16,3),
    MIN_REST                   NUMERIC(16,3),
    O_WARES                    VARCHAR(4),
    SIGN_1                     NUMERIC(17,4),
    SIGN_2                     NUMERIC(17,4),
    SIGN_3                     NUMERIC(17,4),
    TOUCH_CODE                 VARCHAR(30),
    OLD_ARTICL                 VARCHAR(15),
    VAT                        NUMERIC(5,2),
    VAT_OPERATION              CHAR(2),
    NAME_WARES_RECEIPT         VARCHAR(50) COLLATE WIN1251_UA,
    MARKING_ALL_ARE_ASSEMBLED  VARCHAR(50) COLLATE PXW_CYRL,
    EXCISE                     CHAR(2),
    EXCISE_TAX                 NUMERIC(5,2),
    CODE_WARES_RELATIVE        INTEGER,
    DML_DATETIME               TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE WARES_CATALOG (
    CATALOG_ID         INTEGER NOT NULL,
    CATALOG_PARENT_ID  INTEGER,
    CATALOG_LEVEL      INTEGER,
    CODE_WARES         INTEGER,
    NAME_CATALOG       VARCHAR(200) COLLATE WIN1251_UA,
    TYPE_ITEM          CHAR(1) COLLATE WIN1251_UA,
    SIGN_ACTIVE        CHAR(1) DEFAULT 'Y' COLLATE WIN1251_UA,
    DML_DATETIME       TIMESTAMP DEFAULT current_timestamp
);

CREATE TABLE WARES_CONTRACT_OF_PRICE (
    CODE_CONTRACT   INTEGER NOT NULL,
    CODE_WARES      INTEGER NOT NULL,
    CODE_UNIT       INTEGER,
    PRICE_CONTRACT  DOUBLE PRECISION,
    CODE_CURRENCY   INTEGER,
    DML_DATETIME    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE WARES_ORDER_CACHE (
    CODE_ORDER             INTEGER NOT NULL,
    CODE_WARES             INTEGER NOT NULL,
    QUANTITY               NUMERIC(16,3) NOT NULL,
    CODE_UNIT              INTEGER NOT NULL,
    PRICE                  DOUBLE PRECISION NOT NULL,
    PRICE_CATALOG          DOUBLE PRECISION NOT NULL,
    VAT                    NUMERIC(7,4) NOT NULL,
    ADD_GROUPING           INTEGER DEFAULT  0 NOT NULL,
    PRICE_SCHEMA           VARCHAR(255) NOT NULL COLLATE PXW_CYRL,
    DEALER_PRICEPROP       CHAR(1) NOT NULL,
    REC_NO                 INTEGER,
    DISCOUNT               FLOAT DEFAULT 0 NOT NULL,
    QUANTITY_IN_BASIS_RET  NUMERIC(15,3) NOT NULL,
    USER_CHANGE            INTEGER NOT NULL,
    DATE_CHANGE            TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE WARES_PARAMETERS_SUBGROUP (
    CODE_WARES                   INTEGER NOT NULL,
    CODE_SUBGROUP                INTEGER,
    MIN_PERCENT_MARKUP           NUMERIC(5,2),
    BARRIER_RECALCULATION_PRICE  NUMERIC(5,2),
    ALLOW_FOR                    CHAR(1),
    DML_DATETIME                 TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE WARES_RETURN_CACHE (
    CODE_RETURN   INTEGER NOT NULL,
    CODE_WARES    INTEGER NOT NULL,
    PRICE         DOUBLE PRECISION NOT NULL,
    QUANTITY      NUMERIC(16,3) NOT NULL,
    CODE_UNIT     INTEGER NOT NULL,
    VAT           NUMERIC(7,4) NOT NULL,
    ADD_GROUPING  INTEGER DEFAULT 0 NOT NULL,
    CODE_ORDER    INTEGER
);

CREATE TABLE WARES_WITH_FRACTIONAL_UNIT (
    CODE_WARES    INTEGER NOT NULL,
    DML_DATETIME  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE Z_REPORT_TAX_GROUP (
    CODE_REPORT      INTEGER NOT NULL,
    CODE_REC         INTEGER NOT NULL,
    TAX_GROUP        CHAR(2) NOT NULL,
    TURNOVER         NUMERIC(15,2),
    TAX_SUM          NUMERIC(15,2),
    RETURN_TURNOVER  NUMERIC(15,2),
    RETURN_TAX_SUM   NUMERIC(15,2),
    Z_ZVIT_NUM       INTEGER,
    CODENUMBERCASH   INTEGER
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: CASSA_OPERATION_SERVER */
CREATE VIEW CASSA_OPERATION_SERVER(
    CODE_OPERATION,
    NUMBER_OPERATION,
    DATE_OPERATION,
    CODE_CASH_REGISTER,
    TYPE_OPERATION,
    CODE_REASON,
    CODE_PRIVAT,
    SUMMA)
AS
SELECT CODE_OPERATION,
       NUMBER_OPERATION,
       DATE_OPERATION,
       CODE_CASH_REGISTER,
       TYPE_OPERATION,
       CODE_REASON,
       CODE_PRIVAT,
       SUMMA
FROM   CASSA_OPERATION
;



/* View: V_BOX_ADDITION_UNIT */
CREATE VIEW V_BOX_ADDITION_UNIT(
    CODE_WARES,
    CODE_UNIT,
    COEFFICIENT,
    DEFAULT_UNIT,
    SIGN_LOCKING,
    DESCRIPTION,
    NAME_UNIT,
    ABR_UNIT)
AS
SELECT au.code_wares,
       au.code_unit,
       au.coefficient,
       au.default_unit,
       au.sign_locking,
       au.description,
       u.name_unit,
       u.abr_unit
FROM   addition_unit   au
LEFT JOIN unit_dimension  u ON (u.code_unit = au.code_unit)
WHERE ( au.sign_activity = 'Y' )
  AND ( au.sign_locking = 'N')
;



/* View: V_BOX_CREDIT_CARD */
CREATE VIEW V_BOX_CREDIT_CARD(
    CODE_CREDIT_CARD,
    NAME_CREDIT_CARD)
AS
SELECT code_credit_card,
       name_credit_card
FROM   credit_card
WHERE sign_activity = 'Y'
;



/* View: V_BOX_DEALER */
CREATE VIEW V_BOX_DEALER(
    NAME_DEALER,
    ABR_DEALER,
    CODE_DEALER,
    CODE_SUBGROUP,
    SUM_DEALER,
    CODE_CURRENCY,
    MARKUP,
    CODE_CURRENCY_NAC)
AS
SELECT d.name_dealer,
       d.abr_dealer,
       d.code_dealer,
       d.code_subgroup,
       d.sum_dealer,
       d.code_currency,
       d.markup,
       attr.code_cur_nac code_currency_nac
FROM   attrib attr,
       spa_access_objects ao,
       dealer d,
       current_init ci
WHERE  ( ci.code_init = 1)
   AND ( d.code_subgroup = attr.code_subgroup)
   AND ( attr.code_attrib = 1)
   AND ( ao.code_profile = ci.code_profile)
   AND ( ao.type_object  = 'DD' )
   AND ( ao.code_object  = d.code_dealer )
;



/* View: V_CALCULATION_NOT_CHECK */
CREATE VIEW V_CALCULATION_NOT_CHECK(
    CODE_CALCULATION,
    CODE_SUBGROUP,
    TYPE_VAT,
    CODE_FIRM,
    C_NAME_DESTINATION,
    ACCOUNT,
    CODE_ZIP,
    CODE_ORDER,
    NUMBER_CALCULATION,
    STATUS_TRANSFER,
    NUMBER_ORDER,
    ID_WORKPLACE,
    DATE_CALCULATION,
    DATE_PAYMENT,
    TYPE_PAYMENT,
    VAT,
    ADDRESS,
    PHONE,
    TYPE_DOCUMENT,
    LABELVAT,
    SUMCALCULATIONWITHOUTNDS,
    SUMNDS,
    SUMCALCULATION,
    DISCOUNT,
    CODE_MANAGER,
    C_MANAGER,
    BAR_CODE_CLIENT,
    NAME_CLIENT,
    NAME_USER)
AS
SELECT calc.code_calculation,
       calc.code_subgroup,
       o.type_vat,
       f.code_firm,
       f.name                                               c_name_destination,
       f.account,
       f.code_zip,
       calc.code_order,
       calc.number_calculation,
       calc.status_transfer,
       o.number_order,
       o.id_workplace,
       calc.date_calculation,
       o.date_payment,
       o.type_payment,
       calc.vat * 100                                       vat,
       f.address,
       'Тел./факс' || f.phone || '/ ' || f.fax              phone,
       '15 - '                                              type_document,
       (SELECT result FROM GetAddGroupingStr(calc.add_grouping)) LabelVat,
       (SELECT result FROM GetSumCalculationCache(calc.code_calculation)) SumCalculationWithoutNDS,
       (SELECT result FROM GetNDSCalculationCache(calc.code_calculation)) SumNDS,
       (SELECT result FROM GetFullSumCalculationCache(calc.code_calculation)) SumCalculation,
       o.discount,
       o.code_manager,
       (SELECT m.name_for_print FROM privat m WHERE (m.code_privat = o.code_manager)) c_manager,
       (SELECT bar_code FROM GetClientInfo(o.type_client, o.code_client)) bar_code_client,
       (SELECT name FROM GetClientInfo(o.type_client, o.code_client)) Name_Client,
       (SELECT p.surname FROM privat p WHERE (p.code_privat = o.user_change)) Name_User
FROM   firms              f,
       order_client_cache o,
       calculation_cache  calc
WHERE (f.code_firm  = calc.code_firm )
  AND (o.code_order = calc.code_order)
  AND (NOT EXISTS (SELECT 1 FROM calc_cash_register_cache cash WHERE (cash.code_calculation = calc.code_calculation)) )
;



/* View: V_CASH_POS */
CREATE VIEW V_CASH_POS(
    CODE_DOCUMENT,
    DATE_DOCUMENT,
    TYPE_DOCUMENT)
AS
SELECT DISTINCT oc.code_order code_document, oc.date_change date_document, 'C' type_document
FROM calc_cash_register_cache ccrc, order_client_cache oc, calculation_cache calc
WHERE (calc.code_subgroup = (SELECT a.code_subgroup FROM attrib a WHERE (a.code_attrib = 1)))
  AND (calc.status_transfer = '0')
  AND (ccrc.code_calculation = calc.code_calculation)
  AND (oc.code_order = calc.code_order)
UNION ALL
SELECT r.code_return, CAST(r.date_return AS TIMESTAMP), 'R' type_document
FROM return_register_cache rrc, return_cache r
WHERE (r.code_subgroup = (SELECT a.code_subgroup FROM attrib a WHERE (a.code_attrib = 1)))
  AND (r.status_transfer = '0')
  AND (rrc.code_return = r.code_return)
;



/* View: V_CASH_POS_R1 */
CREATE VIEW V_CASH_POS_R1(
    CODE_ORDER,
    TYPE_PAYMENT,
    TYPE_VAT,
    CODE_CLIENT,
    TYPE_CLIENT,
    CODE_DEALER,
    DISCOUNT,
    PER_PP,
    CODE_MANAGER,
    ID_WORKPLACE,
    CODE_ADDITION_SIGN,
    USER_CHANGE,
    NUMBER_ORDER,
    CODE_END,
    DATE_CHANGE,
    DATE_OUT_INVOICE,
    DATE_TAKE,
    SER_POWER_OF_ATTORNEY,
    NUM_POWER_OF_ATTORNEY,
    DATE_POWER_OF_ATTORNEY,
    NSP_POWER_OF_ATTORNEY)
AS
SELECT oc.code_order,
       oc.type_payment,
       oc.type_vat,
       oc.code_client,
       oc.type_client,
       oc.code_dealer,
       oc.discount,
       oc.per_pp,
       oc.code_manager,
       oc.id_workplace,
       oc.code_addition_sign,
       oc.user_change,
       oc.number_order,
       oc.code_end,
       oc.date_change,
       calc.date_out_invoice,
       calc.date_take,
       (SELECT poa.ser_power_of_attorney FROM power_of_attorney poa WHERE (poa.code_order = oc.code_order)) ser_power_of_attorney,
       (SELECT poa.num_power_of_attorney FROM power_of_attorney poa WHERE (poa.code_order = oc.code_order)) num_power_of_attorney,
       (SELECT poa.date_power_of_attorney FROM power_of_attorney poa WHERE (poa.code_order = oc.code_order)) date_power_of_attorney,
       (SELECT poa.nsp_power_of_attorney FROM power_of_attorney poa WHERE (poa.code_order = oc.code_order)) nsp_power_of_attorney
FROM order_client_cache oc, calculation_cache calc
WHERE (calc.status_transfer = '0')
  AND (oc.code_order = calc.code_order)
;



/* View: V_GET_NAME_USER */
CREATE VIEW V_GET_NAME_USER(
    C_NAME_USER)
AS
SELECT p.surname || ' ' || CAST(SUBSTR(p.name, 1, 70) AS VARCHAR(70)) || ' ' || CAST(SUBSTR(p.patronymic, 1, 70) AS VARCHAR(70))
FROM   privat p, current_init c
WHERE (c.code_init = 1)
  AND (p.code_privat = c.code_privat)
;



/* View: V_GET_PRICE_DEALER_WARES */
CREATE VIEW V_GET_PRICE_DEALER_WARES(
    CODE_WARES,
    CODE_DEALER,
    CODE_SUBGROUP,
    CODE_CURRENCY,
    CODECURRENCYNATIONAL,
    PRICE_DEALER)
AS
SELECT pd.code_wares,
       pd.code_dealer,
       pd.code_subgroup,
       pd.code_currency,
       attr.code_cur_nac CodeCurrencyNational,
       pd.price_dealer
FROM   attrib attr,
       price_dealer pd
WHERE  ( pd.code_subgroup = attr.code_subgroup)
   AND ( attr.code_attrib = 1)
;



/* View: V_GET_WARES_ORDER_WITH_CACHE */
CREATE VIEW V_GET_WARES_ORDER_WITH_CACHE(
    CODE_ORDER,
    PRICE_SCHEMA,
    DEALER_PRICEPROP,
    CODE_WARES,
    CODE_UNIT,
    VAT,
    ADD_GROUPING,
    NAME_WARES,
    ARTICL,
    OLD_ARTICL,
    CODE_GROUP,
    CODE_BRAND,
    TOUCH_CODE,
    REC_NO,
    C_NAME_GROUP_WARES,
    C_NAME_BRAND,
    C_NAME_UNIT_INV,
    PRICE_CATALOG,
    PRICEWARES,
    SUMQUANTITYWARESEDIT,
    SUMPRICEWARESEDIT,
    SUMPRICECATALOG)
AS
SELECT wo.code_order,
       wo.price_schema,
       wo.dealer_priceprop,
       wo.code_wares,
       wo.code_unit,
       wo.vat,
       wo.add_grouping,
       w.name_wares,
       w.articl,
       w.old_articl,
       w.code_group,
       w.code_brand,
       w.touch_code,
       wo.rec_no,
       gw.name          c_name_group_wares,
       f.name           c_name_brand,
       u.abr_unit       c_name_unit_inv,
       wo.price_catalog price_catalog,
       wo.price         PriceWares,
       wo.quantity      SumQuantityWaresEdit,
       CAST(wo.quantity * wo.price AS NUMERIC(15, 2))         SumPriceWaresEdit,
       CAST(wo.quantity * wo.price_catalog AS NUMERIC(15, 2)) SumPriceCatalog
FROM      wares_order_cache wo
LEFT JOIN wares w on (w.code_wares=wo.code_wares)
LEFT JOIN group_wares gw on (gw.code_group_wares=w.code_group)
LEFT JOIN unit_dimension u on (u.code_unit=wo.code_unit)
LEFT JOIN firms f on (f.code_firm=w.code_brand)
;



/* View: V_LOCATE_CLIENT */
CREATE VIEW V_LOCATE_CLIENT(
    CODE_CLIENT,
    NAME_CLIENT,
    CODE_ZIP,
    IMPOCITION,
    AGREE_NUMBER,
    BAR_CODE_CLIENT,
    CODE_TRIDE_REGION,
    DOCUMENT,
    VARIANT_PAYMENT,
    DISCOUNT,
    C_VARIANT_PAYMENT,
    CODE_DEALER,
    C_NAME_DEALER,
    ID_CLIENT,
    DISCOUNT_POSITION,
    TYPE_CLIENT,
    NAME_TYPE_CLIENT,
    C_SPEC_DISCOUNT,
    C_PRICE_NOTLESS_SPRICE,
    C_MIN_PRICE_SPRICE,
    C_NOT_SPRICE)
AS
SELECT pc.code_privat  code_client,
       p.surname || ' ' || CAST(SUBSTR(p.name, 1, 70) AS VARCHAR(70)) || ' ' || ' ' || CAST(SUBSTR(p.patronymic, 1, 70) AS VARCHAR(70)) name_client,
       CAST(NULL AS VARCHAR(20))  code_zip,
       p.impocition,
       p.agree_number,
       p.bar_code               bar_code_client,
       pc.code_tride_region,
       p.document,
       pc.variant_payment,
       pc.discount,
       s1.state  c_variant_payment,
       dc.code_dealer,
       d.name_dealer     c_name_dealer,
       pc.id_client,
       pc.discount_position,
       'P'                      type_client,
       'Физ. лицо'              name_type_client,
       s2.state c_spec_discount,
       s3.state  c_price_notless_sprice,
       s4.state c_min_price_sprice,
       s5.state c_not_sprice
FROM p_client pc
left join privat p on (p.code_privat = pc.code_privat)
left join dealer_compliance dc on (dc.code_dealer_center = pc.code_dealer)
left join dealer d on (d.code_dealer = dc.code_dealer)
left join state_all s1 on ((s1.part_state=21)and(s1.abr_state=pc.variant_payment))
left join state_all s2 on ((s2.part_state=44)and(s2.abr_state=pc.check_spec_discount))
left join state_all s3 on ((s3.part_state=45)and(s3.abr_state=pc.price_notless_sprice))
left join state_all s4 on ((s4.part_state=45)and(s4.abr_state=pc.min_price_sprice))
left join state_all s5 on ((s5.part_state=45)and(s5.abr_state=pc.not_sprice))

WHERE
      ( pc.code_subgroup =  (select a.code_subgroup from attrib a where a.code_attrib=1))
  AND ( pc.sign_activity = 'Y' )
UNION ALL
SELECT fc.code_firm  code_client,
       CAST(f.name AS VARCHAR(213)) name_client,
       f.code_zip,
       f.impocition,
       f.agree_number,
       f.bar_code               bar_code_client,
       fc.code_tride_region,
       CAST(NULL AS VARCHAR(120)) document,
       fc.variant_payment,
       fc.discount,
       s1.state  c_variant_payment,
       dc.code_dealer,
       d.name_dealer     c_name_dealer,
       fc.id_client,
       fc.discount_position,
       'F'                      type_client,
       'Юр.  лицо'              name_type_client,
       s2.state c_spec_discount,
       s3.state  c_price_notless_sprice,
       s4.state c_min_price_sprice,
       s5.state c_not_sprice
FROM f_client fc
left join firms f on (f.code_firm = fc.code_firm)
left join dealer_compliance dc on (dc.code_dealer_center = fc.code_dealer)
left join dealer d on (d.code_dealer = dc.code_dealer)
left join state_all s1 on ((s1.part_state=21)and(s1.abr_state=fc.variant_payment))
left join state_all s2 on ((s2.part_state=44)and(s2.abr_state=fc.check_spec_discount))
left join state_all s3 on ((s3.part_state=45)and(s3.abr_state=fc.price_notless_sprice))
left join state_all s4 on ((s4.part_state=45)and(s4.abr_state=fc.min_price_sprice))
left join state_all s5 on ((s5.part_state=45)and(s5.abr_state=fc.not_sprice))
WHERE ( fc.code_subgroup = (select a.code_subgroup from attrib a where a.code_attrib = 1))
  AND ( fc.sign_activity      = 'Y' )
;



/* View: V_LOCATE_WARES_RETAIL */
CREATE VIEW V_LOCATE_WARES_RETAIL(
    CODE_WARES,
    CODE_GROUP,
    NAME_WARES,
    ARTICL,
    CODE_BRAND,
    NAME_WARES_BRAND,
    ARTICL_WARES_BRAND,
    CODE_UNIT,
    OLD_WARES,
    SIGN_1,
    SIGN_2,
    SIGN_3,
    C_NAME_BRAND,
    ABR_UNIT,
    C_NAME_GROUP_WARES,
    OLD_ARTICL,
    VAT,
    TOUCH_CODE,
    CODE_WARES_RELATIVE,
    PRICE_DEALER_PRN)
AS
SELECT w.code_wares,
       w.code_group,
       w.name_wares,
       w.articl,
       w.code_brand,
       w.name_wares_brand,
       w.articl_wares_brand,
       w.code_unit,
       w.o_wares,
       w.sign_1,
       w.sign_2,
       w.sign_3,
       b.name c_name_brand,
       u.abr_unit abr_unit,
       gw.name c_name_group_wares,
       w.old_articl,
       w.vat,
       w.touch_code,
       w.code_wares_relative,
       (SELECT CAST(CAST(pd.price_dealer*au.coefficient AS NUMERIC(18, 10))*(1 + (SELECT result FROM GetNDSInner(w.code_wares, 1))) AS NUMERIC(15, 2))
        FROM price_dealer pd
        WHERE (pd.code_wares = w.code_wares)
          AND (pd.code_dealer = (SELECT code_dealer_roz FROM attrib))) price_dealer_prn
     FROM addition_unit au
LEFT JOIN wares w ON (au.code_wares = w.code_wares)
LEFT JOIN group_wares gw ON (gw.code_group_wares = w.code_group)
LEFT JOIN unit_dimension u ON (u.code_unit = au.code_unit)
LEFT JOIN firms b ON (b.code_firm = w.code_brand)
WHERE  (au.code_unit = (SELECT result FROM GetCodeUnitBasisORDefault(w.code_wares, w.code_unit)))
   AND (w.o_wares = 'No')
;



/* View: V_LOCATE_WARES_RETAIL0 */
CREATE VIEW V_LOCATE_WARES_RETAIL0(
    CODE_WARES,
    CODE_GROUP,
    NAME_WARES,
    ARTICL,
    CODE_BRAND,
    NAME_WARES_BRAND,
    ARTICL_WARES_BRAND,
    CODE_UNIT,
    OLD_WARES,
    SIGN_1,
    SIGN_2,
    SIGN_3,
    C_NAME_BRAND,
    ABR_UNIT,
    C_NAME_GROUP_WARES,
    OLD_ARTICL,
    VAT,
    TOUCH_CODE,
    CODE_WARES_RELATIVE,
    NAME_WARES_RECEIPT,
    PRICE_DEALER_PRN,
    CODE_UNIT_DEF)
AS
SELECT au.code_wares,
       w.code_group,
       w.name_wares,
       w.articl,
       w.code_brand,
       w.name_wares_brand,
       w.articl_wares_brand,
       w.code_unit,
       w.o_wares,
       w.sign_1,
       w.sign_2,
       w.sign_3,
       b.name c_name_brand,
       u.abr_unit abr_unit,
       gw.name c_name_group_wares,
       w.old_articl,
       w.vat,
       au.bar_code,
       w.code_wares_relative,
       w.name_wares_receipt,
       pd.price_dealer*au.coefficient*(1 + w.vat/100 /*(SELECT result FROM GetNDSInner(w.code_wares, 1))*/) price_dealer_prn,
       au.code_unit CODE_UNIT_DEF
       /*(SELECT CAST(CAST(pd.price_dealer*au.coefficient AS NUMERIC(18, 10))*(1 + (SELECT result FROM GetNDSInner(w.code_wares, 1))) AS NUMERIC(15, 2))
        FROM price_dealer pd
        WHERE (pd.code_wares = w.code_wares)
          AND (pd.code_dealer = (SELECT code_dealer_roz FROM attrib))) price_dealer_prn*/
     FROM addition_unit au
LEFT JOIN wares w ON (w.code_wares = au.code_wares)
LEFT JOIN unit_dimension u on (u.code_unit = au.code_unit)
LEFT JOIN firms b on (b.code_firm = w.code_brand)
LEFT JOIN group_wares gw on (gw.code_group_wares = w.code_group)
LEFT JOIN price_dealer pd on ((pd.code_wares=w.code_wares)
--                        and (pd.code_dealer = (SELECT a.code_dealer_roz FROM attrib a where a.code_attrib=1))
                          and (pd.code_subgroup =(select a.CODE_SUBGROUP from attrib a where a.code_attrib=1 )))
WHERE
--       (W.TOUCH_CODE starting with '482001246')
   --au.code_unit in (SELECT result FROM GetCodeUnitBasisORDefault(w.code_wares, w.code_unit))

    au.default_unit='Y'
   AND (w.o_wares = 'No')
--   AND EXISTS (SELECT 1
--           FROM price_dealer pd
--        WHERE (pd.code_wares = w.code_wares)
   AND (pd.price_dealer > 0)
--          AND (pd.code_dealer = (SELECT code_dealer_roz FROM attrib)))
   and (pd.code_dealer = (SELECT a.code_dealer_roz FROM attrib a where a.code_attrib=1))
/*       (SELECT CAST(CAST(pd.price_dealer*au.coefficient AS NUMERIC(18, 10))*(1 + (SELECT result FROM GetNDSInner(w.code_wares, 1))) AS NUMERIC(15, 2))
        FROM price_dealer pd
        WHERE (pd.code_wares = w.code_wares)
          AND (pd.code_dealer = (SELECT code_dealer_roz FROM attrib))) price_dealer_prn
FROM   unit_dimension u, addition_unit au, firms b, group_wares gw, wares w
WHERE  (w.code_wares = au.code_wares)
   AND (au.code_unit = (SELECT result FROM GetCodeUnitBasisORDefault(w.code_wares, w.code_unit)))
   AND (u.code_unit = au.code_unit)
   AND (gw.code_group_wares = w.code_group)
   AND (b.code_firm = w.code_brand)
   AND (w.o_wares = 'No')
   AND EXISTS (SELECT 1
           FROM price_dealer pd
        WHERE (pd.code_wares = w.code_wares)
          AND (pd.price_dealer > 0)
          AND (pd.code_dealer = (SELECT code_dealer_roz FROM attrib)))
;*/
;



/* View: V_OPTIONS */
CREATE VIEW V_OPTIONS(
    TYPE_OPTIONS,
    VARIETY_OPTIONS,
    DESCRIPTION,
    CODE_PRIVAT,
    CHECK_OPTIONS,
    OPTIONS)
AS
SELECT ao.type_options,
       ao.variety_options,
       ao.description,
       aou.code_privat,
       ao.check_options,
       aou.options
FROM   application_options ao
LEFT JOIN application_options_user aou ON (aou.id_application_options = ao.id_application_options)
  AND  (aou.code_privat = (SELECT code_privat FROM current_init WHERE (code_init = 1)))
WHERE (ao.check_options = '1')
;



/* View: V_ORDER_CLIENT_R1 */
CREATE VIEW V_ORDER_CLIENT_R1(
    CODE_ORDER,
    CODE_SUBGROUP,
    NUMBER_ORDER,
    DATE_ORDER,
    CODE_ADDRESSEE,
    CODE_MANAGER,
    VARIETY_ORDER,
    TYPE_ADDRESSEE,
    DISCOUNT,
    TYPE_PAYMENT,
    TYPE_ORDER,
    CODE_END,
    STATE_ORDER,
    RECALC_PRICE,
    CODE_ADDITION_SIGN,
    USER_CHANGE,
    DATE_CHANGE,
    CODE_DEALER,
    DATE_PAYMENT,
    ID_WORKPLACE,
    PER_PP,
    C_NAME_ADD_SIGN_ORDER,
    C_NAME_ADDRESSEE,
    C_NAME_USER,
    C_MANAGER,
    C_VARIETY_ORDER,
    C_TYPE_ORDER,
    C_STATE_ORDER,
    C_TYPE_PAYMENT,
    C_TYPE_ADDRESSEE,
    TYPE_VAT,
    C_TYPE_VAT,
    FIX_PRICE,
    NAME_DEALER,
    PRIORITY,
    SUMORDER,
    BAR_CODE_CLIENT,
    VARIANT_PAYMENT,
    REST_ACCOUNT)
AS
SELECT o.code_order,
       o.code_subgroup,
       o.number_order,
       o.date_order,
       o.code_client                                         code_addressee,
       o.code_manager,
       o.variety_order,
       o.type_client                                         type_addressee,
       o.discount,
       o.type_payment,
       o.type_order,
       o.code_end,
       (SELECT state_order FROM GetStateOrder(o.code_order, o.code_end)) state_order,
       '  '                                                  recalc_price,
       o.code_addition_sign,
       o.user_change,
       o.date_change,
       o.code_dealer,
       o.date_payment,
       o.id_workplace,
       o.per_pp,
       CAST('' AS VARCHAR(70))                               c_name_add_sign_order,
       (SELECT name FROM GetClientInfo(o.type_client, o.code_client)) c_name_addressee,
       (SELECT us.surname || ' ' || CAST(SUBSTR(us.name, 1, 70) AS VARCHAR(70)) || ' ' || CAST(SUBSTR(us.patronymic, 1, 70) AS VARCHAR(70)) FROM privat us WHERE (us.code_privat = o.user_change)) c_name_user,
       (SELECT m.surname || ' ' || CAST(SUBSTR(m.name, 1, 70) AS VARCHAR(70)) || ' ' || CAST(SUBSTR(m.patronymic, 1, 70) AS VARCHAR(70)) FROM privat m WHERE (m.code_privat = o.code_manager)) c_manager,
       (SELECT s1.state FROM state_all s1 WHERE (s1.part_state = 17) AND (s1.abr_state = o.variety_order)) c_variety_order,
       (SELECT s2.state FROM state_all s2 WHERE (s2.part_state = 18) AND (s2.abr_state = o.type_order)) c_type_order,
       (SELECT s6.state FROM state_all s6 WHERE (s6.part_state = 16) AND (s6.abr_state = (SELECT state_order FROM GetStateOrder(o.code_order, o.code_end)))) c_state_order,
       (SELECT s3.state FROM state_all s3 WHERE (s3.part_state = 19) AND (s3.abr_state = o.type_payment)) c_type_payment,
       (SELECT s4.state FROM state_all s4 WHERE (s4.part_state = 13) AND (s4.abr_state = o.type_client)) c_type_addressee,
       o.type_vat,
       (SELECT s5.state FROM state_all s5 WHERE (s5.part_state = 786) AND (s5.abr_state = o.type_vat)) c_type_vat,
       '  '                                                  fix_price,
       (SELECT d.name_dealer FROM dealer d WHERE (d.code_dealer = o.code_dealer)) name_dealer,
       o.priority,
       (SELECT result FROM GetSumOrderCache(o.code_order))   SumOrder,
       (SELECT bar_code FROM GetClientInfo(o.type_client, o.code_client)) bar_code_client,
       (SELECT variant_payment FROM GetClientInfo(o.type_client, o.code_client)) variant_payment,
       (SELECT ac.account FROM account_client ac WHERE (ac.code_client = o.code_client) AND (ac.code_currency = (SELECT code_cur_nac FROM attrib))) rest_account
FROM order_client_cache o
WHERE o.type_payment = 'B'
;



/* View: V_PARED_FIND_CALCULATION_CACHE */
CREATE VIEW V_PARED_FIND_CALCULATION_CACHE(
    CODE_ORDER,
    NUMBER_CALCULATION,
    STATE_ORDER,
    CODE_CALCULATION)
AS
SELECT calc.code_order,
       calc.number_calculation,
       (SELECT state_order FROM GetStateOrder(o.code_order, o.code_end)) state_order,
       calc.code_calculation
FROM   calculation_cache  calc,
       order_client_cache o
WHERE  (o.code_order = calc.code_order)
;



/* View: V_PARED_FIND_ORDER_CACHE */
CREATE VIEW V_PARED_FIND_ORDER_CACHE(
    CODE_ORDER,
    NUMBER_ORDER,
    STATE_ORDER)
AS
SELECT o.code_order,
       o.number_order,
       (SELECT state_order FROM GetStateOrder(o.code_order, o.code_end)) state_order
FROM   order_client_cache o
;



/* View: V_PARED_FIND_RECEIPT_CACHE */
CREATE VIEW V_PARED_FIND_RECEIPT_CACHE(
    CODE_CALCULATION,
    NUMBER_RECEIPT,
    DATE_RECEIPT,
    NUMBER_CASHIER,
    NUMBER_CASH_REGISTER,
    CODE_ORDER)
AS
SELECT rec.code_calculation,
       rec.number_receipt,
       rec.only_date_receipt date_receipt,
       rec.number_cashier,
       rec.number_cash_register,
       calc.code_order
FROM   calculation_cache        calc,
       calc_cash_register_cache rec
WHERE  ( calc.code_calculation = rec.code_calculation )
;



/* View: V_PARED_FIND_TAX_INVOICE */
CREATE VIEW V_PARED_FIND_TAX_INVOICE(
    CODE_ORDER,
    NUMBER_TAX_INVOICE,
    STATE_ORDER,
    CODE_CALCULATION)
AS
SELECT calc.code_order,
       calc.number_tax_invoice,
       (SELECT state_order FROM GetStateOrder(o.code_order, o.code_end)) state_order,
       calc.code_calculation
FROM   calculation_cache  calc,
       order_client_cache o
WHERE  (o.code_order = calc.code_order)
;



/* View: V_REPORT_DOCUMENT_CHECK */
CREATE VIEW V_REPORT_DOCUMENT_CHECK(
    TYPE_VAT,
    CODE_FIRM,
    C_NAME_DESTINATION,
    NAME_FOR_PRINT,
    ACCOUNT,
    CODE_ZIP,
    IMPOCITION,
    AGREE_NUMBER,
    CODE_ORDER,
    NUMBER_ORDER,
    ID_WORKPLACE,
    DATE_ORDER,
    TYPE_PAYMENT,
    C_TYPE_PAYMENT,
    DISCOUNT,
    DESCRIPTION,
    ADDRESS,
    PHONE,
    SUMCALCULATIONWITHOUTNDS,
    SUMNDS,
    SUMCALCULATION,
    SUMDISCOUNT,
    BAR_CODE_CLIENT,
    C_NAME_ADDRESSEE,
    NAME_FOR_PRINT_CLIENT,
    NAME_USER,
    C_NAME_USER,
    C_MANAGER,
    NAME_WAREHOUSE,
    IMPOCITION_CLIENT,
    AGREE_NUMBER_CLIENT,
    PHONE_CLIENT,
    ADDRESS_CLIENT,
    INDEX_MAIL_CLIENT,
    NUMBER_RECEIPT,
    DATE_RECEIPT)
AS
SELECT o.type_vat,
       f.code_firm,
       f.name                                               c_name_destination,
       f.name_for_print,
       f.account,
       f.code_zip,
       f.impocition,
       f.agree_number,
       o.code_order,
       o.number_order,
       o.id_workplace,
       o.date_order,
       o.type_payment,
       (SELECT st.state FROM state_all st WHERE (st.part_state = 19) AND (st.abr_state = o.type_payment)) c_type_payment,
       o.discount,
       o.description,
       (SELECT c.name_city FROM city c WHERE (c.code_city = f.code_city)) || ' ' || f.address,
       'Тел./факс' || f.phone || '/ ' || f.fax              phone,
       (SELECT SUM((SELECT result FROM GetSumCalculationCache(ca.code_calculation)))
        FROM calculation_cache ca
        WHERE (ca.code_order = o.code_order)) SumCalculationWithoutNDS,
       (SELECT SUM((SELECT result FROM GetNDSCalculationCache(ca.code_calculation)))
        FROM calculation_cache ca
        WHERE (ca.code_order = o.code_order)) SumNDS,
       (SELECT SUM((SELECT result FROM GetFullSumCalculationCache(ca.code_calculation)))
        FROM calculation_cache ca
        WHERE (ca.code_order = o.code_order)) SumCalculation,
       (SELECT result FROM GetSumOrderCatalogCache(o.code_order)) - (SELECT result FROM GetSumOrderCache(o.code_order)) SumDiscount,
       (SELECT bar_code FROM GetClientInfo(o.type_client, o.code_client)) bar_code_client,
       (SELECT name FROM GetClientInfo(o.type_client, o.code_client)) c_name_addressee,
       (SELECT name_for_print FROM GetClientInfo(o.type_client, o.code_client)) name_for_print,
       p.surname          name_user,
       p.name_for_print   c_name_user,
       m.name_for_print   c_manager,
       (SELECT name_shop FROM attrib) name_warehouse,
       (SELECT impocition FROM GetClientInfo(o.type_client, o.code_client)) impocition_client,
       (SELECT agree_number FROM GetClientInfo(o.type_client, o.code_client)) agree_number_client,
       (SELECT phone FROM GetClientInfo(o.type_client, o.code_client)) phone_client,
       (SELECT (SELECT c.name_city FROM city c WHERE (c.code_city = r.code_city)) || ' ' || r.address FROM GetClientInfo(o.type_client, o.code_client) r) address_client,
       (SELECT index_mail FROM GetClientInfo(o.type_client, o.code_client)) index_mail_client,
       ccr.number_receipt,
       ccr.date_receipt
FROM   firms              f,
       privat             m,
       privat             p,
       order_client_cache o,
       calculation_cache  calc,
       calc_cash_register_cache ccr
WHERE (f.code_firm   = calc.code_firm )
  AND (o.code_order  = calc.code_order)
  AND (p.code_privat = o.user_change  )
  AND (m.code_privat = o.code_manager )
  AND (ccr.code_calculation = calc.code_calculation)
;



/* View: V_REPORT_DOCUMENT_NOT_CHECK */
CREATE VIEW V_REPORT_DOCUMENT_NOT_CHECK(
    DATE_ORDER,
    SUMCALCULATION)
AS
SELECT o.date_order,
       (SELECT result FROM GetFullSumCalculationCache(calc.code_calculation)) SumCalculation
FROM calculation_cache calc, order_client_cache o
WHERE (o.code_order = calc.code_order)
  AND (NOT EXISTS (SELECT 1 FROM calc_cash_register_cache cash WHERE (cash.code_calculation = calc.code_calculation)) )
;



/* View: V_REPORT_WARES_DOCUMENT */
CREATE VIEW V_REPORT_WARES_DOCUMENT(
    CODE_ORDER,
    DATE_ORDER,
    CODE_CALCULATION,
    CODE_WARES,
    CODE_UNIT,
    ARTICL,
    BAR_CODE,
    COEFFICIENT_TO_BASIS,
    ABR_UNIT_DEF,
    COEFFICIENT_TO_DEF,
    REC_NO,
    NAME_WARES_RECEIPT,
    NAME_WARES,
    CODE_BRAND,
    C_NAME_BRAND,
    NAME_WARES_STR_1,
    NAME_WARES_STR_2,
    NAME_WARES_STR_3,
    C_NAME_UNIT_INV,
    PRICE,
    PRICEWITHVAT,
    PRICE_CATALOG,
    PRICE_CATALOG_WITHVAT,
    SUMQUANTITY,
    SUMPRICE,
    SUMPRICEWITHVAT)
AS
SELECT o.code_order,
       o.date_order,
       calc.code_calculation,
       w.code_wares,
       wo.code_unit,
       w.articl,
       addu.bar_code,
       addu.coefficient coefficient_to_basis,
       udef.abr_unit abr_unit_def,
       (SELECT result FROM GetCoefficient(w.code_wares, udef.code_unit)) coefficient_to_def,
       wo.rec_no,
       w.name_wares_receipt,
       w.name_wares,
       w.code_brand,
       f.name                                            c_name_brand,
       CAST(SUBSTR(w.name_wares, 1, 33) AS VARCHAR(33))  name_wares_str_1,
       CAST(SUBSTR(w.name_wares, 34, 66) AS VARCHAR(33)) name_wares_str_2,
       CAST(SUBSTR(w.name_wares, 67, 99) AS VARCHAR(33)) name_wares_str_3,
       u.abr_unit                                        c_name_unit_inv,
       DECODE5(o.type_vat,'OU', CAST(wo.price AS NUMERIC(15, 2)),'IN', wo.price) price,
       DECODE5(o.type_vat,'OU', CAST(wo.price AS NUMERIC(15, 2)) * (1 + wo.vat),'IN', CAST(CAST(wo.price AS NUMERIC(18, 9)) * (1 + wo.vat) AS NUMERIC(15, 2))) PriceWithVAT,
       DECODE5(o.type_vat,'OU', CAST(wo.price_catalog AS NUMERIC(15, 2)),'IN', wo.price_catalog) price_catalog,
       DECODE5(o.type_vat,'OU', CAST(wo.price_catalog AS NUMERIC(15, 2)) * (1 + wo.vat),'IN', CAST(CAST(wo.price_catalog AS NUMERIC(18, 9)) * (1 + wo.vat) AS NUMERIC(15, 2))) price_catalog_withvat,
       wo.quantity                          SumQuantity,
       DECODE5(o.type_vat,'OU', CAST(wo.quantity * CAST(wo.price AS NUMERIC(15, 2)) AS NUMERIC(15, 2)),'IN', wo.quantity * wo.price) SumPrice,
       DECODE5(o.type_vat,'OU', CAST(wo.quantity * CAST(wo.price AS NUMERIC(15, 2)) AS NUMERIC(15, 2))*(1 + wo.vat), 'IN', CAST(wo.quantity * CAST(CAST(wo.price AS NUMERIC(18, 9)) * (1 + wo.vat) AS NUMERIC(15, 2)) AS NUMERIC(15, 2))) SumPriceWithVAT
FROM
          order_client_cache o
LEFT JOIN calculation_cache  calc on (o.code_order=calc.code_order)
LEFT JOIN wares_order_cache  wo   on (wo.code_order=calc.code_order)
LEFT JOIN addition_unit      addu on (addu.code_unit=wo.code_unit)and(addu.code_wares=wo.code_wares)
LEFT JOIN wares              w    on (w.code_wares = addu.code_wares)
LEFT JOIN unit_dimension     udef on (udef.code_unit=(SELECT result FROM GetCodeUnitDefaultOfWares(w.code_wares)))
LEFT JOIN unit_dimension     u    on (u.code_unit= wo.code_unit)
LEFT JOIN firms              f    on (w.code_brand=f.code_firm)

WHERE  ( calc.vat                = wo.vat          )
  AND  ( calc.add_grouping       = wo.add_grouping )
;



/* View: V_RETURN_CACHE */
CREATE VIEW V_RETURN_CACHE(
    CODE_RETURN,
    CODE_SUBGROUP,
    DATE_RETURN,
    NUMBER_CHECK,
    DATE_CHECK,
    TYPE_VAT,
    ID_WORKPLACE,
    CODE_FIRM,
    CODE_WAREHOUSE,
    CODE_ADDITION_SIGN,
    STATUS_TRANSFER,
    DESCRIPTION,
    USER_CHANGE,
    DATE_CHANGE,
    TYPE_PAYMENT,
    C_TYPE_PAYMENT,
    C_TYPE_VAT,
    C_NAME_USER,
    C_NAME_ADD_RETURN,
    SUM_RETURN,
    NUMBER_RECEIPT,
    DATE_RECEIPT,
    NUMBER_CASHIER,
    NUMBER_CASH_REGISTER,
    MODEL_CASH_REGISTER,
    ID_WORKPLACE_SALE,
    NUMBER_CASH_REGISTER_SALE,
    MODEL_CASH_REGISTER_SALE)
AS
SELECT r.code_return,
       r.code_subgroup,
       r.date_return,
       r.number_check,
       r.date_check,
       r.type_vat,
       r.id_workplace,
       r.code_firm,
       r.code_warehouse,
       r.code_addition_sign,
       r.status_transfer,
       r.description,
       r.user_change,
       r.date_change,
       r.type_payment,
       (SELECT s3.state FROM state_all s3 WHERE (s3.part_state = 19) AND (s3.abr_state = r.type_payment)) c_type_payment,
       (SELECT stvat.state FROM state_all stvat WHERE (stvat.part_state = 786) AND (stvat.abr_state = r.type_vat)) c_type_vat,
       (SELECT p.surname || ' ' || CAST(SUBSTR(p.name, 1, 70) AS VARCHAR(70)) || ' ' || CAST(SUBSTR(p.patronymic, 1, 70) AS VARCHAR(70)) FROM privat p WHERE (p.code_privat = r.user_change)) c_name_user,
       (SELECT ads.name FROM addition_sign ads WHERE (ads.code_addition_sign = r.code_addition_sign)) c_name_add_return,
       (SELECT result FROM GetSumReturnCache(r.code_return)) sum_return,
       cash.number_receipt,
       cash.date_receipt,
       cash.number_cashier,
       cash.number_cash_register,
       cash.model_cash_register,
       r.id_workplace_sale,
       r.number_cash_register_sale,
       r.model_cash_register_sale       
FROM   return_cache r
LEFT JOIN return_register_cache cash ON (cash.code_return = r.code_return)
;



/* View: V_VRO_LIST_REPORTS */
CREATE VIEW V_VRO_LIST_REPORTS(
    LINK_ID,
    POS_NO,
    HAS_MANUAL_PARAMS,
    HAS_PROGRAM_PARAMS,
    CATEGORY_ID,
    LEVEL_ID,
    LEVEL_TYPE,
    REPORT_ID,
    REPORT_NAME,
    REPORT_NUMBER,
    REPORT_TYPE,
    PRINT_FOR_SELECTION,
    DESCRIPTION,
    DLL_NAME)
AS
SELECT
1 link_id,
reps.report_id pos_no,
(select count(*) from vro_report_datasets ds, vro_report_dataset_params ps
where ds.report_id = reps.report_id and (ds.dataset_id = ps.dataset_id) and (ps.param_input = 1)) has_manual_params,
(select count(*) from vro_report_datasets ds, vro_report_dataset_params ps
where ds.report_id = reps.report_id and (ds.dataset_id = ps.dataset_id) and (ps.param_input = 2)) has_program_params,
reps.category_id,
1 level_id,
3 level_type,
reps.report_id,
reps.report_name,
reps.report_number,
reps.report_type,
reps.print_for_selection,
reps.description,
st.description dll_name
FROM state_all st, vro_reports reps
WHERE (reps.report_type = st.abr_state)
  AND (st.part_state = 806)
  AND (st.sign_activity = 'Y')
;



/* View: V_WARES_CALCULATION_CACHE */
CREATE VIEW V_WARES_CALCULATION_CACHE(
    CODE_CALCULATION,
    CODE_FIRM,
    VAT,
    ADD_GROUPING,
    REC_NO,
    C_NAME_GROUP_WARES,
    CODE_GROUP,
    CODE_WARES,
    NAME_WARES,
    ARTICL,
    CODE_BRAND,
    TOUCH_CODE,
    C_NAME_BRAND,
    PRICE,
    CODE_UNIT_BY_INVOICE,
    C_NAME_UNIT_INV,
    SUMQUANTITY,
    SUMPRICE)
AS
SELECT calc.code_calculation,
       calc.code_firm,
       calc.vat,
       calc.add_grouping,
       wo.rec_no,
       gw.name            c_name_group_wares,
       w.code_group,
       wo.code_wares,
       w.name_wares,
       w.articl,
       w.code_brand,
       w.touch_code,
       b.name             c_name_brand,
       wo.price,
       wo.code_unit       code_unit_by_invoice,
       u.abr_unit         c_name_unit_inv,
       wo.quantity        SumQuantity,
       CAST(wo.quantity * wo.price AS NUMERIC(15, 2)) SumPrice
FROM      order_client_cache o
LEFT JOIN calculation_cache  calc on ( o.code_order        = calc.code_order )
LEFT JOIN wares_order_cache  wo on ( wo.code_order       = calc.code_order )
LEFT JOIN wares              w on ( w.code_wares        = wo.code_wares   )
LEFT JOIN firms              b on ( b.code_firm         = w.code_brand    )
LEFT JOIN group_wares        gw on ( gw.code_group_wares = w.code_group    )
LEFT JOIN unit_dimension     u on ( u.code_unit         = wo.code_unit    )
WHERE  ( calc.vat            = wo.vat          )
  AND  ( calc.add_grouping   = wo.add_grouping )
;



/* View: V_WARES_ORDER_CACHE */
CREATE VIEW V_WARES_ORDER_CACHE(
    CODE_ORDER,
    CODE_WARES,
    REC_NO,
    CODE_UNIT_BY_INVOICE,
    VAT,
    NAME_WARES,
    ARTICL,
    OLD_ARTICL,
    CODE_GROUP,
    CODE_BRAND,
    TOUCH_CODE,
    C_NAME_GROUP_WARES,
    C_NAME_BRAND,
    C_NAME_UNIT_INV,
    PRICEWARES,
    SUMQUANTITYWARESEDIT,
    SUMPRICEWARESEDIT,
    SUMPRICECATALOG)
AS
SELECT wo.code_order,
       wo.code_wares,
       wo.rec_no,
       wo.code_unit  code_unit_by_invoice,
       wo.vat * 100  vat,
       w.name_wares,
       w.articl,
       w.old_articl,
       w.code_group,
       w.code_brand,
       w.touch_code,
       gw.name       c_name_group_wares,
       f.name        c_name_brand,
       u.abr_unit    c_name_unit_inv,
       wo.price      PriceWares,
       wo.quantity   SumQuantityWaresEdit,
       cast(wo.quantity * CAST(wo.price AS NUMERIC(15, 2))  AS NUMERIC(15, 2))         SumPriceWaresEdit,
       cast(wo.quantity * CAST(wo.price_catalog AS NUMERIC(15, 2)) AS NUMERIC(15, 2)) SumPriceCatalog
FROM      wares_order_cache  wo
LEFT JOIN wares              w  on ( w.code_wares        = wo.code_wares )
LEFT JOIN group_wares        gw on ( gw.code_group_wares = w.code_group  )
LEFT JOIN unit_dimension     u  on ( u.code_unit         = wo.code_unit  )
LEFT JOIN firms              f  on ( f.code_firm         = w.code_brand  )
;



/* View: V_WARES_RETURN_CACHE */
CREATE VIEW V_WARES_RETURN_CACHE(
    CODE_RETURN,
    CODE_WARES,
    CODE_UNIT_BY_INVOICE,
    VAT,
    NAME_WARES,
    ARTICL,
    OLD_ARTICL,
    CODE_GROUP,
    CODE_BRAND,
    TOUCH_CODE,
    C_NAME_GROUP_WARES,
    C_NAME_BRAND,
    C_NAME_UNIT_INV,
    PRICEWARES,
    QUANTITYWARES,
    SUMPRICEWARES)
AS
SELECT wr.code_return,
       wr.code_wares,
       wr.code_unit  code_unit_by_invoice,
       wr.vat * 100  vat,
       w.name_wares,
       w.articl,
       w.old_articl,
       w.code_group,
       w.code_brand,
       w.touch_code,
       gw.name       c_name_group_wares,
       f.name        c_name_brand,
       u.abr_unit    c_name_unit_inv,
       wr.price      PriceWares,
       wr.quantity   QuantityWares,
       CAST(wr.quantity * wr.price AS NUMERIC(15, 2)) SumPriceWares
FROM   wares_return_cache wr
LEFT JOIN wares              w on ( w.code_wares        = wr.code_wares )
LEFT JOIN group_wares        gw on ( gw.code_group_wares = w.code_group  )
LEFT JOIN unit_dimension     u on ( u.code_unit         = wr.code_unit  )
LEFT JOIN firms              f on ( f.code_firm         = w.code_brand  )
;




/* Check constraints definition */

ALTER TABLE ATTRIB ADD CONSTRAINT CASSA_NOT_NEGATIVE CHECK (CASSA >= 0);
ALTER TABLE ACCOUNT_CLIENT ADD CONSTRAINT ACCOUNT_CHECK CHECK (ACCOUNT >= 0);
ALTER TABLE ACCOUNT_CLIENT ADD CONSTRAINT ACCOUNT_CASH_CHECK CHECK (ACCOUNT_CASH >= 0);
ALTER TABLE ACCOUNT_CLIENT ADD CONSTRAINT ACCOUNT_RC_CHECK CHECK (ACCOUNT_REUSABLE_CONTAINER >= 0);
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT DISCOUNT_WARES_CHECK CHECK ((DISCOUNT < 100) AND (DISCOUNT > -100));
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT QUANTITY_CASH_CHECK CHECK (QUANTITY  > 0);
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT PRICE_CASH_CHECK CHECK (PRICE >= 0 );
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT QUANTITY_RET CHECK (QUANTITY_IN_BASIS_RET >= 0);
ALTER TABLE WARES_RETURN_CACHE ADD CONSTRAINT QUANTITY_RETURN_CHECK CHECK (QUANTITY  > 0);
ALTER TABLE WARES_RETURN_CACHE ADD CONSTRAINT PRICE_RETURN_CHECK CHECK (PRICE  > 0);


/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE A_ACTION ADD CONSTRAINT I2_CHECK_ACTION UNIQUE (STATUS_TRANSFER, DATE_CHANGE, CODE_ACTION, CODE_FRAGMENT);
ALTER TABLE CASH_SHIFT_LOG ADD CONSTRAINT I1_CASH_SHIFT_LOG UNIQUE (STATUS_TRANSFER, CODE_SUBGROUP, DATE_CASH_SHIFT_LOG, ID_WORKPLACE, CODE_FIRM_COMPANY, CODE_WAREHOUSE, CODE_PRIVAT, TYPE_CASH_SHIFT_LOG, VIEW_CASH_SHIFT_LOG);
ALTER TABLE FIRMS ADD CONSTRAINT I_NAME_FIRM UNIQUE (NAME);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCOUNT_CLIENT ADD CONSTRAINT ID_ACCOUNT_CLIENT PRIMARY KEY (CODE_CLIENT, CODE_CURRENCY, CODE_FIRM_COMPANY);
ALTER TABLE ADDITION_SIGN ADD CONSTRAINT ID_ADDITION_SIGN PRIMARY KEY (CODE_ADDITION_SIGN);
ALTER TABLE ADDITION_UNIT ADD CONSTRAINT ID_ADDITION_UNIT PRIMARY KEY (CODE_WARES, CODE_UNIT);
ALTER TABLE APPLICATION_OPTIONS ADD CONSTRAINT ID_APP_OPTIONS PRIMARY KEY (TYPE_OPTIONS, VARIETY_OPTIONS);
ALTER TABLE APPLICATION_OPTIONS_USER ADD CONSTRAINT ID_APPLICATION_OPTIONS_USER PRIMARY KEY (CODE_PRIVAT, TYPE_OPTIONS, VARIETY_OPTIONS);
ALTER TABLE APP_ERRORS ADD CONSTRAINT ID_APP_ERRORS PRIMARY KEY (CODE_ERROR);
ALTER TABLE ATTRIB ADD CONSTRAINT ID_ATTRIB PRIMARY KEY (CODE_ATTRIB);
ALTER TABLE A_ACTION ADD CONSTRAINT ID_ACTION PRIMARY KEY (DATE_CHANGE, CODE_ACTION, CODE_FRAGMENT);
ALTER TABLE A_WARES ADD CONSTRAINT ID_A_WARES PRIMARY KEY (CODE_WARES, UPD_STATUS);
ALTER TABLE CALCULATION_CACHE ADD CONSTRAINT ID_CALCULATION_CACHE PRIMARY KEY (CODE_CALCULATION);
ALTER TABLE CALCULATION_CREDIT_CARD_CACHE ADD CONSTRAINT ID_CAL_CREDIT_CARD_CACHE PRIMARY KEY (CODE_CALCULATION, CODE_CREDIT_CARD);
ALTER TABLE CASH_REGISTER_REPORT ADD CONSTRAINT ID_CASH_REGISTER_REPORT PRIMARY KEY (CODE_CASH_REGISTER_REPORT);
ALTER TABLE CASH_SHIFT_LOG ADD CONSTRAINT ID_CASH_SHIFT_LOG PRIMARY KEY (CODE_SUBGROUP, DATE_CASH_SHIFT_LOG, ID_WORKPLACE, CODE_FIRM_COMPANY, CODE_WAREHOUSE, CODE_PRIVAT, TYPE_CASH_SHIFT_LOG, VIEW_CASH_SHIFT_LOG);
ALTER TABLE CASSA_OPERATION ADD CONSTRAINT ID_C_OPER PRIMARY KEY (CODE_OPERATION);
ALTER TABLE CHOSEN_GROUP_WARES ADD CONSTRAINT ID_CHOSEN_GROUP_WARES PRIMARY KEY (CODE_GROUP, TYPE_CHOICE);
ALTER TABLE CITY ADD CONSTRAINT PK_CITY PRIMARY KEY (CODE_CITY);
ALTER TABLE CONCERN_F_CLIENT ADD CONSTRAINT ID_FCLIENT PRIMARY KEY (CODE_FIRM, CODE_CONCERN);
ALTER TABLE CONCERN_P_CLIENT ADD CONSTRAINT ID_PCLIENT PRIMARY KEY (CODE_PRIVAT, CODE_CONCERN);
ALTER TABLE CONTRACT ADD CONSTRAINT ID_CONTRACT PRIMARY KEY (CODE_CONTRACT);
ALTER TABLE CREDIT_CARD ADD CONSTRAINT ID_CREDIT_CARD PRIMARY KEY (CODE_CREDIT_CARD);
ALTER TABLE CURRENT_INIT ADD CONSTRAINT ID_CURRENT_INIT PRIMARY KEY (CODE_INIT);
ALTER TABLE DEALER ADD CONSTRAINT ID_DEALER PRIMARY KEY (CODE_DEALER, CODE_SUBGROUP);
ALTER TABLE DEALER_COMPLIANCE ADD CONSTRAINT ID_DEALER_COMPLIANCE PRIMARY KEY (CODE_DEALER_CENTER, CODE_DEALER);
ALTER TABLE DEPARTMENT ADD CONSTRAINT ID_DEPARTMENT PRIMARY KEY (CODE_DEPARTMENT);
ALTER TABLE DISCOUNT_CARD ADD CONSTRAINT PK_DISCOUNT_CARD PRIMARY KEY (CODE_DISCOUNT_CARD);
ALTER TABLE DISCOUNT_CARD_FOR_TIME ADD CONSTRAINT ID_DISCOUNT_CARD_FOR_TIME PRIMARY KEY (RECORD_ID);
ALTER TABLE DISCOUNT_CLIENT_OF_BRAND ADD CONSTRAINT ID_DISCOUNT_CL_OF_BR PRIMARY KEY (CODE_CLIENT, CODE_BRAND, CODE_SUBGROUP);
ALTER TABLE DISCOUNT_CLIENT_OF_GROUP ADD CONSTRAINT ID_DISCOUNT_CL_OF_GR PRIMARY KEY (CODE_CLIENT, CODE_GROUP, CODE_SUBGROUP);
ALTER TABLE FIRMS ADD CONSTRAINT ID_FIRM PRIMARY KEY (CODE_FIRM);
ALTER TABLE F_CLIENT ADD CONSTRAINT ID_F_CLIENT PRIMARY KEY (CODE_FIRM, CODE_SUBGROUP);
ALTER TABLE GROUP_WARES ADD CONSTRAINT ID_GROUP_WARES PRIMARY KEY (CODE_GROUP_WARES);
ALTER TABLE HOT_KEY_RESERVE ADD CONSTRAINT ID_HOT_KEY_RESERVE PRIMARY KEY (ID_MENU, CODE_SHOP);
ALTER TABLE HOT_KEY_WARES ADD CONSTRAINT ID_HOT_KEY_WARES PRIMARY KEY (HOT_KEY);
ALTER TABLE KASSA_UPDATE_LOGZ ADD CONSTRAINT PK_KASSA_UPDATE_LOGZ PRIMARY KEY (TABLE_ID);
ALTER TABLE MANAGER ADD CONSTRAINT ID_MANAGER PRIMARY KEY (CODE_TRIDE_REGION, CODE_PRIVAT);
ALTER TABLE MY_TEMP_ORDER ADD CONSTRAINT ID_MY_TEMP_ORDER PRIMARY KEY (NUMBER_COPY, CODE_CLIENT, CODE_WARES, CODE_UNIT, CHECKTYPE);
ALTER TABLE MY_WARES_WORD ADD PRIMARY KEY (ID);
ALTER TABLE OPTS_ITEM_VALUES ADD CONSTRAINT PK_OPTS_ITEM_VALUES PRIMARY KEY (CODE_SUBJECT, CODE_ITEM);
ALTER TABLE OPTS_OPTION_ITEMS ADD CONSTRAINT PKEY_ITEMCODE PRIMARY KEY (CODE_ITEM);
ALTER TABLE ORDER_CLIENT_CACHE ADD CONSTRAINT ID_ORDER_CLIENT_CACHE PRIMARY KEY (CODE_ORDER);
ALTER TABLE POWER_OF_ATTORNEY ADD CONSTRAINT ID_POWER_OF_ATTORNEY PRIMARY KEY (CODE_ORDER);
ALTER TABLE PRICE_DEALER ADD CONSTRAINT ID_PRICE_DEALER PRIMARY KEY (CODE_WARES, CODE_DEALER, CODE_SUBGROUP);
ALTER TABLE PRICE_PROPOCITION ADD CONSTRAINT ID_PRICE_PROPOCITION PRIMARY KEY (CODE_PRICE_PROPOCITION);
ALTER TABLE PRIVAT ADD CONSTRAINT ID_PRIVAT PRIMARY KEY (CODE_PRIVAT);
ALTER TABLE P_CLIENT ADD CONSTRAINT ID_P_CLIENT PRIMARY KEY (CODE_PRIVAT, CODE_SUBGROUP);
ALTER TABLE REGISTER_CASH_REGISTER ADD CONSTRAINT ID_REGISTER_CASH_REGISTER PRIMARY KEY (CODE_REGISTER_CASH_REGISTER);
ALTER TABLE REPOSIT ADD CONSTRAINT NAMECALC PRIMARY KEY (NAMECALC);
ALTER TABLE REPOSITORY_FILTER_CFG ADD CONSTRAINT ID_NAME_FILTER_CONFIG PRIMARY KEY (ID_USER, NAME_GRID, NAME_DATASET);
ALTER TABLE REPOSITORY_XLREP ADD CONSTRAINT ID_NAME_XLREPORT PRIMARY KEY (ID_USER, NAME_MODULE, NAME_GRID, NAME_DATASET);
ALTER TABLE REPOSITORY_XLREP_CFG ADD CONSTRAINT ID_NAME_XLREPORT_CONFIG PRIMARY KEY (ID_USER, NAME_MODULE, NAME_GRID, NAME_DATASET);
ALTER TABLE REPOSIT_QUERY ADD CONSTRAINT ID_NAME_GRID PRIMARY KEY (ID_USER, NAME_GRID, NAME_DATASET);
ALTER TABLE RETURN_CACHE ADD CONSTRAINT ID_RETURN_CACHE PRIMARY KEY (CODE_RETURN);
ALTER TABLE RETURN_REGISTER_CACHE ADD CONSTRAINT ID_RETURN_REGISTER_CACHE PRIMARY KEY (CODE_RETURN);
ALTER TABLE SHOP_CLIENT_FOR_FRONTOFFICE ADD CONSTRAINT ID_SHOP_CLIENT_FOR_FRONTOFFICE PRIMARY KEY (SHOP_CLIENT_FOR_FRONTOFFICE_ID);
ALTER TABLE SHOP_CLIENT_FROM_SUM_ORDER ADD CONSTRAINT ID_SHOP_CLIENT_FROM_SUM_ORDER PRIMARY KEY (CODE_SHOP, CODE_CLIENT);
ALTER TABLE SHOP_DEALER ADD CONSTRAINT ID_SHOP_DEALER PRIMARY KEY (CODE_SHOP, CODE_DEALER);
ALTER TABLE SHOP_DEPARTMENT_WARES ADD CONSTRAINT ID_SHOP_DEPARTMENT_WARES PRIMARY KEY (CODE_WARES, CODE_DEPARTMENT);
ALTER TABLE SHOP_DEPARTMENT_WORKPLACE ADD CONSTRAINT ID_SHOP_DEPARTMENT_WORKPLACE PRIMARY KEY (ID_WORKPLACE, CODE_DEPARTMENT);
ALTER TABLE SHOP_DISCOUNT ADD CONSTRAINT ID_SHOP_DISCOUNT PRIMARY KEY (CODE_DISCOUNT);
ALTER TABLE SHOP_PRICE_SUPPLIER ADD CONSTRAINT ID_SHOP_PRICE_SUPPLIER PRIMARY KEY (CODE_WARES, CODE_SUPPLIER);
ALTER TABLE SHOP_SPECPROPOSITION_TIME ADD CONSTRAINT ID_SHOP_SPECPROPOSITION_TIME PRIMARY KEY (SHOP_SPECPROPOSITION_TIME_ID);
ALTER TABLE SPA_ACCESS_ACTIONS ADD CONSTRAINT ID_SPA_ACCESS_ACTIONS PRIMARY KEY (CODE_PROFILE, CODE_ACTION);
ALTER TABLE SPA_ACCESS_OBJECTS ADD CONSTRAINT ID_SPA_ACCESS_OBJECTS PRIMARY KEY (CODE_PROFILE, TYPE_OBJECT, CODE_OBJECT);
ALTER TABLE SPA_ACCESS_SECURITY ADD CONSTRAINT ID_SPA_ACCESS_SECURITY PRIMARY KEY (CODE_PROFILE, CODE_OBJECT);
ALTER TABLE SPA_EVENTS_AUDIT ADD CONSTRAINT ID_SPA_EVENTS_AUDIT PRIMARY KEY (EVENT_ID);
ALTER TABLE SPA_INSPECTOR ADD CONSTRAINT PKEY_INSPECTOR PRIMARY KEY (CODE_INSPECTOR);
ALTER TABLE SPA_PROFILES ADD CONSTRAINT ID_SPA_PROFILES PRIMARY KEY (CODE_PROFILE);
ALTER TABLE SPA_SECURITY_LIST ADD CONSTRAINT ID_SPA_SECURITY_LIST PRIMARY KEY (CODE_OBJECT);
ALTER TABLE SPA_USERS ADD CONSTRAINT ID_SPA_USERS PRIMARY KEY (CODE_SPOSUSER);
ALTER TABLE SPA_USERS_TEST ADD CONSTRAINT ID_SPA_USERS_TEST PRIMARY KEY (CODE_SPOSUSER);
ALTER TABLE SPA_USER_CASHDESKS ADD CONSTRAINT ID_SPA_USER_CASHDESKS PRIMARY KEY (CODE_SPOSUSER, CODE_REGISTER_CASH_REGISTER);
ALTER TABLE STATE_ALL ADD CONSTRAINT CODE_STATE PRIMARY KEY (PART_STATE, ABR_STATE);
ALTER TABLE TEMP_ORDER ADD CONSTRAINT ID_TEMP_ORDER PRIMARY KEY (NUMBER_COPY, CODE_CLIENT, CODE_WARES, CODE_UNIT);
ALTER TABLE UNIT_DIMENSION ADD CONSTRAINT ID_UNIT_DIMENSION PRIMARY KEY (CODE_UNIT);
ALTER TABLE V_SPA_EVENTS_MONITOR ADD CONSTRAINT PKEY_SPAEI PRIMARY KEY (CODE_COMPLIANCE, CODE_SHOP);
ALTER TABLE WARES ADD CONSTRAINT ID_WARES PRIMARY KEY (CODE_WARES);
ALTER TABLE WARES_CATALOG ADD CONSTRAINT PK_WARES_CATALOG PRIMARY KEY (CATALOG_ID);
ALTER TABLE WARES_CONTRACT_OF_PRICE ADD CONSTRAINT PK_WARES_CONTRACT_OF_PRICE PRIMARY KEY (CODE_CONTRACT);
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT ID_WARES_ORDER_CACHE PRIMARY KEY (CODE_ORDER, CODE_WARES, CODE_UNIT);
ALTER TABLE WARES_PARAMETERS_SUBGROUP ADD CONSTRAINT ID_WARES_PARAMETERS_SUBGROUP PRIMARY KEY (CODE_WARES);
ALTER TABLE WARES_RETURN_CACHE ADD CONSTRAINT ID_WARES_RETURN_CACHE PRIMARY KEY (CODE_RETURN, CODE_WARES);
ALTER TABLE WARES_WITH_FRACTIONAL_UNIT ADD CONSTRAINT ID_WARES_WITH_FRAC_UNIT PRIMARY KEY (CODE_WARES);
ALTER TABLE Z_REPORT_TAX_GROUP ADD CONSTRAINT ID_CODE_REC PRIMARY KEY (CODE_REPORT, CODE_REC);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE CALCULATION_CACHE ADD CONSTRAINT CALCC_ORDER FOREIGN KEY (CODE_ORDER) REFERENCES ORDER_CLIENT_CACHE (CODE_ORDER) ON DELETE CASCADE;
ALTER TABLE CALCULATION_CREDIT_CARD_CACHE ADD CONSTRAINT CALCULATION_CREDIT_CARD_CALCC FOREIGN KEY (CODE_CALCULATION) REFERENCES CALCULATION_CACHE (CODE_CALCULATION) ON DELETE CASCADE;
ALTER TABLE CALC_CASH_REGISTER_CACHE ADD CONSTRAINT CALC_CASH_REGISTER_CACHE_CALC FOREIGN KEY (CODE_CALCULATION) REFERENCES CALCULATION_CACHE (CODE_CALCULATION) ON DELETE CASCADE;
ALTER TABLE POWER_OF_ATTORNEY ADD CONSTRAINT POA_ORDER FOREIGN KEY (CODE_ORDER) REFERENCES ORDER_CLIENT_CACHE (CODE_ORDER) ON DELETE CASCADE;
ALTER TABLE RETURN_REGISTER_CACHE ADD CONSTRAINT RETURN_REGISTER_CACHE_RET FOREIGN KEY (CODE_RETURN) REFERENCES RETURN_CACHE (CODE_RETURN) ON DELETE CASCADE;
ALTER TABLE WARES_CATALOG ADD CONSTRAINT FK_WARES_CATALOG_1 FOREIGN KEY (CATALOG_PARENT_ID) REFERENCES WARES_CATALOG (CATALOG_ID);
ALTER TABLE WARES_ORDER_CACHE ADD CONSTRAINT WOC_ORDER FOREIGN KEY (CODE_ORDER) REFERENCES ORDER_CLIENT_CACHE (CODE_ORDER) ON DELETE CASCADE;
ALTER TABLE WARES_RETURN_CACHE ADD CONSTRAINT WOC_RETURN FOREIGN KEY (CODE_RETURN) REFERENCES RETURN_CACHE (CODE_RETURN) ON DELETE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX ADDITION_UNIT_IDX1 ON ADDITION_UNIT (CODE_WARES, DEFAULT_UNIT);
CREATE INDEX I_ADDITION_UNIT ON ADDITION_UNIT (BAR_CODE, CHECK_FIND_BAR_CODE, CODE_WARES);
CREATE INDEX I1_CHECK_ACTION ON A_ACTION (NUMBER_CHECK, DATE_CHANGE, EVENT_ID);
CREATE INDEX I2_CALCULATION_CACHE ON CALCULATION_CACHE (DATE_CHANGE, CODE_CALCULATION);
CREATE INDEX ORDER_CALCULATION_CACHE ON CALCULATION_CACHE (CODE_ORDER);
CREATE INDEX TR_ORD_CALCULATION_CACHE ON CALCULATION_CACHE (STATUS_TRANSFER, CODE_ORDER);
CREATE INDEX I2_CALC_CASH_REGISTER_CACHE ON CALC_CASH_REGISTER_CACHE (DATE_RECEIPT, CODE_CALCULATION);
CREATE INDEX I3_CALC_CASH_REGISTER_CACHE ON CALC_CASH_REGISTER_CACHE (DATE_CHANGE, CODE_CALCULATION);
CREATE UNIQUE INDEX ID_CALC_CASH_REGISTER_CACHE ON CALC_CASH_REGISTER_CACHE (CODE_CALCULATION);
CREATE INDEX I_CALC_CASH_REGISTER_CACHE ON CALC_CASH_REGISTER_CACHE (ONLY_DATE_RECEIPT, NUMBER_RECEIPT);
CREATE INDEX I1_CASH_REGISTER_REPORT ON CASH_REGISTER_REPORT (STATUS_TRANSFER);
CREATE INDEX I2_CASH_REGISTER_REPORT ON CASH_REGISTER_REPORT (TIME_CASH_REGISTER_REPORT);
CREATE INDEX I1_CASSA_OPERATION ON CASSA_OPERATION (DATE_OPERATION, CODE_CASH_REGISTER);
CREATE INDEX I2_CASSA_OPERATION ON CASSA_OPERATION (STATUS_TRANSFER);
CREATE INDEX CHOSEN_GROUP_WARES_IDX1 ON CHOSEN_GROUP_WARES (TYPE_CHOICE);
CREATE INDEX CLIENT_CONTRACT ON CONTRACT (CODE_CLIENT);
CREATE INDEX TYPE_CLIENT_CONTRACT ON CONTRACT (TYPE_CLIENT);
CREATE INDEX I_BARCODE_F ON FIRMS (BAR_CODE);
CREATE INDEX I_CODE_ZIP ON FIRMS (CODE_ZIP);
CREATE DESCENDING INDEX KASSA_UPDATE_LOGZ_IDX2 ON KASSA_UPDATE_LOGZ (DML_DATETIME);
CREATE UNIQUE INDEX MY_STATE_ALL_IDX1 ON MY_STATE_ALL (ABR_STATE);
CREATE INDEX MY_WARES_WORD_BIDX ON MY_WARES_WORD (NAME_ORDERB_IDX, WARES_WORD, ID);
CREATE INDEX MY_WARES_WORD_CODE ON MY_WARES_WORD (CODE_WARES, WARES_WORD);
CREATE INDEX MY_WARES_WORD_NAME ON MY_WARES_WORD (WARES_WORD);
CREATE INDEX IND_OPTI_CODEOPTION ON OPTS_OPTION_ITEMS (CODE_OPTION);
CREATE INDEX IDX_CLIENT_ORDER ON ORDER_CLIENT_CACHE (CODE_CLIENT);
CREATE INDEX IDX_DATE_ORDER ON ORDER_CLIENT_CACHE (DATE_ORDER, ID_WORKPLACE);
CREATE INDEX IDX_END_ORDER ON ORDER_CLIENT_CACHE (CODE_END, CODE_ORDER);
CREATE INDEX IDX_ORDER_PRIORITY ON ORDER_CLIENT_CACHE (PRIORITY);
CREATE INDEX IDX_PAYMENT_ORDER ON ORDER_CLIENT_CACHE (TYPE_PAYMENT);
CREATE INDEX I_SUBGROUP_CUBIC_PP ON PRICE_PROPOCITION (CODE_WARES, CUBIC);
CREATE INDEX I_BARCODE_P ON PRIVAT (BAR_CODE);
CREATE INDEX DATE_RETURN_CACHE ON RETURN_CACHE (DATE_RETURN, STATUS_TRANSFER);
CREATE INDEX I2_RETURN_CACHE ON RETURN_CACHE (DATE_CHANGE, CODE_RETURN);
CREATE INDEX SUB_TR_RETURN_CACHE ON RETURN_CACHE (STATUS_TRANSFER, CODE_RETURN);
CREATE INDEX I2_RETURN_REGISTER_CACHE ON RETURN_REGISTER_CACHE (DATE_RECEIPT, CODE_RETURN);
CREATE INDEX SUM_ORDER_CLIENT ON SHOP_CLIENT_FROM_SUM_ORDER (SUM_ORDER, CODE_SHOP);
CREATE INDEX SPA_USERS_IDX1 ON SPA_USERS (USER_NAME);
CREATE INDEX TEST_DELETE_BY_IDX_TABLE_IDX1 ON TEST_DELETE_BY_IDX_TABLE (PARENT);
ALTER INDEX TEST_DELETE_BY_IDX_TABLE_IDX1 INACTIVE;
CREATE INDEX TEST_IDX1 ON TEST_DELETE_BY_IDX_TABLE (IDX);
CREATE INDEX DIV_UNIT_DIMENSION ON UNIT_DIMENSION (CODE_UNIT, SIGN_DIVISIONAL);
CREATE UNIQUE INDEX ID_VRO_REPORTS ON VRO_REPORTS (CATEGORY_ID, REPORT_ID);
CREATE UNIQUE INDEX PK_VRO_DS ON VRO_REPORT_DATASETS (REPORT_ID, DATASET_ID);
CREATE UNIQUE INDEX PK_VRO_DSP ON VRO_REPORT_DATASET_PARAMS (DATASET_ID, PARAM_ID);
CREATE UNIQUE INDEX PK_VRO_PCAT ON VRO_REPORT_LINK_PARAMS (PARAM_ID);
CREATE UNIQUE INDEX PK_VRO_TCAT ON VRO_REPORT_LINK_TEMPLATES (TEMPLATE_ID);
CREATE UNIQUE INDEX PK_VRO_VCAT ON VRO_REPORT_LINK_VARIABLES (VARIABLE_ID);
CREATE UNIQUE INDEX PK_VRO_TMPL ON VRO_REPORT_TEMPLATES (REPORT_ID, TEMPLATE_ID);
CREATE UNIQUE INDEX PK_VRO_VARS ON VRO_REPORT_VARIABLES (REPORT_ID, VARIABLE_ID);
CREATE INDEX I1_V_SPA_EVENTS_MONITOR ON V_SPA_EVENTS_MONITOR (EVENT_ID, CODE_INSPECTOR, INSPECTOR_EVENT_ID);
CREATE INDEX I_CODE_WARES_RELATIVE ON WARES (CODE_WARES_RELATIVE);
CREATE INDEX WARES_IDX4 ON WARES (CODE_GROUP);
CREATE INDEX WARES_NAME_WARES_IDX5 ON WARES COMPUTED BY (NAME_WARES COLLATE WIN1251_UA);
CREATE INDEX WARES_O_WARES_IDX6 ON WARES COMPUTED BY (UPPER(O_WARES COLLATE WIN1251_UA));
CREATE INDEX WARES_RETURN_CACHE_IDX1 ON WARES_RETURN_CACHE (CODE_ORDER, CODE_WARES, CODE_UNIT);
CREATE INDEX Z_REPORT_TAX_GROUP_IDX1 ON Z_REPORT_TAX_GROUP (TAX_GROUP);
CREATE INDEX Z_REPORT_TAX_GROUP_IDX2 ON Z_REPORT_TAX_GROUP (CODE_REC);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: DEL_CALCULATION_CACHE */
CREATE TRIGGER DEL_CALCULATION_CACHE FOR CALCULATION_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_cache(
code_order,
code_calculation,
code_subgroup,
code_firm,
number_calculation,
date_calculation,
vat,
add_grouping,
state_pay,
number_tax_invoice,
date_out_invoice,
date_take,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_order,
old.code_calculation,
old.code_subgroup,
old.code_firm,
old.number_calculation,
old.date_calculation,
old.vat,
old.add_grouping,
old.state_pay,
old.number_tax_invoice,
old.date_out_invoice,
old.date_take,
old.status_transfer,
:intCodePrivat,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_CALC_CASH_REGISTER_CACHE */
CREATE TRIGGER DEL_CALC_CASH_REGISTER_CACHE FOR CALC_CASH_REGISTER_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
/*
INSERT INTO a_calc_cash_register_cache(
code_calculation,
number_receipt,
date_receipt,
only_date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_calculation,
old.number_receipt,
old.date_receipt,
old.only_date_receipt,
old.number_cashier,
old.number_cash_register,
old.model_cash_register,
old.user_change,
old.date_change,
old.user_change,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_CALC_CREDIT_CARD_CACHE */
CREATE TRIGGER DEL_CALC_CREDIT_CARD_CACHE FOR CALCULATION_CREDIT_CARD_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_credit_card_cache(
code_calculation,
code_credit_card,
number_slip,
description,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_calculation,
old.code_credit_card,
old.number_slip,
old.description,
:intCodePrivat,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_CASSA_OPERATION */
CREATE TRIGGER DEL_CASSA_OPERATION FOR CASSA_OPERATION
ACTIVE AFTER DELETE POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_cassa_operation(
code_operation,
number_operation,
date_operation,
code_cash_register,
type_operation,
code_reason,
code_privat,
summa,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_operation,
old.number_operation,
old.date_operation,
old.code_cash_register,
old.type_operation,
old.code_reason,    
old.code_privat,    
old.summa,
old.status_transfer,
:intCodePrivat,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_ORDER_CLIENT_CACHE */
CREATE TRIGGER DEL_ORDER_CLIENT_CACHE FOR ORDER_CLIENT_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
/*
INSERT INTO a_order_client_cache(
code_order,
code_subgroup,
number_order,
date_order,
variety_order,
type_order,
type_payment,
type_vat,
code_client,
type_client,
date_payment,
code_dealer,
discount,
per_pp,
code_manager,
id_workplace,
code_end,
indication,
priority,
code_addition_sign,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_order,
old.code_subgroup,
old.number_order,
old.date_order,
old.variety_order,
old.type_order,
old.type_payment,
old.type_vat,
old.code_client,
old.type_client,
old.date_payment,
old.code_dealer,
old.discount,
old.per_pp,
old.code_manager,
old.id_workplace,
old.code_end,
old.indication,
old.priority,
old.code_addition_sign,
old.description,
old.user_change,
old.date_change,
old.user_change,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_RETURN_CACHE */
CREATE TRIGGER DEL_RETURN_CACHE FOR RETURN_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_cache(
code_return,
code_subgroup,
date_return,
number_check,
date_check,
type_vat,
id_workplace,
code_firm,
code_warehouse,
code_addition_sign,
type_payment,
status_transfer,
id_workplace_sale,
number_cash_register_sale,
model_cash_register_sale,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_return,
old.code_subgroup,
old.date_return,
old.number_check,    
old.date_check,
old.type_vat,        
old.id_workplace,
old.code_firm,
old.code_warehouse,
old.code_addition_sign,
old.type_payment,
old.status_transfer,
old.id_workplace_sale,
old.number_cash_register_sale,
old.model_cash_register_sale,
old.description,
old.user_change,
old.date_change,
old.user_change,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_RETURN_REGISTER_CACHE */
CREATE TRIGGER DEL_RETURN_REGISTER_CACHE FOR RETURN_REGISTER_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_register_cache(
code_return,
number_receipt,
date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_return,
old.number_receipt,
old.date_receipt,
old.number_cashier,
old.number_cash_register,
old.model_cash_register,
old.user_change,
old.date_change,
old.user_change,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_SPA_EVENTS_AUDIT */
CREATE TRIGGER DEL_SPA_EVENTS_AUDIT FOR SPA_EVENTS_AUDIT
ACTIVE AFTER DELETE POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_spa_events_audit(
event_id,
event_name,
date_audit,
flag_audit,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.event_id,
old.event_name,
old.date_audit,
old.flag_audit,
:intCodePrivat,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_WARES_ORDER_CACHE */
CREATE TRIGGER DEL_WARES_ORDER_CACHE FOR WARES_ORDER_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
/*
INSERT INTO a_wares_order_cache(
code_order,
code_wares,
quantity,
code_unit,
price,
price_catalog,
vat,
price_schema,
dealer_priceprop,
rec_no,
user_change,
date_change,
add_grouping,
discount,
quantity_in_basis_ret,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_order,
old.code_wares,
old.quantity,
old.code_unit,
old.price,
old.price_catalog,
old.vat,
old.price_schema,
old.dealer_priceprop,
old.rec_no,
old.user_change,
old.date_change,
old.add_grouping,
old.discount,
old.quantity_in_basis_ret,
old.user_change,
'DEL',
'OLD');
*/
END
^

/* Trigger: DEL_WARES_RETURN_CACHE */
CREATE TRIGGER DEL_WARES_RETURN_CACHE FOR WARES_RETURN_CACHE
ACTIVE AFTER DELETE POSITION 0
AS
declare variable intCodePrivat INTEGER;
DECLARE VARIABLE coef          FLOAT;
DECLARE VARIABLE restQty       NUMERIC(16, 3);
DECLARE VARIABLE RetQty        NUMERIC(16, 3);
DECLARE VARIABLE ordUnit       INTEGER;
BEGIN

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

IF (old.code_order <> -1) THEN BEGIN
  SELECT result
  FROM GetCoefficient(old.code_wares, old.code_unit)
  INTO :coef;

  restQty = old.quantity * :coef;

  FOR SELECT quantity_in_basis_ret, code_unit
      FROM v_wares_order_for_return(old.code_order, old.code_wares, -1 * :coef)
      ORDER BY ord, coefficient
      INTO :RetQty, :ordUnit
  DO BEGIN

  IF (:RetQty >= :restQty) THEN
  BEGIN
     UPDATE wares_order_cache
     SET quantity_in_basis_ret = quantity_in_basis_ret + :restQty
     WHERE (code_order = old.code_order)
       AND (code_wares = old.code_wares)
       AND (code_unit  = :ordUnit);
     restQty = 0;
  END
  ELSE
  BEGIN
     UPDATE wares_order_cache
     SET quantity_in_basis_ret = quantity_in_basis_ret + :RetQty
     WHERE (code_order = old.code_order)
       AND (code_wares = old.code_wares)
       AND (code_unit  = :ordUnit);

     restQty = :restQty - :RetQty;
  END
  END
END
/*
INSERT INTO a_wares_return_cache(
code_return,
code_wares,
price,
quantity,
code_unit,
vat,
add_grouping,
code_order,
a_user_change,
a_operation,
a_new_old)
VALUES(
old.code_return,
old.code_wares,
old.price,
old.quantity,
old.code_unit,
old.vat,
old.add_grouping,
old.code_order,
:intCodePrivat,
'DEL',
'OLD');
*/
END
^

/* Trigger: INSRECZREPORT */
CREATE TRIGGER INSRECZREPORT FOR Z_REPORT_TAX_GROUP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
     new.code_rec = GEN_ID(gen_code_zreport_rec, 1);
END
^

/* Trigger: INS_CALCULATION_CACHE */
CREATE TRIGGER INS_CALCULATION_CACHE FOR CALCULATION_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_cache(
code_order,
code_calculation,
code_subgroup,
code_firm,
number_calculation,
date_calculation,
vat,
add_grouping,
state_pay,
number_tax_invoice,
date_out_invoice,
date_take,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_calculation,
new.code_subgroup,
new.code_firm,
new.number_calculation,
new.date_calculation,
new.vat,
new.add_grouping,
new.state_pay,
new.number_tax_invoice,
new.date_out_invoice,
new.date_take,
new.status_transfer,
:intCodePrivat,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_CALC_CASH_REGISTER_CACHE */
CREATE TRIGGER INS_CALC_CASH_REGISTER_CACHE FOR CALC_CASH_REGISTER_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
/*
INSERT INTO a_calc_cash_register_cache(
code_calculation,
number_receipt,
date_receipt,
only_date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_calculation,
new.number_receipt,
new.date_receipt,
new.only_date_receipt,
new.number_cashier,
new.number_cash_register,
new.model_cash_register,
new.user_change,
new.date_change,
new.user_change,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_CALC_CREDIT_CARD_CACHE */
CREATE TRIGGER INS_CALC_CREDIT_CARD_CACHE FOR CALCULATION_CREDIT_CARD_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_credit_card_cache(
code_calculation,
code_credit_card,
number_slip,
description,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_calculation,
new.code_credit_card,
new.number_slip,
new.description,
:intCodePrivat,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_CASSA_OPERATION */
CREATE TRIGGER INS_CASSA_OPERATION FOR CASSA_OPERATION
ACTIVE AFTER INSERT POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_cassa_operation(
code_operation,
number_operation,
date_operation,
code_cash_register,
type_operation,
code_reason,
code_privat,
summa,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_operation,
new.number_operation,
new.date_operation,
new.code_cash_register,
new.type_operation,
new.code_reason,    
new.code_privat,    
new.summa,
new.status_transfer,
:intCodePrivat,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_ORDER_CLIENT_CACHE */
CREATE TRIGGER INS_ORDER_CLIENT_CACHE FOR ORDER_CLIENT_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
/*
INSERT INTO a_order_client_cache(
code_order,
code_subgroup,
number_order,
date_order,
variety_order,
type_order,
type_payment,
type_vat,
code_client,
type_client,
date_payment,
code_dealer,
discount,
per_pp,
code_manager,
id_workplace,
code_end,
indication,
priority,
code_addition_sign,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_subgroup,
new.number_order,
new.date_order,
new.variety_order,
new.type_order,
new.type_payment,
new.type_vat,
new.code_client,
new.type_client,
new.date_payment,
new.code_dealer,
new.discount,
new.per_pp,
new.code_manager,
new.id_workplace,
new.code_end,
new.indication,
new.priority,
new.code_addition_sign,
new.description,
new.user_change,
new.date_change,
new.user_change,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_RETURN_CACHE */
CREATE TRIGGER INS_RETURN_CACHE FOR RETURN_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_cache(
code_return,
code_subgroup,
date_return,
number_check,
date_check,
type_vat,
id_workplace,
code_firm,
code_warehouse,
code_addition_sign,
type_payment,
status_transfer,
id_workplace_sale,
number_cash_register_sale,
model_cash_register_sale,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.code_subgroup,
new.date_return,
new.number_check,
new.date_check,
new.type_vat,
new.id_workplace,
new.code_firm,
new.code_warehouse,
new.code_addition_sign,
new.type_payment,
new.status_transfer,
new.id_workplace_sale,
new.number_cash_register_sale,
new.model_cash_register_sale,
new.description,
new.user_change,
new.date_change,
new.user_change,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_RETURN_REGISTER_CACHE */
CREATE TRIGGER INS_RETURN_REGISTER_CACHE FOR RETURN_REGISTER_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_register_cache(
code_return,
number_receipt,
date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.number_receipt,
new.date_receipt,
new.number_cashier,
new.number_cash_register,
new.model_cash_register,
new.user_change,
new.date_change,
new.user_change,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_SPA_EVENTS_AUDIT */
CREATE TRIGGER INS_SPA_EVENTS_AUDIT FOR SPA_EVENTS_AUDIT
ACTIVE AFTER INSERT POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_spa_events_audit(
event_id,
event_name,
date_audit,
flag_audit,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.event_id,
new.event_name,
new.date_audit,
new.flag_audit,
:intCodePrivat,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_WARES_ORDER_CACHE */
CREATE TRIGGER INS_WARES_ORDER_CACHE FOR WARES_ORDER_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
/*
INSERT INTO a_wares_order_cache(
code_order,
code_wares,
quantity,
code_unit,
price,
price_catalog,
vat,
price_schema,
dealer_priceprop,
rec_no,
user_change,
date_change,
add_grouping,
discount,
quantity_in_basis_ret,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_wares,
new.quantity,
new.code_unit,
new.price,
new.price_catalog,
new.vat,
new.price_schema,
new.dealer_priceprop,
new.rec_no,
new.user_change,
new.date_change,
new.add_grouping,
new.discount,
new.quantity_in_basis_ret,
new.user_change,
'INS',
'NEW');
*/
END
^

/* Trigger: INS_WARES_RETURN_CACHE */
CREATE TRIGGER INS_WARES_RETURN_CACHE FOR WARES_RETURN_CACHE
ACTIVE AFTER INSERT POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;
/*
INSERT INTO a_wares_return_cache(
code_return,
code_wares,
price,
quantity,
code_unit,
vat,    
add_grouping,
code_order,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.code_wares,
new.price,
new.quantity,
new.code_unit,
new.vat,
new.add_grouping,
new.code_order,
:intCodePrivat,
'INS',
'NEW');
*/
END
^

/* Trigger: MY_TEMP_ORDER_BI0 */
CREATE TRIGGER MY_TEMP_ORDER_BI0 FOR MY_TEMP_ORDER
ACTIVE BEFORE INSERT POSITION 0
AS
/*declare variable BASE_UNIT integer;*/
declare variable COEFFICIENT double precision;
declare variable QUANTITY_SALED double precision;
declare variable QUANTITY_SALED_IN_BASIS double precision;
declare variable QUANTITY_CAN_RETURN double precision;
declare variable QUANTITY_CAN_RETURN_IN_BASIS double precision;

begin
  NEW.date_insert='NOW';
  SELECT GC.RESULT FROM GETCOEFFICIENT(NEW.CODE_WARES,NEW.code_unit) GC INTO :COEFFICIENT;
  NEW.QUANTITY_IN_BASIS=NEW.QUANTITY * :COEFFICIENT;

  IF (NEW.CHECKTYPE=0)/*fiscal check*/ THEN NEW.code_order_for_return=NULL;
  ELSE
  IF (NEW.CHECKTYPE=1)/*return check*/ THEN BEGIN
   IF (NEW.code_order_for_return IS NULL) THEN BEGIN
     NEW.QUANTITY_IN_BASIS=0;
     NEW.QUANTITY=0;
     EXCEPTION cant_return_wares;
   END ELSE BEGIN
     SELECT wo.quantity,wo.quantity_in_basis_ret,sum(wr.quantity),sum(wr.quantity * au.coefficient)
     FROM WARES_ORDER_CACHE WO
     LEFT JOIN WARES_RETURN_CACHE WR ON (WO.code_order=WR.code_order and WO.code_wares=WR.code_wares and WO.code_unit=WR.code_unit)
     LEFT JOIN ADDITION_UNIT AU ON (au.code_wares=wr.code_wares and au.code_unit=wr.code_unit)
     WHERE WO.CODE_ORDER=NEW.code_order_for_return
       AND WO.CODE_WARES=NEW.CODE_WARES
       AND WO.code_unit=NEW.code_unit
     GROUP BY wo.quantity,wo.quantity_in_basis_ret
     INTO :QUANTITY_SALED,:QUANTITY_SALED_IN_BASIS,:quantity_can_return,:quantity_can_return_in_basis;/*,:COEFFICIENT;*/

     IF (:QUANTITY_SALED IS NULL) THEN BEGIN
        QUANTITY_SALED=0;
        QUANTITY_SALED_IN_BASIS=0;
        EXCEPTION cant_return_wares;
     END

     IF (:quantity_can_return IS NULL) THEN BEGIN
        quantity_can_return=:QUANTITY_SALED;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS;
     END ELSE BEGIN
        quantity_can_return=:QUANTITY_SALED-:quantity_can_return;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS-:quantity_can_return_in_basis;
     END

     IF (quantity_can_return_in_basis<NEW.QUANTITY_IN_BASIS) THEN BEGIN
        NEW.QUANTITY=:quantity_can_return;
        NEW.QUANTITY_IN_BASIS=:quantity_can_return_in_basis;
        if (NEW.QUANTITY<0) then EXCEPTION cant_return_wares;
     END




   END
  END
end
^

/* Trigger: MY_TEMP_ORDER_BU0 */
CREATE TRIGGER MY_TEMP_ORDER_BU0 FOR MY_TEMP_ORDER
ACTIVE BEFORE UPDATE POSITION 0
as
declare variable prev_quantity double precision;
declare variable COEFFICIENT double precision;
declare variable QUANTITY_SALED double precision;
declare variable QUANTITY_SALED_IN_BASIS double precision;
declare variable QUANTITY_CAN_RETURN double precision;
declare variable QUANTITY_CAN_RETURN_IN_BASIS double precision;

begin
  NEW.date_insert='NOW';
  if (new.code_unit<>old.code_unit) then begin
   select t.quantity from my_temp_order t
   where t.number_copy=new.number_copy
     and t.code_unit=new.code_unit
     and t.checktype=new.checktype
     and t.code_wares=new.code_wares
   into :prev_quantity;

   if (prev_quantity is not null ) then begin
     new.quantity=new.quantity + prev_quantity;
     delete from my_temp_order t
     where t.number_copy=new.number_copy
       and t.code_unit=new.code_unit
       and t.checktype=new.checktype
       and t.code_wares=new.code_wares;
   end
  end

  SELECT GC.RESULT FROM GETCOEFFICIENT(NEW.CODE_WARES,NEW.CODE_UNIT) GC INTO :COEFFICIENT;
  NEW.QUANTITY_IN_BASIS=NEW.QUANTITY * :COEFFICIENT;


  IF (NEW.CHECKTYPE=0) THEN NEW.code_order_for_return=NULL; ELSE
  IF (NEW.CHECKTYPE=1) THEN BEGIN/*RETURN*/
   IF (NEW.code_order_for_return IS NULL) THEN BEGIN
     NEW.QUANTITY_IN_BASIS=0;
     NEW.QUANTITY=0;
   END ELSE BEGIN
     SELECT wo.quantity,wo.quantity_in_basis_ret,sum(wr.quantity),sum(wr.quantity * au.coefficient)
     FROM WARES_ORDER_CACHE WO
     LEFT JOIN WARES_RETURN_CACHE WR ON (WO.code_order=WR.code_order and WO.code_wares=WR.code_wares and WO.code_unit=WR.code_unit)
     LEFT JOIN ADDITION_UNIT AU ON (au.code_wares=wr.code_wares and au.code_unit=wr.code_unit)
     WHERE WO.CODE_ORDER=NEW.code_order_for_return
       AND WO.CODE_WARES=NEW.CODE_WARES
       AND WO.code_unit=NEW.code_unit
     GROUP BY wo.quantity,wo.quantity_in_basis_ret
     INTO :QUANTITY_SALED,:QUANTITY_SALED_IN_BASIS,:quantity_can_return,:quantity_can_return_in_basis;/*,:COEFFICIENT;*/

     IF (:QUANTITY_SALED IS NULL) THEN BEGIN
        QUANTITY_SALED=0;
        QUANTITY_SALED_IN_BASIS=0;
     END

     IF (:quantity_can_return IS NULL) THEN BEGIN
        quantity_can_return=:QUANTITY_SALED;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS;
     END ELSE BEGIN
        quantity_can_return=:QUANTITY_SALED-:quantity_can_return;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS-:quantity_can_return_in_basis;
     END

     IF (quantity_can_return_in_basis<NEW.QUANTITY_IN_BASIS) THEN BEGIN
        NEW.QUANTITY=:quantity_can_return;
        NEW.QUANTITY_IN_BASIS=:quantity_can_return_in_basis;
     END
   END
  END

  /*SELECT GC.RESULT FROM GETCOEFFICIENT(NEW.CODE_WARES,NEW.CODE_UNIT) GC INTO :COEFFICIENT;*/
  /*if (NEW.quantity is null) then begin
      NEW.QUANTITY=NEW.QUANTITY / :COEFFICIENT;
  end*/





end
^

/* Trigger: MY_WARES_WORD_BI0 */
CREATE TRIGGER MY_WARES_WORD_BI0 FOR MY_WARES_WORD
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  /* Trigger text */
  NEW.ID = GEN_ID(GEN_MY_WORD_ID, 1);

end
^

/* Trigger: SQL_ERROR_LOG_AI0 */
CREATE TRIGGER SQL_ERROR_LOG_AI0 FOR SQL_ERROR_LOG
ACTIVE AFTER INSERT POSITION 0
AS
declare variable TIMESTAMP_1 TIMESTAMP;
declare variable INTEGER_1 INTEGER;
declare variable VARCHAR1024_1 VARCHAR(1024);
begin
/*


 FOR SELECT WORKPLACE_ID,TIMEZ,SQL_ERROR from SQL_ERROR_LOG where STATUS_TRANSFER='0'
 INTO :INTEGER_1,:TIMESTAMP_1,:VARCHAR1024_1
 AS CURSOR TEMP_CURSOR
 DO BEGIN
   EXECUTE STATEMENT ('INSERT INTO SQL_ERROR_LOG(TIMEZ,WORKPLACE_ID,SQL_ERROR)VALUES(?,?,?)')(:TIMESTAMP_1,:INTEGER_1,:VARCHAR1024_1)
   ON EXTERNAL DATA SOURCE '10.127.8.10/3050:d:\spruttp\servertp\server\server.gdb' AS USER 'SYSDBA' PASSWORD 'masterkey';

   UPDATE SQL_ERROR_LOG SET STATUS_TRANSFER='1' WHERE CURRENT OF TEMP_CURSOR;
 END
*/
end
^

/* Trigger: UPD_CALCULATION_CACHE */
CREATE TRIGGER UPD_CALCULATION_CACHE FOR CALCULATION_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_cache(
code_order,
code_calculation,
code_subgroup,
code_firm,
number_calculation,
date_calculation,
vat,
add_grouping,
state_pay,
number_tax_invoice,
date_out_invoice,
date_take,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_calculation,
new.code_subgroup,
new.code_firm,
new.number_calculation,
new.date_calculation,
new.vat,
new.add_grouping,
new.state_pay,
new.number_tax_invoice,
new.date_out_invoice,
new.date_take,
new.status_transfer,
:intCodePrivat,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_CALC_CASH_REGISTER_CACHE */
CREATE TRIGGER UPD_CALC_CASH_REGISTER_CACHE FOR CALC_CASH_REGISTER_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
/*
INSERT INTO a_calc_cash_register_cache(
code_calculation,
number_receipt,
date_receipt,
only_date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_calculation,
new.number_receipt,
new.date_receipt,
new.only_date_receipt,
new.number_cashier,
new.number_cash_register,
new.model_cash_register,
new.user_change,
new.date_change,
new.user_change,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_CALC_CREDIT_CARD_CACHE */
CREATE TRIGGER UPD_CALC_CREDIT_CARD_CACHE FOR CALCULATION_CREDIT_CARD_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
DECLARE VARIABLE intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_calculation_credit_card_cache(
code_calculation,
code_credit_card,
number_slip,
description,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_calculation,
new.code_credit_card,
new.number_slip,
new.description,
:intCodePrivat,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_CASSA_OPERATION */
CREATE TRIGGER UPD_CASSA_OPERATION FOR CASSA_OPERATION
ACTIVE AFTER UPDATE POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_cassa_operation(
code_operation,
number_operation,
date_operation,
code_cash_register,
type_operation,
code_reason,
code_privat,
summa,
status_transfer,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_operation,
new.number_operation,
new.date_operation,
new.code_cash_register,
new.type_operation,
new.code_reason,    
new.code_privat,    
new.summa,
new.status_transfer,
:intCodePrivat,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_ORDER_CLIENT_CACHE */
CREATE TRIGGER UPD_ORDER_CLIENT_CACHE FOR ORDER_CLIENT_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
/*
INSERT INTO a_order_client_cache(
code_order,
code_subgroup,
number_order,
date_order,
variety_order,
type_order,
type_payment,
type_vat,
code_client,
type_client,
date_payment,
code_dealer,
discount,
per_pp,
code_manager,
id_workplace,
code_end,
indication,
priority,
code_addition_sign,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_subgroup,
new.number_order,
new.date_order,
new.variety_order,
new.type_order,
new.type_payment,
new.type_vat,
new.code_client,
new.type_client,
new.date_payment,
new.code_dealer,
new.discount,
new.per_pp,
new.code_manager,
new.id_workplace,
new.code_end,
new.indication,
new.priority,
new.code_addition_sign,
new.description,
new.user_change,
new.date_change,
new.user_change,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_RETURN_CACHE */
CREATE TRIGGER UPD_RETURN_CACHE FOR RETURN_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_cache(
code_return,
code_subgroup,
date_return,
number_check,
date_check,
type_vat,
id_workplace,
code_firm,
code_warehouse,
code_addition_sign,
type_payment,
status_transfer,
id_workplace_sale,
number_cash_register_sale,
model_cash_register_sale,
description,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.code_subgroup,
new.date_return,
new.number_check,
new.date_check,
new.type_vat,
new.id_workplace,
new.code_firm,
new.code_warehouse,
new.code_addition_sign,
new.type_payment,
new.status_transfer,
new.id_workplace_sale,
new.number_cash_register_sale,
new.model_cash_register_sale,
new.description,
new.user_change,
new.date_change,
new.user_change,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_RETURN_REGISTER_CACHE */
CREATE TRIGGER UPD_RETURN_REGISTER_CACHE FOR RETURN_REGISTER_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
/*
INSERT INTO a_return_register_cache(
code_return,
number_receipt,
date_receipt,
number_cashier,
number_cash_register,
model_cash_register,
user_change,
date_change,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.number_receipt,
new.date_receipt,
new.number_cashier,
new.number_cash_register,
new.model_cash_register,
new.user_change,
new.date_change,
new.user_change,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_SPA_EVENTS_AUDIT */
CREATE TRIGGER UPD_SPA_EVENTS_AUDIT FOR SPA_EVENTS_AUDIT
ACTIVE AFTER UPDATE POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN
/*
SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;

INSERT INTO a_spa_events_audit(
event_id,
event_name,
date_audit,
flag_audit,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.event_id,
new.event_name,
new.date_audit,
new.flag_audit,
:intCodePrivat,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_WARES */
CREATE TRIGGER UPD_WARES FOR WARES
ACTIVE AFTER UPDATE POSITION 0
AS
declare variable intOpts INTEGER;
declare variable intCount INTEGER;
BEGIN
 /*IF ((NEW.CODE_WARES IS NOT NULL)and(NEW.CODE_WARES>0))
 THEN EXECUTE PROCEDURE MY_INTO_WARES_WORD(NEW.CODE_WARES);*/
/*
SELECT MAX(CAST(o.value1 AS INTEGER))
FROM opts_item_values o, attrib a
WHERE (o.code_item = 111)
  AND (o.code_subject = a.code_subgroup)
  AND (a.code_attrib = 1)
INTO intOpts;

if (NOT ((intOpts IS NULL) or (intOpts = 0))) then
BEGIN
  SELECT COUNT(code_wares)
  FROM a_wares
  WHERE code_wares = new.code_wares
    AND upd_status = 'UPD'
  INTO intCount;

  if (intCount = 0) then
     INSERT INTO a_wares(
     code_wares,
     upd_status,
     name_wares_receipt,
     name_wares)
     VALUES(
     new.code_wares,
     'UPD',
     old.name_wares_receipt,
     old.name_wares);
END
*/

END
^

/* Trigger: UPD_WARES_ORDER_CACHE */
CREATE TRIGGER UPD_WARES_ORDER_CACHE FOR WARES_ORDER_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
/*
INSERT INTO a_wares_order_cache(
code_order,
code_wares,
quantity,
code_unit,
price,
price_catalog,
vat,
price_schema,
dealer_priceprop,
rec_no,
user_change,
date_change,
add_grouping,
discount,
quantity_in_basis_ret,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_order,
new.code_wares,
new.quantity,
new.code_unit,
new.price,
new.price_catalog,
new.vat,
new.price_schema,
new.dealer_priceprop,
new.rec_no,
new.user_change,
new.date_change,
new.add_grouping,
new.discount,
new.quantity_in_basis_ret,
new.user_change,
'UPD',
'NEW');
*/
END
^

/* Trigger: UPD_WARES_RETURN_CACHE */
CREATE TRIGGER UPD_WARES_RETURN_CACHE FOR WARES_RETURN_CACHE
ACTIVE AFTER UPDATE POSITION 0
AS
declare variable intCodePrivat INTEGER;
BEGIN

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO intCodePrivat;
/*
INSERT INTO a_wares_return_cache(
code_return,
code_wares,
price,
quantity,
code_unit,
vat,    
add_grouping,
code_order,
a_user_change,
a_operation,
a_new_old)
VALUES(
new.code_return,
new.code_wares,
new.price,
new.quantity,
new.code_unit,
new.vat,
new.add_grouping,
new.code_order,
:intCodePrivat,
'UPD',
'NEW');
*/
END
^

/* Trigger: WARES_AD0 */
CREATE TRIGGER WARES_AD0 FOR WARES
ACTIVE AFTER DELETE POSITION 0
AS
begin
  /* Trigger text */
  /*DELETE FROM MY_WARES_WORD M WHERE M.CODE_WARES=OLD.CODE_WARES;*/
end
^

/* Trigger: WARES_AI0 */
CREATE TRIGGER WARES_AI0 FOR WARES
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
  /* Trigger text */
  /*insert into a_wares (code_wares, name_wares,name_wares_receipt, UPD_STATUS)
  values(new.code_wares,new.name_wares,'','');
  */
  /*IF ((NEW.CODE_WARES IS NOT NULL)AND(NEW.CODE_WARES>0))
  THEN EXECUTE PROCEDURE MY_INTO_WARES_WORD(NEW.CODE_WARES);*/
END
^

/* Trigger: WARES_BI0 */
CREATE TRIGGER WARES_BI0 FOR WARES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  /*new.name_wares_up=substr(upper(new.name_wares collate win1251_ua),1,84);*/
--  EXECUTE PROCEDURE MY_INTO_WARES_WORD
end
^

/* Trigger: WARES_BU0 */
CREATE TRIGGER WARES_BU0 FOR WARES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  /* Trigger text */
  /*new.name_wares_up=substr(upper(new.name_wares collate win1251_ua),1,84);*/
end
^

/* Trigger: WARES_CATALOG_BI0 */
CREATE TRIGGER WARES_CATALOG_BI0 FOR WARES_CATALOG
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  NEW.CATALOG_ID=gen_id(gen_catalog_item,1);
end
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE ADDGROUPINGWHENWRITECALC (
    INTCODEWARES INTEGER,
    INTCHECKOPTION INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intcount integer;
declare variable realvat numeric(5,2);
declare variable chvatoperation char(2);
declare variable intnotvat integer;
declare variable int_code_group integer;
BEGIN

if (INTCODEWARES is null) then begin
                                   result=0;
                                   suspend;
                                   exit;
end
chVATOperation = '02';
realVAT = 0;

SELECT not_vat
FROM current_init
WHERE (code_init = 1)
INTO :intNotVAT;

if ((intCheckOption = 1) AND (intNotVAT = 1)) then begin
   realVAT         = 0;
   chVATOperation  = '02';

   SELECT code_group
   FROM WARES w
   where w.code_wares=:intCodeWares
   INTO :INT_CODE_GROUP;
end
else
  SELECT w.vat, w.vat_operation, w.code_group
  FROM wares w
  WHERE w.code_wares = :intCodeWares
  INTO :realVAT, :chVATOperation, :INT_CODE_GROUP;

SELECT COUNT(*)
FROM chosen_group_wares sgw
WHERE (sgw.type_choice = '07' ) AND (sgw.code_group = :INT_CODE_GROUP )
INTO :intCount;

if (intCount <> 0) then begin
   RESULT = 7;
   SUSPEND;
   EXIT;
end

SELECT COUNT(*)
FROM chosen_group_wares  sgw
WHERE (sgw.type_choice = '03') AND ( sgw.code_group  = :INT_CODE_GROUP )
INTO   :intCount;

IF (intCount <> 0) THEN BEGIN
   IF (realVAT = 0) THEN
      RESULT = 15; /* Малоценка (без НДС) (mz.state_all 62)*/
   ELSE
      RESULT = 13; /* Малоценка (mz.state_all 62)*/
   SUSPEND;
   EXIT;
END

SELECT COUNT(*)
FROM chosen_group_wares  sgw
WHERE ( sgw.type_choice = '12' ) AND  ( sgw.code_group  = :INT_CODE_GROUP )
INTO   :intCount;

IF (intCount <> 0) THEN BEGIN
   IF (realVAT = 0) THEN
      RESULT = 14; /* Материалы (без НДС) (mz.state_all 62)*/
   ELSE
      RESULT = 12; /* Материалы (mz.state_all 62)*/
   SUSPEND;
   EXIT;
END

SELECT COUNT(*)
FROM chosen_group_wares  sgw
WHERE (sgw.type_choice = '20') AND ( sgw.code_group  = :INT_CODE_GROUP )
INTO   :intCount;

IF (intCount <> 0) THEN BEGIN
   IF (realVAT = 0) THEN
      RESULT = 21; /* Табачные изделия (без НДС) (mz.state_all 62)*/
   ELSE
      RESULT = 20; /* Табачные изделия (mz.state_all 62)*/
   SUSPEND;
   EXIT;
END

SELECT COUNT(*)
FROM chosen_group_wares sgw
WHERE (sgw.type_choice = '11') AND (sgw.code_group  = :INT_CODE_GROUP )
INTO :intCount;

if (intCount <> 0) then begin
   RESULT = 11;
   SUSPEND;
   EXIT;
end
else if ((chVATOperation = '00') OR ((chVATOperation = '02') AND (intCheckOption = 1) AND (intNotVAT = 1))) then begin
   SELECT check_options
   FROM application_options
   WHERE (type_options = 'AG') AND (variety_options = 'AL')
   INTO :intCount;

   if (intCount = 1) then begin
      SELECT COUNT(*)
      FROM chosen_group_wares sgw
      WHERE (sgw.type_choice = '01' ) AND (sgw.code_group  = :INT_CODE_GROUP )
      INTO :intCount;

      if (intCount <> 0) then begin
         RESULT = 1;
         SUSPEND;
         EXIT;
      end
   end

   RESULT = 0;
   SUSPEND;
   EXIT;
end
else if (chVATOperation = '01') then begin
   SELECT COUNT(*)
   FROM chosen_group_wares sgw
   WHERE (sgw.type_choice = '05' ) AND (sgw.code_group  = :INT_CODE_GROUP )
   INTO :intCount;

   if (intCount <> 0) then begin
      RESULT = 5;
      SUSPEND;
      EXIT;
   end

   RESULT = 2;
   SUSPEND;
   EXIT;
end
else if (chVATOperation = '02') then begin
   RESULT = 3;
   SUSPEND;
   EXIT;
end
else if (chVATOperation = '03') then begin
   RESULT = 4;
   SUSPEND;
   EXIT;
end

RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE ADDWARESTOORDER (
    INTCODEORDER INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1),
    REALVAT NUMERIC(7,4),
    INTRECNO INTEGER,
    INTADDGROUPING INTEGER,
    CHTYPEORDER CHAR(2),
    NDISCOUNTPOSITION DOUBLE PRECISION,
    DATEORDER DATE)
RETURNS (
    RESULT INTEGER,
    INTCODEPROBLEMINVOICE INTEGER)
AS
declare variable intcodeprivat integer;
BEGIN

/*
SELECT type_vat, user_change
FROM order_client_cache
WHERE code_order = :intCodeOrder
INTO :chTypeVat, :intCodePrivat;

IF (:chTypeVat = 'IN') THEN BEGIN
   realPrice = CAST(CAST(:realPrice AS NUMERIC(18, 10)) * (1 + :realVat) AS NUMERIC(15, 2))/(1 + :realVat);
   realPriceCatalog = CAST(CAST(:realPriceCatalog AS NUMERIC(18, 10)) * (1 + :realVat) AS NUMERIC(15, 2))/(1 + :realVat);
END
*/

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO :intCodePrivat;

IF (exists
 (SELECT 1 from wares_order_cache
   WHERE (code_order=:intCodeOrder)
    AND  (code_wares=:intCodeWares)
    AND  (code_unit=:intCodeUnit)
  ))
THEN BEGIN
UPDATE wares_order_cache
SET quantity_in_basis_ret=quantity_in_basis_ret+:realQuantity*(SELECT result FROM GetCoefficient(:intCodeWares, :intCodeUnit)),
quantity=quantity+:realQuantity,
user_change=:intCodePrivat
WHERE (Code_order=:intCodeOrder)
AND (code_wares=:intCodeWares)
and (code_unit=:intCodeUnit);

END
ELSE BEGIN
INSERT INTO wares_order_cache(
code_order,
code_wares,
quantity,
code_unit,
price,
price_catalog,
vat,
price_schema,
dealer_priceprop,
rec_no,
user_change,
add_grouping,
discount,
quantity_in_basis_ret)
VALUES (:intCodeOrder,
:intCodeWares,
:realQuantity,
:intCodeUnit,
:realPrice,
:realPriceCatalog,
:realVat,
:chPriceSchema,
:chAbrPriceSchema,
:intRecNo,
:intCodePrivat,
:intAddGrouping,
dnvl(:nDiscountPosition, 0),
:realQuantity*(SELECT result FROM GetCoefficient(:intCodeWares, :intCodeUnit)));
END

RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE ADDWARESTORETURN (
    INTCODERETURN INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(7,4),
    INTADDGROUPING INTEGER,
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
DECLARE VARIABLE coef    FLOAT;
DECLARE VARIABLE restQty NUMERIC(16, 3);
DECLARE VARIABLE RetQty  NUMERIC(16, 3);
DECLARE VARIABLE ordUnit INTEGER;
BEGIN

INSERT INTO wares_return_cache(
code_return,
code_wares,
quantity,
code_unit,
price,
vat,
add_grouping,
code_order)
VALUES (:intCodeReturn,
:intCodeWares,
:realQuantity,
:intCodeUnit,
:realPrice,
:realVat,
:intAddGrouping,
:intCodeOrder);

SELECT result
FROM GetCoefficient(:intCodeWares, :intCodeUnit)
INTO :coef;

restQty = :realQuantity * :coef;

FOR SELECT quantity_in_basis_ret, code_unit
    FROM v_wares_order_for_return(:intCodeOrder, :intCodeWares, :coef)
    ORDER BY ord, coefficient
    INTO :RetQty, :ordUnit
DO BEGIN

IF (:RetQty >= :restQty) THEN
BEGIN
   UPDATE wares_order_cache
   SET quantity_in_basis_ret = quantity_in_basis_ret - :restQty
   WHERE (code_order = :intCodeOrder)
     AND (code_wares = :intCodeWares)
     AND (code_unit  = :ordUnit);

   RESULT = 0;
   SUSPEND;
   EXIT;
END
ELSE
BEGIN
   UPDATE wares_order_cache
   SET quantity_in_basis_ret = quantity_in_basis_ret - :RetQty
   WHERE (code_order = :intCodeOrder)
     AND (code_wares = :intCodeWares)
     AND (code_unit  = :ordUnit);

   restQty = :restQty - :RetQty;
END
END

IF ((:intCodeOrder <> 0) AND (:restQty > 0)) THEN
   RESULT = -2;
ELSE
   RESULT = 0;

SUSPEND;

WHEN ANY DO begin
  RESULT = -1;
  SUSPEND;
end

END^


ALTER PROCEDURE CANEDITORDER (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intCount INTEGER;
declare variable chTypePayment CHAR(2);
BEGIN
   RESULT = 0;

   SELECT COUNT(*)
   FROM calculation_cache
   WHERE (code_order  = :intCodeOrder)
     AND (status_transfer = '1')
   INTO :intCount;

   IF (intCount > 0) THEN
      RESULT = -1;
   ELSE BEGIN
      SELECT type_payment
      FROM order_client_cache
      WHERE (code_order  = :intCodeOrder)
      INTO :chTypePayment;

      IF (RTRIM(chTypePayment) <> 'B') THEN BEGIN
         SELECT COUNT(*)
         FROM calculation_cache c
         WHERE (c.code_order  = :intCodeOrder)
           AND (EXISTS (SELECT 1
                        FROM calc_cash_register_cache cc
                        WHERE (c.code_calculation = cc.code_calculation)))
         INTO :intCount;

         IF (intCount > 0) THEN
            RESULT = -2;
      END
   END   

   SUSPEND;
END^


ALTER PROCEDURE CANYOUGETDOIT (
    KAK CHAR(1),
    DOC CHAR(2),
    CODEDOC INTEGER,
    TYPEDOC CHAR(2),
    HOW CHAR(1),
    TABNAME VARCHAR(30),
    OPER CHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
if (Kak = '6') then
   SELECT 1
   FROM   spa_access_actions saa, current_init c
   WHERE (c.code_init = 1)
     AND (saa.code_profile = c.code_profile)
     AND (saa.code_action = :TypeDoc)
   INTO
     :RESULT;

if (RESULT IS NULL) then
   RESULT = -1;

SUSPEND;

END^


ALTER PROCEDURE CHECKCLOSESHIFT (
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
declare variable intCodeSubgroup INTEGER;
declare variable CodeFirm INTEGER;
declare variable intCodeWarehouse INTEGER;
declare variable rSum NUMERIC(15, 2);
declare variable rDate1 TIMESTAMP;
declare variable rDate2 TIMESTAMP;
BEGIN

SELECT code_subgroup, company_problem_invoice, warehouse_problem_invoice, cassa, date_begin_shift, date_end_shift
FROM attrib
WHERE (code_attrib = 1)
INTO :intCodeSubgroup,
     :CodeFirm,
     :intCodeWarehouse,
     :rSum,
     :rDate1,
     :rDate2;

/*
SELECT MAX(date_cash_shift_log)
FROM cash_shift_log
WHERE (code_subgroup = :intCodeSubgroup)
  AND (id_workplace = :IdWorkPlace)
  AND (code_firm_company = :CodeFirm)
  AND (code_warehouse = :intCodeWarehouse)
  AND (type_cash_shift_log = '00')
  AND (view_cash_shift_log = '01')
INTO :rDate1;

if (rDate1 IS NULL) then
   rDate1 = CAST('01.01.1900' AS DATE);

SELECT MAX(date_cash_shift_log)
FROM cash_shift_log
WHERE (code_subgroup = :intCodeSubgroup)
  AND (id_workplace = :IdWorkPlace)
  AND (code_firm_company = :CodeFirm)
  AND (code_warehouse = :intCodeWarehouse)
  AND (type_cash_shift_log = '00')
  AND (view_cash_shift_log = '00')
INTO :rDate2;

if (rDate2 IS NULL) then
   rDate2 = CAST('01.01.1900' AS DATE);
*/   

RESULT = :rSum;

IF (rDate1 IS NOT NULL) THEN
   RESULT = -1;
ELSE IF (rDate2 IS NULL) THEN
   RESULT = 0;

/*
if ((rDate1 = rDate2) AND (rDate1 = CAST('01.01.1900' AS DATE))) then
   RESULT = 0;
ELSE
BEGIN
   if (rDate1 < rDate2) then
      RESULT = -1;
   else
      UPDATE attrib
      SET next_number_check = 1,
          begin_cassa = cassa,
          cassa_credit = 0
      WHERE code_attrib = 1;
END
*/

SUSPEND;
  
END^


ALTER PROCEDURE CHECKINDICATIVE (
    NPRICE DOUBLE PRECISION,
    DINDICATIVEBEGINDATE DATE,
    DINDICATIVEENDDATE DATE,
    NINDICATIVEMINPRICE DOUBLE PRECISION,
    NINDICATIVEMAXPRICE DOUBLE PRECISION,
    CHINDICATIVEACTIVE CHAR(1),
    INTINDICATIVECODECURRENCY INTEGER,
    INTCODECURRENCY INTEGER,
    INTCODESUBGROUP INTEGER)
RETURNS (
    RESULT DOUBLE PRECISION)
AS
declare variable nPriceNew DOUBLE PRECISION;
BEGIN

nPriceNew = :nPrice;

if (chIndicativeActive = '1') then begin
   if ((dIndicativeBeginDate IS NULL) AND (dIndicativeEndDate IS NULL)) then begin
      if ((nIndicativeMinPrice IS NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
         if (nPrice > nIndicativeMaxPrice) then
            nPriceNew = :nIndicativeMaxPrice;
      end
      else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
         if (nIndicativeMinPrice > nIndicativeMaxPrice) then begin
            RESULT = -10;
            SUSPEND;
            EXIT;
         end

         if (nPrice < nIndicativeMinPrice) then
            nPriceNew = :nIndicativeMinPrice;
         else if (nPrice > nIndicativeMaxPrice) then
            nPriceNew = :nIndicativeMaxPrice;
      end
      else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NULL)) then begin
         if (nPrice < nIndicativeMinPrice) then
            nPriceNew = :nIndicativeMinPrice;
      end
   end
   else if ((dIndicativeBeginDate IS NULL) AND (dIndicativeEndDate IS NOT NULL)) then begin
      if (CURRENT_DATE <= dIndicativeEndDate) then begin
         if ((nIndicativeMinPrice IS NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nIndicativeMinPrice > nIndicativeMaxPrice) then begin
               RESULT = -10;
               SUSPEND;
               EXIT;
            end

            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
            else if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NULL)) then begin
            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
         end
      end
   end
   else if ((dIndicativeBeginDate IS NOT NULL) AND (dIndicativeEndDate IS NULL)) then begin
      if (CURRENT_DATE >= dIndicativeBeginDate) then begin
         if ((nIndicativeMinPrice IS NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nIndicativeMinPrice > nIndicativeMaxPrice) then begin
               RESULT = -10;
               SUSPEND;
               EXIT;
            end

            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
            else if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NULL)) then begin
            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
         end
      end
   end
   else if ((dIndicativeBeginDate IS NOT NULL) AND (dIndicativeEndDate IS NOT NULL)) then begin
      if (dIndicativeBeginDate > dIndicativeEndDate) then begin
         RESULT = -11;
         SUSPEND;
         EXIT;
      end

      if ((CURRENT_DATE >= dIndicativeBeginDate) AND (CURRENT_DATE <= dIndicativeEndDate)) then begin
         if ((nIndicativeMinPrice IS NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NOT NULL)) then begin
            if (nIndicativeMinPrice > nIndicativeMaxPrice) then begin
               RESULT = -10;
               SUSPEND;
               EXIT;
            end

            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
            else if (nPrice > nIndicativeMaxPrice) then
               nPriceNew = :nIndicativeMaxPrice;
         end
         else if ((nIndicativeMinPrice IS NOT NULL) AND (nIndicativeMaxPrice IS NULL)) then begin
            if (nPrice < nIndicativeMinPrice) then
               nPriceNew = :nIndicativeMinPrice;
         end
      end
   end
end

RESULT = :nPriceNew;

SUSPEND;

END^


ALTER PROCEDURE CHECKLASTCHECK (
    IDWORKPLACE INTEGER,
    CODEWAREHOUSE INTEGER,
    INTCODEDOCUMENT INTEGER,
    CHTYPEDOCUMENT CHAR(1))
RETURNS (
    RESULT INTEGER)
AS
declare variable dDateLast timestamp;
declare variable intCount INTEGER;
BEGIN
if (chTypeDocument = 'O') then
   SELECT MAX(ccr.date_receipt)
   FROM calc_cash_register_cache ccr,
        calculation_cache ca
   WHERE (ccr.code_calculation = ca.code_calculation)
     AND (ca.code_order = :intCodeDocument)
   INTO :dDateLast;
else
   SELECT MAX(date_receipt)
   FROM calc_cash_register_cache
   WHERE (code_calculation = :intCodeDocument)
   INTO :dDateLast;
           
if (dDateLast IS NULL) then
   RESULT = 0;
else begin
   if (chTypeDocument = 'O') then
      SELECT COUNT(*)
      FROM calc_cash_register_cache ccr, calculation_cache ca
      WHERE (ccr.date_receipt > :dDateLast)
        AND (ccr.code_calculation = ca.code_calculation)
      INTO :intCount;
   else
      SELECT COUNT(*)
      FROM calc_cash_register_cache
      WHERE (date_receipt > :dDateLast)
      INTO :intCount;

   if (intCount = 0) then
      RESULT = 1;
   else
      RESULT = 0;
end
           
SUSPEND;

END^


ALTER PROCEDURE CHECKSPECPROPOSITIONTIME (
    INTCATSPECPROPOSITION INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE CHECKUSERACCESS (
    USERNAME VARCHAR(30),
    SERIALNUMBERFP VARCHAR(50))
RETURNS (
    USERPASSWORD VARCHAR(50),
    RESULT INTEGER)
AS
declare variable intCodeUser INTEGER;
declare variable intCount INTEGER;
BEGIN

SELECT code_sposuser, pswd
FROM spa_users
WHERE (user_name = :UserName)
  AND (sign_activity = 'Y')
INTO :intCodeUser,
     :UserPassword;
     
if (intCodeUser IS NULL) then
   RESULT = -1;
ELSE
BEGIN
   if (SerialNumberFP = '') then
      RESULT = 0;
   ELSE
   BEGIN
      SELECT COUNT(*)
      FROM register_cash_register rcr, spa_user_cashdesks suc
      WHERE (suc.code_sposuser = :intCodeUser)
        AND (rcr.code_register_cash_register = suc.code_register_cash_register)
        AND (rcr.serial_number_cash_register = :SerialNumberFP)
      INTO :intCount;
      
      if (intCount > 0) then
         RESULT = 0;
      else
         RESULT = -2;
   END
END

SUSPEND;

END^


ALTER PROCEDURE COMPARE_ORDERS
RETURNS (
    CODE_ORDER INTEGER,
    SUM_ORDER NUMERIC(18,2),
    COUNT_WARES INTEGER,
    CODE_ORDER_DUBLE INTEGER)
AS
declare variable intCount INTEGER;
declare variable rSum NUMERIC(15, 2);
BEGIN
  FOR
    select o.code_order, (select result FROM getsumordercache(o.code_order)) sum_order, (select count(*) FROM wares_order_cache wo WHERE (wo.code_order = o.code_order)) count_wares
    from order_client_cache o
    order by o.code_order
    INTO
      :CODE_ORDER,
      :SUM_ORDER,
      :COUNT_WARES
  DO
  BEGIN
    for select o.code_order, (select result FROM getsumordercache(o.code_order)) sum_order, (select count(*) FROM wares_order_cache wo WHERE (wo.code_order = o.code_order)) count_wares
    from order_client_cache o
    where o.code_order > :CODE_ORDER
    order by o.code_order
    INTO
      :CODE_ORDER_DUBLE,
      :rSum,
      :intCount
    DO
    BEGIN
      if ((rSum = sum_order) AND (intCount = count_wares)) then
         SUSPEND;
    END
  END
END^


ALTER PROCEDURE DELETERETURN (
    INTCODERETURN INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intCount INTEGER;
declare variable intStop  INTEGER;
BEGIN

SELECT COUNT(*)
FROM   spa_access_actions saa, current_init c
WHERE (c.code_init = 1)
  AND (saa.code_profile  = c.code_profile)
  AND (saa.code_action = '-2')
INTO :intStop;

SELECT COUNT(*)
FROM return_register_cache
WHERE (code_return = :intCodeReturn)
INTO :intCount;

if (intCount > 0) then begin
   RESULT = -3;
   SUSPEND;
   EXIT;
end

SELECT COUNT(*)
FROM return_cache
WHERE (code_return  = :intCodeReturn)
  AND (status_transfer = 1)
INTO :intCount;

if (intCount > 0) THEN
   RESULT = -2;
ELSE
BEGIN
  DELETE FROM return_cache
  WHERE  code_return = :intCodeReturn;

  RESULT = 0;
END

if ((RESULT = 0) AND (intStop = 0)) THEN
   RESULT = -1;

SUSPEND;

END^


ALTER PROCEDURE EXISTUNITDIVISIONAL (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intCount INTEGER;
BEGIN

SELECT COUNT(code_wares)
FROM wares_with_fractional_unit
WHERE (code_wares = :intCodeWares)
INTO :intCount;

if (intCount > 0) then begin
   RESULT = 2;
   SUSPEND;
   EXIT;
end

SELECT COUNT(au.code_wares)
FROM addition_unit au
WHERE (au.code_wares = :intCodeWares)
  AND (au.code_unit = :intCodeUnit)
  AND (EXISTS (SELECT 1
               FROM unit_dimension u
               WHERE (u.code_unit       = au.code_unit )
                 AND (u.sign_divisional = 'Y'          )))
INTO :intCount;

if (intCount = 0) then
   RESULT = 0;
else
   RESULT = 1;

SUSPEND;

END^


ALTER PROCEDURE FILLCAPTIONORDER (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER,
    INTCODESUBGROUP INTEGER,
    CHTYPEPAYMENT CHAR(2),
    INTCODEMANAGER INTEGER,
    INTIDCASHREGISTER INTEGER,
    REALDISCOUNT NUMERIC(9,6),
    REALPERPP NUMERIC(5,2),
    DATEPAYMENT DATE,
    CHDESCRIPTION VARCHAR(250),
    INTCODEEND INTEGER,
    INTCODEORDERCACHE INTEGER,
    INTNUMBERORDERCACHE INTEGER,
    INTUSERCHANGECACHE INTEGER,
    DATEDATECHANGECACHE TIMESTAMP,
    INTINDICATION INTEGER,
    CHTYPEVAT CHAR(2),
    DATEORDER DATE,
    CHCREDITCARD CHAR(1),
    CHTYPEORDER CHAR(2),
    INTPRIORITY INTEGER,
    INTCODEDELIVERY INTEGER,
    INTCODEADDITIONSIGN INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable datePaymentNew DATE;
declare variable chTypePaymentNew CHAR(2);
declare variable realPerPPNew NUMERIC(5, 2);
declare variable intCodeOrder INTEGER;
declare variable intNumberOrder INTEGER;
declare variable intCodePrivat INTEGER;
declare variable intCodeDealer INTEGER;
--declare variable intNewCodeDelivery INTEGER;
BEGIN

if (chTypeVat IS NULL) then
   chTypeVat = 'OU';

if (dateOrder IS NULL) then
   dateOrder = current_date;

if (chCreditCard IS NULL) then
   chCreditCard = '0';

if (chTypeOrder IS NULL) then
   chTypeOrder = 'O';

intCodeOrder = GEN_ID(GetCodeOrder, 1);
intNumberOrder = GEN_ID(GetNumberOrder, 1);

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO :intCodePrivat;

if (chTypeClient = 'P') then
   SELECT dc.code_dealer
   FROM dealer_compliance dc, p_client pc
   WHERE (pc.code_privat   = :intCodeClient)
     AND (pc.code_subgroup = :intCodeSubgroup)
     AND (dc.code_dealer_center = pc.code_dealer)
   INTO :intCodeDealer;
else
   SELECT dc.code_dealer
   FROM dealer_compliance dc, f_client fc
   WHERE (fc.code_firm     = :intCodeClient)
     AND (fc.code_subgroup = :intCodeSubgroup)
     AND (dc.code_dealer_center = fc.code_dealer)
   INTO :intCodeDealer;

if (chCreditCard = '1') then begin
   chTypePaymentNew = 'NC';
   datePaymentNew = :dateOrder;
   realPerPPNew = 0;
end
else begin
   chTypePaymentNew = :chTypePayment;
   datePaymentNew = :datePayment;
   realPerPPNew = :realPerPP;
end

INSERT INTO order_client_cache(
code_order,
code_subgroup,
number_order,
date_order,
variety_order,
type_order,
type_payment,
code_client,
type_client,
date_payment,
code_dealer,
discount,
per_pp,
code_manager,
id_workplace,
indication,
type_vat,
priority,
code_addition_sign,
description,
code_end,
user_change,
date_change)
VALUES (
:intCodeOrder,
:intCodeSubgroup,
:intNumberOrder,
:dateOrder,
'O',
:chTypeOrder,
:chTypePaymentNew,
:intCodeClient,
:chTypeClient,
:datePaymentNew,
:intCodeDealer,
:realDiscount,
:realPerPPNew,
:intCodeManager,
:intIDCashRegister,
:intIndication,
:chTypeVat,
:intPriority,
:intCodeAdditionSign,
:chDescription,
:intCodeEnd,
:intCodePrivat,
CURRENT_TIMESTAMP);

--if (intCodeDelivery <> 0) then
--   EXECUTE PROCEDURE InsDeliveryToOrder :intCodeOrder, :intCodeDelivery RETURNING_VALUES :intNewCodeDelivery;

RESULT = :intCodeOrder;

SUSPEND;

END^


ALTER PROCEDURE FILLCAPTIONRETURN (
    INTCODESUBGROUP INTEGER,
    DATERETURN DATE,
    INTNUMBERCHECK INTEGER,
    DATECHECK TIMESTAMP,
    CHTYPEVAT CHAR(2),
    IDWORKPLACE INTEGER,
    INTCODEADDSIGN INTEGER,
    CHDESCRIPTION VARCHAR(250),
    CHTYPEPAYMENT CHAR(2),
    IDWORKPLACESALE INTEGER,
    CHSERIALNUMBERSALE VARCHAR(30),
    CHMODELSALE VARCHAR(50))
RETURNS (
    RESULT INTEGER)
AS
declare variable intCodeTradeWarehouse INTEGER;
declare variable intFirm INTEGER;
declare variable intCodePrivat INTEGER;
declare variable intCodeReturn INTEGER;
BEGIN

SELECT invl(warehouse_problem_invoice, -1), invl(company_problem_invoice, -1)
FROM attrib
WHERE (code_attrib = 1)
INTO :intCodeTradeWarehouse, :intFirm;

intCodeReturn = GEN_ID(gen_return_id, 1);

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO :intCodePrivat;

INSERT INTO return_cache(
            code_return,
            code_subgroup,
            date_return,
            number_check,
            date_check,
            type_vat,
            id_workplace,
            code_firm,
            code_warehouse,
            code_addition_sign,
            type_payment,
            id_workplace_sale,
            number_cash_register_sale,
            model_cash_register_sale,
            description,
            user_change)
VALUES (
:intCodeReturn,
:intCodeSubgroup,
:dateReturn,
:intNumberCheck,
:dateCheck,
:chTypeVAT,
:IdWorkplace,
:intFirm,
:intCodeTradeWarehouse,
:intCodeAddsign,
:chTypePayment,
:idWorkplaceSale,
:chSerialNumberSale,
:chModelSale,
:chDescription,
:intCodePrivat);

RESULT = :intCodeReturn;

SUSPEND;

END^


ALTER PROCEDURE FRONTOFFICECHANGEDATEORDER (
    INTCODECALCULATION INTEGER,
    DATEORDER DATE)
AS
declare variable intCodeOrder INTEGER;
BEGIN

SELECT code_order
FROM calculation_cache
WHERE code_calculation = :intCodeCalculation
INTO :intCodeOrder;

UPDATE calculation_cache
SET date_calculation = :dateOrder
WHERE  code_calculation = :intCodeCalculation;

UPDATE order_client_cache
SET date_order   = :dateOrder,
    date_payment = :dateOrder
WHERE  code_order = :intCodeOrder;

END^


ALTER PROCEDURE FRONTOFFICECHECKFRACTIONALNUM (
    REALVALUE DOUBLE PRECISION)
RETURNS (
    RESULT INTEGER)
AS
BEGIN

if (realValue - CAST(realValue AS INTEGER)>0.001) then
   RESULT = 1;
ELSE
   RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE FRONTOFFICEDELETEORDER (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intCount INTEGER;
declare variable intStop INTEGER;
declare variable intCodeClient INTEGER;
declare variable chTypePayment CHAR(2);
declare variable rSumma NUMERIC(15, 2);
BEGIN

SELECT COUNT(*)
FROM   spa_access_actions saa, current_init c
WHERE (c.code_init = 1)
  AND (saa.code_profile  = c.code_profile)
  AND (saa.code_action = '59')
INTO :intStop;

if (intStop = 0) then begin
   RESULT = -8;
   SUSPEND;
   EXIT;
end

SELECT type_payment, code_client
FROM order_client_cache
WHERE  code_order = :intCodeOrder
INTO :chTypePayment, :intCodeClient;

if (chTypePayment IS NOT NULL) then begin

   SELECT COUNT(*)
   FROM calculation_cache
   WHERE (code_order  = :intCodeOrder)
     AND (status_transfer = '1')
   INTO :intCount;

   if (intCount > 0) then begin
      RESULT = -9;
      SUSPEND;
      EXIT;
   end

   SELECT COUNT(*)
   FROM calculation_cache c
   WHERE (c.code_order  = :intCodeOrder)
     AND (EXISTS (SELECT 1
                  FROM calc_cash_register_cache cc
                  WHERE (c.code_calculation = cc.code_calculation)
                    AND (cc.number_cashier IS NOT NULL)))
   INTO :intCount;
/*   PLAN (c INDEX (order_calculation_cache), cc INDEX(id_calc_cash_register_cache))*/

   if (intCount > 0) then begin
      RESULT = -7;
      SUSPEND;
      EXIT;
   end

end

IF (RTRIM(chTypePayment) = 'B') THEN
   SELECT SUM((SELECT result FROM GetFullSumCalculationCache(c.code_calculation)))
   FROM calculation_cache c
   WHERE (c.code_order  = :intCodeOrder)
     AND (c.state_pay = '2')
INTO :rSumma;

DELETE FROM order_client_cache
WHERE  code_order = :intCodeOrder;

IF (rSumma IS NULL) THEN
   rSumma = 0;

IF (rSumma > 0) THEN
   UPDATE account_client
   SET account = account + :rSumma
   WHERE code_client = :intCodeClient;

RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE FRONTOFFICEEXISTUNITDIVISIONAL (
    INTCODEWARES INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable intCount INTEGER;
BEGIN

SELECT code_wares
FROM wares_with_fractional_unit
WHERE (code_wares = :intCodeWares)
INTO :intCount;

if (intCount IS NOT NULL) then begin
   RESULT = 2;
   SUSPEND;
   EXIT;
end

if (EXISTS (SELECT 1
            FROM addition_unit au
            WHERE (au.code_wares = :intCodeWares)
              AND EXISTS (SELECT 1
                          FROM unit_dimension u
                          WHERE (u.code_unit       = au.code_unit )
                            AND (u.sign_divisional = 'Y'          )))) then
   RESULT = 1;
else
   RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE FRONTOFFICEEXISTUNITLOCKING (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE FRONTOFFICEWRITEORDER (
    INTCODEORDER INTEGER,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    DATEORDER DATE,
    DATETAKE DATE,
    CHCREDITCARD CHAR(1),
    CHNUMBERSLIP VARCHAR(30),
    INTCODECREDITCARD INTEGER,
    CHDESCRIPTIONCREDITCARD VARCHAR(255),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
RETURNS (
    RESULT INTEGER,
    CHCODESOUTINVOICE VARCHAR(30),
    CHCODESCALCULATION VARCHAR(30))
AS
declare variable intCodeFirm INTEGER;
declare variable intCodeCalculation INTEGER;
declare variable intNumberCalculation INTEGER;
declare variable intNumberTaxInvoice INTEGER;
--declare variable intCodeOutInvoice INTEGER;
--declare variable intNumberOutInvoice INTEGER;
declare variable rVat NUMERIC(7, 4);
declare variable rAddGrouping INTEGER;
declare variable intCodeSubgroup INTEGER;
declare variable intPrize INTEGER;
declare variable intCountPrize INTEGER;
declare variable intCodeClient INTEGER;
declare variable chTypePayment CHAR(2);
declare variable chActionType CHAR(2);
declare variable rActionSumma NUMERIC(15, 2);
declare variable rOrderSumma NUMERIC(15, 2);
declare variable dDateOutInvoice DATE;
BEGIN

chCodesCalculation = '';
chCodesOutInvoice = '';
RESULT = -2;

SELECT company_problem_invoice, action_prize, action_counter, action_type, action_summa
FROM attrib
WHERE code_attrib = 1
INTO :intCodeFirm, :intPrize, :intCountPrize, :chActionType, :rActionSumma;

SELECT type_payment, code_client, code_subgroup
FROM order_client_cache
WHERE (code_order = :intCodeOrder)
INTO :chTypePayment, :intCodeClient, :intCodeSubgroup;

if ((chActionType = '02') OR ((RTRIM(chTypePayment) = 'B') AND (chStatePay = '2'))) then
   SELECT result FROM GetSumOrderCache(:intCodeOrder)
   INTO :rOrderSumma;

if ((RTRIM(chTypePayment) = 'B') AND (chStatePay = '2')) then
   UPDATE account_client
   SET account = CAST(account AS NUMERIC(15, 2)) - :rOrderSumma
   WHERE code_client = :intCodeClient;

if ((RTRIM(chTypePayment) = 'B') AND (chnsppoa <> '')) then
   INSERT INTO power_of_attorney(code_order, ser_power_of_attorney, num_power_of_attorney, date_power_of_attorney, nsp_power_of_attorney)
   VALUES(:intCodeOrder, :chserpoa, :chnumpoa, :datepoa, :chnsppoa);

FOR
SELECT wo.vat,
       wo.add_grouping
FROM order_client_cache o,
     wares_order_cache  wo
WHERE (o.code_order = :intCodeOrder)
  AND (o.code_order = wo.code_order)
GROUP BY o.date_payment,
         o.code_order,
         o.code_client,
         o.type_client,
         o.type_payment,
         o.code_manager,
         wo.vat,
         wo.add_grouping
INTO :rVat, :rAddGrouping
DO BEGIN

  intCodeCalculation = GEN_ID(gen_code_calculation, 1);
  intNumberCalculation = GEN_ID(gen_number_calculation, 1);

  chCodesCalculation = :chCodesCalculation || rtrim(CAST(:intCodeCalculation AS VARCHAR(30))) || ';';

  if (intEnd IN (7, 8)) then
     intNumberTaxInvoice = GEN_ID(gen_number_tax_invoice, 1);

  if (intEnd > 0) then
     dDateOutInvoice = :dateOrder;

  INSERT INTO calculation_cache
          (code_order,
           code_subgroup,
           code_firm,
           code_calculation,
           number_calculation,
           date_calculation,
           vat,
           add_grouping,
           state_pay,
           number_tax_invoice,
           date_out_invoice,
           date_take)
  VALUES (:intCodeOrder,
          :intCodeSubgroup,
          :intCodeFirm,
          :intCodeCalculation,
          :intNumberCalculation,
          :dateOrder,
          :rVat,
          :rAddGrouping,
          :chStatePay,
          :intNumberTaxInvoice,
          :dDateOutInvoice,
          :dateTake);

  if (intEnd IN (1, 5, 4)) then begin
     if (chCreditCard = '1') then
        INSERT INTO calculation_credit_card_cache
                (code_calculation,
                 code_credit_card,
                 number_slip,
                 description)
        VALUES (:intCodeCalculation,
                :intCodeCreditCard,
                :chNumberSLIP,
                :chDescriptionCreditCard);

/*
     if (RTRIM(chTypePayment) = 'B') then begin
        intCodeOutInvoice = GEN_ID(gen_code_out_invoice, 1);
        intNumberOutInvoice = GEN_ID(gen_number_out_invoice, 1);

        chCodesOutInvoice = :chCodesOutInvoice || rtrim(CAST(:intCodeOutInvoice AS VARCHAR(30))) || ';';

        INSERT INTO out_invoice_cache
                (code_out_invoice,
                 code_subgroup,
                 code_order,
                 code_calculation,
                 number_out_invoice,
                 date_out_invoice,
                 code_warehouse)
        VALUES (:intCodeOutInvoice,
                :intCodeSubgroup,
                :intCodeOrder,
                :intCodeCalculation,
                :intNumberOutInvoice,
                :dateOrder,
                :intCodeWarehouse);
     end
*/     
  end
end

chCodesOutInvoice = :chCodesCalculation;

if (RTRIM(chTypePayment) <> 'B') then begin
   if (chActionType = '01') then begin
      if (intCountPrize = intPrize - 1) then begin
         UPDATE attrib
         SET action_counter = 0;

         UPDATE order_client_cache
         SET description = description || ' - Чек с акционным номером ' || CAST(:intPrize AS VARCHAR(20))
         WHERE code_order = :intCodeOrder;

         RESULT = :intPrize;
         SUSPEND;
         EXIT;
      end
      else
         UPDATE attrib
         SET action_counter = INVL(action_counter, 0) + 1;
   end

   if (chActionType = '02') then begin
      if (rOrderSumma >= rActionSumma) then
         if (intCountPrize = intPrize - 1) then begin
            UPDATE attrib
            SET action_counter = 0;

            UPDATE order_client_cache
            SET description = description || ' - Чек с акционным номером ' || CAST(:intPrize AS VARCHAR(20)) || '. К.сумма = ' || CAST(:rActionSumma AS VARCHAR(40))
            WHERE code_order = :intCodeOrder;

            RESULT = :intPrize;
            SUSPEND;
            EXIT;
         end
         else
            UPDATE attrib
            SET action_counter = INVL(action_counter, 0) + 1;
   end
end

RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE FRONTOFFICEWRITERECEIPT (
    INTCODECALCULATION INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50),
    NOTCHECK INTEGER)
AS
declare variable intCount INTEGER;
declare variable dCalculation TIMESTAMP;
declare variable userChange INTEGER;
declare variable chNumberReceiptNew VARCHAR(40);
declare variable chError VARCHAR(2000);
declare variable chTypePayment CHAR(2);
declare variable rSumma NUMERIC(15, 2);
BEGIN

SELECT cc.number_calculation,
       cc.date_change,
       oc.user_change,
       oc.type_payment,
       (SELECT result FROM GetFullSumCalculationCache(cc.code_calculation))
FROM order_client_cache oc, calculation_cache cc
WHERE (cc.code_calculation = :intCodeCalculation)
  AND (oc.code_order = cc.code_order)
INTO :intCount, :dCalculation, :userChange, :chTypePayment, :rSumma;

if (notCheck = 1) then
   chNumberReceipt = :intCount;
else
   dCalculation = :chDateReceipt;

if (intCount <> 0) then begin

   EXECUTE PROCEDURE FrontOfficeChangeDateOrder :intCodeCalculation, :dCalculation;

   if (notCheck = 1) then
      INSERT INTO calc_cash_register_cache
             ( code_calculation,
               number_receipt,
               date_receipt,
               only_date_receipt,
               user_change)
      SELECT code_calculation,
             number_calculation,
             date_calculation,
             date_calculation,
             :userChange
      FROM calculation_cache
      WHERE code_calculation = :intCodeCalculation;
   else
      INSERT INTO calc_cash_register_cache
             ( code_calculation,
               number_receipt,
               date_receipt,
               only_date_receipt,
               number_cashier,
               number_cash_register,
               model_cash_register,
               user_change)
      VALUES (:intCodeCalculation,
              :chNumberReceipt,
              :dCalculation,
              CAST(:dCalculation AS DATE),
              :chNumberCashier,
              :chNumberCashRegister,
              :chModelCashRegister,
              :userChange);

   IF (chTypePayment = 'NC') THEN
      UPDATE attrib
      SET cassa_credit = cassa_credit + :rSumma
      WHERE code_attrib = 1;
   ELSE IF (chTypePayment = 'B1') THEN
      UPDATE attrib
      SET cassa_card = cassa_card + :rSumma
      WHERE code_attrib = 1;
   ELSE
      UPDATE attrib
      SET cassa = cassa + :rSumma
      WHERE code_attrib = 1;

   WHEN ANY DO BEGIN
      chError = 'Чек : Номер ' || :chNumberReceipt || ' от ' || CAST(:chDateReceipt AS VARCHAR(50)) || ' кассир ' || :chNumberCashier || ' кассовый аппарат ' || :chNumberCashRegister || ' модель ' || :chModelCashRegister;
      EXECUTE PROCEDURE SaveAppErrors 1, 0, '', :chError, :intCodeCalculation, 0, 0, 0, 0;
   END

end

END^


ALTER PROCEDURE GET_BARCODE_PARAMS
RETURNS (
    FIRST_CHAR_CODE INTEGER,
    LAST_CHAR_CODE INTEGER,
    FIRST_CHAR_WEIGHT INTEGER,
    LAST_CHAR_WEIGHT INTEGER)
AS
declare variable chVal CHAR(2);
declare variable i INTEGER;
BEGIN
first_char_code = -1;
first_char_weight = -1;
i = 0;

FOR
SELECT o.value1
FROM opts_item_values o, attrib a
WHERE (o.code_item >= 4)
  AND (o.code_item <= 16)
  AND (o.code_subject = a.code_ldb)
  AND (a.code_attrib = 1)
ORDER BY o.code_item
INTO :chVal
do
BEGIN
  i = :i + 1;
  if ((:chVal = 'WC') AND (:first_char_code = -1)) THEN
     first_char_code = :i;
  if (:chVal = 'WC') THEN
     last_char_code = :i;
  if (:chVal = 'QN') THEN
  BEGIN
     if (:first_char_weight = -1) THEN
        first_char_weight = :i;
     last_char_weight = :i;
  END

END

if (:last_char_code IS NULL) then
BEGIN
  first_char_code = 3;
  last_char_code = 7;
  first_char_weight = 8;
  last_char_weight = 12;
END

SUSPEND;

END^


ALTER PROCEDURE GET_DATASET_PARAM_ATTRIBS (
    ALEVEL_ID INTEGER,
    AREPORT_ID INTEGER,
    APARAM_NAME VARCHAR(100))
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
    error_code = 0;
  begin
      select master_field
    from vro_report_link_params
    where param_id in
    ( select rdp.param_id
      from vro_report_dataset_params rdp, vro_report_datasets rd
    where rd.report_id = :areport_id
      and rd.dataset_id = rdp.dataset_id
      and Upper(rdp.param_name) = Upper(:aparam_name)
    )
    into :amaster_field;

    if (amaster_field is null) then
        select rdp.master_field
      from vro_report_dataset_params rdp, vro_report_datasets rd
    where rd.report_id = :areport_id
      and rd.dataset_id = rdp.dataset_id
      and Upper(rdp.param_name) = Upper(:aparam_name)
    into :amaster_field;
  end
  suspend;

    when any do
      begin
          error_code = -1;
          SUSPEND;
      end

END^


ALTER PROCEDURE GET_FULL_REPORTNAME (
    AREPORT_ID INTEGER)
RETURNS (
    FULL_NAME VARCHAR(500))
AS
BEGIN
  select report_name
  from vro_reports
  where report_id = :areport_id
  into :FULL_NAME;

  SUSPEND;
END^


ALTER PROCEDURE GET_NUMBERS_CHECK (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT VARCHAR(150))
AS
declare variable chreceipt varchar(30);
declare variable chcoma varchar(1);
BEGIN

RESULT = '';

FOR SELECT ccr.number_receipt
    FROM calculation_cache ca
    left join calc_cash_register_cache ccr on (ccr.code_calculation = ca.code_calculation)
    WHERE (ca.code_order = :intCodeOrder)
    INTO :chReceipt
DO
BEGIN
  IF ((:RESULT = '')or(:RESULT is null)) THEN
     chComa = '';
  ELSE
     chComa = ',';

  RESULT = :RESULT || :chComa || :chReceipt;

END

SUSPEND;

END^


ALTER PROCEDURE GET_REPORT_TEMPLATE_ATTRIBS (
    ALEVEL_ID INTEGER,
    ATEMPLATE_ID INTEGER)
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    AMASTER_VALUE VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
    error_code = 0;
  begin
      select master_field, master_value 
    from vro_report_link_templates
      where template_id = :atemplate_id
      into :amaster_field, :amaster_value;

    if (amaster_field is null and amaster_value is null) then
        select master_field, master_value
      from vro_report_templates
      where template_id = :atemplate_id
        into :amaster_field, :amaster_value;
  end
  suspend;

    when any do
      begin
          error_code = -1;
          SUSPEND;
      end
END^


ALTER PROCEDURE GET_REPORT_VARIABLE_ATTRIBS (
    ALEVEL_ID INTEGER,
    AREPORT_ID INTEGER,
    AVARIABLE_NAME VARCHAR(100))
RETURNS (
    AMASTER_FIELD VARCHAR(100),
    ERROR_CODE INTEGER)
AS
BEGIN
    error_code = 0;
  begin
      select rlv.master_field 
    from vro_report_link_variables rlv
    where rlv.variable_id in
    ( select rv.variable_id
      from vro_report_variables rv
    where rv.report_id = :areport_id
      and Upper(rv.variable_name) = Upper(:avariable_name)
    )
    into :amaster_field;

    if (amaster_field is null) then
        select rv.master_field 
      from vro_report_variables rv
      where Upper(rv.variable_name) = Upper(:avariable_name)
      and rv.report_id = :areport_id
        into :amaster_field;
  end
  suspend;

    when any do
      begin
          error_code = -1;
          SUSPEND;
      end
END^


ALTER PROCEDURE GETADDGROUPINGSTR (
    INTADDGROUPING INTEGER)
RETURNS (
    RESULT VARCHAR(8))
AS
BEGIN

if (intAddGrouping IN (0, 1)) then
   RESULT = 'ПВД 20%:';
else if (intAddGrouping = 2) then
   RESULT = 'ПВД 0%:';
else if (intAddGrouping = 3) then
   RESULT = 'Без ПВД:';

SUSPEND;

END^


ALTER PROCEDURE GETBARCODECLIENTSIZE
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT bar_code_client_size
    FROM attrib
    WHERE code_attrib = 1
    INTO :RESULT;

    SUSPEND;
END^


ALTER PROCEDURE GETCLIENTINFO (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER)
RETURNS (
    NAME VARCHAR(212),
    BAR_CODE DOUBLE PRECISION,
    VARIANT_PAYMENT CHAR(2),
    IMPOCITION VARCHAR(15),
    AGREE_NUMBER VARCHAR(20),
    PHONE VARCHAR(111),
    ADDRESS VARCHAR(70),
    NAME_FOR_PRINT VARCHAR(250),
    INDEX_MAIL VARCHAR(10),
    CODE_CITY INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETCLIENTWITHATTRIB (
    INTLOCATE INTEGER,
    INTLOCATEOPTIONS INTEGER)
RETURNS (
    RESULT INTEGER,
    INTCODEDEALER INTEGER,
    INTCODEPRIVAT INTEGER,
    INTCODECLIENT INTEGER,
    INTCODEMANAGER INTEGER,
    INTMAXENDPAYMENT INTEGER,
    REALDISCOUNT FLOAT,
    REALPERCENT FLOAT,
    CHCOURSE CHAR(2),
    CHRECALCORDER CHAR(2),
    CHVARIANTPAYMENT CHAR(2),
    CHTYPEDISCOUNT CHAR(2),
    INTACTIVECONTRACT INTEGER,
    CHTYPECLIENT CHAR(1),
    CHNAMECLIENT VARCHAR(212),
    NBARCODE DOUBLE PRECISION,
    CHABRDEALER VARCHAR(8),
    CHDISCOUNTPOSITION CHAR(2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETCODEDATABASE
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT code_ldb
    FROM attrib
    WHERE code_attrib = 1
    INTO :RESULT;

    SUSPEND;
END^


ALTER PROCEDURE GETCODESUBGROUPUSERLOGON (
    CHNAMEUSER VARCHAR(30))
RETURNS (
    RESULT INTEGER)
AS
declare variable S_ACT CHAR(1);
BEGIN
    RESULT = -2;

    SELECT sign_activity, code_subgroup
    FROM spa_users
    WHERE (user_name = :chNameUser)
    INTO :S_ACT, :RESULT;

    if (S_ACT = 'N') then
       RESULT = -1;
       
    SUSPEND;
END^


ALTER PROCEDURE GETCODEUNITBASISORDEFAULT (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN

SELECT result
FROM FrontOfficeExistUnitDivisional(:intCodeWares)
INTO :RESULT;

if (RESULT = 0) then
   RESULT = :intCodeUnit;
else begin
   RESULT = 0;
   /*+ INDEX(au def_addition_unit)*/
   SELECT code_unit
   FROM addition_unit
   WHERE (code_wares   = :intCodeWares)
     AND (default_unit = 'Y'         )
   INTO :RESULT;
end

SUSPEND;

END^


ALTER PROCEDURE GETCODEUNITDEFAULTOFWARES (
    INTCODEWARES INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN

/*+ INDEX(mz.addition_unit def_addition_unit)*/
SELECT code_unit
FROM addition_unit
WHERE (code_wares = :intCodeWares)
  AND (default_unit = 'Y')
INTO :RESULT;

SUSPEND;
  
END^


ALTER PROCEDURE GETCODEUSER
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT code_privat
    FROM current_init
    WHERE (code_init = 1)
    INTO
      :RESULT;
      
    SUSPEND;
END^


ALTER PROCEDURE GETCODEUSERGLOBAL
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT code_privat
    FROM current_init
    WHERE (code_init = 1)
    INTO
      :RESULT;

    SUSPEND;
END^


ALTER PROCEDURE GETCOEFFICIENT (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER)
RETURNS (
    RESULT FLOAT)
AS
BEGIN

SELECT coefficient
FROM addition_unit
WHERE (code_wares = :intCodeWares)
  AND (code_unit = :intCodeUnit)
INTO :RESULT;

SUSPEND;

END^


ALTER PROCEDURE GETFULLSUMCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETINFXREPORT (
    IDWORKPLACE INTEGER)
RETURNS (
    CHECKCOUNT INTEGER,
    BEGINCHECK INTEGER,
    LASTCHECK INTEGER,
    BEGINCASSA NUMERIC(15,2),
    CURRENTCASSA NUMERIC(15,2),
    RESULT TIMESTAMP)
AS
declare variable intCodeSubgroup INTEGER;
declare variable CodeFirm INTEGER;
declare variable intCodeWarehouse INTEGER;
declare variable dEndShift TIMESTAMP;
declare variable dLastDateReport TIMESTAMP;
BEGIN

SELECT code_subgroup, company_problem_invoice, warehouse_problem_invoice, begin_cassa, cassa, date_begin_shift, date_end_shift
FROM attrib
WHERE (code_attrib = 1)
INTO :intCodeSubgroup,
     :CodeFirm,
     :intCodeWarehouse,
     :BeginCassa,
     :CurrentCassa,
     :dLastDateReport,
     :dEndShift;

/*
SELECT MAX(date_cash_shift_log)
FROM cash_shift_log
WHERE (code_subgroup = :intCodeSubgroup)
  AND (id_workplace = :IdWorkPlace)
  AND (code_firm_company = :CodeFirm)
  AND (code_warehouse = :intCodeWarehouse)
  AND (type_cash_shift_log = '00')
  AND (view_cash_shift_log = '01')
INTO :dEndShift;

if (dEndShift IS NULL) then
   dEndShift = CAST('01.01.1980' AS DATE);

SELECT MAX(date_cash_shift_log)
FROM cash_shift_log
WHERE (code_subgroup = :intCodeSubgroup)
  AND (date_cash_shift_log >= :dEndShift)
  AND (id_workplace = :IdWorkPlace)
  AND (code_firm_company = :CodeFirm)
  AND (code_warehouse = :intCodeWarehouse)
  AND (type_cash_shift_log = '00')
  AND (view_cash_shift_log = '00')
INTO :dLastDateReport;
*/

if (dEndShift IS NULL) then
   dLastDateReport = CAST('01.01.1980' AS DATE);

SELECT COUNT(DISTINCT ccr.number_receipt), MIN(CAST(ccr.number_receipt AS INTEGER)), MAX(CAST(ccr.number_receipt AS INTEGER))
FROM calc_cash_register_cache ccr
WHERE (ccr.date_change >= :dLastDateReport)
INTO :CheckCount,
     :BeginCheck,
     :LastCheck;

RESULT = :dLastDateReport;

SUSPEND;

END^


ALTER PROCEDURE GETNAMEWARESRECEIPT (
    CHBARCODE VARCHAR(30),
    INTCODEWARES INTEGER,
    CHNAMEWARES VARCHAR(100))
RETURNS (
    RESULT VARCHAR(300))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETNDSCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETNDSINNER (
    INTCODEWARES INTEGER,
    INTCHECKOPTION INTEGER)
RETURNS (
    RESULT NUMERIC(5,2))
AS
declare variable intnotvat integer;
BEGIN

if (intCodeWares = 0) THEN
   RESULT = 0.2;
ELSE
BEGIN
   SELECT not_vat
   FROM current_init
   WHERE (code_init = 1)
   INTO :intNotVAT;

   if ((intCheckOption = 1) AND (intNotVAT = 1)) THEN
      RESULT = 0;
   ELSE
   BEGIN
     SELECT vat/100
     FROM wares
     WHERE code_wares = :INTCODEWARES
     INTO :RESULT;
   END
END

if (RESULT IS NULL) then begin
   EXCEPTION waresnotfound;
end ELSE SUSPEND;

END^


ALTER PROCEDURE GETNUMORDERFROMCODEORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN

SELECT number_order
FROM order_client_cache
WHERE code_order = :intCodeOrder
INTO :RESULT;

SUSPEND;

END^


ALTER PROCEDURE GETONOFFOPTIONS (
    CHTYPE VARCHAR(2),
    CHVARIETY VARCHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT CAST(check_options AS INTEGER)
    FROM application_options
    WHERE (type_options = :chType)
      AND (variety_options = :chVariety)
    INTO
      :RESULT;

    if (:RESULT IS NULL) THEN
       RESULT = 0;

    SUSPEND;
END^


ALTER PROCEDURE GETONOFFOPTIONSOFUSER (
    CHTYPE VARCHAR(2),
    CHVARIETY VARCHAR(2))
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT CAST(aou.options AS INTEGER)
    FROM application_options_user aou, current_init c
    WHERE (c.code_init = 1)
      AND (aou.code_privat = c.code_privat)
      AND (aou.type_options = :chType)
      AND (aou.variety_options = :chVariety)
    INTO
      :RESULT;

    if (:RESULT IS NULL) then
       SELECT CAST(options AS INTEGER)
       FROM application_options
       WHERE (type_options = :chType)
         AND (variety_options = :chVariety)
       INTO
         :RESULT;

    SUSPEND;
END^


ALTER PROCEDURE GETPRICE (
    INTCODEWARES INTEGER,
    INTCODESUBGROUP INTEGER,
    INTCODEUNIT INTEGER,
    INTCODECURRENCYPRICE INTEGER,
    NPRICE DOUBLE PRECISION,
    INTCODECURRENCY INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETPRICEDEALERWARESCUR (
    INTCODEWARES INTEGER,
    INTCODESUBGROUP INTEGER,
    INTCODEDEALER INTEGER,
    INTCODEUNIT INTEGER,
    INTCODECURRENCY INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    INTCODECURRENCYPRICE INTEGER,
    RMARKUP NUMERIC(8,2),
    RESULT DOUBLE PRECISION)
AS
declare variable rprice1 numeric(15,2);
declare variable rprice2 double precision;
BEGIN

SELECT CAST(pd.price_dealer * au.coefficient AS NUMERIC(15, 2)), pd.price_dealer * au.coefficient, pd.code_currency, pd.markup
FROM price_dealer pd
LEFT JOIN addition_unit au on (( au.code_wares    = pd.code_wares )and(au.code_unit = :intCodeUnit))
WHERE  ( pd.code_subgroup = :intCodeSubgroup )
  AND  ( pd.code_dealer   = :intCodeDealer   )
  AND  ( pd.code_wares    = :intCodeWares    )
INTO :rPrice1, :rPrice2, :intCodeCurrencyPrice, :rMarkup;

if (chTypeVAT = 'OU') then
   RESULT = :rPrice1;
else
   RESULT = :rPrice2;

if (RESULT IS NULL) then
   RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE GETPRICEDEALERWARESPRN (
    INTCODEWARES INTEGER,
    INTCODEUNIT INTEGER,
    INTCODEDEALER INTEGER,
    CHTYPEVAT VARCHAR(2))
RETURNS (
    RESULT DOUBLE PRECISION)
AS
declare variable intdealer integer;
declare variable rprice1 numeric(15,2);
declare variable rprice2 double precision;
BEGIN

if (intCodeDealer IS NULL) then
   SELECT code_dealer_print_invoice
   FROM current_init
   WHERE code_init = 1
   INTO :intDealer;
ELSE
   intDealer = :intCodeDealer;

SELECT CAST(pd.price_dealer*au.coefficient AS NUMERIC(15, 2)), pd.price_dealer*au.coefficient
FROM price_dealer pd
LEFT JOIN addition_unit au ON ((au.code_wares=pd.code_wares)and(au.code_unit=:intCodeUnit))
WHERE (pd.code_wares    = :intCodeWares)
  AND (pd.code_dealer   = :intDealer)

INTO :rPrice1, :rPrice2;

if (chTypeVAT = 'OU') then
   RESULT = rPrice1;
else
   RESULT = rPrice2;

if (RESULT IS NULL) then
   RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE GETPRICEWARES (
    INTCODEWARES INTEGER,
    NQUANTITY NUMERIC(15,3),
    INTCODEUNIT INTEGER,
    INTCODEDEALER INTEGER,
    INTCODESUBGROUP INTEGER,
    CHTYPEVAT CHAR(2),
    NDISCOUNT FLOAT,
    INTACTIVECONTRACT INTEGER,
    INTCODECLIENT INTEGER,
    NDISCOUNTPOSITIONIN FLOAT,
    REALVAT NUMERIC(5,2))
RETURNS (
    RESULT INTEGER,
    NDISCOUNTPOSITION FLOAT,
    NPRICE DOUBLE PRECISION,
    NPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETRETURNWARES (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER,
    CHTYPEVAT CHAR(2),
    CHUNIT CHAR(1),
    NUMBERCHECK VARCHAR(30),
    DATECHECK DATE)
RETURNS (
    RESULT INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    RPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(5,2),
    INTADDGROUPING INTEGER,
    CHNAMEUNIT CHAR(4),
    CHNAMEWARES VARCHAR(100),
    CHCODEBARWARES VARCHAR(30),
    CHARTICLWARES VARCHAR(30),
    DATETIMECHECK TIMESTAMP,
    CHNAMECLIENT VARCHAR(212),
    INTCODEORDER INTEGER,
    QTYRETURN NUMERIC(16,3),
    CHTYPEPAYMENT CHAR(2),
    CHSERIALNUMBER VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETSTATECALCULATION (
    INTCODEEND INTEGER)
RETURNS (
    STATE_CALCULATION CHAR(1))
AS
BEGIN
IF (intCodeEnd = 0) THEN
   state_calculation = 'C';

IF (intCodeEnd = 1) THEN
   state_calculation = 'I';

IF (intCodeEnd = 7) THEN
   state_calculation = 'N';

SUSPEND;
END^


ALTER PROCEDURE GETSTATEORDER (
    INTCODEORDER INTEGER,
    INTCODEEND INTEGER)
RETURNS (
    STATE_ORDER CHAR(1))
AS
declare variable intcount integer;
BEGIN
IF (intCodeEnd = 0) THEN state_order = 'F'; ELSE
IF (intCodeEnd = 1) THEN state_order = 'I'; ELSE
IF (intCodeEnd = 7) THEN state_order = 'N';
IF (intCodeEnd IN (1, 7)) THEN BEGIN
   IF (NOT EXISTS(
           SELECT *
           FROM calculation_cache
           WHERE code_order = :intCodeOrder
           and state_pay<>'2'))
   THEN
      state_order = 'E';
END

SUSPEND;
END^


ALTER PROCEDURE GETSTATUSTRANSFERSTRING (
    CHTYPEDOCUMENT CHAR(1),
    INTCODEDOCUMENT INTEGER)
RETURNS (
    RESULT VARCHAR(3))
AS
declare variable chStatus CHAR(1);
declare variable intCount INTEGER;
BEGIN
if (chTypeDocument = 'O') then begin
    SELECT COUNT(*)
    FROM calculation_cache
    WHERE code_order = :intCodeDocument
      AND status_transfer = '0'
    INTO :intCount;

    IF (intCount = 0) THEN
       result = 'Да';
    ELSE
       result = 'Нет';
end
else begin
    SELECT status_transfer
    FROM return_cache
    WHERE code_return = :intCodeDocument
    INTO :chStatus;

    IF (chStatus = '1') THEN
       result = 'Да';
    ELSE
       result = 'Нет';
end

SUSPEND;

END^


ALTER PROCEDURE GETSUMCALCULATIONCACHE (
    INTCODECALCULATION INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETSUMCHECKFROMLASTZREPORT (
    CHNUMBERCASHREGISTER VARCHAR(50),
    CODEWAREHOUSE INTEGER)
RETURNS (
    RESULT NUMERIC(15,2),
    RSUMCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RSUMCARD NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETSUMORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETSUMORDERCATALOGCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETSUMRETURNCACHE (
    INTCODERETURN INTEGER)
RETURNS (
    RESULT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE GETUSERID
RETURNS (
    RESULT INTEGER)
AS
BEGIN
    SELECT su.code_sposuser
    FROM spa_users su, current_init c
    WHERE (c.code_init = 1)
      AND (su.user_name = c.user_name)
    INTO
      :RESULT;
    if (RESULT IS NULL) then
       RESULT = -1;      

    SUSPEND;
END^


ALTER PROCEDURE GETWARESWITHPRICE (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER,
    INTCODEDEALER INTEGER,
    INTCODESUBGROUP INTEGER,
    CHUNIT CHAR(1),
    CHTYPEDISCOUNT CHAR(1),
    CHRECALCCOURSE CHAR(1),
    REALQUANTITY NUMERIC(16,3),
    REALDISCOUNT FLOAT,
    INTACTIVECONTRACT INTEGER,
    INTCODECLIENT INTEGER,
    CHDISCOUNTPOSITION CHAR(1),
    CHTYPEVAT CHAR(2),
    INTEXISTWARES INTEGER,
    INTCODEUNITIN INTEGER,
    NDISCOUNTPOSITIONIN FLOAT)
RETURNS (
    RESULT INTEGER,
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    CHNAMEUNIT VARCHAR(4),
    CHNAMEWARES VARCHAR(100),
    CHCODEBARWARES VARCHAR(30),
    CHARTICLWARES VARCHAR(30),
    REALVAT NUMERIC(5,2),
    REALPRICECATALOG DOUBLE PRECISION,
    CHPRICESCHEMA VARCHAR(100),
    CHABRPRICESCHEMA CHAR(1),
    INTADDGROUPING INTEGER,
    NEXISTWARES INTEGER,
    NDISCOUNTPOSITION FLOAT,
    PRICE_IN DOUBLE PRECISION,
    UNIT_IN INTEGER,
    RQTY_IN NUMERIC(16,3))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE INH_OK (
    C_CODE INTEGER)
RETURNS (
    P_CODE INTEGER)
AS
BEGIN

FOR SELECT code_parent_object
FROM spa_security_list
WHERE (code_parent_object = :C_CODE)
INTO :P_CODE
DO BEGIN
  SUSPEND;
  FOR SELECT P_CODE FROM INH_OK(:P_CODE)
  INTO :P_CODE
  DO BEGIN
     SUSPEND;
  END
END
END^


ALTER PROCEDURE INITPARAMETERS (
    USERNAME VARCHAR(30),
    ID_WORKPLACE INTEGER)
RETURNS (
    CASHNAME VARCHAR(50),
    CASHPASSWORD VARCHAR(50))
AS
declare variable intCodeProfileUser INTEGER;
declare variable intCodePrivat INTEGER;
declare variable intCodeSubgroup INTEGER;
declare variable intCodeDealerPrintInvoice INTEGER;
declare variable iPar1 INTEGER;
declare variable iPar2 INTEGER;
declare variable intCheckIndicative INTEGER;
declare variable intNotVAT INTEGER;
BEGIN

SELECT cash_user_name, cash_password
FROM current_init
WHERE (code_init = 1)
INTO :CashName,
     :CashPassword;

SELECT code_profile, code_privat, code_subgroup
FROM spa_users
WHERE (user_name = :UserName)
INTO :intCodeProfileUser,
     :intCodePrivat,
     :intCodeSubgroup;

SELECT code_dealer_roz
FROM attrib
WHERE code_attrib = 1
INTO :intCodeDealerPrintInvoice;

FOR
SELECT o.code_item, CAST(o.value1 AS INTEGER)
FROM opts_item_values o
WHERE (o.code_item IN (54, 55))
  AND (o.code_subject = :intCodeSubgroup)
INTO :iPar1, :iPar2
DO BEGIN
   if (iPar1 = 54) THEN
      intCheckIndicative = :iPar2;
   else
      intNotVAT = :iPar2;
END

UPDATE current_init
SET code_privat = :intCodePrivat,
    user_name = :UserName,
    code_profile = :intCodeProfileUser,
    not_vat = :intNotVAT,
    check_indicative = :intCheckIndicative,
    code_dealer_print_invoice = :intCodeDealerPrintInvoice,
    id_workplace = :id_workplace
WHERE code_init = 1;

SUSPEND;

END^


ALTER PROCEDURE LOCATEWARES (
    CHLOCATE VARCHAR(30),
    INTLOCATEOPTIONS INTEGER)
RETURNS (
    RESULT INTEGER,
    INTCODEUNIT INTEGER)
AS
declare variable intcodewaresfind integer;
declare variable intcodewares integer;
declare variable intcount integer;
declare variable intresult integer;
declare variable chbarcode varchar(30);
declare variable choldwares varchar(4);
BEGIN

if (intLocateOptions = 0) then begin
   intCodeWaresFind = CAST(chLocate AS INTEGER);

   SELECT w.code_wares
   FROM wares w
   WHERE w.code_wares = :intCodeWaresFind
     AND w.o_wares  = 'No'
     AND (NOT w.code_group IN (SELECT cgw.code_group
                               FROM chosen_group_wares cgw
                               WHERE (cgw.type_choice IN ('03', '19'))
                               AND (cgw.code_group  = w.code_group)))
   INTO :intCodeWares;

   SELECT result
   FROM FrontOfficeExistUnitDivisional(:intCodeWaresFind)
   INTO :intResult;

   if (intResult > 0) then
      SELECT code_unit
      FROM addition_unit
      WHERE (code_wares   = :intCodeWaresFind)
        AND (default_unit = 'Y')
      INTO :intCodeUnit;
end
else if (intLocateOptions = 1) then begin
   chBarCode = rtrim(chLocate);

   SELECT au.code_wares,
          w.o_wares,
          au.code_unit
   FROM addition_unit au
   LEFT JOIN wares w on (w.code_wares = au.code_wares)
   WHERE (au.bar_code            = :chBarCode)
     AND (au.check_find_bar_code = 'Y')
     AND (NOT w.code_group    IN (SELECT cgw.code_group
                                  FROM chosen_group_wares cgw
                                  WHERE (cgw.type_choice IN ('03', '19'))
                                    AND (cgw.code_group  = w.code_group)))
   INTO :intCodeWares, :chOldWares, :intCodeUnit;

   SELECT result
   FROM OPTS_GET_BOOL_VALUE(445, (SELECT code_shop FROM attrib))
   INTO :intCount;

   if ((intCodeWares > 0) AND (intCount <> 0)) then begin
      SELECT COUNT(*)
      FROM   rdb$database
      WHERE  EXISTS ( SELECT 1
                      FROM   wares
                      WHERE  code_wares_relative = :intCodeWares )
      INTO :intCount;

      if (intCount > 0) then begin
         RESULT = intCodeWares;
         intCodeUnit = -1;
         SUSPEND;
         EXIT;
      end
   end

   if (chOldWares <> 'No') then
      intCodeWares = NULL;

   SELECT result
   FROM FrontOfficeExistUnitLocking(:intCodeWares, :intCodeUnit)
   INTO :intResult;

   if (intResult > 0) then begin
      SELECT result
      FROM FrontOfficeExistUnitDivisional(:intCodeWares)
      INTO :intResult;

      if (intResult > 0) then
         SELECT code_unit
         FROM addition_unit
         WHERE (code_wares    = :intCodeWares)
           AND (default_unit  = 'Y')
         INTO :intCodeUnit;
   end
end

RESULT = :intCodeWares;

SUSPEND;

END^


ALTER PROCEDURE MY_FROM_WARES_GROUPED_ID (
    WORD_01 VARCHAR(50),
    WORD_02 VARCHAR(50),
    WORD_03 VARCHAR(50),
    WORD_04 VARCHAR(50),
    WORD_05 VARCHAR(50),
    WORD_06 VARCHAR(50),
    WORD_07 VARCHAR(50),
    WORD_08 VARCHAR(50),
    WORD_09 VARCHAR(50),
    WORD_10 VARCHAR(50),
    WORD_11 VARCHAR(50),
    WORD_12 VARCHAR(50),
    WORD_COUNT INTEGER)
RETURNS (
    IDD INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE MY_FROM_WARES_SUBSTR (
    WORD_BIG VARCHAR(50),
    WORD_01 VARCHAR(50),
    WORD_02 VARCHAR(50),
    WORD_03 VARCHAR(50),
    WORD_04 VARCHAR(50),
    WORD_05 VARCHAR(50),
    WORD_06 VARCHAR(50),
    WORD_07 VARCHAR(50),
    WORD_08 VARCHAR(50),
    WORD_09 VARCHAR(50),
    WORD_10 VARCHAR(50),
    WORD_11 VARCHAR(50),
    WORD_12 VARCHAR(50),
    WORD_COUNT INTEGER)
RETURNS (
    WORD_IDX INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE MY_FROM_WARES_WORD (
    WORDS VARCHAR(50))
RETURNS (
    CODE_WARES INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE MY_INITPARAMETERS (
    USERNAME VARCHAR(30),
    ID_WORKPLACE INTEGER)
RETURNS (
    CASHNAME VARCHAR(50),
    CASHPASSWORD VARCHAR(50),
    NEED_TO_RUN_INIT_IF0 INTEGER)
AS
declare variable intcodeprofileuser integer;
declare variable intcodeprivat integer;
declare variable intcodesubgroup integer;
declare variable intcodedealerprintinvoice integer;
declare variable ipar1 integer;
declare variable ipar2 integer;
declare variable intcheckindicative integer;
declare variable intnotvat integer;
BEGIN

SELECT cash_user_name, cash_password
FROM current_init
WHERE (code_init = 1)
INTO :CashName,
     :CashPassword;

SELECT code_profile, code_privat, code_subgroup
FROM spa_users su
WHERE (user_name = :UserName)
INTO :intCodeProfileUser,
     :intCodePrivat,
     :intCodeSubgroup;

SELECT code_dealer_roz
FROM attrib
WHERE code_attrib = 1
INTO :intCodeDealerPrintInvoice;

FOR
SELECT o.code_item, CAST(o.value1 AS INTEGER)
FROM opts_item_values o
WHERE (o.code_item IN (54, 55))
  AND (o.code_subject = :intCodeSubgroup)
INTO :iPar1, :iPar2
DO BEGIN
   if (iPar1 = 54) THEN
      intCheckIndicative = :iPar2;
   else
      intNotVAT = :iPar2;
END

 NEED_TO_RUN_INIT_IF0=1;
 if (  (:intCodePrivat is null)
     or(:UserName is null)
     or(:intCodeProfileUser is null)
     or(:intCheckIndicative is null)
     or(:intCodeDealerPrintInvoice is null)
     or(:id_workplace is null)
    )
 then begin
     NEED_TO_RUN_INIT_IF0=0;
 end else

 SELECT 0 FROM CURRENT_INIT
 WHERE (CODE_INIT=1)
  AND ((code_privat <> :intCodePrivat)or(code_privat is null)
    OR (user_name <> :UserName)or(user_name is null)
    OR (code_profile <> :intCodeProfileUser)or(code_profile is null)
    OR (check_indicative <> :intCheckIndicative)or(check_indicative is null)
    OR (code_dealer_print_invoice <> :intCodeDealerPrintInvoice)or (code_dealer_print_invoice is null)
    OR (id_workplace <> :id_workplace) or (id_workplace is null) )
 INTO :NEED_TO_RUN_INIT_IF0;

 IF (NEED_TO_RUN_INIT_IF0 IS NULL) THEN NEED_TO_RUN_INIT_IF0=1;





SUSPEND;

END^


ALTER PROCEDURE MY_INTO_WARES_WORD (
    CODE_WARES INTEGER)
AS
declare variable code_wares_fnd integer;
declare variable code_wares_not_in integer;
declare variable donothing1_update2 integer;
declare variable last_name_idx bigint;
declare variable name_idx bigint;
BEGIN
  /*Викликаємо процедуру для вставки даного товару у перелік індексуємих:*/
  EXECUTE PROCEDURE MY_INTO_WARES_WORD_INSERT(:CODE_WARES);
  /*Тепер перевірим чи потрібно обновляти індекс NAME_ORDERB_IDX:*/
--  IF (EXISTS(SELECT 1 FROM MY_WARES_WORD WHERE NAME_ORDERB_IDX IS NULL)) THEN BEGIN
  LAST_NAME_IDX=0;/*Індекс назви - допоміжний/проміжний*/
  CODE_WARES=0;   /*Код товара який ми будим апдейтити*/
  DONOTHING1_UPDATE2=1; /*=1 - значить апдейтим попередный бай-1, =2 апдейтим наступний бай +1 */
  FOR SELECT
      W.CODE_WARES,
      (SELECT FIRST 1 M.CODE_WARES FROM MY_WARES_WORD M WHERE M.CODE_WARES=W.CODE_WARES),
      (SELECT FIRST 1 M.NAME_ORDERB_IDX FROM MY_WARES_WORD M WHERE M.CODE_WARES=W.CODE_WARES)
      FROM WARES W
      ORDER BY UPPER(W.NAME_WARES COLLATE WIN1251_UA)
  INTO :CODE_WARES_NOT_IN,:CODE_WARES_FND,:NAME_IDX
  DO BEGIN
    /*Якщо випадково найшли товар якого немає у списку індексів - то вставим його:*/
    IF (CODE_WARES_FND IS NULL) then BEGIN
       EXECUTE PROCEDURE MY_INTO_WARES_WORD_INSERT(:CODE_WARES_NOT_IN);
       CODE_WARES_FND=:CODE_WARES_NOT_IN;
    END
    IF (DONOTHING1_UPDATE2=2) then BEGIN
       UPDATE MY_WARES_WORD SET NAME_ORDERB_IDX=:LAST_NAME_IDX+(:NAME_IDX-:LAST_NAME_IDX)/2 WHERE CODE_WARES=:CODE_WARES;
       DONOTHING1_UPDATE2=1;
    END
    IF (NAME_IDX IS NULL) THEN BEGIN
       DONOTHING1_UPDATE2=2;
       CODE_WARES=:CODE_WARES_FND;
    END ELSE BEGIN
       LAST_NAME_IDX=:NAME_IDX;
    END
  END
  IF (DONOTHING1_UPDATE2=2) THEN BEGIN
       UPDATE MY_WARES_WORD SET NAME_ORDERB_IDX=:LAST_NAME_IDX+4294967296 WHERE CODE_WARES=:CODE_WARES;
  END
END^


ALTER PROCEDURE MY_INTO_WARES_WORD_INSERT (
    CODE_WARES INTEGER)
AS
BEGIN
  EXIT;
END^


ALTER PROCEDURE MY_MICRO_PROC (
    "VALUE" DOUBLE PRECISION,
    TEXT VARCHAR(100),
    NUMBER INTEGER,
    ACTIONZ INTEGER)
RETURNS (
    MICRO_PROC_RESULT INTEGER)
AS
declare variable DISC_PRICE double precision;
declare variable CUR_PRICE double precision;
declare variable CUR_DISCOUNT double precision;
declare variable CUR_CODE_CLIENT integer;
declare variable CUR_CODE_UNIT integer;
begin
  MICRO_PROC_RESULT=0;

  if (:ACTIONZ=1) then begin
    /*Актіон=1 - це значить що будимо дивитись чи є в чеці номер NUMBER товари з нужними нам кодами, і в той же час по яких ще не було проведено дисконтних-прайсо-понижуючих робіт, тобто DISCOUNT=0*/
    CUR_PRICE=null;
    DISC_PRICE=null;
    CUR_CODE_CLIENT=NULL;
    CUR_CODE_UNIT=NULL;
    FOR select t.CODE_CLIENT, t.code_unit,  t.price, (cast(t.price * (1+w.vat/100) as numeric(15,2))*cast(t.quantity as numeric(15,3))-15)/(cast(t.quantity as numeric(15,3))*(1+w.vat/100)) from my_temp_order t
        left join wares w on w.code_wares=t.code_wares
        where t.number_copy=:NUMBER and t.code_wares=132117 and t.checktype=0 and abs(t.discount_position)<0.001 and t.price>0.00
    INTO :CUR_CODE_CLIENT,:CUR_CODE_UNIT,:CUR_PRICE,:DISC_PRICE
    do begin
      if ((:DISC_PRICE is not null)and(:DISC_PRICE>0.00)and(:cur_price is not null)and(:cur_price>0.00))
      then begin
        update my_temp_order t
        set t.price=:DISC_PRICE,
        t.discount_position=(100/:CUR_PRICE)*(:CUR_PRICE-:DISC_PRICE)
        where t.number_copy=:NUMBER and t.code_client=:cur_code_client and t.code_wares=132117 and t.code_unit=:CUR_code_UNIT and t.checktype=0 and abs(t.discount_position)<0.001;
        MICRO_PROC_RESULT=1;
        suspend;
        exit;
      end
    end




  end else
  if (:ACTIONZ=2) then begin



    MICRO_PROC_RESULT=2;
  end


  suspend;
end^


ALTER PROCEDURE NEW_ADDWARESTORETURN (
    INTCODERETURN INTEGER,
    INTCODEWARES INTEGER,
    REALQUANTITY NUMERIC(16,3),
    INTCODEUNIT INTEGER,
    REALPRICE DOUBLE PRECISION,
    REALVAT NUMERIC(7,4),
    INTADDGROUPING INTEGER,
    INTCODEORDER INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable coef double precision;
declare variable realquantity_in_basis double precision;
declare variable quantity_saled double precision;
declare variable quantity_saled_in_basis double precision;
declare variable quantity_can_return double precision;
declare variable quantity_can_return_in_basis double precision;
BEGIN

    SELECT WO.QUANTITY,WO.QUANTITY_IN_BASIS_RET,sum(wr.quantity),sum(wr.quantity * au.coefficient)
    FROM WARES_ORDER_CACHE WO
    LEFT JOIN WARES_RETURN_CACHE WR ON (WO.code_order=WR.code_order and WO.code_wares=WR.code_wares and WO.code_unit=WR.code_unit)
    LEFT JOIN ADDITION_UNIT AU ON (au.code_wares=wr.code_wares and au.code_unit=wr.code_unit)
    WHERE WO.CODE_ORDER=:intcodeorder
      AND WO.CODE_WARES=:intcodewares
      AND WO.CODE_UNIT=:intcodeunit
    GROUP BY WO.QUANTITY,WO.QUANTITY_IN_BASIS_RET
    INTO :QUANTITY_SALED,:QUANTITY_SALED_IN_BASIS,:quantity_can_return,:quantity_can_return_in_basis;/*,:COEFFICIENT;*/

     IF (:QUANTITY_SALED IS NULL) THEN BEGIN
        QUANTITY_SALED=0;
        QUANTITY_SALED_IN_BASIS=0;
        /*EXCEPTION cant_return_wares;*/
        RESULT = -2;
        SUSPEND;
        EXIT;
     END

     IF (:quantity_can_return IS NULL) THEN BEGIN
        quantity_can_return=:QUANTITY_SALED;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS;
     END ELSE BEGIN
        quantity_can_return=:QUANTITY_SALED-:quantity_can_return;
        quantity_can_return_in_basis=:QUANTITY_SALED_IN_BASIS-:quantity_can_return_in_basis;
     END


     SELECT GC.RESULT FROM GETCOEFFICIENT(:intcodewares,:intcodeunit) GC INTO :coef;

     realquantity_in_basis=:realquantity * :coef;

     IF (:quantity_can_return_in_basis<:realquantity_in_basis) THEN BEGIN
        realquantity=:quantity_can_return_in_basis/:coef;
        realquantity_in_basis=:quantity_can_return_in_basis;
        /*if (:realquantity<0) then EXCEPTION cant_return_wares;*/
        RESULT = -1;
        SUSPEND;
        EXIT;
     END




INSERT INTO wares_return_cache(code_return,code_wares,quantity,code_unit,price,vat,add_grouping,code_order )
VALUES(:intCodeReturn,:intCodeWares,:realQuantity,:intCodeUnit,:realPrice,:realVat,:intAddGrouping,:intCodeOrder);
RESULT=0;
SUSPEND;

END^


ALTER PROCEDURE NEW_FRONTOFFICEWRITEORDER (
    INTCODEORDER INTEGER,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    DATEORDER DATE,
    DATETAKE DATE,
    CHCREDITCARD CHAR(1),
    CHNUMBERSLIP VARCHAR(30),
    INTCODECREDITCARD INTEGER,
    CHDESCRIPTIONCREDITCARD VARCHAR(255),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
RETURNS (
    INTCODECALCULATION INTEGER,
    RESULT INTEGER,
    CHCODESOUTINVOICE VARCHAR(30),
    CHCODESCALCULATION VARCHAR(30))
AS
declare variable INTCODEFIRM integer;
declare variable INTNUMBERCALCULATION integer;
declare variable INTNUMBERTAXINVOICE integer;
declare variable RVAT numeric(7,4);
declare variable RADDGROUPING integer;
declare variable INTCODESUBGROUP integer;
declare variable INTPRIZE integer;
declare variable INTCOUNTPRIZE integer;
declare variable INTCODECLIENT integer;
declare variable CHTYPEPAYMENT char(2);
declare variable CHACTIONTYPE char(2);
declare variable RACTIONSUMMA numeric(15,2);
declare variable RORDERSUMMA numeric(15,2);
declare variable DDATEOUTINVOICE date;
BEGIN

chCodesCalculation = '';
chCodesOutInvoice = '';
RESULT = -2;

SELECT company_problem_invoice, action_prize, action_counter, action_type, action_summa
FROM attrib
WHERE code_attrib = 1
INTO :intCodeFirm, :intPrize, :intCountPrize, :chActionType, :rActionSumma;

SELECT type_payment, code_client, code_subgroup
FROM order_client_cache
WHERE (code_order = :intCodeOrder)
INTO :chTypePayment, :intCodeClient, :intCodeSubgroup;

if ((chActionType = '02') OR ((RTRIM(chTypePayment) = 'B') AND (chStatePay = '2'))) then
   SELECT result FROM GetSumOrderCache(:intCodeOrder)
   INTO :rOrderSumma;

if ((RTRIM(chTypePayment) = 'B') AND (chStatePay = '2')) then
   UPDATE account_client
   SET account = CAST(account AS NUMERIC(15, 2)) - :rOrderSumma
   WHERE code_client = :intCodeClient;

if ((RTRIM(chTypePayment) = 'B') AND (chnsppoa <> '')) then
   INSERT INTO power_of_attorney(code_order, ser_power_of_attorney, num_power_of_attorney, date_power_of_attorney, nsp_power_of_attorney)
   VALUES(:intCodeOrder, :chserpoa, :chnumpoa, :datepoa, :chnsppoa);

FOR
SELECT wo.vat,
       wo.add_grouping
FROM order_client_cache o
INNER JOIN wares_order_cache wo ON (o.code_order = wo.code_order)
WHERE (o.code_order = :intCodeOrder)
GROUP BY o.date_payment,
         o.code_order,
         o.code_client,
         o.type_client,
         o.type_payment,
         o.code_manager,
         wo.vat,
         wo.add_grouping
INTO :rVat, :rAddGrouping
DO BEGIN
 if (not exists(select 1 from calculation_cache where code_order=:INTCODEORDER and vat=:rVat and add_grouping=:rAddGrouping)) then
 begin



  intCodeCalculation = GEN_ID(gen_code_calculation, 1);
  intNumberCalculation = GEN_ID(gen_number_calculation, 1);

  chCodesCalculation = :chCodesCalculation || rtrim(CAST(:intCodeCalculation AS VARCHAR(30))) || '';

  if (intEnd IN (7, 8)) then
     intNumberTaxInvoice = GEN_ID(gen_number_tax_invoice, 1);

  if (intEnd > 0) then
     dDateOutInvoice = :dateOrder;

  INSERT INTO calculation_cache
          (code_order,
           code_subgroup,
           code_firm,
           code_calculation,
           number_calculation,
           date_calculation,
           vat,
           add_grouping,
           state_pay,
           number_tax_invoice,
           date_out_invoice,
           date_take)
  VALUES (:intCodeOrder,
          :intCodeSubgroup,
          :intCodeFirm,
          :intCodeCalculation,
          :intNumberCalculation,
          :dateOrder,
          :rVat,
          :rAddGrouping,
          :chStatePay,
          :intNumberTaxInvoice,
          :dDateOutInvoice,
          :dateTake);

  if (intEnd IN (1, 5, 4)) then begin
     if (chCreditCard = '1') then
        INSERT INTO calculation_credit_card_cache
                (code_calculation,
                 code_credit_card,
                 number_slip,
                 description)
        VALUES (:intCodeCalculation,
                :intCodeCreditCard,
                :chNumberSLIP,
                :chDescriptionCreditCard);

/*
     if (RTRIM(chTypePayment) = 'B') then begin
        intCodeOutInvoice = GEN_ID(gen_code_out_invoice, 1);
        intNumberOutInvoice = GEN_ID(gen_number_out_invoice, 1);

        chCodesOutInvoice = :chCodesOutInvoice || rtrim(CAST(:intCodeOutInvoice AS VARCHAR(30))) || ';';

        INSERT INTO out_invoice_cache
                (code_out_invoice,
                 code_subgroup,
                 code_order,
                 code_calculation,
                 number_out_invoice,
                 date_out_invoice,
                 code_warehouse)
        VALUES (:intCodeOutInvoice,
                :intCodeSubgroup,
                :intCodeOrder,
                :intCodeCalculation,
                :intNumberOutInvoice,
                :dateOrder,
                :intCodeWarehouse);
     end
*/     
  end
 end
end

chCodesOutInvoice = :chCodesCalculation;

if (RTRIM(chTypePayment) <> 'B') then begin
   if (chActionType = '01') then begin
      if (intCountPrize = intPrize - 1) then begin
         UPDATE attrib
         SET action_counter = 0;

         UPDATE order_client_cache
         SET description = description || ' - Чек с акционным номером ' || CAST(:intPrize AS VARCHAR(20))
         WHERE code_order = :intCodeOrder;

         RESULT = :intPrize;
         SUSPEND;
         EXIT;
      end
      else
         UPDATE attrib
         SET action_counter = INVL(action_counter, 0) + 1;
   end

   if (chActionType = '02') then begin
      if (rOrderSumma >= rActionSumma) then
         if (intCountPrize = intPrize - 1) then begin
            UPDATE attrib
            SET action_counter = 0;

            UPDATE order_client_cache
            SET description = description || ' - Чек с акционным номером ' || CAST(:intPrize AS VARCHAR(20)) || '. К.сумма = ' || CAST(:rActionSumma AS VARCHAR(40))
            WHERE code_order = :intCodeOrder;

            RESULT = :intPrize;
            SUSPEND;
            EXIT;
         end
         else
            UPDATE attrib
            SET action_counter = INVL(action_counter, 0) + 1;
   end
end

RESULT = 0;

SUSPEND;

END^


ALTER PROCEDURE NEW_FRONTOFFICEWRITERECEIPT (
    INTCODEORDER INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50),
    NOTCHECK INTEGER)
AS
declare variable INTCODECALCULATION integer;
declare variable DCALCULATION timestamp;
declare variable USERCHANGE integer;
declare variable CHNUMBERRECEIPTNEW varchar(40);
declare variable CHERROR varchar(2000);
declare variable CHTYPEPAYMENT char(2);
declare variable RSUMMA numeric(15,2);
BEGIN

FOR SELECT cc.number_calculation,
                 cc.date_change,
                 oc.user_change,
                 oc.type_payment,
                 (SELECT result FROM GetFullSumCalculationCache(cc.code_calculation))
FROM order_client_cache oc
INNER JOIN calculation_cache cc ON (oc.code_order = cc.code_order)
WHERE (oc.Code_Order = :intCodeOrder)
INTO :intCodeCalculation,:dCalculation,:userChange,:chTypePayment,:rSumma
DO BEGIN

   EXECUTE PROCEDURE FrontOfficeChangeDateOrder( :intCodeCalculation, :dCalculation);

   if (notCheck = 1) then BEGIN
      chNumberReceipt = :intCodeCalculation;
      INSERT INTO calc_cash_register_cache
             ( code_calculation,
               number_receipt,
               date_receipt,
               only_date_receipt,
               user_change)
      SELECT code_calculation,
             number_calculation,
             date_calculation,
             date_calculation,
             :userChange
      FROM calculation_cache
      WHERE code_calculation = :intCodeCalculation;
   END ELSE BEGIN
      dCalculation = :chDateReceipt;
      INSERT INTO calc_cash_register_cache
             ( code_calculation,
               number_receipt,
               date_receipt,
               only_date_receipt,
               number_cashier,
               number_cash_register,
               model_cash_register,
               user_change)
      VALUES (:intCodeCalculation,
              :chNumberReceipt,
              :dCalculation,
              CAST(:dCalculation AS DATE),
              :chNumberCashier,
              :chNumberCashRegister,
              :chModelCashRegister,
              :userChange);

   END

  IF (chTypePayment = 'NC')
   THEN UPDATE attrib SET cassa_credit = cassa_credit + :rSumma WHERE code_attrib = 1;
   ELSE
  IF (chTypePayment = 'B1')
   THEN UPDATE attrib SET cassa_card = cassa_card + :rSumma WHERE code_attrib = 1;
   ELSE UPDATE attrib SET cassa = cassa + :rSumma WHERE code_attrib = 1;

   WHEN ANY DO BEGIN
      chError = 'Чек : Номер ' || :chNumberReceipt || ' от ' || CAST(:chDateReceipt AS VARCHAR(50)) || ' кассир ' || :chNumberCashier || ' кассовый аппарат ' || :chNumberCashRegister || ' модель ' || :chModelCashRegister;
      EXECUTE PROCEDURE SaveAppErrors 1, 0, '', :chError, :intCodeCalculation, 0, 0, 0, 0;
   END

end

END^


ALTER PROCEDURE NEW_GET_NUMBERS_CHECK (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT VARCHAR(150),
    CODEORDER_IN INTEGER)
AS
declare variable chreceipt varchar(30);
declare variable chcoma varchar(1);
BEGIN

RESULT = '';
CODEORDER_IN=:INTCODEORDER;

FOR SELECT ccr.number_receipt
    FROM calculation_cache ca
    left join calc_cash_register_cache ccr on (ccr.code_calculation = ca.code_calculation)
    WHERE (ca.code_order = :intCodeOrder)
    INTO :chReceipt
DO
BEGIN
  IF ((:RESULT = '')or(:RESULT is null)) THEN
     chComa = '';
  ELSE
     chComa = ',';

  RESULT = :RESULT || :chComa || :chReceipt;

END

SUSPEND;

END^


ALTER PROCEDURE NEW_GETCLIENTINFO (
    CHTYPECLIENT CHAR(1),
    INTCODECLIENT INTEGER)
RETURNS (
    CODECLIENT_IN INTEGER,
    NAME VARCHAR(212),
    BAR_CODE DOUBLE PRECISION,
    VARIANT_PAYMENT CHAR(2),
    IMPOCITION VARCHAR(15),
    AGREE_NUMBER VARCHAR(20),
    PHONE VARCHAR(111),
    ADDRESS VARCHAR(70),
    NAME_FOR_PRINT VARCHAR(250),
    INDEX_MAIL VARCHAR(10),
    CODE_CITY INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE NEW_GETSTATEORDER (
    INTCODEORDER INTEGER,
    INTCODEEND INTEGER)
RETURNS (
    STATE_ORDER CHAR(1),
    CODEORDER_IN INTEGER)
AS
declare variable intcount integer;
BEGIN
CODEORDER_IN=:INTCODEORDER;
IF (intCodeEnd = 0) THEN state_order = 'F'; ELSE
IF (intCodeEnd = 1) THEN state_order = 'I'; ELSE
IF (intCodeEnd = 7) THEN state_order = 'N';
IF (intCodeEnd IN (1, 7)) THEN BEGIN
   IF (NOT EXISTS(
           SELECT *
           FROM calculation_cache
           WHERE code_order = :intCodeOrder
           and state_pay<>'2'))
   THEN
      state_order = 'E';
END

SUSPEND;
END^


ALTER PROCEDURE NEW_GETSUMORDERCACHE (
    INTCODEORDER INTEGER)
RETURNS (
    RESULT NUMERIC(15,2),
    CODEORDER_IN INTEGER)
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE NEW_WRITEOPERATION (
    CHNUMBERCASHREGISTER VARCHAR(50),
    TYPEOPER INTEGER,
    INTCODEREASON INTEGER,
    CODECASHIER INTEGER,
    RSUMMA NUMERIC(15,2),
    CODEWAREHOUSE INTEGER,
    DESCRIPTION VARCHAR(255),
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable privatecodecashier integer;
declare variable numoperation integer;
declare variable codecashregister integer;
declare variable rcassa numeric(15,2);
declare variable rsummanew numeric(15,2);
BEGIN

SELECT next_number_check
FROM attrib
WHERE (code_attrib = 1)
INTO :NumOperation;

select spu.code_privat
from current_init spu where spu.code_init=1
--from spa_users spu where spu.code_sposuser=:CodeCashier
into :PrivateCodeCashier;

SELECT MIN(rcr.code_register_cash_register)
FROM register_cash_register rcr, attrib a
WHERE (a.code_attrib = 1)
  AND (rcr.code_subgroup = a.code_subgroup)
  AND (rcr.serial_number_cash_register = :chNumberCashRegister)
INTO :CodeCashRegister;

if (CodeCashRegister IS NULL) then
   RESULT = -1; /*незнайдено касовий апарат у таблиці register_cash_register */
ELSE
BEGIN
  if (TYPEOPER=0) THEN BEGIN INTCODEREASON=2;
                             rSummaNew = -:rSumma;
                       END
                  ELSE BEGIN INTCODEREASON=1;
                             rSummaNew = :rSumma;
                       END

  INSERT INTO cassa_operation(
  code_operation,
  number_operation,
  code_cash_register,
  type_operation,
  code_reason,
  code_privat,
  summa)
  VALUES(GEN_ID(GetCodeCassaOperation, 1),
  :NumOperation,
  :CodeCashRegister,
  :TypeOper,
  :intCodeReason,
  :PrivateCodeCashier,
  :rSummaNew);


  SELECT cassa
  FROM attrib
  WHERE code_attrib = 1
  INTO :rCassa;

  IF ((rCassa+rSumma) < 0) THEN
     RESULT = -2; /*тіпа грєшно записувати мінусову суму */
  ELSE
  BEGIN
     UPDATE attrib
     SET next_number_check = next_number_check + 1,
         cassa = cassa + :rSumma
     WHERE code_attrib = 1;

     RESULT = :NumOperation;
  END
       
END

SUSPEND;

END^


ALTER PROCEDURE NEW_WRITEZREPORT (
    INTCODEZREPORT INTEGER,
    Z_ZVIT_NUM INTEGER,
    CHNUMBERCASHREGISTER VARCHAR(50),
    RSUMREPORT NUMERIC(15,2),
    RSUMREPORTCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2),
    CHDATEREPORT TIMESTAMP,
    CODEWAREHOUSE INTEGER,
    RSUMCARD NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2))
RETURNS (
    RESULT INTEGER)
AS
declare variable intcodefirm integer;
declare variable intcodesubgroup integer;
declare variable intcodeprivat integer;
declare variable intcodenumbercash integer;
declare variable rcassa numeric(15,2);
declare variable rcassacredit numeric(15,2);
declare variable rcassacard numeric(15,2);
BEGIN

SELECT company_problem_invoice, code_subgroup, cassa, cassa_credit, cassa_card
FROM attrib
WHERE code_attrib = 1
INTO :intCodeFirm,
     :intCodeSubgroup,
     :rCassa,
     :rCassaCredit,
     :rCassaCard;

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO :intCodePrivat;

SELECT MIN(code_register_cash_register)
FROM register_cash_register
WHERE serial_number_cash_register = :chNumberCashRegister
INTO :intCodeNumberCash;

if (:INTCODEZREPORT IS NULL) then intCodeZReport = GEN_ID(gen_code_zreport, 1);/*залишино для сумісності*/

if ((:intCodeNumberCash IS NULL)or(:Z_ZVIT_NUM IS NULL)or(:INTCODEZREPORT IS NULL)) then
   RESULT = -1;
ELSE
BEGIN

   /*DELETE FROM cash_register_report
   WHERE Z_ZVIT_NUMBER=:Z_ZVIT_NUM
   AND number_cash_register_report=:intCodeNumberCash;*/

   INSERT INTO cash_register_report(
   code_cash_register_report,
   code_subgroup,
   code_firm_company,
   code_warehouse,
   number_cash_register_report,
   time_cash_register_report,
   sum_cash_register_report,
   sum_ready_money,
   sum_ready_credit,
   return_sum_cash,
   return_sum_ready_money,
   return_sum_ready_credit,
   serviceinput,
   serviceoutput,
   user_change,
   cassa,
   cassa_credit,
   cassa_card,
   sum_ready_card,
   return_sum_ready_card,
   Z_ZVIT_NUMBER)
   VALUES(:intCodeZReport,
          :intCodeSubgroup,
          :intCodeFirm,
          :CodeWarehouse,
          :intCodeNumberCash,
          :chDateReport,
          :rSumReport,
          :rSumReportCash,
          :rSumCredit,
          :rReturn,
          :rReturnCash,
          :rReturnCredit,
          :rInput,
          :rOutput,
          :intCodePrivat,
          :rCassa,
          :rCassaCredit,
          :rCassaCard,
          :rSumCard,
          :rReturnCard,
          :Z_ZVIT_NUM);

   RESULT = :intCodeZReport;
END

SUSPEND;

END^


ALTER PROCEDURE OPTS_GET_BOOL_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
SELECT CAST(o.value1 AS INTEGER)
FROM opts_item_values o
WHERE (o.code_item = :ITEMCODE)
  AND (o.code_subject = :SUBJECTCODE)
INTO :RESULT;

if (RESULT IS NULL) then
   SELECT CAST(DEFAULT_VALUE AS INTEGER)
   FROM OPTS_OPTION_ITEMS
   WHERE (CODE_ITEM = :ITEMCODE)
   INTO :RESULT;

SUSPEND;

END^


ALTER PROCEDURE OPTS_GET_REAL_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT DOUBLE PRECISION)
AS
BEGIN
SELECT CAST(o.value1 AS DOUBLE PRECISION)
FROM opts_item_values o
WHERE (o.code_item = :ITEMCODE)
  AND (o.code_subject = :SUBJECTCODE)
INTO :RESULT;

if (RESULT IS NULL) then
   SELECT CAST(DEFAULT_VALUE AS DOUBLE PRECISION)
   FROM OPTS_OPTION_ITEMS
   WHERE (CODE_ITEM = :ITEMCODE)
   INTO :RESULT;

SUSPEND;

END^


ALTER PROCEDURE OPTS_GET_VCHAR_VALUE (
    ITEMCODE INTEGER,
    SUBJECTCODE INTEGER)
RETURNS (
    RESULT VARCHAR(254))
AS
BEGIN
SELECT o.value1
FROM opts_item_values o
WHERE (o.code_item = :ITEMCODE)
  AND (o.code_subject = :SUBJECTCODE)
INTO :RESULT;

if (RESULT IS NULL) then
   SELECT DEFAULT_VALUE
   FROM OPTS_OPTION_ITEMS
   WHERE (CODE_ITEM = :ITEMCODE)
   INTO :RESULT;

SUSPEND;

END^


ALTER PROCEDURE PS_FR_SYNC (
    PASS_SERVER_TP VARCHAR(10),
    USER_SERVER_TP VARCHAR(10),
    SERVER_TP VARCHAR(255),
    KASSA_ID INTEGER)
RETURNS (
    EX_PARAM INTEGER,
    DOC_COUNT INTEGER,
    OMSG VARCHAR(1024))
AS
declare variable NUD timestamp;
declare variable TID integer;
declare variable ID1 integer;
declare variable NU integer;
declare variable ST varchar(40);
declare variable IDOCUMENT integer;
declare variable CHAR1_1 char(1);
declare variable CHAR1_2 char(1);
declare variable CHAR1_3 char(1);
declare variable CHAR1_4 char(1);
declare variable CHAR1_5 char(1);
declare variable CHAR2_1 char(2);
declare variable CHAR2_2 char(2);
declare variable CHAR2_3 char(2);
declare variable CHAR2_4 char(2);
declare variable CHAR2_5 char(2);
declare variable CHAR2_6 char(2);
declare variable CHAR2_7 char(2);
declare variable CHAR2_8 char(2);
declare variable CHAR2_9 char(2);
declare variable CHAR4_1 char(4);
declare variable CHAR5_1 char(5);
declare variable CHAR5_2 char(5);
declare variable DATE_1 date;
declare variable DATE_2 date;
declare variable DATE_3 date;
declare variable DATE_4 date;
declare variable DOUBLEPRECISION_1 double precision;
declare variable DOUBLEPRECISION_2 double precision;
declare variable DOUBLEPRECISION_3 double precision;
declare variable INTEGER_1 integer;
declare variable INTEGER_2 integer;
declare variable INTEGER_3 integer;
declare variable INTEGER_4 integer;
declare variable INTEGER_5 integer;
declare variable INTEGER_6 integer;
declare variable INTEGER_7 integer;
declare variable INTEGER_8 integer;
declare variable INTEGER_9 integer;
declare variable INTEGER_10 integer;
declare variable NUMERIC152_1 numeric(15,2);
declare variable NUMERIC152_2 numeric(15,2);
declare variable NUMERIC152_3 numeric(15,2);
declare variable NUMERIC152_4 numeric(15,2);
declare variable NUMERIC152_5 numeric(15,2);
declare variable NUMERIC152_6 numeric(15,2);
declare variable NUMERIC152_7 numeric(15,2);
declare variable NUMERIC152_8 numeric(15,2);
declare variable NUMERIC152_9 numeric(15,2);
declare variable NUMERIC152_10 numeric(15,2);
declare variable NUMERIC153_1 numeric(15,3);
declare variable NUMERIC163_1 numeric(16,3);
declare variable NUMERIC163_2 numeric(16,3);
declare variable NUMERIC163_3 numeric(16,3);
declare variable NUMERIC163_4 numeric(16,3);
declare variable NUMERIC166_1 numeric(16,6);
declare variable NUMERIC174_1 numeric(17,4);
declare variable NUMERIC174_2 numeric(17,4);
declare variable NUMERIC174_3 numeric(17,4);
declare variable NUMERIC52_1 numeric(5,2);
declare variable NUMERIC52_2 numeric(5,2);
declare variable NUMERIC74_1 numeric(7,4);
declare variable NUMERIC82_1 numeric(8,2);
declare variable NUMERIC96_1 numeric(9,6);
declare variable TIMESTAMP_1 timestamp;
declare variable TIMESTAMP_2 timestamp;
declare variable TIMESTAMP_3 timestamp;
declare variable VARCHAR10_1 varchar(10);
declare variable VARCHAR100_1 varchar(100);
declare variable VARCHAR100_2 varchar(100);
declare variable VARCHAR120_1 varchar(120);
declare variable VARCHAR128_1 varchar(128);
declare variable VARCHAR15_1 varchar(15);
declare variable VARCHAR20_1 varchar(20);
declare variable VARCHAR20_2 varchar(20);
declare variable VARCHAR20_3 varchar(20);
declare variable VARCHAR250_1 varchar(250);
declare variable VARCHAR254_1 varchar(254);
declare variable VARCHAR255_1 varchar(255);
declare variable VARCHAR255_2 varchar(255);
declare variable VARCHAR256_1 varchar(256);
declare variable VARCHAR30_1 varchar(30);
declare variable VARCHAR30_2 varchar(30);
declare variable VARCHAR30_3 varchar(30);
declare variable VARCHAR30_4 varchar(30);
declare variable VARCHAR4_1 varchar(4);
declare variable VARCHAR40_1 varchar(40);
declare variable VARCHAR40_2 varchar(40);
declare variable VARCHAR50_1 varchar(50);
declare variable VARCHAR50_2 varchar(50);
declare variable VARCHAR50_3 varchar(50);
declare variable VARCHAR50_4 varchar(50);
declare variable VARCHAR500_1 varchar(500);
declare variable VARCHAR1024_1 varchar(1024);
declare variable VARCHAR70_1 varchar(70);
declare variable VARCHAR70_2 varchar(70);
declare variable VARCHAR70_3 varchar(70);
declare variable VARCHAR70_4 varchar(70);
declare variable VARCHAR70_5 varchar(70);
declare variable VARCHAR8_1 varchar(8);
declare variable WAREHOUSE_ID integer;
declare variable COMPANY_ID integer;
declare variable CODE_SUBGROUP_ID integer;
declare variable TIM integer;
declare variable CODE_DEALER_ROZ integer;
declare variable TLINES integer;
BEGIN

IF (KASSA_ID IS NULL) THEN BEGIN
  SELECT ID_WORKPLACE FROM CURRENT_INIT WHERE code_init=1 INTO :KASSA_ID;
  IF (KASSA_ID IS NULL) THEN EXIT;
END

  omsg = 'Отримано ідентифікатор каси: ' || :KASSA_ID;
  suspend;

 -- IF (SERVER_TP IS NULL) THEN SERVER_TP='192.168.133.55/3050:/BASE/TP.GDB';
  IF (SERVER_TP IS NULL) THEN SERVER_TP='192.168.133.55:/BASE/TP.GDB';
  IF (USER_SERVER_TP IS NULL) THEN USER_SERVER_TP='SYSDBA';
  IF (PASS_SERVER_TP IS NULL) THEN PASS_SERVER_TP='masterkey';

  SELECT a.WAREHOUSE_PROBLEM_INVOICE, a.COMPANY_PROBLEM_INVOICE, a.CODE_SUBGROUP,a.code_dealer_roz
      FROM attrib a
        WHERE code_attrib = 1
    INTO :WAREHOUSE_ID, :COMPANY_ID, :CODE_SUBGROUP_ID,:CODE_DEALER_ROZ;

  ex_param=0;
  doc_count=0;
  TID=1;

  while (tid<49) do
  begin --===початок циклу===
    nu=0;
    nud=null;
    select dml_datetime from kassa_update_logz where table_id=:tid into :nud;
    if (nud is null) then nud=cast('01.01.1979' as timestamp);
   -- tim=tickcount();
    tlines = 0;
    if (tid=1) then
    begin
        omsg = '-коди ділимих товарів'; suspend;

        st='WARES_WITH_FRACTIONAL_UNIT';
        for execute statement ('select CODE_WARES,DML_DATETIME from WARES_WITH_FRACTIONAL_UNIT where dml_datetime>?') (:nud)
            on external DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
          into :INTEGER_1,:TIMESTAMP_1
        do begin
            update or insert into wares_with_fractional_unit (code_wares,dml_datetime)
                values (:integer_1,:timestamp_1 )
              matching (code_wares);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
    if (tid=2) then
    begin
        omsg = '-товари';   suspend;
        st='WARES';
        for execute statement ('select data_wares,code_wares,code_group,code_unit,code_wares_relative,code_brand,vat_operation,excise,dml_datetime,o_wares,old_articl,articl_wares_brand,articl,touch_code,name_wares_receipt,marking_all_are_assembled,name_wares_brand,name_wares,min_quantity,min_rest,sign_1,sign_2,sign_3,vat,excise_tax from wares where dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char2_1,:char2_2,:timestamp_1,:varchar4_1,:varchar15_1,:varchar30_1,:varchar30_2,:varchar30_3,:varchar50_1,:varchar50_2,:varchar100_1,:varchar100_2,:numeric163_1,:numeric163_2,:numeric174_1,:numeric174_2,:numeric174_3,:numeric52_1,:numeric52_2
        do begin
            update or insert into wares (data_wares,code_wares,code_group,code_unit,code_wares_relative,code_brand,vat_operation,excise,dml_datetime,o_wares,old_articl,articl_wares_brand,articl,touch_code,name_wares_receipt,marking_all_are_assembled,name_wares_brand,name_wares,min_quantity,min_rest,sign_1,sign_2,sign_3,vat,excise_tax)
                values (:date_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char2_1,:char2_2,:timestamp_1,:varchar4_1,:varchar15_1,:varchar30_1,:varchar30_2,:varchar30_3,:varchar50_1,:varchar50_2,:varchar100_1,:varchar100_2,:numeric163_1,:numeric163_2,:numeric174_1,:numeric174_2,:numeric174_3,:numeric52_1,:numeric52_2 )
              matching (code_wares);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
   /* if (tid=3) then
    begin
        omsg = '-одиниці виміру';   suspend;
        st='ADDITION_UNIT';
        for execute statement ('select r.code_wares,r.code_unit from refresh_delete_log r where r.table_id=3 and r.dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2
        do begin
            delete from addition_unit a where a.code_wares=:integer_1 and a.code_unit=:integer_2;
            nu=1;
            for execute statement ('select code_wares,code_unit,default_unit,report_unit,sign_activity,check_find_bar_code,sign_locking,dml_datetime,bar_code,description,coefficient,height,lengt_,weight,width from addition_unit where dml_datetime>?')
                         (:nud)
                on external data source :server_tp as user 'sysdba' password 'masterkey'
              into :integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char1_4,:char1_5,:timestamp_1,:varchar30_1,:varchar255_1,:numeric166_1,:numeric163_1,:numeric163_2,:numeric163_3,:numeric163_4
            do begin
                if (:char1_2='Y') then
                    update addition_unit set default_unit='N' where code_wares=:integer_1 and default_unit='Y';

                update or insert into addition_unit (code_wares,code_unit,default_unit,report_unit,sign_activity,check_find_bar_code,sign_locking,dml_datetime,bar_code,description,coefficient,height,lengt_,weight,width)
                    values (:integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char1_4,:char1_5,:timestamp_1,:varchar30_1,:varchar255_1,:numeric166_1,:numeric163_1,:numeric163_2,:numeric163_3,:numeric163_4 )
                  matching (code_wares,code_unit);
                nu=1;
            end
            tlines = :tlines + 1;
        end
    end else  */
    if (tid=4) then
    begin
        omsg = '-ціни товарів';   suspend;
        st='PRICE_DEALER';
      /*  for execute statement ('select r.code_wares,r.code_dealer,r.code_subgroup from refresh_delete_log r where r.table_id=2 and r.dml_datetime>?')
                      (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3
        do begin
            delete from price_dealer p where p.code_wares=:integer_1 and p.code_dealer=:integer_2 and p.code_subgroup=:integer_3;
            nu=1;
        end  */
        for execute statement ('select fixed_end_date,indicative_begin_date,indicative_end_date,fixed_begin_date,price_dealer,indicative_min_price,indicative_max_price,code_wares,code_dealer,code_subgroup,code_currency,indicative_id,indicative_code_currency,fixed_id,indicative_active,disregard_price_propocition,fixed_price,dml_datetime,markup from price_dealer where dml_datetime>? and code_dealer=?')
                 (:nud,:code_dealer_roz)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char2_1,:char2_2,:char2_3,:timestamp_1,:numeric82_1
        do begin
            update or insert into price_dealer (fixed_end_date,indicative_begin_date,indicative_end_date,fixed_begin_date,price_dealer,indicative_min_price,indicative_max_price,code_wares,code_dealer,code_subgroup,code_currency,indicative_id,indicative_code_currency,fixed_id,indicative_active,disregard_price_propocition,fixed_price,dml_datetime,markup)
                values (:date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char2_1,:char2_2,:char2_3,:timestamp_1,:numeric82_1 )
            matching(code_wares,code_dealer);
           nu=1;
           tlines = :tlines + 1;
        end
    end else
    if (tid=5) then
    begin
        omsg = '-спеціальні пропозиції';   suspend;
        st='PRICE_PROPOCITION';
     /*   for execute statement ('select r.code_price_propocition from refresh_delete_log r where r.table_id=1 and r.dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1
        do begin
            delete from price_propocition p where p.code_price_propocition=:integer_1;
            nu=1;
        end  */
        for execute statement ('select fixed_begin_date,fixed_end_date,indicative_begin_date,indicative_end_date,indicative_min_price,indicative_max_price,price_propocition,code_price_propocition,code_wares,code_subgroup,cat_specproposition_id,indicative_id,indicative_code_currency,code_currency,fixed_id,indicative_active,fixed_price,dml_datetime,cubic,markup from price_propocition where dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:integer_8,:char2_1,:char2_2,:timestamp_1,:numeric153_1,:numeric82_1
        do begin
            update or insert into price_propocition (fixed_begin_date,fixed_end_date,indicative_begin_date,indicative_end_date,indicative_min_price,indicative_max_price,price_propocition,code_price_propocition,code_wares,code_subgroup,cat_specproposition_id,indicative_id,indicative_code_currency,code_currency,fixed_id,indicative_active,fixed_price,dml_datetime,cubic,markup)
                values (:date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:integer_8,:char2_1,:char2_2,:timestamp_1,:numeric153_1,:numeric82_1 )
              matching(code_price_propocition);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
    if (tid=6) then
    begin
        omsg = '-розподіл товарів по відділах';   suspend;
        st='SHOP_DEPARTMENT_WARES';
        for execute statement ('select weight_tare,code_wares,code_department,number_wares_scale,number_tare,shelf_life,const_shelf_life,code_shop,send_to_scale,label_format,dml_datetime from shop_department_wares where dml_datetime>?')
                    (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char1_1,:char2_1,:timestamp_1
        do begin
            update or insert into shop_department_wares (weight_tare,code_wares,code_department,number_wares_scale,number_tare,shelf_life,const_shelf_life,code_shop,send_to_scale,label_format,dml_datetime)
                values (:doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char1_1,:char2_1,:timestamp_1 )
              matching(code_wares,code_department);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
    if (tid=7) then
    begin
        omsg = '-бар"єр дисконту';   suspend;
        st='WARES_PARAMETERS_SUBGROUP';
        for execute statement ('select code_wares,code_subgroup,allow_for,dml_datetime,min_percent_markup,barrier_recalculation_price from wares_parameters_subgroup where dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:char1_1,:timestamp_1,:numeric52_1,:numeric52_2
        do begin
            update or insert into wares_parameters_subgroup (code_wares,code_subgroup,allow_for,dml_datetime,min_percent_markup,barrier_recalculation_price)
                values (:integer_1,:integer_2,:char1_1,:timestamp_1,:numeric52_1,:numeric52_2) matching (code_wares);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
   /* if (tid=8) then begin
        omsg = '-вхідні ціни постачальників';   suspend;
        st='SHOP_PRICE_SUPPLIER';
        for execute statement ('select price,code_wares,code_supplier,code_shop,code_currency,number_invoice,dml_datetime,date_invoice,date_change,quantity from shop_price_supplier where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:timestamp_1,:timestamp_2,:timestamp_3,:numeric163_1
        do begin
            update or insert into shop_price_supplier (price,code_wares,code_supplier,code_shop,code_currency,number_invoice,dml_datetime,date_invoice,date_change,quantity)
                values (:doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:timestamp_1,:timestamp_2,:timestamp_3,:numeric163_1 )
              matching(code_wares,code_supplier);
            nu=1;
            tlines = :tlines + 1;
        end
    end else   */
    if (tid=9) then begin
        omsg = '-часові проміжки спецьпропозицій';   suspend;
        st='SHOP_SPECPROPOSITION_TIME';
        for execute statement ('select shop_specproposition_time_id,code_shop,cat_specproposition_id,day_begin,day_end,time_end,time_begin,dml_datetime from shop_specproposition_time where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:char5_1,:char5_2,:timestamp_1
        do begin
            update or insert into shop_specproposition_time (shop_specproposition_time_id,code_shop,cat_specproposition_id,day_begin,day_end,time_end,time_begin,dml_datetime)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:char5_1,:char5_2,:timestamp_1 )
            matching(shop_specproposition_time_id);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
    if (tid=10) then
    begin
        omsg = '-фізичні особи';   suspend;
        st='PRIVAT';
        for execute statement ('select date_animation_bar_code,bar_code,code_privat,code_currency_account,code_city,sign_activity,flag_check,tax_payer_vat,dml_datetime,index_mail,impocition,work_phone,agree_number,house_phone,surname,name,mail,patronymic,address,document,name_for_print from privat where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:doubleprecision_1,:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:char1_3,:timestamp_1,:varchar10_1,:varchar15_1,:varchar20_1,:varchar20_2,:varchar20_3,:varchar70_1,:varchar70_2,:varchar70_3,:varchar70_4,:varchar70_5,:varchar120_1,:varchar250_1
        do begin
            update or insert into privat (date_animation_bar_code,bar_code,code_privat,code_currency_account,code_city,sign_activity,flag_check,tax_payer_vat,dml_datetime,index_mail,impocition,work_phone,agree_number,house_phone,surname,name,mail,patronymic,address,document,name_for_print)
                values (:date_1,:doubleprecision_1,:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:char1_3,:timestamp_1,:varchar10_1,:varchar15_1,:varchar20_1,:varchar20_2,:varchar20_3,:varchar70_1,:varchar70_2,:varchar70_3,:varchar70_4,:varchar70_5,:varchar120_1,:varchar250_1 )
              matching(code_privat);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
   /* if (tid=11) then
    begin
        st='CONCERN_P_CLIENT';
        for execute statement ('select code_concern,code_privat,code_subgroup,sign_activity,dml_datetime from concern_p_client where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:timestamp_1
        do begin
            update or insert into concern_p_client (code_concern,code_privat,code_subgroup,sign_activity,dml_datetime)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:timestamp_1 )
              matching(code_privat,code_concern);
            nu=1;
            tlines = :tlines + 1;
        end
    end else */
    if (tid=12) then
    begin
        omsg = '-P_CLIENT - не знаю що це';   suspend;
        st='P_CLIENT';
        for execute statement ('select code_privat,code_subgroup,code_discount_card,code_currency,code_tride_region,code_dealer,max_end_payment,sign_activity,recalc_order,control_min_percent,recalc_course,variant_payment,price_notless_sprice,min_price_sprice,not_sprice,check_spec_discount,discount_position,dml_datetime,id_client,max_debt,per_pp,discount from p_client where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char1_1,:char2_1,:char2_2,:char2_3,:char2_4,:char2_5,:char2_6,:char2_7,:char2_8,:char2_9,:timestamp_1,:varchar30_1,:numeric152_1,:numeric152_2,:numeric96_1
        do begin
            update or insert into p_client (code_privat,code_subgroup,code_discount_card,code_currency,code_tride_region,code_dealer,max_end_payment,sign_activity,recalc_order,control_min_percent,recalc_course,variant_payment,price_notless_sprice,min_price_sprice,not_sprice,check_spec_discount,discount_position,dml_datetime,id_client,max_debt,per_pp,discount)
                values (:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char1_1,:char2_1,:char2_2,:char2_3,:char2_4,:char2_5,:char2_6,:char2_7,:char2_8,:char2_9,:timestamp_1,:varchar30_1,:numeric152_1,:numeric152_2,:numeric96_1 )
              matching(code_privat,code_subgroup);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
  /*  if (tid=13) then
    begin
        omsg = '';   suspend;
        st='DISCOUNT_CLIENT_OF_BRAND';
        for execute statement ('select code_brand,code_client,code_subgroup,type_client,sign_activity,dml_datetime,discount from discount_client_of_brand where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1,:numeric52_1
        do begin
            update or insert into discount_client_of_brand (code_brand,code_client,code_subgroup,type_client,sign_activity,dml_datetime,discount)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1,:numeric52_1 )
              matching(code_client,code_brand,code_subgroup);
            nu=1;
            tlines = :tlines + 1;
        end
    end else
    if (tid=14) then
    begin
        st='DISCOUNT_CLIENT_OF_GROUP';
        for execute statement ('select code_client,code_subgroup,code_group,sign_activity,type_client,dml_datetime,discount from discount_client_of_group where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1,:numeric52_1
        do begin
            update or insert into discount_client_of_group (code_client,code_subgroup,code_group,sign_activity,type_client,dml_datetime,discount)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1,:numeric52_1 )
              matching(code_client,code_group,code_subgroup);
            nu=1;
            tlines = :tlines + 1;
        end
    end else */
    if (tid=15) then
    begin
        omsg = '-фірми';   suspend;
        st='FIRMS';
        for execute statement ('select date_animation_bar_code,bar_code,code_firm,code_currency_account,code_city,code_parent_firm,code_bank,tax_payer_vat,sign_activity,flag_check,dml_datetime,index_mail,impocition,agree_number,code_zip,account,currency_account,mail,phone,fax,telex,name,address,address_location,name_for_print from firms where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char1_1,:char1_2,:char1_3,:timestamp_1,:varchar10_1,:varchar15_1,:varchar20_1,:varchar20_2,:varchar40_1,:varchar40_2,:varchar50_1,:varchar50_2,:varchar50_3,:varchar50_4,:varchar70_1,:varchar70_2,:varchar70_3,:varchar250_1
        do begin
            delete from firms where (name=:varchar70_1)and(code_firm<>:integer_1);

            id1=null;
            for select code_firm
                from firms where code_firm=:integer_1
              into :id1
                as cursor tmpcursor
            do
                update firms set
                    date_animation_bar_code=:date_1,
                    bar_code=:doubleprecision_1,
                    code_currency_account=:integer_2,
                    code_city=:integer_3,
                    code_parent_firm=:integer_4,
                    code_bank=:integer_5,
                    tax_payer_vat=:char1_1,
                    sign_activity=:char1_2,
                    flag_check=:char1_3,
                    dml_datetime=:timestamp_1,
                    index_mail=:varchar10_1,
                    impocition=:varchar15_1,
                    agree_number=:varchar20_1,
                    code_zip=:varchar20_2,
                    account=:varchar40_1,
                    currency_account=:varchar40_2,
                    mail=:varchar50_1,
                    phone=:varchar50_2,
                    fax=:varchar50_3,
                    telex=:varchar50_4,
                    name=:varchar70_1,
                    address=:varchar70_2,
                    address_location=:varchar70_3,
                    name_for_print=:varchar250_1
                  where current of tmpcursor;
            end
        if (id1 is null) then
            insert into firms (date_animation_bar_code,bar_code,code_firm,code_currency_account,code_city,code_parent_firm,code_bank,tax_payer_vat,sign_activity,flag_check,dml_datetime,index_mail,impocition,agree_number,code_zip,account,currency_account,mail,phone,fax,telex,name,address,address_location,name_for_print)
                values (:date_1,:doubleprecision_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char1_1,:char1_2,:char1_3,:timestamp_1,:varchar10_1,:varchar15_1,:varchar20_1,:varchar20_2,:varchar40_1,:varchar40_2,:varchar50_1,:varchar50_2,:varchar50_3,:varchar50_4,:varchar70_1,:varchar70_2,:varchar70_3,:varchar250_1 );

        nu=1;
    end else
    if (tid=16) then
    begin
        st='CONCERN_F_CLIENT';
        for execute statement ('select code_subgroup,code_concern,code_firm,sign_activity,dml_datetime from concern_f_client where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:timestamp_1
        do begin
            update or insert into concern_f_client (code_subgroup,code_concern,code_firm,sign_activity,dml_datetime)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:timestamp_1 )
              matching(code_firm,code_concern);
            nu=1;
        end
    end else
    if (tid=17) then
    begin
        omsg = '-F_CLIENT - не ясно';   suspend;
        st='F_CLIENT';
        for execute statement ('select code_firm,code_subgroup,code_currency,code_discount_card,code_tride_region,code_dealer,max_end_payment,code_privat,sign_activity,check_spec_discount,not_sprice,recalc_order,discount_position,recalc_course,control_min_percent,variant_payment,price_notless_sprice,min_price_sprice,dml_datetime,id_client,max_debt,per_pp,discount from f_client where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:integer_8,:char1_1,:char2_1,:char2_2,:char2_3,:char2_4,:char2_5,:char2_6,:char2_7,:char2_8,:char2_9,:timestamp_1,:varchar30_1,:numeric152_1,:numeric152_2,:numeric96_1
        do begin
            update or insert into f_client (code_firm,code_subgroup,code_currency,code_discount_card,code_tride_region,code_dealer,max_end_payment,code_privat,sign_activity,check_spec_discount,not_sprice,recalc_order,discount_position,recalc_course,control_min_percent,variant_payment,price_notless_sprice,min_price_sprice,dml_datetime,id_client,max_debt,per_pp,discount)
                values (:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:integer_8,:char1_1,:char2_1,:char2_2,:char2_3,:char2_4,:char2_5,:char2_6,:char2_7,:char2_8,:char2_9,:timestamp_1,:varchar30_1,:numeric152_1,:numeric152_2,:numeric96_1 )
              matching(code_firm,code_subgroup);
            nu=1;
        end
    end else
    if (tid=18) then
    begin
        omsg = '-рахунки клієнтів';   suspend;
        st='ACCOUNT_CLIENT';
        for execute statement ('select account_cash,account_reusable_container,account,code_client,code_currency,code_firm_company,type_client,dml_datetime from account_client where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:char2_1,:timestamp_1
        do begin
            update or insert into account_client (account_cash,account_reusable_container,account,code_client,code_currency,code_firm_company,type_client,dml_datetime)
                values (:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:char2_1,:timestamp_1 )
              matching(code_client,code_currency,code_firm_company);
            nu=1;
        end
    end else
    if (tid=19) then
    begin
        omsg = '-магазини';   suspend;
        st='SHOP_DEALER';
        for execute statement ('select code_shop,code_dealer,id_level,discount,shop_dealer_print_second,dml_datetime from shop_dealer where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1
        do begin
            update or insert into shop_dealer (code_shop,code_dealer,id_level,discount,shop_dealer_print_second,dml_datetime)
                values (:integer_1,:integer_2,:integer_3,:char1_1,:char1_2,:timestamp_1 )
              matching(code_shop,code_dealer);
            nu=1;
        end
    end else
    if (tid=20) then
    begin
        omsg = '-додаткові признаки';   suspend;
        st='ADDITION_SIGN';
        for execute statement ('select code_addition_sign,sign_activity,part_addition_sign,dml_datetime,name,description from addition_sign where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:char1_1,:char2_1,:timestamp_1,:varchar70_1,:varchar256_1
        do begin
            update or insert into addition_sign (code_addition_sign,sign_activity,part_addition_sign,dml_datetime,name,description)
                values (:integer_1,:char1_1,:char2_1,:timestamp_1,:varchar70_1,:varchar256_1 )
              matching(code_addition_sign);
            nu=1;
        end
    end else
    if (tid=21) then
    begin
        omsg = '-одиниці виміру';   suspend;
        st='UNIT_DIMENSION';
        for execute statement ('select code_unit,code_wares_reusable_container,sign_activity,sign_divisional,reusable_container,abr_unit,dml_datetime,name_unit,description from unit_dimension where dml_datetime>?') (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char4_1,:timestamp_1,:varchar70_1,:varchar250_1
        do begin
            update or insert into unit_dimension (code_unit,code_wares_reusable_container,sign_activity,sign_divisional,reusable_container,abr_unit,dml_datetime,name_unit,description)
                values (:integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char4_1,:timestamp_1,:varchar70_1,:varchar250_1 )
              matching(code_unit);
            nu=1;
            tlines = :tlines + 1;
        end
    end     -- else

    if (:tlines <> 0) then
    begin
        omsg = ' оброблено ' || :tlines || ' записів';   suspend;
    end
    TID=TID+1;

  end

/*
--   INSERT INTO spa_users_test (code_sposuser,user_name,sign_activity,date_begin,date_end,code_privat,pswd,code_profile,code_shop,code_subgroup)
--   select code_sposuser,user_name,sign_activity,date_begin,date_end,code_privat,pswd,code_profile,code_shop,code_subgroup from spa_users;
--for
--EXECUTE STATEMENT 'select CURRENT_TRANSACTION from RDB$DATABASE'





IF (TID=22) THEN BEGIN
 ST='GROUP_WARES';
 FOR EXECUTE STATEMENT ('select CODE_GROUP_WARES,CODE_PARENT_GROUP_WARES,SIGN_ACTIVITY,DML_DATETIME,NIK_NAME_GROUP_WARES,NAME from GROUP_WARES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO GROUP_WARES (CODE_GROUP_WARES,CODE_PARENT_GROUP_WARES,SIGN_ACTIVITY,DML_DATETIME,NIK_NAME_GROUP_WARES,NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR70_1 )
   MATCHING(CODE_GROUP_WARES);
   NU=1;
 END
END ELSE

IF (TID=23) THEN BEGIN
 ST='CHOSEN_GROUP_WARES';
 FOR EXECUTE STATEMENT ('select CODE_GROUP,CODE_PARENT_GROUP,USER_CHANGE,TYPE_CHOICE,DML_DATETIME,DATE_CHANGE from CHOSEN_GROUP_WARES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2 
 DO BEGIN
   UPDATE OR INSERT INTO CHOSEN_GROUP_WARES (CODE_GROUP,CODE_PARENT_GROUP,USER_CHANGE,TYPE_CHOICE,DML_DATETIME,DATE_CHANGE)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2 )
   MATCHING(CODE_GROUP,TYPE_CHOICE);
   NU=1;
 END
END ELSE

IF (TID=24) THEN BEGIN
 ST='DEPARTMENT';
 FOR EXECUTE STATEMENT ('select CODE_DEPARTMENT,CODE_SUBGROUP,NUMBER_DEPARTMENT,SIGN_ACTIVITY,DML_DATETIME,NAME_DEPARTMENT from DEPARTMENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO DEPARTMENT (CODE_DEPARTMENT,CODE_SUBGROUP,NUMBER_DEPARTMENT,SIGN_ACTIVITY,DML_DATETIME,NAME_DEPARTMENT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 )
   MATCHING(CODE_DEPARTMENT);
   NU=1;
 END
END ELSE

IF (TID=25) THEN BEGIN
 ST='CONTRACT';
 FOR EXECUTE STATEMENT ('select DATE_CONTRACT,DATE_END_CONTRACT,DATE_COUNT_ALL,CODE_CONTRACT,NUMBER_CONTRACT,PRIORITY,CODE_CLIENT,CODE_ADDITION_SIGN,CODE_SUBGROUP,SIGN_ACTIVITY,TYPE_PAYMENT,TYPE_CLIENT,TYPE_CONTRACT,STATE_CONTRACT,FIX_PRICE,DML_DATETIME from CONTRACT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DATE_2,:DATE_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO CONTRACT (DATE_CONTRACT,DATE_END_CONTRACT,DATE_COUNT_ALL,CODE_CONTRACT,NUMBER_CONTRACT,PRIORITY,CODE_CLIENT,CODE_ADDITION_SIGN,CODE_SUBGROUP,SIGN_ACTIVITY,TYPE_PAYMENT,TYPE_CLIENT,TYPE_CONTRACT,STATE_CONTRACT,FIX_PRICE,DML_DATETIME)
   VALUES (:DATE_1,:DATE_2,:DATE_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:TIMESTAMP_1 )
   MATCHING(CODE_CONTRACT);
   NU=1;
 END
END ELSE

IF (TID=26) THEN BEGIN
 ST='SHOP_CLIENT_FROM_SUM_ORDER';
 FOR EXECUTE STATEMENT ('select CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,CODE_PRIVAT,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME,SUM_ORDER from SHOP_CLIENT_FROM_SUM_ORDER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:TIMESTAMP_1,:NUMERIC152_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_CLIENT_FROM_SUM_ORDER (CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,CODE_PRIVAT,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME,SUM_ORDER)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:TIMESTAMP_1,:NUMERIC152_1 )
   MATCHING(CODE_SHOP,CODE_CLIENT);
   NU=1;
 END
END ELSE

IF (TID=27) THEN BEGIN
 ST='SHOP_CLIENT_FOR_FRONTOFFICE';
 FOR EXECUTE STATEMENT ('select SHOP_CLIENT_FOR_FRONTOFFICE_ID,CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,DAY_END,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME from SHOP_CLIENT_FOR_FRONTOFFICE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_CLIENT_FOR_FRONTOFFICE (SHOP_CLIENT_FOR_FRONTOFFICE_ID,CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,DAY_END,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 )
   MATCHING(SHOP_CLIENT_FOR_FRONTOFFICE_ID);
   NU=1;
 END
END ELSE

IF (TID=28) THEN BEGIN
 ST='SHOP_DISCOUNT';
 FOR EXECUTE STATEMENT ('select CODE_DISCOUNT,CODE_SHOP,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT from SHOP_DISCOUNT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC74_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DISCOUNT (CODE_DISCOUNT,CODE_SHOP,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC74_1 )
   MATCHING(CODE_DISCOUNT);
   NU=1;
 END
END ELSE

IF (TID=29) THEN BEGIN
 ST='MANAGER';
 FOR EXECUTE STATEMENT ('select CODE_TRIDE_REGION,CODE_PRIVAT,SIGN_ACTIVITY,DML_DATETIME,CODE_MANAGER from MANAGER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1 
 DO BEGIN
   UPDATE OR INSERT INTO MANAGER (CODE_TRIDE_REGION,CODE_PRIVAT,SIGN_ACTIVITY,DML_DATETIME,CODE_MANAGER)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1 )
   MATCHING(CODE_TRIDE_REGION,CODE_PRIVAT);
   NU=1;
 END
END ELSE

IF (TID=30) THEN BEGIN
 ST='V_SPA_EVENTS_MONITOR';
 FOR EXECUTE STATEMENT ('select CODE_SHOP,CODE_COMPLIANCE,PRIORITY,CODE_INSPECTOR,EVENT_ID,DML_DATETIME,INSPECTOR_EVENT_ID,ADDITION_PARAMS,INSPECTOR_EVENT_NAME from V_SPA_EVENTS_MONITOR where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR2_1,:TIMESTAMP_1,:VARCHAR15_1,:VARCHAR255_1,:VARCHAR255_2 
 DO BEGIN
   UPDATE OR INSERT INTO V_SPA_EVENTS_MONITOR (CODE_SHOP,CODE_COMPLIANCE,PRIORITY,CODE_INSPECTOR,EVENT_ID,DML_DATETIME,INSPECTOR_EVENT_ID,ADDITION_PARAMS,INSPECTOR_EVENT_NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR2_1,:TIMESTAMP_1,:VARCHAR15_1,:VARCHAR255_1,:VARCHAR255_2 )
   MATCHING(CODE_COMPLIANCE,CODE_SHOP);
   NU=1;
 END
END ELSE

IF (TID=31) THEN BEGIN
 ST='DISCOUNT_CARD';
 FOR EXECUTE STATEMENT ('select CODE_DISCOUNT_CARD,PERIOD_OF_VALIDITY,CODE_SUBGROUP,CODE_DISCOUNT_CARD_GROUP,SIGN_ACTIVITY,FIXED_DISCOUNT,DML_DATETIME,NAME_DISCOUNT_CARD,SUM_DISCOUNT_CARD,PERCENT_DISCOUNT_CARD from DISCOUNT_CARD where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:VARCHAR50_1,:NUMERIC152_1,:NUMERIC52_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CARD (CODE_DISCOUNT_CARD,PERIOD_OF_VALIDITY,CODE_SUBGROUP,CODE_DISCOUNT_CARD_GROUP,SIGN_ACTIVITY,FIXED_DISCOUNT,DML_DATETIME,NAME_DISCOUNT_CARD,SUM_DISCOUNT_CARD,PERCENT_DISCOUNT_CARD)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:VARCHAR50_1,:NUMERIC152_1,:NUMERIC52_1 )
   MATCHING(CODE_DISCOUNT_CARD);
   NU=1;
 END
END ELSE

IF (TID=32) THEN BEGIN
 ST='CITY';
 FOR EXECUTE STATEMENT ('select CODE_CITY,CODE_REGION,CODE_COUNTRY,DML_DATETIME,NAME_CITY,PHONE_CODE from CITY where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR70_2 
 DO BEGIN
   UPDATE OR INSERT INTO CITY (CODE_CITY,CODE_REGION,CODE_COUNTRY,DML_DATETIME,NAME_CITY,PHONE_CODE)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR70_2 )
   MATCHING(CODE_CITY);
   NU=1;
 END
END ELSE

IF (TID=33) THEN BEGIN
 ST='OPTS_ITEM_VALUES';
 FOR EXECUTE STATEMENT ('select CODE_SUBJECT,CODE_ITEM,DML_DATETIME,VALUE1 from OPTS_ITEM_VALUES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR254_1 
 DO BEGIN
   UPDATE OR INSERT INTO OPTS_ITEM_VALUES (CODE_SUBJECT,CODE_ITEM,DML_DATETIME,VALUE1)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR254_1 )
   MATCHING(CODE_SUBJECT,CODE_ITEM);
   NU=1;
 END
END ELSE

IF (TID=34) THEN BEGIN
 ST='REGISTER_CASH_REGISTER';
 FOR EXECUTE STATEMENT ('select CODE_REGISTER_CASH_REGISTER,CODE_SUBGROUP,CODE_COMPANY,NUMBER_CASH_REGISTER,DML_DATETIME,SERIAL_NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER from REGISTER_CASH_REGISTER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR50_2 
 DO BEGIN
   UPDATE OR INSERT INTO REGISTER_CASH_REGISTER (CODE_REGISTER_CASH_REGISTER,CODE_SUBGROUP,CODE_COMPANY,NUMBER_CASH_REGISTER,DML_DATETIME,SERIAL_NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR50_2 )
   MATCHING(CODE_REGISTER_CASH_REGISTER);
   NU=1;
 END
END ELSE

IF (TID=35) THEN BEGIN
 ST='SPA_USERS';
 FOR EXECUTE STATEMENT ('select DATE_BEGIN,DATE_END,CODE_SHOP,CODE_SPOSUSER,CODE_PRIVAT,CODE_SUBGROUP,CODE_PROFILE,SIGN_ACTIVITY,USER_NAME,PSWD from SPA_USERS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DATE_2,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:VARCHAR30_1,:VARCHAR128_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_USERS (DATE_BEGIN,DATE_END,CODE_SHOP,CODE_SPOSUSER,CODE_PRIVAT,CODE_SUBGROUP,CODE_PROFILE,SIGN_ACTIVITY,USER_NAME,PSWD)
   VALUES (:DATE_1,:DATE_2,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:VARCHAR30_1,:VARCHAR128_1 )
   MATCHING(CODE_SPOSUSER);
   NU=1;
 END
END ELSE

IF (TID=36) THEN BEGIN
 ST='SPA_SECURITY_LIST';
 FOR EXECUTE STATEMENT ('select CODE_OBJECT,CODE_PARENT_OBJECT,TYPE_OBJECT,DML_DATETIME,REAL_NAME_OBJECT,NAME_OBJECT from SPA_SECURITY_LIST where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_SECURITY_LIST (CODE_OBJECT,CODE_PARENT_OBJECT,TYPE_OBJECT,DML_DATETIME,REAL_NAME_OBJECT,NAME_OBJECT)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR100_1 )
   MATCHING(CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=37) THEN BEGIN
 ST='SPA_PROFILES';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,DML_DATETIME,NAME_PROFILE from SPA_PROFILES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:TIMESTAMP_1,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_PROFILES (CODE_PROFILE,DML_DATETIME,NAME_PROFILE)
   VALUES (:INTEGER_1,:TIMESTAMP_1,:VARCHAR70_1 )
   MATCHING(CODE_PROFILE);
   NU=1;
 END
END ELSE

IF (TID=38) THEN BEGIN
 ST='SPA_ACCESS_SECURITY';
 FOR EXECUTE STATEMENT ('select CODE_OBJECT,CODE_PROFILE,ACCESS_FLAG,DML_DATETIME from SPA_ACCESS_SECURITY where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_SECURITY (CODE_OBJECT,CODE_PROFILE,ACCESS_FLAG,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=39) THEN BEGIN
 ST='SPA_ACCESS_ACTIONS';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,CODE_ACTION,DML_DATETIME from SPA_ACCESS_ACTIONS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_ACTIONS (CODE_PROFILE,CODE_ACTION,DML_DATETIME)
   VALUES (:INTEGER_1,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,CODE_ACTION);
   NU=1;
 END
END ELSE

IF (TID=40) THEN BEGIN
 ST='SPA_ACCESS_OBJECTS';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,CODE_OBJECT,TYPE_OBJECT,DML_DATETIME from SPA_ACCESS_OBJECTS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_OBJECTS (CODE_PROFILE,CODE_OBJECT,TYPE_OBJECT,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,TYPE_OBJECT,CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=41) THEN BEGIN
 ST='SPA_USER_CASHDESKS';
 FOR EXECUTE STATEMENT ('select CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER,DML_DATETIME from SPA_USER_CASHDESKS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_USER_CASHDESKS (CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1 )
   MATCHING(CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER);
   NU=1;
 END
END ELSE

IF (TID=42) THEN BEGIN
 ST='SPA_EVENTS_AUDIT';
 FOR EXECUTE STATEMENT ('select FLAG_AUDIT,EVENT_ID,DML_DATETIME,DATE_AUDIT,EVENT_NAME from SPA_EVENTS_AUDIT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_EVENTS_AUDIT (FLAG_AUDIT,EVENT_ID,DML_DATETIME,DATE_AUDIT,EVENT_NAME)
   VALUES (:CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR70_1 )
   MATCHING (EVENT_ID);
   NU=1;
 END
END ELSE

IF (TID=43) THEN BEGIN
 ST='SPA_INSPECTOR';
 FOR EXECUTE STATEMENT ('select CODE_INSPECTOR,SIGN_ACTIVITY,TYPE_INSPECTOR,DML_DATETIME,NAME_INSPECTOR,PARAMS from SPA_INSPECTOR where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:VARCHAR100_1,:VARCHAR500_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_INSPECTOR (CODE_INSPECTOR,SIGN_ACTIVITY,TYPE_INSPECTOR,DML_DATETIME,NAME_INSPECTOR,PARAMS)
   VALUES (:INTEGER_1,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:VARCHAR100_1,:VARCHAR500_1 )
   MATCHING (CODE_INSPECTOR);
   NU=1;
 END
END ELSE

IF (TID=44) THEN BEGIN
 ST='CREDIT_CARD';
 FOR EXECUTE STATEMENT ('select CODE_CREDIT_CARD,SIGN_ACTIVITY,DML_DATETIME,NAME_CREDIT_CARD from CREDIT_CARD where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO CREDIT_CARD (CODE_CREDIT_CARD,SIGN_ACTIVITY,DML_DATETIME,NAME_CREDIT_CARD)
   VALUES (:INTEGER_1,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 )
   MATCHING (CODE_CREDIT_CARD);
   NU=1;
 END
END ELSE

IF (TID=45) THEN BEGIN
 ST='DEALER';
 FOR EXECUTE STATEMENT ('select CODE_DEALER,CODE_SUBGROUP,CODE_CURRENCY,EXPORT_CD,PRINT,REPORT,PRINT_LABEL_PRICE,INS_DEFAULT,DML_DATETIME,ABR_DEALER,NAME_DEALER,SUM_DEALER,MARKUP from DEALER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR1_4,:CHAR1_5,:TIMESTAMP_1,:VARCHAR8_1,:VARCHAR70_1,:NUMERIC152_1,:NUMERIC82_1 
 DO BEGIN
   UPDATE OR INSERT INTO DEALER (CODE_DEALER,CODE_SUBGROUP,CODE_CURRENCY,EXPORT_CD,PRINT,REPORT,PRINT_LABEL_PRICE,INS_DEFAULT,DML_DATETIME,ABR_DEALER,NAME_DEALER,SUM_DEALER,MARKUP)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR1_4,:CHAR1_5,:TIMESTAMP_1,:VARCHAR8_1,:VARCHAR70_1,:NUMERIC152_1,:NUMERIC82_1 )
   MATCHING (CODE_DEALER,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=46) THEN BEGIN
 ST='HOT_KEY_RESERVE';
 FOR EXECUTE STATEMENT ('select ID_MENU,CODE_SHOP,DML_DATETIME,HOT_KEY,MENU_NAME from HOT_KEY_RESERVE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR255_1 
 DO BEGIN
   UPDATE OR INSERT INTO HOT_KEY_RESERVE (ID_MENU,CODE_SHOP,DML_DATETIME,HOT_KEY,MENU_NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR255_1 )
   MATCHING (ID_MENU,CODE_SHOP);
   NU=1;
 END
END ELSE

IF (TID=47) THEN BEGIN
 ST='SHOP_DEPARTMENT_WORKPLACE';
 FOR EXECUTE STATEMENT ('select ID_WORKPLACE,CODE_DEPARTMENT,CODE_SHOP,ACCESSIBLE,DML_DATETIME from SHOP_DEPARTMENT_WORKPLACE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DEPARTMENT_WORKPLACE (ID_WORKPLACE,CODE_DEPARTMENT,CODE_SHOP,ACCESSIBLE,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 )
   MATCHING (ID_WORKPLACE,CODE_DEPARTMENT);
   NU=1;
 END
END ELSE

IF (TID=48) THEN BEGIN
 ST='DISCOUNT_CARD_FOR_TIME';
 FOR EXECUTE STATEMENT ('select RECORD_ID,CODE_DISCOUNT_CARD,CODE_SUBGROUP,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME from DISCOUNT_CARD_FOR_TIME where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CARD_FOR_TIME (RECORD_ID,CODE_DISCOUNT_CARD,CODE_SUBGROUP,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 )
   MATCHING (RECORD_ID);
   NU=1;
 END
END



----------------------------------------------------------------------------

IF (NU=1) THEN BEGIN
  ex_param=ex_param+1;
  NUD=NULL;
  EXECUTE STATEMENT 'SELECT MAX(DML_DATETIME) FROM '||ST
  ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
  INTO :NUD;
  IF (NUD IS NULL) THEN NUD=CAST('01.01.1980' AS TIMESTAMP);
  TIM=tickcount()-TIM;
  UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,:NUD,:TIM)
  MATCHING (TABLE_ID);

END


TID=TID+1;
END--===КІНЕЦЬ ЦИКЛУ===if (CURRENT_TABLE_ID<49)
--=====
--ЗАМУТИМ ЩЕ ОДИН ЕТАП - передачі документів та звітів на головну базу
--=======
TIM=tickcount(); TID=101;
--Cassa Operation
FOR SELECT                                               --KASSA_ID
       co.code_operation,rcr.number_cash_register, co.number_operation,co.date_operation,co.code_reason,co.code_privat,rcr.code_company,co.code_cash_register,co.type_operation,co.summa,(p.surname || ' ' || p.name) AS name
FROM cassa_operation co
INNER JOIN register_cash_register rcr ON (co.code_cash_register = rcr.code_register_cash_register)
LEFT JOIN privat p ON (p.code_privat = co.code_privat) WHERE co.status_transfer = '0'
INTO :INTEGER_1, :INTEGER_7,:INTEGER_2,:TIMESTAMP_1,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR1_1,:NUMERIC152_1,:VARCHAR100_1
DO BEGIN
--EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_OPERATION, 1) FROM RDB$DATABASE')
-- ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
-- INTO :IDOCUMENT;

  EXECUTE STATEMENT ('UPDATE OR INSERT INTO CASSA_OPERATION_SERVER (ID_WORKPLACE,NUMBER_OPERATION,DATE_OPERATION,CODE_REASON,CODE_PRIVAT,CODE_FIRM_COMPANY,CODE_WAREHOUSE,CODE_CASH_REGISTER,TYPE_OPERATION,SUMMA,accept_from) VALUES (?,?,?,?,?,?,?,?,?,?,?) MATCHING (ID_WORKPLACE,NUMBER_OPERATION,DATE_OPERATION)') (:INTEGER_7,:INTEGER_2,:TIMESTAMP_1,:INTEGER_3,:INTEGER_4,:INTEGER_5,:WAREHOUSE_ID,:INTEGER_6,:CHAR1_1,:NUMERIC152_1,:VARCHAR100_1 )
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 UPDATE cassa_operation SET status_transfer = '1' WHERE code_operation = :INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=102;
--CASH REGISTER REPORT
FOR SELECT CODE_CASH_REGISTER_REPORT,NUMBER_CASH_REGISTER_REPORT,USER_CHANGE,CODE_FIRM_COMPANY,CODE_WAREHOUSE,DATE_CHANGE,TIME_CASH_REGISTER_REPORT,SUM_CASH_REGISTER_REPORT,SUM_READY_MONEY,SUM_READY_CREDIT,SUM_READY_CARD,RETURN_SUM_CASH,RETURN_SUM_READY_CARD,RETURN_SUM_READY_MONEY,RETURN_SUM_READY_CREDIT,SERVICEINPUT,SERVICEOUTPUT,'Z-звіт №-'||z_zvit_number
FROM CASH_REGISTER_REPORT WHERE STATUS_TRANSFER = '0'
INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4,:NUMERIC152_5,:NUMERIC152_6,:NUMERIC152_7,:NUMERIC152_8,:NUMERIC152_9,:NUMERIC152_10,:VARCHAR255_1
DO BEGIN
 EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_ZREPORT, 1) FROM RDB$DATABASE')
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :iDocument;

 EXECUTE STATEMENT ('UPDATE OR INSERT INTO CASH_REGISTER_REPORT_SERVER(CODE_CASH_REGISTER_REPORT,ID_WORKPLACE,NUMBER_CASH_REGISTER_REPORT,USER_CHANGE,CODE_FIRM_COMPANY,CODE_WAREHOUSE,DATE_CHANGE,TIME_CASH_REGISTER_REPORT,SUM_CASH_REGISTER_REPORT,SUM_READY_MONEY,SUM_READY_CREDIT,SUM_READY_CARD,RETURN_SUM_CASH,RETURN_SUM_READY_CARD,RETURN_SUM_READY_MONEY,RETURN_SUM_READY_CREDIT,SERVICEINPUT,SERVICEOUTPUT,DESCRIPTION) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(ID_WORKPLACE,TIME_CASH_REGISTER_REPORT,NUMBER_CASH_REGISTER_REPORT)')(:iDocument,:KASSA_ID,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4,:NUMERIC152_5,:NUMERIC152_6,:NUMERIC152_7,:NUMERIC152_8,:NUMERIC152_9,:NUMERIC152_10,:VARCHAR255_1)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 FOR SELECT CODE_REC,TAX_GROUP,TAX_SUM,TURNOVER,RETURN_TAX_SUM,RETURN_TURNOVER
     FROM Z_REPORT_TAX_GROUP WHERE (CODE_REPORT = :INTEGER_1)
 INTO :INTEGER_2,:CHAR2_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4
 DO BEGIN
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO Z_REPORT_TAX_GROUP_SERVER (CODE_REPORT,CODE_REC,TAX_GROUP,TAX_SUM,TURNOVER,RETURN_TAX_SUM,RETURN_TURNOVER)VALUES (?,?,?,?,?,?,?) MATCHING(CODE_REPORT,CODE_REC)')(:iDocument,:INTEGER_2,:CHAR2_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
 END

 UPDATE CASH_REGISTER_REPORT SET STATUS_TRANSFER='1' WHERE CODE_CASH_REGISTER_REPORT=:INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=103;
-- ACTION
FOR SELECT PRICE,CODE_ACTION,CODE_FRAGMENT,USER_CHANGE,CODE_DOCUMENT,CODE_WARES,CODE_CLIENT,CODE_UNIT,HANDLE_MODULE,EVENT_ID,DATE_CHANGE,NUMBER_CHECK,NAME_ACTION,SUM_WITH_VAT,QUANTITY
FROM A_ACTION WHERE STATUS_TRANSFER = '0'
INTO :DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR254_1,:NUMERIC152_1,:NUMERIC163_1
DO BEGIN
 EXECUTE STATEMENT ('UPDATE OR INSERT INTO A_ACTION_SERVER (PRICE,CODE_ACTION,CODE_FRAGMENT,USER_CHANGE,CODE_DOCUMENT,CODE_WARES,CODE_CLIENT,CODE_UNIT,HANDLE_MODULE,EVENT_ID,DATE_CHANGE,NUMBER_CHECK,NAME_ACTION,SUM_WITH_VAT,QUANTITY,CODE_FIRM_COMPANY,CODE_WAREHOUSE,ID_WORKPLACE) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(DATE_CHANGE,CODE_ACTION,CODE_FRAGMENT,ID_WORKPLACE)')(:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR254_1,:NUMERIC152_1,:NUMERIC163_1,:COMPANY_ID,:WAREHOUSE_ID,:KASSA_ID)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 UPDATE A_ACTION SET STATUS_TRANSFER = '1'
 WHERE DATE_CHANGE = :TIMESTAMP_1 AND CODE_ACTION = :INTEGER_1 AND CODE_FRAGMENT = :INTEGER_2;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

-------------
TIM=tickcount(); TID=104;
FOR SELECT DISTINCT CALC.CODE_ORDER,CCRC.NUMBER_CASHIER,CCRC.NUMBER_CASH_REGISTER,CCRC.MODEL_CASH_REGISTER,CCRC.NUMBER_RECEIPT,CCRC.DATE_RECEIPT
FROM CALCULATION_CACHE CALC
INNER JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER = CALC.CODE_ORDER)
INNER JOIN CALC_CASH_REGISTER_CACHE CCRC ON (CCRC.CODE_CALCULATION = CALC.CODE_CALCULATION)
WHERE (CALC.CODE_SUBGROUP = :CODE_SUBGROUP_ID)
  AND (CALC.STATUS_TRANSFER = '0')
INTO :INTEGER_1,:VARCHAR30_1,:VARCHAR30_2,:VARCHAR50_1,:VARCHAR30_3,:TIMESTAMP_1
DO BEGIN
 FOR SELECT DATE_ORDER,ID_WORKPLACE,CODE_CLIENT,CODE_ADDITION_SIGN,USER_CHANGE,CODE_END,CODE_DEALER,NUMBER_ORDER,CODE_MANAGER,TYPE_PAYMENT,TYPE_VAT,TYPE_CLIENT,DATE_CHANGE,DESCRIPTION,PER_PP,DISCOUNT
 FROM ORDER_CLIENT_CACHE WHERE CODE_ORDER=:INTEGER_1 AND CODE_END=1
 INTO :DATE_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:INTEGER_9,:CHAR2_1,:CHAR2_2,:CHAR2_3,:TIMESTAMP_2,:VARCHAR250_1,:NUMERIC152_1,:NUMERIC96_1
 DO BEGIN
   iDocument=NULL;
   EXECUTE STATEMENT ('SELECT CODE_DOCUMENT FROM ORDER_CACHE WHERE DATE_TAKE=? AND ID_WORKPLACE=? AND TYPE_PAYMENT=? AND NUMBER_ORDER=? ')(:DATE_1,:INTEGER_2,:CHAR2_1,:INTEGER_8)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
   INTO :iDocument;

   if (iDocument IS NULL) then
   EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_CASH_DOCUMENT, 1) FROM RDB$DATABASE')
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
   INTO :iDocument;

   IF (CHAR2_1='NC')
   THEN BEGIN
              VARCHAR30_4='0000';
              INTEGER_10=0;
        END
   ELSE BEGIN
              VARCHAR30_4='';
              INTEGER_10=NULL;
        END
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO ORDER_CACHE(DATE_TAKE,CODE_DOCUMENT,ID_WORKPLACE,CODE_CLIENT,CODE_WAREHOUSE,CODE_ADDITION_SIGN,USER_CHANGE,CODE_END,CODE_DEALER,NUMBER_ORDER,CODE_MANAGER,CODE_FIRM,CODE_CREDIT_CARD,TYPE_PAYMENT,TYPE_VAT,TYPE_CLIENT,DATE_CHANGE,DESCRIPTION,PER_PP,DISCOUNT,NUMBER_SLIP,NUMBER_CASHIER,NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER)VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT)')(:DATE_1,:iDocument,:INTEGER_2,:INTEGER_3,:WAREHOUSE_ID,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:INTEGER_9,:COMPANY_ID,:INTEGER_10,:CHAR2_1,:CHAR2_2,:CHAR2_3,:TIMESTAMP_2,:VARCHAR250_1,:NUMERIC152_1,:NUMERIC96_1,:VARCHAR30_4,:VARCHAR30_1,:VARCHAR30_2,:VARCHAR50_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

   FOR SELECT PRICE,PRICE_CATALOG,CODE_WARES,CODE_UNIT,ADD_GROUPING,DEALER_PRICEPROP,DISCOUNT,QUANTITY,VAT,PRICE_SCHEMA
   FROM WARES_ORDER_CACHE WHERE CODE_ORDER=:INTEGER_1
   INTO :DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:INTEGER_2,:INTEGER_3,:INTEGER_4,CHAR1_1,:DOUBLEPRECISION_3,:NUMERIC163_1,:NUMERIC74_1,:VARCHAR255_1
   DO BEGIN
     EXECUTE STATEMENT('UPDATE OR INSERT INTO WARES_ORDER_CACHE (PRICE,PRICE_CATALOG,CODE_DOCUMENT,CODE_WARES,CODE_UNIT,ADD_GROUPING,DEALER_PRICEPROP,DISCOUNT_WARES,QUANTITY,VAT,PRICE_SCHEMA,STATE_PAY,DATE_RECEIPT,NUMBER_RECEIPT) VALUES(?,?,?,?,?,?,?,?,?,?,?,2,?,?) MATCHING(CODE_DOCUMENT,CODE_WARES,CODE_UNIT)')(:DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,CAST(:DOUBLEPRECISION_3 AS NUMERIC(7,4)),:NUMERIC163_1,:NUMERIC74_1,:VARCHAR255_1,:TIMESTAMP_1,:VARCHAR30_3)
     ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
   END

   UPDATE CALCULATION_CACHE SET STATUS_TRANSFER='1' WHERE CODE_ORDER = :INTEGER_1;
   doc_count=doc_count+1;
 END

END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=105;
--return:
FOR SELECT
RC.CODE_RETURN,RC.ID_WORKPLACE,RC.CODE_WAREHOUSE,RC.CODE_ADDITION_SIGN,RC.CODE_FIRM,RC.USER_CHANGE,
RC.TYPE_VAT,RC.TYPE_PAYMENT,
RC.NUMBER_CHECK,RR.NUMBER_RECEIPT,
RR.NUMBER_CASHIER,RR.NUMBER_CASH_REGISTER,RR.MODEL_CASH_REGISTER,
--RC.MODEL_CASH_REGISTER_SALE,
RC.NUMBER_CASH_REGISTER_SALE,
CAST(RC.DATE_CHECK AS DATE),CAST(RR.DATE_RECEIPT AS DATE),
RC.DESCRIPTION
FROM RETURN_CACHE RC
INNER JOIN RETURN_REGISTER_CACHE RR ON (RC.CODE_RETURN=RR.CODE_RETURN)
WHERE RC.STATUS_TRANSFER='0'
INTO
:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,
:CHAR2_1,:CHAR2_2,
:INTEGER_7,:VARCHAR30_1,
:VARCHAR30_2,:VARCHAR30_3,:VARCHAR50_1,
--:VARCHAR30_3,
:VARCHAR30_4,
:TIMESTAMP_1,:TIMESTAMP_2,
:VARCHAR250_1
DO BEGIN
 EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_CASH_DOCUMENT, 1) FROM RDB$DATABASE')
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :iDocument;

 SELECT FIRST 1 OC.CODE_CLIENT, OC.PRIORITY
 FROM WARES_RETURN_CACHE WR
 LEFT JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER=WR.CODE_ORDER)
 WHERE WR.CODE_RETURN=:INTEGER_1
 INTO :INTEGER_8,:INTEGER_9;

 CHAR2_3='13';--sale fp model
 EXECUTE STATEMENT ('UPDATE OR INSERT INTO RETURN_CACHE(
 CODE_CLIENT,
 CODE_DOCUMENT,ID_WORKPLACE,CODE_WAREHOUSE,CODE_ADDITION_SIGN,CODE_FIRM,
 USER_CHANGE,TYPE_VAT,TYPE_PAYMENT,NUMBER_RECEIPT,NUMBER_RECEIPT_RET,
 NUMBER_CASHIER,NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER,MODEL_CASH_REGISTER_SALE,NUMBER_CASH_REGISTER_SALE,
 DATE_RECEIPT,DATE_RECEIPT_RET,DESCRIPTION) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT)')(
 :INTEGER_8,
 :iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,
 :INTEGER_6,:CHAR2_1,:CHAR2_2,CAST(:INTEGER_7 AS VARCHAR(30)),cast(:VARCHAR250_1 as VARCHAR(30)),
 :VARCHAR30_2,:VARCHAR30_3,:VARCHAR50_1,:CHAR2_3,:VARCHAR30_4,
 :TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR250_1)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 FOR SELECT WR.PRICE,WR.CODE_WARES,WR.CODE_UNIT,WR.ADD_GROUPING,WR.QUANTITY,WR.VAT,WR.CODE_ORDER,oc.code_client
     FROM WARES_RETURN_CACHE WR
     LEFT JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER=WR.CODE_ORDER)
     WHERE CODE_RETURN=:INTEGER_1
 INTO :DOUBLEPRECISION_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:NUMERIC163_1,:NUMERIC74_1,:INTEGER_5,:INTEGER_6
 DO BEGIN
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO WARES_RETURN_CACHE(PRICE,CODE_DOCUMENT,CODE_WARES,CODE_UNIT,ADD_GROUPING,QUANTITY,VAT)VALUES (?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT,CODE_WARES)')(:DOUBLEPRECISION_1,:iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,-:NUMERIC163_1,:NUMERIC74_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
 END


 UPDATE RETURN_CACHE SET STATUS_TRANSFER='1' WHERE CODE_RETURN = :INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,current_timestamp,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=106;
--send SQL ERRORs
FOR SELECT WORKPLACE_ID,TIMEZ,SQL_ERROR FROM SQL_ERROR_LOG WHERE STATUS_TRANSFER='0'
 INTO :INTEGER_1,:TIMESTAMP_1,:VARCHAR1024_1
 AS CURSOR TEMP_CURSOR
DO BEGIN
   EXECUTE STATEMENT ('INSERT INTO SQL_ERROR_LOG(TIMEZ,WORKPLACE_ID,SQL_ERROR)VALUES(?,?,?)')(:TIMESTAMP_1,:INTEGER_1,:VARCHAR1024_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

   UPDATE SQL_ERROR_LOG SET STATUS_TRANSFER='1' WHERE CURRENT OF TEMP_CURSOR;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,current_timestamp,:TIM) MATCHING (TABLE_ID);

FOR SELECT DML_DATETIME,TABLE_ID,TIMEELAPSED FROM KASSA_UPDATE_LOGZ
INTO :TIMESTAMP_1,:INTEGER_1,:INTEGER_2
DO BEGIN
  EXECUTE STATEMENT ('UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TIMEELAPSED,DML_DATETIME,TABLE_ID,KASSA_ID) VALUES(?,?,?,?)')(:INTEGER_2,:TIMESTAMP_1,:INTEGER_1,:KASSA_ID)
  ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
END

  SUSPEND;
END

*/
END^


ALTER PROCEDURE REFRESH_QUALITY_CHECK (
    TP_CONNECT_STRING VARCHAR(255))
RETURNS (
    CODE_WAREZ INTEGER,
    PRICE_TP DOUBLE PRECISION,
    PRICE_LOCAL DOUBLE PRECISION,
    PRICE_TP_TIMESTAMP TIMESTAMP,
    CODE_UNITZ INTEGER)
AS
begin
  /*TP_CONNECT_STRING='10.127.8.10/3050:d:\spruttp\servertp\server\server.gdb';*/
  /* Procedure Text */
  FOR EXECUTE STATEMENT ('select w.code_wares,pd.price_dealer,pd.dml_datetime from wares w left join price_dealer pd on (CODE_DEALER=823 AND CODE_SUBGROUP=36 and w.code_wares=pd.code_wares) where w.o_wares=''No''')
      ON EXTERNAL DATA SOURCE :TP_CONNECT_STRING AS USER 'SYSDBA' PASSWORD 'masterkey'
      INTO :CODE_WAREZ,:PRICE_TP,:PRICE_TP_TIMESTAMP
  DO BEGIN
      SELECT PD.PRICE_DEALER FROM PRICE_DEALER PD WHERE PD.CODE_WARES=:CODE_WAREZ AND PD.CODE_DEALER=823 AND PD.CODE_SUBGROUP=36
      INTO :PRICE_LOCAL;
      if (:PRICE_LOCAL>:PRICE_TP)
      then PRICE_LOCAL=:PRICE_LOCAL-:PRICE_TP;
      else PRICE_LOCAL=:PRICE_TP-:PRICE_LOCAL;
      if (:PRICE_LOCAL>0.001) then SUSPEND;
  END

  FOR EXECUTE STATEMENT ('SELECT A.code_wares,a.code_unit,a.dml_datetime FROM ADDITION_UNIT A')
      ON EXTERNAL DATA SOURCE :TP_CONNECT_STRING AS USER 'SYSDBA' PASSWORD 'masterkey'
      INTO :CODE_WAREZ,CODE_UNITZ,:PRICE_TP_TIMESTAMP
  DO BEGIN
      if (not(exists( SELECT 1 FROM ADDITION_UNIT A WHERE A.CODE_WARES=:CODE_WAREZ AND A.code_unit=:code_unitz))) then begin
        suspend;
      end
  END

END^


ALTER PROCEDURE REFRESH_SERVICE (
    PASS_SERVER_TP VARCHAR(10),
    USER_SERVER_TP VARCHAR(10),
    SERVER_TP VARCHAR(255),
    KASSA_ID INTEGER)
RETURNS (
    EX_PARAM INTEGER,
    DOC_COUNT INTEGER,
    OMSG VARCHAR(1024))
AS
declare variable NUD timestamp;
declare variable TID integer;
declare variable ID1 integer;
declare variable NU integer;
declare variable ST varchar(40);
declare variable IDOCUMENT integer;
declare variable CHAR1_1 char(1);
declare variable CHAR1_2 char(1);
declare variable CHAR1_3 char(1);
declare variable CHAR1_4 char(1);
declare variable CHAR1_5 char(1);
declare variable CHAR2_1 char(2);
declare variable CHAR2_2 char(2);
declare variable CHAR2_3 char(2);
declare variable CHAR2_4 char(2);
declare variable CHAR2_5 char(2);
declare variable CHAR2_6 char(2);
declare variable CHAR2_7 char(2);
declare variable CHAR2_8 char(2);
declare variable CHAR2_9 char(2);
declare variable CHAR4_1 char(4);
declare variable CHAR5_1 char(5);
declare variable CHAR5_2 char(5);
declare variable DATE_1 date;
declare variable DATE_2 date;
declare variable DATE_3 date;
declare variable DATE_4 date;
declare variable DOUBLEPRECISION_1 double precision;
declare variable DOUBLEPRECISION_2 double precision;
declare variable DOUBLEPRECISION_3 double precision;
declare variable INTEGER_1 integer;
declare variable INTEGER_2 integer;
declare variable INTEGER_3 integer;
declare variable INTEGER_4 integer;
declare variable INTEGER_5 integer;
declare variable INTEGER_6 integer;
declare variable INTEGER_7 integer;
declare variable INTEGER_8 integer;
declare variable INTEGER_9 integer;
declare variable INTEGER_10 integer;
declare variable NUMERIC152_1 numeric(15,2);
declare variable NUMERIC152_2 numeric(15,2);
declare variable NUMERIC152_3 numeric(15,2);
declare variable NUMERIC152_4 numeric(15,2);
declare variable NUMERIC152_5 numeric(15,2);
declare variable NUMERIC152_6 numeric(15,2);
declare variable NUMERIC152_7 numeric(15,2);
declare variable NUMERIC152_8 numeric(15,2);
declare variable NUMERIC152_9 numeric(15,2);
declare variable NUMERIC152_10 numeric(15,2);
declare variable NUMERIC153_1 numeric(15,3);
declare variable NUMERIC163_1 numeric(16,3);
declare variable NUMERIC163_2 numeric(16,3);
declare variable NUMERIC163_3 numeric(16,3);
declare variable NUMERIC163_4 numeric(16,3);
declare variable NUMERIC166_1 numeric(16,6);
declare variable NUMERIC174_1 numeric(17,4);
declare variable NUMERIC174_2 numeric(17,4);
declare variable NUMERIC174_3 numeric(17,4);
declare variable NUMERIC52_1 numeric(5,2);
declare variable NUMERIC52_2 numeric(5,2);
declare variable NUMERIC74_1 numeric(7,4);
declare variable NUMERIC82_1 numeric(8,2);
declare variable NUMERIC96_1 numeric(9,6);
declare variable TIMESTAMP_1 timestamp;
declare variable TIMESTAMP_2 timestamp;
declare variable TIMESTAMP_3 timestamp;
declare variable VARCHAR10_1 varchar(10);
declare variable VARCHAR100_1 varchar(100);
declare variable VARCHAR100_2 varchar(100);
declare variable VARCHAR120_1 varchar(120);
declare variable VARCHAR128_1 varchar(128);
declare variable VARCHAR15_1 varchar(15);
declare variable VARCHAR20_1 varchar(20);
declare variable VARCHAR20_2 varchar(20);
declare variable VARCHAR20_3 varchar(20);
declare variable VARCHAR250_1 varchar(250);
declare variable VARCHAR254_1 varchar(254);
declare variable VARCHAR255_1 varchar(255);
declare variable VARCHAR255_2 varchar(255);
declare variable VARCHAR256_1 varchar(256);
declare variable VARCHAR30_1 varchar(30);
declare variable VARCHAR30_2 varchar(30);
declare variable VARCHAR30_3 varchar(30);
declare variable VARCHAR30_4 varchar(30);
declare variable VARCHAR4_1 varchar(4);
declare variable VARCHAR40_1 varchar(40);
declare variable VARCHAR40_2 varchar(40);
declare variable VARCHAR50_1 varchar(50);
declare variable VARCHAR50_2 varchar(50);
declare variable VARCHAR50_3 varchar(50);
declare variable VARCHAR50_4 varchar(50);
declare variable VARCHAR500_1 varchar(500);
declare variable VARCHAR1024_1 varchar(1024);
declare variable VARCHAR70_1 varchar(70);
declare variable VARCHAR70_2 varchar(70);
declare variable VARCHAR70_3 varchar(70);
declare variable VARCHAR70_4 varchar(70);
declare variable VARCHAR70_5 varchar(70);
declare variable VARCHAR8_1 varchar(8);
declare variable WAREHOUSE_ID integer;
declare variable COMPANY_ID integer;
declare variable CODE_SUBGROUP_ID integer;
declare variable TIM integer;
declare variable CODE_DEALER_ROZ integer;
BEGIN

IF (KASSA_ID IS NULL) THEN BEGIN
  SELECT ID_WORKPLACE FROM CURRENT_INIT WHERE code_init=1 INTO :KASSA_ID;
  IF (KASSA_ID IS NULL) THEN EXIT;
END

  omsg = 'Отримано ідентифікатор каси: ' || :KASSA_ID;
  suspend;

  IF (SERVER_TP IS NULL) THEN SERVER_TP='192.168.133.55/3050:/BASE/TP.GDB';
  IF (USER_SERVER_TP IS NULL) THEN USER_SERVER_TP='SYSDBA';
  IF (PASS_SERVER_TP IS NULL) THEN PASS_SERVER_TP='masterkey';

  SELECT a.WAREHOUSE_PROBLEM_INVOICE, a.COMPANY_PROBLEM_INVOICE, a.CODE_SUBGROUP,a.code_dealer_roz
      FROM attrib a
        WHERE code_attrib = 1
    INTO :WAREHOUSE_ID, :COMPANY_ID, :CODE_SUBGROUP_ID,:CODE_DEALER_ROZ;

  ex_param=0;
  doc_count=0;
  TID=1;

  while (tid<49) do
  begin --===початок циклу===
    nu=0;
    nud=null;
    select dml_datetime from kassa_update_logz where table_id=:tid into :nud;
    if (nud is null) then nud=cast('01.01.1979' as timestamp);
   -- tim=tickcount();

    if (tid=1) then
    begin
        omsg = '-коди ділимих товарів';
        suspend;

        st='wares_with_fractional_unit';
        for execute statement ('select code_wares,dml_datetime from wares_with_fractional_unit where dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:timestamp_1
        do begin
            update or insert into wares_with_fractional_unit (code_wares,dml_datetime)
                values (:integer_1,:timestamp_1 )
              matching (code_wares);
        nu=1;
        end
    end else
    if (tid=2) then
    begin
        omsg = '-товари';   suspend;
        st='wares';
        for execute statement ('select data_wares,code_wares,code_group,code_unit,code_wares_relative,code_brand,vat_operation,excise,dml_datetime,o_wares,old_articl,articl_wares_brand,articl,touch_code,name_wares_receipt,marking_all_are_assembled,name_wares_brand,name_wares,min_quantity,min_rest,sign_1,sign_2,sign_3,vat,excise_tax from wares where dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char2_1,:char2_2,:timestamp_1,:varchar4_1,:varchar15_1,:varchar30_1,:varchar30_2,:varchar30_3,:varchar50_1,:varchar50_2,:varchar100_1,:varchar100_2,:numeric163_1,:numeric163_2,:numeric174_1,:numeric174_2,:numeric174_3,:numeric52_1,:numeric52_2
        do begin
            update or insert into wares (data_wares,code_wares,code_group,code_unit,code_wares_relative,code_brand,vat_operation,excise,dml_datetime,o_wares,old_articl,articl_wares_brand,articl,touch_code,name_wares_receipt,marking_all_are_assembled,name_wares_brand,name_wares,min_quantity,min_rest,sign_1,sign_2,sign_3,vat,excise_tax)
                values (:date_1,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:char2_1,:char2_2,:timestamp_1,:varchar4_1,:varchar15_1,:varchar30_1,:varchar30_2,:varchar30_3,:varchar50_1,:varchar50_2,:varchar100_1,:varchar100_2,:numeric163_1,:numeric163_2,:numeric174_1,:numeric174_2,:numeric174_3,:numeric52_1,:numeric52_2 )
              matching (code_wares);
            nu=1;
        end
    end else
    if (tid=3) then
    begin
        omsg = '-одиниці виміру';   suspend;
        st='addition_unit';
        for execute statement ('select r.code_wares,r.code_unit from refresh_delete_log r where r.table_id=3 and r.dml_datetime>?')
                     (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2
        do begin
            delete from addition_unit a where a.code_wares=:integer_1 and a.code_unit=:integer_2;
            nu=1;
            for execute statement ('select code_wares,code_unit,default_unit,report_unit,sign_activity,check_find_bar_code,sign_locking,dml_datetime,bar_code,description,coefficient,height,lengt_,weight,width from addition_unit where dml_datetime>?')
                         (:nud)
                on external data source :server_tp as user 'sysdba' password 'masterkey'
              into :integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char1_4,:char1_5,:timestamp_1,:varchar30_1,:varchar255_1,:numeric166_1,:numeric163_1,:numeric163_2,:numeric163_3,:numeric163_4
            do begin
                if (:char1_2='Y') then
                    update addition_unit set default_unit='N' where code_wares=:integer_1 and default_unit='Y';

                update or insert into addition_unit (code_wares,code_unit,default_unit,report_unit,sign_activity,check_find_bar_code,sign_locking,dml_datetime,bar_code,description,coefficient,height,lengt_,weight,width)
                    values (:integer_1,:integer_2,:char1_1,:char1_2,:char1_3,:char1_4,:char1_5,:timestamp_1,:varchar30_1,:varchar255_1,:numeric166_1,:numeric163_1,:numeric163_2,:numeric163_3,:numeric163_4 )
                  matching (code_wares,code_unit);
                nu=1;
            end
        end
    end else
    if (tid=4) then
    begin
        omsg = '-ціни товарів';   suspend;
        st='price_dealer';
        for execute statement ('select r.code_wares,r.code_dealer,r.code_subgroup from refresh_delete_log r where r.table_id=2 and r.dml_datetime>?')
                      (:nud)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :integer_1,:integer_2,:integer_3
        do begin
            delete from price_dealer p where p.code_wares=:integer_1 and p.code_dealer=:integer_2 and p.code_subgroup=:integer_3;
            nu=1;
        end
        for execute statement ('select fixed_end_date,indicative_begin_date,indicative_end_date,fixed_begin_date,price_dealer,indicative_min_price,indicative_max_price,code_wares,code_dealer,code_subgroup,code_currency,indicative_id,indicative_code_currency,fixed_id,indicative_active,disregard_price_propocition,fixed_price,dml_datetime,markup from price_dealer where dml_datetime>? and code_dealer=?')
                 (:nud,:code_dealer_roz)
            on external data source :server_tp as user 'sysdba' password 'masterkey'
          into :date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char2_1,:char2_2,:char2_3,:timestamp_1,:numeric82_1
        do begin
            update or insert into price_dealer (fixed_end_date,indicative_begin_date,indicative_end_date,fixed_begin_date,price_dealer,indicative_min_price,indicative_max_price,code_wares,code_dealer,code_subgroup,code_currency,indicative_id,indicative_code_currency,fixed_id,indicative_active,disregard_price_propocition,fixed_price,dml_datetime,markup)
                values (:date_1,:date_2,:date_3,:date_4,:doubleprecision_1,:doubleprecision_2,:doubleprecision_3,:integer_1,:integer_2,:integer_3,:integer_4,:integer_5,:integer_6,:integer_7,:char2_1,:char2_2,:char2_3,:timestamp_1,:numeric82_1 )
            matching(code_wares,code_dealer);

           nu=1;
        end
    end --else
  end

  omsg = 'Передача розмірностей';
  suspend;
  omsg = 'Касса -> ТП';
  suspend;
  omsg = 'Передача чеків';
  suspend;
  omsg = 'Касса -> ТП';
  suspend;
  omsg = 'Передача документів';
  suspend;
/*
--   INSERT INTO spa_users_test (code_sposuser,user_name,sign_activity,date_begin,date_end,code_privat,pswd,code_profile,code_shop,code_subgroup)
--   select code_sposuser,user_name,sign_activity,date_begin,date_end,code_privat,pswd,code_profile,code_shop,code_subgroup from spa_users;
--for
--EXECUTE STATEMENT 'select CURRENT_TRANSACTION from RDB$DATABASE'








IF (TID=5) THEN BEGIN
 ST='PRICE_PROPOCITION';
--select r.table_id,r.code_wares,r.code_unit,r.code_price_propocition,r.code_subgroup,r.code_dealer from refresh_delete_log r where r.dml_datetime>?
 FOR EXECUTE STATEMENT ('select r.code_price_propocition from refresh_delete_log r where r.table_id=1 and r.dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1
 DO BEGIN
   DELETE FROM PRICE_PROPOCITION P WHERE P.code_price_propocition=:INTEGER_1;
   NU=1;
 END
 FOR EXECUTE STATEMENT ('select FIXED_BEGIN_DATE,FIXED_END_DATE,INDICATIVE_BEGIN_DATE,INDICATIVE_END_DATE,INDICATIVE_MIN_PRICE,INDICATIVE_MAX_PRICE,PRICE_PROPOCITION,CODE_PRICE_PROPOCITION,CODE_WARES,CODE_SUBGROUP,CAT_SPECPROPOSITION_ID,INDICATIVE_ID,INDICATIVE_CODE_CURRENCY,CODE_CURRENCY,FIXED_ID,INDICATIVE_ACTIVE,FIXED_PRICE,DML_DATETIME,CUBIC,MARKUP from PRICE_PROPOCITION where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DATE_2,:DATE_3,:DATE_4,:DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:DOUBLEPRECISION_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:NUMERIC153_1,:NUMERIC82_1 
 DO BEGIN
   UPDATE OR INSERT INTO PRICE_PROPOCITION (FIXED_BEGIN_DATE,FIXED_END_DATE,INDICATIVE_BEGIN_DATE,INDICATIVE_END_DATE,INDICATIVE_MIN_PRICE,INDICATIVE_MAX_PRICE,PRICE_PROPOCITION,CODE_PRICE_PROPOCITION,CODE_WARES,CODE_SUBGROUP,CAT_SPECPROPOSITION_ID,INDICATIVE_ID,INDICATIVE_CODE_CURRENCY,CODE_CURRENCY,FIXED_ID,INDICATIVE_ACTIVE,FIXED_PRICE,DML_DATETIME,CUBIC,MARKUP)
   VALUES (:DATE_1,:DATE_2,:DATE_3,:DATE_4,:DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:DOUBLEPRECISION_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:NUMERIC153_1,:NUMERIC82_1 )
   MATCHING(CODE_PRICE_PROPOCITION);
   NU=1;
 END
END ELSE

IF (TID=6) THEN BEGIN
 ST='SHOP_DEPARTMENT_WARES';
 FOR EXECUTE STATEMENT ('select WEIGHT_TARE,CODE_WARES,CODE_DEPARTMENT,NUMBER_WARES_SCALE,NUMBER_TARE,SHELF_LIFE,CONST_SHELF_LIFE,CODE_SHOP,SEND_TO_SCALE,LABEL_FORMAT,DML_DATETIME from SHOP_DEPARTMENT_WARES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:CHAR1_1,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DEPARTMENT_WARES (WEIGHT_TARE,CODE_WARES,CODE_DEPARTMENT,NUMBER_WARES_SCALE,NUMBER_TARE,SHELF_LIFE,CONST_SHELF_LIFE,CODE_SHOP,SEND_TO_SCALE,LABEL_FORMAT,DML_DATETIME)
   VALUES (:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:CHAR1_1,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_WARES,CODE_DEPARTMENT);
   NU=1;
 END
END ELSE

IF (TID=7) THEN BEGIN
 ST='WARES_PARAMETERS_SUBGROUP';
 FOR EXECUTE STATEMENT ('select CODE_WARES,CODE_SUBGROUP,ALLOW_FOR,DML_DATETIME,MIN_PERCENT_MARKUP,BARRIER_RECALCULATION_PRICE from WARES_PARAMETERS_SUBGROUP where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC52_1,:NUMERIC52_2 
 DO BEGIN
   UPDATE OR INSERT INTO WARES_PARAMETERS_SUBGROUP (CODE_WARES,CODE_SUBGROUP,ALLOW_FOR,DML_DATETIME,MIN_PERCENT_MARKUP,BARRIER_RECALCULATION_PRICE)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC52_1,:NUMERIC52_2) MATCHING (CODE_WARES);
   NU=1;
 END
END ELSE

IF (TID=8) THEN BEGIN
 ST='SHOP_PRICE_SUPPLIER';
 FOR EXECUTE STATEMENT ('select PRICE,CODE_WARES,CODE_SUPPLIER,CODE_SHOP,CODE_CURRENCY,NUMBER_INVOICE,DML_DATETIME,DATE_INVOICE,DATE_CHANGE,QUANTITY from SHOP_PRICE_SUPPLIER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:TIMESTAMP_3,:NUMERIC163_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_PRICE_SUPPLIER (PRICE,CODE_WARES,CODE_SUPPLIER,CODE_SHOP,CODE_CURRENCY,NUMBER_INVOICE,DML_DATETIME,DATE_INVOICE,DATE_CHANGE,QUANTITY)
   VALUES (:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:TIMESTAMP_3,:NUMERIC163_1 )
   MATCHING(CODE_WARES,CODE_SUPPLIER);
   NU=1;
 END
END ELSE

IF (TID=9) THEN BEGIN
 ST='SHOP_SPECPROPOSITION_TIME';
 FOR EXECUTE STATEMENT ('select SHOP_SPECPROPOSITION_TIME_ID,CODE_SHOP,CAT_SPECPROPOSITION_ID,DAY_BEGIN,DAY_END,TIME_END,TIME_BEGIN,DML_DATETIME from SHOP_SPECPROPOSITION_TIME where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_SPECPROPOSITION_TIME (SHOP_SPECPROPOSITION_TIME_ID,CODE_SHOP,CAT_SPECPROPOSITION_ID,DAY_BEGIN,DAY_END,TIME_END,TIME_BEGIN,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 )
   MATCHING(SHOP_SPECPROPOSITION_TIME_ID);
   NU=1;
 END
END ELSE

IF (TID=10) THEN BEGIN
 ST='PRIVAT';
 FOR EXECUTE STATEMENT ('select DATE_ANIMATION_BAR_CODE,BAR_CODE,CODE_PRIVAT,CODE_CURRENCY_ACCOUNT,CODE_CITY,SIGN_ACTIVITY,FLAG_CHECK,TAX_PAYER_VAT,DML_DATETIME,INDEX_MAIL,IMPOCITION,WORK_PHONE,AGREE_NUMBER,HOUSE_PHONE,SURNAME,NAME,MAIL,PATRONYMIC,ADDRESS,DOCUMENT,NAME_FOR_PRINT from PRIVAT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:TIMESTAMP_1,:VARCHAR10_1,:VARCHAR15_1,:VARCHAR20_1,:VARCHAR20_2,:VARCHAR20_3,:VARCHAR70_1,:VARCHAR70_2,:VARCHAR70_3,:VARCHAR70_4,:VARCHAR70_5,:VARCHAR120_1,:VARCHAR250_1 
 DO BEGIN
   UPDATE OR INSERT INTO PRIVAT (DATE_ANIMATION_BAR_CODE,BAR_CODE,CODE_PRIVAT,CODE_CURRENCY_ACCOUNT,CODE_CITY,SIGN_ACTIVITY,FLAG_CHECK,TAX_PAYER_VAT,DML_DATETIME,INDEX_MAIL,IMPOCITION,WORK_PHONE,AGREE_NUMBER,HOUSE_PHONE,SURNAME,NAME,MAIL,PATRONYMIC,ADDRESS,DOCUMENT,NAME_FOR_PRINT)
   VALUES (:DATE_1,:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:TIMESTAMP_1,:VARCHAR10_1,:VARCHAR15_1,:VARCHAR20_1,:VARCHAR20_2,:VARCHAR20_3,:VARCHAR70_1,:VARCHAR70_2,:VARCHAR70_3,:VARCHAR70_4,:VARCHAR70_5,:VARCHAR120_1,:VARCHAR250_1 )
   MATCHING(CODE_PRIVAT);
   NU=1;
 END
END ELSE

IF (TID=11) THEN BEGIN
 ST='CONCERN_P_CLIENT';
 FOR EXECUTE STATEMENT ('select CODE_CONCERN,CODE_PRIVAT,CODE_SUBGROUP,SIGN_ACTIVITY,DML_DATETIME from CONCERN_P_CLIENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO CONCERN_P_CLIENT (CODE_CONCERN,CODE_PRIVAT,CODE_SUBGROUP,SIGN_ACTIVITY,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 )
   MATCHING(CODE_PRIVAT,CODE_CONCERN);
   NU=1;
 END
END ELSE

IF (TID=12) THEN BEGIN
 ST='P_CLIENT';
 FOR EXECUTE STATEMENT ('select CODE_PRIVAT,CODE_SUBGROUP,CODE_DISCOUNT_CARD,CODE_CURRENCY,CODE_TRIDE_REGION,CODE_DEALER,MAX_END_PAYMENT,SIGN_ACTIVITY,RECALC_ORDER,CONTROL_MIN_PERCENT,RECALC_COURSE,VARIANT_PAYMENT,PRICE_NOTLESS_SPRICE,MIN_PRICE_SPRICE,NOT_SPRICE,CHECK_SPEC_DISCOUNT,DISCOUNT_POSITION,DML_DATETIME,ID_CLIENT,MAX_DEBT,PER_PP,DISCOUNT from P_CLIENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:CHAR1_1,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:CHAR2_7,:CHAR2_8,:CHAR2_9,:TIMESTAMP_1,:VARCHAR30_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC96_1 
 DO BEGIN
   UPDATE OR INSERT INTO P_CLIENT (CODE_PRIVAT,CODE_SUBGROUP,CODE_DISCOUNT_CARD,CODE_CURRENCY,CODE_TRIDE_REGION,CODE_DEALER,MAX_END_PAYMENT,SIGN_ACTIVITY,RECALC_ORDER,CONTROL_MIN_PERCENT,RECALC_COURSE,VARIANT_PAYMENT,PRICE_NOTLESS_SPRICE,MIN_PRICE_SPRICE,NOT_SPRICE,CHECK_SPEC_DISCOUNT,DISCOUNT_POSITION,DML_DATETIME,ID_CLIENT,MAX_DEBT,PER_PP,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:CHAR1_1,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:CHAR2_7,:CHAR2_8,:CHAR2_9,:TIMESTAMP_1,:VARCHAR30_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC96_1 )
   MATCHING(CODE_PRIVAT,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=13) THEN BEGIN
 ST='DISCOUNT_CLIENT_OF_BRAND';
 FOR EXECUTE STATEMENT ('select CODE_BRAND,CODE_CLIENT,CODE_SUBGROUP,TYPE_CLIENT,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT from DISCOUNT_CLIENT_OF_BRAND where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:NUMERIC52_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CLIENT_OF_BRAND (CODE_BRAND,CODE_CLIENT,CODE_SUBGROUP,TYPE_CLIENT,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:NUMERIC52_1 )
   MATCHING(CODE_CLIENT,CODE_BRAND,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=14) THEN BEGIN
 ST='DISCOUNT_CLIENT_OF_GROUP';
 FOR EXECUTE STATEMENT ('select CODE_CLIENT,CODE_SUBGROUP,CODE_GROUP,SIGN_ACTIVITY,TYPE_CLIENT,DML_DATETIME,DISCOUNT from DISCOUNT_CLIENT_OF_GROUP where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:NUMERIC52_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CLIENT_OF_GROUP (CODE_CLIENT,CODE_SUBGROUP,CODE_GROUP,SIGN_ACTIVITY,TYPE_CLIENT,DML_DATETIME,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:NUMERIC52_1 )
   MATCHING(CODE_CLIENT,CODE_GROUP,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=15) THEN BEGIN
 ST='FIRMS';
 FOR EXECUTE STATEMENT ('select DATE_ANIMATION_BAR_CODE,BAR_CODE,CODE_FIRM,CODE_CURRENCY_ACCOUNT,CODE_CITY,CODE_PARENT_FIRM,CODE_BANK,TAX_PAYER_VAT,SIGN_ACTIVITY,FLAG_CHECK,DML_DATETIME,INDEX_MAIL,IMPOCITION,AGREE_NUMBER,CODE_ZIP,ACCOUNT,CURRENCY_ACCOUNT,MAIL,PHONE,FAX,TELEX,NAME,ADDRESS,ADDRESS_LOCATION,NAME_FOR_PRINT from FIRMS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:CHAR1_2,:CHAR1_3,:TIMESTAMP_1,:VARCHAR10_1,:VARCHAR15_1,:VARCHAR20_1,:VARCHAR20_2,:VARCHAR40_1,:VARCHAR40_2,:VARCHAR50_1,:VARCHAR50_2,:VARCHAR50_3,:VARCHAR50_4,:VARCHAR70_1,:VARCHAR70_2,:VARCHAR70_3,:VARCHAR250_1 
 DO BEGIN
   DELETE FROM FIRMS WHERE (NAME=:VARCHAR70_1)AND(CODE_FIRM<>:INTEGER_1);

   ID1=NULL;
   FOR SELECT CODE_FIRM FROM FIRMS WHERE CODE_FIRM=:INTEGER_1
   INTO :ID1
   AS CURSOR TMPCURSOR
   DO
   UPDATE FIRMS SET
   DATE_ANIMATION_BAR_CODE=:DATE_1,
   BAR_CODE=:DOUBLEPRECISION_1,
   CODE_CURRENCY_ACCOUNT=:INTEGER_2,
   CODE_CITY=:INTEGER_3,
   CODE_PARENT_FIRM=:INTEGER_4,
   CODE_BANK=:INTEGER_5,
   TAX_PAYER_VAT=:CHAR1_1,
   SIGN_ACTIVITY=:CHAR1_2,
   FLAG_CHECK=:CHAR1_3,
   DML_DATETIME=:TIMESTAMP_1,
   INDEX_MAIL=:VARCHAR10_1,
   IMPOCITION=:VARCHAR15_1,
   AGREE_NUMBER=:VARCHAR20_1,
   CODE_ZIP=:VARCHAR20_2,
   ACCOUNT=:VARCHAR40_1,
   CURRENCY_ACCOUNT=:VARCHAR40_2,
   MAIL=:VARCHAR50_1,
   PHONE=:VARCHAR50_2,
   FAX=:VARCHAR50_3,
   TELEX=:VARCHAR50_4,
   NAME=:VARCHAR70_1,
   ADDRESS=:VARCHAR70_2,
   ADDRESS_LOCATION=:VARCHAR70_3,
   NAME_FOR_PRINT=:VARCHAR250_1
   WHERE CURRENT OF TMPCURSOR;

  IF (ID1 IS NULL) THEN
   INSERT INTO FIRMS (DATE_ANIMATION_BAR_CODE,BAR_CODE,CODE_FIRM,CODE_CURRENCY_ACCOUNT,CODE_CITY,CODE_PARENT_FIRM,CODE_BANK,TAX_PAYER_VAT,SIGN_ACTIVITY,FLAG_CHECK,DML_DATETIME,INDEX_MAIL,IMPOCITION,AGREE_NUMBER,CODE_ZIP,ACCOUNT,CURRENCY_ACCOUNT,MAIL,PHONE,FAX,TELEX,NAME,ADDRESS,ADDRESS_LOCATION,NAME_FOR_PRINT)
   VALUES (:DATE_1,:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:CHAR1_2,:CHAR1_3,:TIMESTAMP_1,:VARCHAR10_1,:VARCHAR15_1,:VARCHAR20_1,:VARCHAR20_2,:VARCHAR40_1,:VARCHAR40_2,:VARCHAR50_1,:VARCHAR50_2,:VARCHAR50_3,:VARCHAR50_4,:VARCHAR70_1,:VARCHAR70_2,:VARCHAR70_3,:VARCHAR250_1 );

   NU=1;
 END
END ELSE

IF (TID=16) THEN BEGIN
 ST='CONCERN_F_CLIENT';
 FOR EXECUTE STATEMENT ('select CODE_SUBGROUP,CODE_CONCERN,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME from CONCERN_F_CLIENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO CONCERN_F_CLIENT (CODE_SUBGROUP,CODE_CONCERN,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 )
   MATCHING(CODE_FIRM,CODE_CONCERN);
   NU=1;
 END
END ELSE

IF (TID=17) THEN BEGIN
 ST='F_CLIENT';
 FOR EXECUTE STATEMENT ('select CODE_FIRM,CODE_SUBGROUP,CODE_CURRENCY,CODE_DISCOUNT_CARD,CODE_TRIDE_REGION,CODE_DEALER,MAX_END_PAYMENT,CODE_PRIVAT,SIGN_ACTIVITY,CHECK_SPEC_DISCOUNT,NOT_SPRICE,RECALC_ORDER,DISCOUNT_POSITION,RECALC_COURSE,CONTROL_MIN_PERCENT,VARIANT_PAYMENT,PRICE_NOTLESS_SPRICE,MIN_PRICE_SPRICE,DML_DATETIME,ID_CLIENT,MAX_DEBT,PER_PP,DISCOUNT from F_CLIENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR1_1,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:CHAR2_7,:CHAR2_8,:CHAR2_9,:TIMESTAMP_1,:VARCHAR30_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC96_1 
 DO BEGIN
   UPDATE OR INSERT INTO F_CLIENT (CODE_FIRM,CODE_SUBGROUP,CODE_CURRENCY,CODE_DISCOUNT_CARD,CODE_TRIDE_REGION,CODE_DEALER,MAX_END_PAYMENT,CODE_PRIVAT,SIGN_ACTIVITY,CHECK_SPEC_DISCOUNT,NOT_SPRICE,RECALC_ORDER,DISCOUNT_POSITION,RECALC_COURSE,CONTROL_MIN_PERCENT,VARIANT_PAYMENT,PRICE_NOTLESS_SPRICE,MIN_PRICE_SPRICE,DML_DATETIME,ID_CLIENT,MAX_DEBT,PER_PP,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR1_1,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:CHAR2_7,:CHAR2_8,:CHAR2_9,:TIMESTAMP_1,:VARCHAR30_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC96_1 )
   MATCHING(CODE_FIRM,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=18) THEN BEGIN
 ST='ACCOUNT_CLIENT';
 FOR EXECUTE STATEMENT ('select ACCOUNT_CASH,ACCOUNT_REUSABLE_CONTAINER,ACCOUNT,CODE_CLIENT,CODE_CURRENCY,CODE_FIRM_COMPANY,TYPE_CLIENT,DML_DATETIME from ACCOUNT_CLIENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:DOUBLEPRECISION_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO ACCOUNT_CLIENT (ACCOUNT_CASH,ACCOUNT_REUSABLE_CONTAINER,ACCOUNT,CODE_CLIENT,CODE_CURRENCY,CODE_FIRM_COMPANY,TYPE_CLIENT,DML_DATETIME)
   VALUES (:DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:DOUBLEPRECISION_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_CLIENT,CODE_CURRENCY,CODE_FIRM_COMPANY);
   NU=1;
 END
END ELSE

IF (TID=19) THEN BEGIN
 ST='SHOP_DEALER';
 FOR EXECUTE STATEMENT ('select CODE_SHOP,CODE_DEALER,ID_LEVEL,DISCOUNT,SHOP_DEALER_PRINT_SECOND,DML_DATETIME from SHOP_DEALER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DEALER (CODE_SHOP,CODE_DEALER,ID_LEVEL,DISCOUNT,SHOP_DEALER_PRINT_SECOND,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1 )
   MATCHING(CODE_SHOP,CODE_DEALER);
   NU=1;
 END
END ELSE

IF (TID=20) THEN BEGIN
 ST='ADDITION_SIGN';
 FOR EXECUTE STATEMENT ('select CODE_ADDITION_SIGN,SIGN_ACTIVITY,PART_ADDITION_SIGN,DML_DATETIME,NAME,DESCRIPTION from ADDITION_SIGN where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR256_1 
 DO BEGIN
   UPDATE OR INSERT INTO ADDITION_SIGN (CODE_ADDITION_SIGN,SIGN_ACTIVITY,PART_ADDITION_SIGN,DML_DATETIME,NAME,DESCRIPTION)
   VALUES (:INTEGER_1,:CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR256_1 )
   MATCHING(CODE_ADDITION_SIGN);
   NU=1;
 END
END ELSE

IF (TID=21) THEN BEGIN
 ST='UNIT_DIMENSION';
 FOR EXECUTE STATEMENT ('select CODE_UNIT,CODE_WARES_REUSABLE_CONTAINER,SIGN_ACTIVITY,SIGN_DIVISIONAL,REUSABLE_CONTAINER,ABR_UNIT,DML_DATETIME,NAME_UNIT,DESCRIPTION from UNIT_DIMENSION where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR4_1,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR250_1 
 DO BEGIN
   UPDATE OR INSERT INTO UNIT_DIMENSION (CODE_UNIT,CODE_WARES_REUSABLE_CONTAINER,SIGN_ACTIVITY,SIGN_DIVISIONAL,REUSABLE_CONTAINER,ABR_UNIT,DML_DATETIME,NAME_UNIT,DESCRIPTION)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR4_1,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR250_1 )
   MATCHING(CODE_UNIT);
   NU=1;
 END
END ELSE

IF (TID=22) THEN BEGIN
 ST='GROUP_WARES';
 FOR EXECUTE STATEMENT ('select CODE_GROUP_WARES,CODE_PARENT_GROUP_WARES,SIGN_ACTIVITY,DML_DATETIME,NIK_NAME_GROUP_WARES,NAME from GROUP_WARES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO GROUP_WARES (CODE_GROUP_WARES,CODE_PARENT_GROUP_WARES,SIGN_ACTIVITY,DML_DATETIME,NIK_NAME_GROUP_WARES,NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR70_1 )
   MATCHING(CODE_GROUP_WARES);
   NU=1;
 END
END ELSE

IF (TID=23) THEN BEGIN
 ST='CHOSEN_GROUP_WARES';
 FOR EXECUTE STATEMENT ('select CODE_GROUP,CODE_PARENT_GROUP,USER_CHANGE,TYPE_CHOICE,DML_DATETIME,DATE_CHANGE from CHOSEN_GROUP_WARES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2 
 DO BEGIN
   UPDATE OR INSERT INTO CHOSEN_GROUP_WARES (CODE_GROUP,CODE_PARENT_GROUP,USER_CHANGE,TYPE_CHOICE,DML_DATETIME,DATE_CHANGE)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2 )
   MATCHING(CODE_GROUP,TYPE_CHOICE);
   NU=1;
 END
END ELSE

IF (TID=24) THEN BEGIN
 ST='DEPARTMENT';
 FOR EXECUTE STATEMENT ('select CODE_DEPARTMENT,CODE_SUBGROUP,NUMBER_DEPARTMENT,SIGN_ACTIVITY,DML_DATETIME,NAME_DEPARTMENT from DEPARTMENT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO DEPARTMENT (CODE_DEPARTMENT,CODE_SUBGROUP,NUMBER_DEPARTMENT,SIGN_ACTIVITY,DML_DATETIME,NAME_DEPARTMENT)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 )
   MATCHING(CODE_DEPARTMENT);
   NU=1;
 END
END ELSE

IF (TID=25) THEN BEGIN
 ST='CONTRACT';
 FOR EXECUTE STATEMENT ('select DATE_CONTRACT,DATE_END_CONTRACT,DATE_COUNT_ALL,CODE_CONTRACT,NUMBER_CONTRACT,PRIORITY,CODE_CLIENT,CODE_ADDITION_SIGN,CODE_SUBGROUP,SIGN_ACTIVITY,TYPE_PAYMENT,TYPE_CLIENT,TYPE_CONTRACT,STATE_CONTRACT,FIX_PRICE,DML_DATETIME from CONTRACT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DATE_2,:DATE_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO CONTRACT (DATE_CONTRACT,DATE_END_CONTRACT,DATE_COUNT_ALL,CODE_CONTRACT,NUMBER_CONTRACT,PRIORITY,CODE_CLIENT,CODE_ADDITION_SIGN,CODE_SUBGROUP,SIGN_ACTIVITY,TYPE_PAYMENT,TYPE_CLIENT,TYPE_CONTRACT,STATE_CONTRACT,FIX_PRICE,DML_DATETIME)
   VALUES (:DATE_1,:DATE_2,:DATE_3,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR2_1,:CHAR2_2,:CHAR2_3,:CHAR2_4,:CHAR2_5,:CHAR2_6,:TIMESTAMP_1 )
   MATCHING(CODE_CONTRACT);
   NU=1;
 END
END ELSE

IF (TID=26) THEN BEGIN
 ST='SHOP_CLIENT_FROM_SUM_ORDER';
 FOR EXECUTE STATEMENT ('select CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,CODE_PRIVAT,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME,SUM_ORDER from SHOP_CLIENT_FROM_SUM_ORDER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:TIMESTAMP_1,:NUMERIC152_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_CLIENT_FROM_SUM_ORDER (CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,CODE_PRIVAT,CODE_FIRM,SIGN_ACTIVITY,DML_DATETIME,SUM_ORDER)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:TIMESTAMP_1,:NUMERIC152_1 )
   MATCHING(CODE_SHOP,CODE_CLIENT);
   NU=1;
 END
END ELSE

IF (TID=27) THEN BEGIN
 ST='SHOP_CLIENT_FOR_FRONTOFFICE';
 FOR EXECUTE STATEMENT ('select SHOP_CLIENT_FOR_FRONTOFFICE_ID,CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,DAY_END,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME from SHOP_CLIENT_FOR_FRONTOFFICE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_CLIENT_FOR_FRONTOFFICE (SHOP_CLIENT_FOR_FRONTOFFICE_ID,CODE_SHOP,CODE_CLIENT,CODE_SUBGROUP,DAY_END,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 )
   MATCHING(SHOP_CLIENT_FOR_FRONTOFFICE_ID);
   NU=1;
 END
END ELSE

IF (TID=28) THEN BEGIN
 ST='SHOP_DISCOUNT';
 FOR EXECUTE STATEMENT ('select CODE_DISCOUNT,CODE_SHOP,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT from SHOP_DISCOUNT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC74_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DISCOUNT (CODE_DISCOUNT,CODE_SHOP,SIGN_ACTIVITY,DML_DATETIME,DISCOUNT)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:NUMERIC74_1 )
   MATCHING(CODE_DISCOUNT);
   NU=1;
 END
END ELSE

IF (TID=29) THEN BEGIN
 ST='MANAGER';
 FOR EXECUTE STATEMENT ('select CODE_TRIDE_REGION,CODE_PRIVAT,SIGN_ACTIVITY,DML_DATETIME,CODE_MANAGER from MANAGER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1 
 DO BEGIN
   UPDATE OR INSERT INTO MANAGER (CODE_TRIDE_REGION,CODE_PRIVAT,SIGN_ACTIVITY,DML_DATETIME,CODE_MANAGER)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR30_1 )
   MATCHING(CODE_TRIDE_REGION,CODE_PRIVAT);
   NU=1;
 END
END ELSE

IF (TID=30) THEN BEGIN
 ST='V_SPA_EVENTS_MONITOR';
 FOR EXECUTE STATEMENT ('select CODE_SHOP,CODE_COMPLIANCE,PRIORITY,CODE_INSPECTOR,EVENT_ID,DML_DATETIME,INSPECTOR_EVENT_ID,ADDITION_PARAMS,INSPECTOR_EVENT_NAME from V_SPA_EVENTS_MONITOR where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR2_1,:TIMESTAMP_1,:VARCHAR15_1,:VARCHAR255_1,:VARCHAR255_2 
 DO BEGIN
   UPDATE OR INSERT INTO V_SPA_EVENTS_MONITOR (CODE_SHOP,CODE_COMPLIANCE,PRIORITY,CODE_INSPECTOR,EVENT_ID,DML_DATETIME,INSPECTOR_EVENT_ID,ADDITION_PARAMS,INSPECTOR_EVENT_NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR2_1,:TIMESTAMP_1,:VARCHAR15_1,:VARCHAR255_1,:VARCHAR255_2 )
   MATCHING(CODE_COMPLIANCE,CODE_SHOP);
   NU=1;
 END
END ELSE

IF (TID=31) THEN BEGIN
 ST='DISCOUNT_CARD';
 FOR EXECUTE STATEMENT ('select CODE_DISCOUNT_CARD,PERIOD_OF_VALIDITY,CODE_SUBGROUP,CODE_DISCOUNT_CARD_GROUP,SIGN_ACTIVITY,FIXED_DISCOUNT,DML_DATETIME,NAME_DISCOUNT_CARD,SUM_DISCOUNT_CARD,PERCENT_DISCOUNT_CARD from DISCOUNT_CARD where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:VARCHAR50_1,:NUMERIC152_1,:NUMERIC52_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CARD (CODE_DISCOUNT_CARD,PERIOD_OF_VALIDITY,CODE_SUBGROUP,CODE_DISCOUNT_CARD_GROUP,SIGN_ACTIVITY,FIXED_DISCOUNT,DML_DATETIME,NAME_DISCOUNT_CARD,SUM_DISCOUNT_CARD,PERCENT_DISCOUNT_CARD)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,:CHAR1_2,:TIMESTAMP_1,:VARCHAR50_1,:NUMERIC152_1,:NUMERIC52_1 )
   MATCHING(CODE_DISCOUNT_CARD);
   NU=1;
 END
END ELSE

IF (TID=32) THEN BEGIN
 ST='CITY';
 FOR EXECUTE STATEMENT ('select CODE_CITY,CODE_REGION,CODE_COUNTRY,DML_DATETIME,NAME_CITY,PHONE_CODE from CITY where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR70_2 
 DO BEGIN
   UPDATE OR INSERT INTO CITY (CODE_CITY,CODE_REGION,CODE_COUNTRY,DML_DATETIME,NAME_CITY,PHONE_CODE)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:TIMESTAMP_1,:VARCHAR70_1,:VARCHAR70_2 )
   MATCHING(CODE_CITY);
   NU=1;
 END
END ELSE

IF (TID=33) THEN BEGIN
 ST='OPTS_ITEM_VALUES';
 FOR EXECUTE STATEMENT ('select CODE_SUBJECT,CODE_ITEM,DML_DATETIME,VALUE1 from OPTS_ITEM_VALUES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR254_1 
 DO BEGIN
   UPDATE OR INSERT INTO OPTS_ITEM_VALUES (CODE_SUBJECT,CODE_ITEM,DML_DATETIME,VALUE1)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR254_1 )
   MATCHING(CODE_SUBJECT,CODE_ITEM);
   NU=1;
 END
END ELSE

IF (TID=34) THEN BEGIN
 ST='REGISTER_CASH_REGISTER';
 FOR EXECUTE STATEMENT ('select CODE_REGISTER_CASH_REGISTER,CODE_SUBGROUP,CODE_COMPANY,NUMBER_CASH_REGISTER,DML_DATETIME,SERIAL_NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER from REGISTER_CASH_REGISTER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR50_2 
 DO BEGIN
   UPDATE OR INSERT INTO REGISTER_CASH_REGISTER (CODE_REGISTER_CASH_REGISTER,CODE_SUBGROUP,CODE_COMPANY,NUMBER_CASH_REGISTER,DML_DATETIME,SERIAL_NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR50_2 )
   MATCHING(CODE_REGISTER_CASH_REGISTER);
   NU=1;
 END
END ELSE

IF (TID=35) THEN BEGIN
 ST='SPA_USERS';
 FOR EXECUTE STATEMENT ('select DATE_BEGIN,DATE_END,CODE_SHOP,CODE_SPOSUSER,CODE_PRIVAT,CODE_SUBGROUP,CODE_PROFILE,SIGN_ACTIVITY,USER_NAME,PSWD from SPA_USERS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :DATE_1,:DATE_2,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:VARCHAR30_1,:VARCHAR128_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_USERS (DATE_BEGIN,DATE_END,CODE_SHOP,CODE_SPOSUSER,CODE_PRIVAT,CODE_SUBGROUP,CODE_PROFILE,SIGN_ACTIVITY,USER_NAME,PSWD)
   VALUES (:DATE_1,:DATE_2,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:CHAR1_1,:VARCHAR30_1,:VARCHAR128_1 )
   MATCHING(CODE_SPOSUSER);
   NU=1;
 END
END ELSE

IF (TID=36) THEN BEGIN
 ST='SPA_SECURITY_LIST';
 FOR EXECUTE STATEMENT ('select CODE_OBJECT,CODE_PARENT_OBJECT,TYPE_OBJECT,DML_DATETIME,REAL_NAME_OBJECT,NAME_OBJECT from SPA_SECURITY_LIST where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_SECURITY_LIST (CODE_OBJECT,CODE_PARENT_OBJECT,TYPE_OBJECT,DML_DATETIME,REAL_NAME_OBJECT,NAME_OBJECT)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR1_1,:TIMESTAMP_1,:VARCHAR50_1,:VARCHAR100_1 )
   MATCHING(CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=37) THEN BEGIN
 ST='SPA_PROFILES';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,DML_DATETIME,NAME_PROFILE from SPA_PROFILES where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:TIMESTAMP_1,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_PROFILES (CODE_PROFILE,DML_DATETIME,NAME_PROFILE)
   VALUES (:INTEGER_1,:TIMESTAMP_1,:VARCHAR70_1 )
   MATCHING(CODE_PROFILE);
   NU=1;
 END
END ELSE

IF (TID=38) THEN BEGIN
 ST='SPA_ACCESS_SECURITY';
 FOR EXECUTE STATEMENT ('select CODE_OBJECT,CODE_PROFILE,ACCESS_FLAG,DML_DATETIME from SPA_ACCESS_SECURITY where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_SECURITY (CODE_OBJECT,CODE_PROFILE,ACCESS_FLAG,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=39) THEN BEGIN
 ST='SPA_ACCESS_ACTIONS';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,CODE_ACTION,DML_DATETIME from SPA_ACCESS_ACTIONS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_ACTIONS (CODE_PROFILE,CODE_ACTION,DML_DATETIME)
   VALUES (:INTEGER_1,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,CODE_ACTION);
   NU=1;
 END
END ELSE

IF (TID=40) THEN BEGIN
 ST='SPA_ACCESS_OBJECTS';
 FOR EXECUTE STATEMENT ('select CODE_PROFILE,CODE_OBJECT,TYPE_OBJECT,DML_DATETIME from SPA_ACCESS_OBJECTS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_ACCESS_OBJECTS (CODE_PROFILE,CODE_OBJECT,TYPE_OBJECT,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:CHAR2_1,:TIMESTAMP_1 )
   MATCHING(CODE_PROFILE,TYPE_OBJECT,CODE_OBJECT);
   NU=1;
 END
END ELSE

IF (TID=41) THEN BEGIN
 ST='SPA_USER_CASHDESKS';
 FOR EXECUTE STATEMENT ('select CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER,DML_DATETIME from SPA_USER_CASHDESKS where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_USER_CASHDESKS (CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1 )
   MATCHING(CODE_SPOSUSER,CODE_REGISTER_CASH_REGISTER);
   NU=1;
 END
END ELSE

IF (TID=42) THEN BEGIN
 ST='SPA_EVENTS_AUDIT';
 FOR EXECUTE STATEMENT ('select FLAG_AUDIT,EVENT_ID,DML_DATETIME,DATE_AUDIT,EVENT_NAME from SPA_EVENTS_AUDIT where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR70_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_EVENTS_AUDIT (FLAG_AUDIT,EVENT_ID,DML_DATETIME,DATE_AUDIT,EVENT_NAME)
   VALUES (:CHAR1_1,:CHAR2_1,:TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR70_1 )
   MATCHING (EVENT_ID);
   NU=1;
 END
END ELSE

IF (TID=43) THEN BEGIN
 ST='SPA_INSPECTOR';
 FOR EXECUTE STATEMENT ('select CODE_INSPECTOR,SIGN_ACTIVITY,TYPE_INSPECTOR,DML_DATETIME,NAME_INSPECTOR,PARAMS from SPA_INSPECTOR where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:VARCHAR100_1,:VARCHAR500_1 
 DO BEGIN
   UPDATE OR INSERT INTO SPA_INSPECTOR (CODE_INSPECTOR,SIGN_ACTIVITY,TYPE_INSPECTOR,DML_DATETIME,NAME_INSPECTOR,PARAMS)
   VALUES (:INTEGER_1,:CHAR2_1,:CHAR2_2,:TIMESTAMP_1,:VARCHAR100_1,:VARCHAR500_1 )
   MATCHING (CODE_INSPECTOR);
   NU=1;
 END
END ELSE

IF (TID=44) THEN BEGIN
 ST='CREDIT_CARD';
 FOR EXECUTE STATEMENT ('select CODE_CREDIT_CARD,SIGN_ACTIVITY,DML_DATETIME,NAME_CREDIT_CARD from CREDIT_CARD where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 
 DO BEGIN
   UPDATE OR INSERT INTO CREDIT_CARD (CODE_CREDIT_CARD,SIGN_ACTIVITY,DML_DATETIME,NAME_CREDIT_CARD)
   VALUES (:INTEGER_1,:CHAR1_1,:TIMESTAMP_1,:VARCHAR100_1 )
   MATCHING (CODE_CREDIT_CARD);
   NU=1;
 END
END ELSE

IF (TID=45) THEN BEGIN
 ST='DEALER';
 FOR EXECUTE STATEMENT ('select CODE_DEALER,CODE_SUBGROUP,CODE_CURRENCY,EXPORT_CD,PRINT,REPORT,PRINT_LABEL_PRICE,INS_DEFAULT,DML_DATETIME,ABR_DEALER,NAME_DEALER,SUM_DEALER,MARKUP from DEALER where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR1_4,:CHAR1_5,:TIMESTAMP_1,:VARCHAR8_1,:VARCHAR70_1,:NUMERIC152_1,:NUMERIC82_1 
 DO BEGIN
   UPDATE OR INSERT INTO DEALER (CODE_DEALER,CODE_SUBGROUP,CODE_CURRENCY,EXPORT_CD,PRINT,REPORT,PRINT_LABEL_PRICE,INS_DEFAULT,DML_DATETIME,ABR_DEALER,NAME_DEALER,SUM_DEALER,MARKUP)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR1_2,:CHAR1_3,:CHAR1_4,:CHAR1_5,:TIMESTAMP_1,:VARCHAR8_1,:VARCHAR70_1,:NUMERIC152_1,:NUMERIC82_1 )
   MATCHING (CODE_DEALER,CODE_SUBGROUP);
   NU=1;
 END
END ELSE

IF (TID=46) THEN BEGIN
 ST='HOT_KEY_RESERVE';
 FOR EXECUTE STATEMENT ('select ID_MENU,CODE_SHOP,DML_DATETIME,HOT_KEY,MENU_NAME from HOT_KEY_RESERVE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR255_1 
 DO BEGIN
   UPDATE OR INSERT INTO HOT_KEY_RESERVE (ID_MENU,CODE_SHOP,DML_DATETIME,HOT_KEY,MENU_NAME)
   VALUES (:INTEGER_1,:INTEGER_2,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR255_1 )
   MATCHING (ID_MENU,CODE_SHOP);
   NU=1;
 END
END ELSE

IF (TID=47) THEN BEGIN
 ST='SHOP_DEPARTMENT_WORKPLACE';
 FOR EXECUTE STATEMENT ('select ID_WORKPLACE,CODE_DEPARTMENT,CODE_SHOP,ACCESSIBLE,DML_DATETIME from SHOP_DEPARTMENT_WORKPLACE where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO SHOP_DEPARTMENT_WORKPLACE (ID_WORKPLACE,CODE_DEPARTMENT,CODE_SHOP,ACCESSIBLE,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:TIMESTAMP_1 )
   MATCHING (ID_WORKPLACE,CODE_DEPARTMENT);
   NU=1;
 END
END ELSE

IF (TID=48) THEN BEGIN
 ST='DISCOUNT_CARD_FOR_TIME';
 FOR EXECUTE STATEMENT ('select RECORD_ID,CODE_DISCOUNT_CARD,CODE_SUBGROUP,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME from DISCOUNT_CARD_FOR_TIME where dml_datetime>?') (:NUD)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 
 DO BEGIN
   UPDATE OR INSERT INTO DISCOUNT_CARD_FOR_TIME (RECORD_ID,CODE_DISCOUNT_CARD,CODE_SUBGROUP,DAY_BEGIN,TIME_BEGIN,TIME_END,DML_DATETIME)
   VALUES (:INTEGER_1,:INTEGER_2,:INTEGER_3,:CHAR1_1,:CHAR5_1,:CHAR5_2,:TIMESTAMP_1 )
   MATCHING (RECORD_ID);
   NU=1;
 END
END



----------------------------------------------------------------------------

IF (NU=1) THEN BEGIN
  ex_param=ex_param+1;
  NUD=NULL;
  EXECUTE STATEMENT 'SELECT MAX(DML_DATETIME) FROM '||ST
  ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
  INTO :NUD;
  IF (NUD IS NULL) THEN NUD=CAST('01.01.1980' AS TIMESTAMP);
  TIM=tickcount()-TIM;
  UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,:NUD,:TIM)
  MATCHING (TABLE_ID);

END


TID=TID+1;
END--===КІНЕЦЬ ЦИКЛУ===if (CURRENT_TABLE_ID<49)
--=====
--ЗАМУТИМ ЩЕ ОДИН ЕТАП - передачі документів та звітів на головну базу
--=======
TIM=tickcount(); TID=101;
--Cassa Operation
FOR SELECT                                               --KASSA_ID
       co.code_operation,rcr.number_cash_register, co.number_operation,co.date_operation,co.code_reason,co.code_privat,rcr.code_company,co.code_cash_register,co.type_operation,co.summa,(p.surname || ' ' || p.name) AS name
FROM cassa_operation co
INNER JOIN register_cash_register rcr ON (co.code_cash_register = rcr.code_register_cash_register)
LEFT JOIN privat p ON (p.code_privat = co.code_privat) WHERE co.status_transfer = '0'
INTO :INTEGER_1, :INTEGER_7,:INTEGER_2,:TIMESTAMP_1,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:CHAR1_1,:NUMERIC152_1,:VARCHAR100_1
DO BEGIN
--EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_OPERATION, 1) FROM RDB$DATABASE')
-- ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
-- INTO :IDOCUMENT;

  EXECUTE STATEMENT ('UPDATE OR INSERT INTO CASSA_OPERATION_SERVER (ID_WORKPLACE,NUMBER_OPERATION,DATE_OPERATION,CODE_REASON,CODE_PRIVAT,CODE_FIRM_COMPANY,CODE_WAREHOUSE,CODE_CASH_REGISTER,TYPE_OPERATION,SUMMA,accept_from) VALUES (?,?,?,?,?,?,?,?,?,?,?) MATCHING (ID_WORKPLACE,NUMBER_OPERATION,DATE_OPERATION)') (:INTEGER_7,:INTEGER_2,:TIMESTAMP_1,:INTEGER_3,:INTEGER_4,:INTEGER_5,:WAREHOUSE_ID,:INTEGER_6,:CHAR1_1,:NUMERIC152_1,:VARCHAR100_1 )
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 UPDATE cassa_operation SET status_transfer = '1' WHERE code_operation = :INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=102;
--CASH REGISTER REPORT
FOR SELECT CODE_CASH_REGISTER_REPORT,NUMBER_CASH_REGISTER_REPORT,USER_CHANGE,CODE_FIRM_COMPANY,CODE_WAREHOUSE,DATE_CHANGE,TIME_CASH_REGISTER_REPORT,SUM_CASH_REGISTER_REPORT,SUM_READY_MONEY,SUM_READY_CREDIT,SUM_READY_CARD,RETURN_SUM_CASH,RETURN_SUM_READY_CARD,RETURN_SUM_READY_MONEY,RETURN_SUM_READY_CREDIT,SERVICEINPUT,SERVICEOUTPUT,'Z-звіт №-'||z_zvit_number
FROM CASH_REGISTER_REPORT WHERE STATUS_TRANSFER = '0'
INTO :INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4,:NUMERIC152_5,:NUMERIC152_6,:NUMERIC152_7,:NUMERIC152_8,:NUMERIC152_9,:NUMERIC152_10,:VARCHAR255_1
DO BEGIN
 EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_ZREPORT, 1) FROM RDB$DATABASE')
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :iDocument;

 EXECUTE STATEMENT ('UPDATE OR INSERT INTO CASH_REGISTER_REPORT_SERVER(CODE_CASH_REGISTER_REPORT,ID_WORKPLACE,NUMBER_CASH_REGISTER_REPORT,USER_CHANGE,CODE_FIRM_COMPANY,CODE_WAREHOUSE,DATE_CHANGE,TIME_CASH_REGISTER_REPORT,SUM_CASH_REGISTER_REPORT,SUM_READY_MONEY,SUM_READY_CREDIT,SUM_READY_CARD,RETURN_SUM_CASH,RETURN_SUM_READY_CARD,RETURN_SUM_READY_MONEY,RETURN_SUM_READY_CREDIT,SERVICEINPUT,SERVICEOUTPUT,DESCRIPTION) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(ID_WORKPLACE,TIME_CASH_REGISTER_REPORT,NUMBER_CASH_REGISTER_REPORT)')(:iDocument,:KASSA_ID,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:TIMESTAMP_1,:TIMESTAMP_2,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4,:NUMERIC152_5,:NUMERIC152_6,:NUMERIC152_7,:NUMERIC152_8,:NUMERIC152_9,:NUMERIC152_10,:VARCHAR255_1)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 FOR SELECT CODE_REC,TAX_GROUP,TAX_SUM,TURNOVER,RETURN_TAX_SUM,RETURN_TURNOVER
     FROM Z_REPORT_TAX_GROUP WHERE (CODE_REPORT = :INTEGER_1)
 INTO :INTEGER_2,:CHAR2_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4
 DO BEGIN
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO Z_REPORT_TAX_GROUP_SERVER (CODE_REPORT,CODE_REC,TAX_GROUP,TAX_SUM,TURNOVER,RETURN_TAX_SUM,RETURN_TURNOVER)VALUES (?,?,?,?,?,?,?) MATCHING(CODE_REPORT,CODE_REC)')(:iDocument,:INTEGER_2,:CHAR2_1,:NUMERIC152_1,:NUMERIC152_2,:NUMERIC152_3,:NUMERIC152_4)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
 END

 UPDATE CASH_REGISTER_REPORT SET STATUS_TRANSFER='1' WHERE CODE_CASH_REGISTER_REPORT=:INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=103;
-- ACTION
FOR SELECT PRICE,CODE_ACTION,CODE_FRAGMENT,USER_CHANGE,CODE_DOCUMENT,CODE_WARES,CODE_CLIENT,CODE_UNIT,HANDLE_MODULE,EVENT_ID,DATE_CHANGE,NUMBER_CHECK,NAME_ACTION,SUM_WITH_VAT,QUANTITY
FROM A_ACTION WHERE STATUS_TRANSFER = '0'
INTO :DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR254_1,:NUMERIC152_1,:NUMERIC163_1
DO BEGIN
 EXECUTE STATEMENT ('UPDATE OR INSERT INTO A_ACTION_SERVER (PRICE,CODE_ACTION,CODE_FRAGMENT,USER_CHANGE,CODE_DOCUMENT,CODE_WARES,CODE_CLIENT,CODE_UNIT,HANDLE_MODULE,EVENT_ID,DATE_CHANGE,NUMBER_CHECK,NAME_ACTION,SUM_WITH_VAT,QUANTITY,CODE_FIRM_COMPANY,CODE_WAREHOUSE,ID_WORKPLACE) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(DATE_CHANGE,CODE_ACTION,CODE_FRAGMENT,ID_WORKPLACE)')(:DOUBLEPRECISION_1,:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:CHAR2_1,:TIMESTAMP_1,:VARCHAR30_1,:VARCHAR254_1,:NUMERIC152_1,:NUMERIC163_1,:COMPANY_ID,:WAREHOUSE_ID,:KASSA_ID)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 UPDATE A_ACTION SET STATUS_TRANSFER = '1'
 WHERE DATE_CHANGE = :TIMESTAMP_1 AND CODE_ACTION = :INTEGER_1 AND CODE_FRAGMENT = :INTEGER_2;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

-------------
TIM=tickcount(); TID=104;
FOR SELECT DISTINCT CALC.CODE_ORDER,CCRC.NUMBER_CASHIER,CCRC.NUMBER_CASH_REGISTER,CCRC.MODEL_CASH_REGISTER,CCRC.NUMBER_RECEIPT,CCRC.DATE_RECEIPT
FROM CALCULATION_CACHE CALC
INNER JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER = CALC.CODE_ORDER)
INNER JOIN CALC_CASH_REGISTER_CACHE CCRC ON (CCRC.CODE_CALCULATION = CALC.CODE_CALCULATION)
WHERE (CALC.CODE_SUBGROUP = :CODE_SUBGROUP_ID)
  AND (CALC.STATUS_TRANSFER = '0')
INTO :INTEGER_1,:VARCHAR30_1,:VARCHAR30_2,:VARCHAR50_1,:VARCHAR30_3,:TIMESTAMP_1
DO BEGIN
 FOR SELECT DATE_ORDER,ID_WORKPLACE,CODE_CLIENT,CODE_ADDITION_SIGN,USER_CHANGE,CODE_END,CODE_DEALER,NUMBER_ORDER,CODE_MANAGER,TYPE_PAYMENT,TYPE_VAT,TYPE_CLIENT,DATE_CHANGE,DESCRIPTION,PER_PP,DISCOUNT
 FROM ORDER_CLIENT_CACHE WHERE CODE_ORDER=:INTEGER_1 AND CODE_END=1
 INTO :DATE_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:INTEGER_9,:CHAR2_1,:CHAR2_2,:CHAR2_3,:TIMESTAMP_2,:VARCHAR250_1,:NUMERIC152_1,:NUMERIC96_1
 DO BEGIN
   iDocument=NULL;
   EXECUTE STATEMENT ('SELECT CODE_DOCUMENT FROM ORDER_CACHE WHERE DATE_TAKE=? AND ID_WORKPLACE=? AND TYPE_PAYMENT=? AND NUMBER_ORDER=? ')(:DATE_1,:INTEGER_2,:CHAR2_1,:INTEGER_8)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
   INTO :iDocument;

   if (iDocument IS NULL) then
   EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_CASH_DOCUMENT, 1) FROM RDB$DATABASE')
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
   INTO :iDocument;

   IF (CHAR2_1='NC')
   THEN BEGIN
              VARCHAR30_4='0000';
              INTEGER_10=0;
        END
   ELSE BEGIN
              VARCHAR30_4='';
              INTEGER_10=NULL;
        END
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO ORDER_CACHE(DATE_TAKE,CODE_DOCUMENT,ID_WORKPLACE,CODE_CLIENT,CODE_WAREHOUSE,CODE_ADDITION_SIGN,USER_CHANGE,CODE_END,CODE_DEALER,NUMBER_ORDER,CODE_MANAGER,CODE_FIRM,CODE_CREDIT_CARD,TYPE_PAYMENT,TYPE_VAT,TYPE_CLIENT,DATE_CHANGE,DESCRIPTION,PER_PP,DISCOUNT,NUMBER_SLIP,NUMBER_CASHIER,NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER)VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT)')(:DATE_1,:iDocument,:INTEGER_2,:INTEGER_3,:WAREHOUSE_ID,:INTEGER_4,:INTEGER_5,:INTEGER_6,:INTEGER_7,:INTEGER_8,:INTEGER_9,:COMPANY_ID,:INTEGER_10,:CHAR2_1,:CHAR2_2,:CHAR2_3,:TIMESTAMP_2,:VARCHAR250_1,:NUMERIC152_1,:NUMERIC96_1,:VARCHAR30_4,:VARCHAR30_1,:VARCHAR30_2,:VARCHAR50_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

   FOR SELECT PRICE,PRICE_CATALOG,CODE_WARES,CODE_UNIT,ADD_GROUPING,DEALER_PRICEPROP,DISCOUNT,QUANTITY,VAT,PRICE_SCHEMA
   FROM WARES_ORDER_CACHE WHERE CODE_ORDER=:INTEGER_1
   INTO :DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:INTEGER_2,:INTEGER_3,:INTEGER_4,CHAR1_1,:DOUBLEPRECISION_3,:NUMERIC163_1,:NUMERIC74_1,:VARCHAR255_1
   DO BEGIN
     EXECUTE STATEMENT('UPDATE OR INSERT INTO WARES_ORDER_CACHE (PRICE,PRICE_CATALOG,CODE_DOCUMENT,CODE_WARES,CODE_UNIT,ADD_GROUPING,DEALER_PRICEPROP,DISCOUNT_WARES,QUANTITY,VAT,PRICE_SCHEMA,STATE_PAY,DATE_RECEIPT,NUMBER_RECEIPT) VALUES(?,?,?,?,?,?,?,?,?,?,?,2,?,?) MATCHING(CODE_DOCUMENT,CODE_WARES,CODE_UNIT)')(:DOUBLEPRECISION_1,:DOUBLEPRECISION_2,:iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,:CHAR1_1,CAST(:DOUBLEPRECISION_3 AS NUMERIC(7,4)),:NUMERIC163_1,:NUMERIC74_1,:VARCHAR255_1,:TIMESTAMP_1,:VARCHAR30_3)
     ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
   END

   UPDATE CALCULATION_CACHE SET STATUS_TRANSFER='1' WHERE CODE_ORDER = :INTEGER_1;
   doc_count=doc_count+1;
 END

END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,CURRENT_TIMESTAMP,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=105;
--return:
FOR SELECT
RC.CODE_RETURN,RC.ID_WORKPLACE,RC.CODE_WAREHOUSE,RC.CODE_ADDITION_SIGN,RC.CODE_FIRM,RC.USER_CHANGE,
RC.TYPE_VAT,RC.TYPE_PAYMENT,
RC.NUMBER_CHECK,RR.NUMBER_RECEIPT,
RR.NUMBER_CASHIER,RR.NUMBER_CASH_REGISTER,RR.MODEL_CASH_REGISTER,
--RC.MODEL_CASH_REGISTER_SALE,
RC.NUMBER_CASH_REGISTER_SALE,
CAST(RC.DATE_CHECK AS DATE),CAST(RR.DATE_RECEIPT AS DATE),
RC.DESCRIPTION
FROM RETURN_CACHE RC
INNER JOIN RETURN_REGISTER_CACHE RR ON (RC.CODE_RETURN=RR.CODE_RETURN)
WHERE RC.STATUS_TRANSFER='0'
INTO
:INTEGER_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,:INTEGER_6,
:CHAR2_1,:CHAR2_2,
:INTEGER_7,:VARCHAR30_1,
:VARCHAR30_2,:VARCHAR30_3,:VARCHAR50_1,
--:VARCHAR30_3,
:VARCHAR30_4,
:TIMESTAMP_1,:TIMESTAMP_2,
:VARCHAR250_1
DO BEGIN
 EXECUTE STATEMENT ('SELECT GEN_ID(GEN_CODE_CASH_DOCUMENT, 1) FROM RDB$DATABASE')
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey'
 INTO :iDocument;

 SELECT FIRST 1 OC.CODE_CLIENT, OC.PRIORITY
 FROM WARES_RETURN_CACHE WR
 LEFT JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER=WR.CODE_ORDER)
 WHERE WR.CODE_RETURN=:INTEGER_1
 INTO :INTEGER_8,:INTEGER_9;

 CHAR2_3='13';--sale fp model
 EXECUTE STATEMENT ('UPDATE OR INSERT INTO RETURN_CACHE(
 CODE_CLIENT,
 CODE_DOCUMENT,ID_WORKPLACE,CODE_WAREHOUSE,CODE_ADDITION_SIGN,CODE_FIRM,
 USER_CHANGE,TYPE_VAT,TYPE_PAYMENT,NUMBER_RECEIPT,NUMBER_RECEIPT_RET,
 NUMBER_CASHIER,NUMBER_CASH_REGISTER,MODEL_CASH_REGISTER,MODEL_CASH_REGISTER_SALE,NUMBER_CASH_REGISTER_SALE,
 DATE_RECEIPT,DATE_RECEIPT_RET,DESCRIPTION) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT)')(
 :INTEGER_8,
 :iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,:INTEGER_5,
 :INTEGER_6,:CHAR2_1,:CHAR2_2,CAST(:INTEGER_7 AS VARCHAR(30)),cast(:VARCHAR250_1 as VARCHAR(30)),
 :VARCHAR30_2,:VARCHAR30_3,:VARCHAR50_1,:CHAR2_3,:VARCHAR30_4,
 :TIMESTAMP_1,:TIMESTAMP_2,:VARCHAR250_1)
 ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

 FOR SELECT WR.PRICE,WR.CODE_WARES,WR.CODE_UNIT,WR.ADD_GROUPING,WR.QUANTITY,WR.VAT,WR.CODE_ORDER,oc.code_client
     FROM WARES_RETURN_CACHE WR
     LEFT JOIN ORDER_CLIENT_CACHE OC ON (OC.CODE_ORDER=WR.CODE_ORDER)
     WHERE CODE_RETURN=:INTEGER_1
 INTO :DOUBLEPRECISION_1,:INTEGER_2,:INTEGER_3,:INTEGER_4,:NUMERIC163_1,:NUMERIC74_1,:INTEGER_5,:INTEGER_6
 DO BEGIN
   EXECUTE STATEMENT ('UPDATE OR INSERT INTO WARES_RETURN_CACHE(PRICE,CODE_DOCUMENT,CODE_WARES,CODE_UNIT,ADD_GROUPING,QUANTITY,VAT)VALUES (?,?,?,?,?,?,?) MATCHING(CODE_DOCUMENT,CODE_WARES)')(:DOUBLEPRECISION_1,:iDocument,:INTEGER_2,:INTEGER_3,:INTEGER_4,-:NUMERIC163_1,:NUMERIC74_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
 END


 UPDATE RETURN_CACHE SET STATUS_TRANSFER='1' WHERE CODE_RETURN = :INTEGER_1;
 doc_count=doc_count+1;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,current_timestamp,:TIM) MATCHING (TABLE_ID);

TIM=tickcount(); TID=106;
--send SQL ERRORs
FOR SELECT WORKPLACE_ID,TIMEZ,SQL_ERROR FROM SQL_ERROR_LOG WHERE STATUS_TRANSFER='0'
 INTO :INTEGER_1,:TIMESTAMP_1,:VARCHAR1024_1
 AS CURSOR TEMP_CURSOR
DO BEGIN
   EXECUTE STATEMENT ('INSERT INTO SQL_ERROR_LOG(TIMEZ,WORKPLACE_ID,SQL_ERROR)VALUES(?,?,?)')(:TIMESTAMP_1,:INTEGER_1,:VARCHAR1024_1)
   ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';

   UPDATE SQL_ERROR_LOG SET STATUS_TRANSFER='1' WHERE CURRENT OF TEMP_CURSOR;
END
TIM=tickcount()-TIM;
UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TABLE_ID,DML_DATETIME,TIMEELAPSED) VALUES (:TID,current_timestamp,:TIM) MATCHING (TABLE_ID);

FOR SELECT DML_DATETIME,TABLE_ID,TIMEELAPSED FROM KASSA_UPDATE_LOGZ
INTO :TIMESTAMP_1,:INTEGER_1,:INTEGER_2
DO BEGIN
  EXECUTE STATEMENT ('UPDATE OR INSERT INTO KASSA_UPDATE_LOGZ (TIMEELAPSED,DML_DATETIME,TABLE_ID,KASSA_ID) VALUES(?,?,?,?)')(:INTEGER_2,:TIMESTAMP_1,:INTEGER_1,:KASSA_ID)
  ON EXTERNAL DATA SOURCE :SERVER_TP AS USER 'SYSDBA' PASSWORD 'masterkey';
END



  SUSPEND;
END

*/
END^


ALTER PROCEDURE SAVEAPPERRORS (
    CHAPPSOURCE INTEGER,
    INTORANUMERROR INTEGER,
    CHORAMSGERROR VARCHAR(254),
    CHMSGERROR VARCHAR(2000),
    INTAPPIDRECORD_1 INTEGER,
    INTAPPIDRECORD_2 INTEGER,
    INTAPPIDRECORD_3 INTEGER,
    INTAPPIDRECORD_4 INTEGER,
    INTAPPIDRECORD_5 INTEGER)
AS
BEGIN

INSERT INTO app_errors
           ( code_error,
             app_source,
             app_id_record_1,
             app_id_record_2,
             app_id_record_3,
             app_id_record_4,
             app_id_record_5,
             ora_num_error,
             ora_msg_error,
             msg_error,
             user_error)
VALUES (GEN_ID(gen_app_errors_id, 1),
        :chAppSource,
        :intAppIdRecord_1,
        :intAppIdRecord_2,
        :intAppIdRecord_3,
        :intAppIdRecord_4,
        :intAppIdRecord_5,
        :intOraNumError,
        :chOraMsgError,
        :chMsgError,
        (SELECT code_privat FROM current_init WHERE code_init = 1));

END^


ALTER PROCEDURE TEST_REFRESH_SERVICE_TP
RETURNS (
    REFRESH_TYPE_OK VARCHAR(1),
    WORK_TIME_OUT INTEGER,
    DOC_COUNT INTEGER)
AS
declare variable LAST_TIME_TO_REFRESH timestamp;
declare variable NEXT_TIME_TO_REFRESH timestamp;
declare variable REFRESH_TYPE char(1);
begin
  /* REFRESH_TYPE
     '1' - отримати з сервера довідники
     '2' - відіслати на сервер чеки */
  WORK_TIME_OUT=0;
  DOC_COUNT=0;
  for select t.last_time_to_refresh, t.next_time_to_refresh, t.refresh_type
     from TEST_TIMETOREFRESH T
     where T.CODE_SHOP=71
     and T.NEXT_REFRESH_IS_ACTIVE='1'
  into :LAST_TIME_TO_REFRESH, :NEXT_TIME_TO_REFRESH, :REFRESH_TYPE
  do begin
     if ((:NEXT_TIME_TO_REFRESH is not null)and(:NEXT_TIME_TO_REFRESH < current_timestamp)) then begin
       if (:REFRESH_TYPE='1')/*отримуємо з сервера довідники*/ then begin
           REFRESH_TYPE_OK=:REFRESH_TYPE;

       end else
       if (:REFRESH_TYPE='2')/*відсилаємо на сервер чеки*/ then begin
           REFRESH_TYPE_OK=:REFRESH_TYPE;

       end

     end

  end

  suspend;

end^


ALTER PROCEDURE UPDATEOPTIONS (
    CHOPTIONS VARCHAR(255),
    CHTYPEOPTIONS CHAR(2),
    CHVARIETYOPTIONS CHAR(2),
    CHCHECKOPTIONS CHAR(2))
AS
declare variable intCount INTEGER;
BEGIN

SELECT COUNT(*)
FROM application_options_user
WHERE (code_privat     = (SELECT code_privat FROM current_init WHERE code_init = 1))
  AND (variety_options = :chVarietyOptions)
  AND (type_options    = :chTypeOptions)
INTO :intCount;

if (intCount = 0) then
   INSERT INTO application_options_user (
          id_application_options,
          code_privat,
          type_options,
          variety_options,
          check_options,
          options)
   SELECT id_application_options,
          (SELECT code_privat FROM current_init WHERE code_init = 1),
          type_options,
          variety_options,
          :chCheckOptions,
          :chOptions
   FROM application_options
   WHERE (variety_options = :chVarietyOptions)
     AND (type_options    = :chTypeOptions);
ELSE
   UPDATE application_options_user
   SET options       = :chOptions,
       check_options = :chCheckOptions
   WHERE (code_privat    = (SELECT code_privat FROM current_init WHERE code_init = 1))
     AND (variety_options = :chVarietyOptions)
     AND (type_options    = :chTypeOptions);

END^


ALTER PROCEDURE UPDREPOSITQUERY (
    CHNAMEGRID VARCHAR(50),
    CHNAMEDATASET VARCHAR(50),
    CHWHEREOLD VARCHAR(3000),
    CHWHEREFULL VARCHAR(3000),
    CHFULL VARCHAR(4000),
    FADD CHAR(1))
AS
declare variable intCount INTEGER;
BEGIN

SELECT COUNT(*)
FROM reposit_query
WHERE  ( name_grid    = :chNameGrid    )
  AND  ( name_dataset = :chNameDataSet )
  AND  ( ID_USER      = 1             )
INTO :intCount;

IF (intCount > 0) THEN
   IF ((fAdd = '0') OR (fAdd IS NULL)) THEN
      UPDATE reposit_query
         SET where_old  = :chWhereOld,
             where_full = :chWhereFull
      WHERE  ( name_grid    = :chNameGrid    )
        AND  ( name_dataset = :chNameDataSet )
        AND  ( ID_USER      = 1             );
   ELSE
      UPDATE reposit_query
         SET where_old  = where_old || :chWhereOld,
             where_full = where_full || :chWhereFull
      WHERE  ( name_grid    = :chNameGrid    )
        AND  ( name_dataset = :chNameDataSet )
        AND  ( ID_USER      = 1             );
ELSE
   INSERT INTO reposit_query
          ( id_user,
            name_grid,
            name_dataset,
            where_old,
            where_full,
            fulll)
   VALUES ( 1,
            :chNameGrid,
            :chNameDataSet,
            :chWhereOld,
            :chWhereFull,
            :chFull );

END^


ALTER PROCEDURE V_WARES_ORDER_FOR_RETURN (
    INTCODEORDER INTEGER,
    INTCODEWARES INTEGER,
    COEF FLOAT)
RETURNS (
    CODE_ORDER INTEGER,
    CODE_WARES INTEGER,
    QUANTITY_IN_BASIS_RET NUMERIC(16,3),
    CODE_UNIT INTEGER,
    COEFFICIENT NUMERIC(18,6),
    ORD NUMERIC(18,6))
AS
BEGIN
IF (:coef > 0) THEN
  FOR
    SELECT w.code_order, w.code_wares, w.quantity_in_basis_ret, w.code_unit, au.coefficient, (:coef - au.coefficient)*(:coef - au.coefficient) ord
    FROM wares_order_cache w
    LEFT JOIN addition_unit au on ((au.code_wares=w.code_wares)and(au.code_unit=w.code_unit))
    WHERE (w.code_order = :intCodeOrder)
      AND (w.code_wares = :intCodeWares)
      AND (w.quantity_in_basis_ret > 0)
    INTO
      :CODE_ORDER,
      :CODE_WARES,
      :QUANTITY_IN_BASIS_RET,
      :CODE_UNIT,
      :COEFFICIENT,
      :ORD
  DO
  BEGIN
    SUSPEND;
  END
ELSE
  FOR
    SELECT w.code_order, w.code_wares, w.quantity*au.coefficient - w.quantity_in_basis_ret, w.code_unit, au.coefficient, (:coef - au.coefficient)*(:coef - au.coefficient) ord
    FROM  wares_order_cache w
    LEFT JOIN addition_unit au ON ((au.code_wares = w.code_wares)and(au.code_unit = w.code_unit))
    WHERE (w.code_order = :intCodeOrder)
      AND (w.code_wares = :intCodeWares)
      AND (w.quantity*au.coefficient <> w.quantity_in_basis_ret)
    INTO
      :CODE_ORDER,
      :CODE_WARES,
      :QUANTITY_IN_BASIS_RET,
      :CODE_UNIT,
      :COEFFICIENT,
      :ORD
  DO
  BEGIN
    SUSPEND;
  END
END^


ALTER PROCEDURE V_WARESRECEIPTORDER (
    CODE_ORDERS INTEGER)
RETURNS (
    CODE_ORDER INTEGER,
    VAT NUMERIC(7,4),
    ADD_GROUPING INTEGER,
    CODE_WARES INTEGER,
    CODE_UNIT INTEGER,
    ARTICL VARCHAR(30),
    BAR_CODE VARCHAR(30),
    REC_NO INTEGER,
    NAME_WARES_RECEIPT VARCHAR(50),
    NAME_WARES VARCHAR(100),
    NAME_WARES_STR_1 VARCHAR(33),
    NAME_WARES_STR_2 VARCHAR(33),
    NAME_WARES_STR_3 VARCHAR(33),
    C_NAME_UNIT_INV CHAR(4),
    PRICE DOUBLE PRECISION,
    PRICEWITHVAT NUMERIC(15,2),
    PRICE_CATALOG DOUBLE PRECISION,
    PRICE_CATALOG_WITHVAT NUMERIC(15,2),
    SUMQUANTITY NUMERIC(16,3),
    SUMPRICE DOUBLE PRECISION,
    SUMPRICEWITHVAT NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE V_WARESRECEIPTRETURN (
    CODE_RETURNS INTEGER)
RETURNS (
    CODE_RETURN INTEGER,
    VAT NUMERIC(7,4),
    ADD_GROUPING INTEGER,
    CODE_WARES INTEGER,
    CODE_UNIT INTEGER,
    ARTICL VARCHAR(30),
    BAR_CODE VARCHAR(30),
    NAME_WARES_RECEIPT VARCHAR(50),
    NAME_WARES VARCHAR(100),
    NAME_WARES_STR_1 VARCHAR(33),
    NAME_WARES_STR_2 VARCHAR(33),
    NAME_WARES_STR_3 VARCHAR(33),
    C_NAME_UNIT_INV CHAR(4),
    PRICE DOUBLE PRECISION,
    PRICEWITHVAT NUMERIC(15,2),
    SUMQUANTITY NUMERIC(16,3),
    SUMPRICE DOUBLE PRECISION,
    SUMPRICEWITHVAT NUMERIC(15,5))
AS
BEGIN
  SUSPEND;
END^


ALTER PROCEDURE WRITEOPERATION (
    CHNUMBERCASHREGISTER VARCHAR(50),
    TYPEOPER INTEGER,
    INTCODEREASON INTEGER,
    CODECASHIER INTEGER,
    RSUMMA NUMERIC(15,2),
    CODEWAREHOUSE INTEGER,
    DESCRIPTION VARCHAR(255),
    IDWORKPLACE INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable NumOperation INTEGER;
declare variable CodeCashRegister INTEGER;
declare variable rCassa NUMERIC(15, 2);
declare variable rSummaNew NUMERIC(15, 2);
BEGIN

SELECT next_number_check
FROM attrib
WHERE (code_attrib = 1)
INTO :NumOperation;

SELECT MIN(rcr.code_register_cash_register)
FROM register_cash_register rcr, attrib a
WHERE (a.code_attrib = 1)
  AND (rcr.code_subgroup = a.code_subgroup)
  AND (rcr.serial_number_cash_register = :chNumberCashRegister)
INTO :CodeCashRegister;

if (CodeCashRegister IS NULL) then
   RESULT = -1;
ELSE
BEGIN
  INSERT INTO cassa_operation(
  code_operation,
  number_operation,
  code_cash_register,
  type_operation,
  code_reason,
  code_privat,
  summa)
  VALUES(GEN_ID(GetCodeCassaOperation, 1),:NumOperation,:CodeCashRegister,:TypeOper,:intCodeReason,:CodeCashier,:rSumma);

  if (TypeOper = 0) THEN
     rSummaNew = -:rSumma;
  ELSE
     rSummaNew = :rSumma;

  SELECT cassa
  FROM attrib
  WHERE code_attrib = 1
  INTO :rCassa;

  if ((rCassa+rSummaNew) < 0) then
     RESULT = -2;
  ELSE
  BEGIN
    UPDATE attrib
    SET next_number_check = next_number_check + 1,
        cassa = cassa + :rSummaNew
    WHERE code_attrib = 1;

    RESULT = :NumOperation;
  END
       
END

SUSPEND;

END^


ALTER PROCEDURE WRITEOUTINVOICE (
    INTCODEORDER INTEGER,
    DATEOUTINVOICE DATE,
    DATETAKE DATE,
    INTEND INTEGER,
    CHSTATEPAY CHAR(1),
    CHSERPOA CHAR(3),
    CHNUMPOA VARCHAR(20),
    DATEPOA DATE,
    CHNSPPOA VARCHAR(200))
AS
declare variable intCodeCalculation INTEGER;
declare variable intNumberTaxInvoice INTEGER;
declare variable intCodeClient INTEGER;
declare variable chTypePayment CHAR(2);
declare variable chStatusTransfer CHAR(1);
declare variable rOrderSumma NUMERIC(15, 2);
BEGIN

SELECT type_payment, code_client
FROM order_client_cache
WHERE (code_order = :intCodeOrder)
INTO :chTypePayment, :intCodeClient;

if ((RTRIM(chTypePayment) = 'B') AND (chStatePay = '2')) then begin
   SELECT result FROM GetSumOrderCache(:intCodeOrder)
   INTO :rOrderSumma;

   UPDATE account_client
   SET account = CAST(account AS NUMERIC(15, 2)) - :rOrderSumma
   WHERE code_client = :intCodeClient;
end

FOR
SELECT code_calculation, status_transfer
FROM calculation_cache
WHERE (code_order = :intCodeOrder)
INTO :intCodeCalculation, :chStatusTransfer
DO BEGIN
  if (chStatusTransfer = '1') then
     EXCEPTION CheckTransfer;
     
  if (intEnd IN (7, 8)) then
     intNumberTaxInvoice = GEN_ID(gen_number_tax_invoice, 1);

  UPDATE calculation_cache
  SET number_tax_invoice = :intNumberTaxInvoice,
      state_pay          = :chStatePay,
      date_out_invoice   = :dateOutInvoice,
      date_take          = :dateTake,
      status_transfer    = '0'
  WHERE (code_calculation = :intCodeCalculation);
end

if (chnsppoa <> '') then
   INSERT INTO power_of_attorney(code_order, ser_power_of_attorney, num_power_of_attorney, date_power_of_attorney, nsp_power_of_attorney)
   VALUES(:intCodeOrder, :chserpoa, :chnumpoa, :datepoa, :chnsppoa);

UPDATE order_client_cache
SET code_end = :intEnd,
 date_change = CURRENT_TIMESTAMP
WHERE (code_order = :intCodeOrder);

END^


ALTER PROCEDURE WRITERETURNRECEIPT (
    INTCODERETURN INTEGER,
    CHNUMBERRECEIPT VARCHAR(30),
    CHDATERECEIPT TIMESTAMP,
    CHNUMBERCASHIER VARCHAR(30),
    CHNUMBERCASHREGISTER VARCHAR(30),
    CHMODELCASHREGISTER VARCHAR(50))
AS
declare variable intCount INTEGER;
declare variable userChange INTEGER;
declare variable chTypePayment CHAR(2);
declare variable rSumma NUMERIC(15, 2);
declare variable chError VARCHAR(2000);
BEGIN

SELECT code_return, user_change, type_payment,
       (SELECT result FROM GetSumReturnCache(:intCodeReturn))
FROM return_cache
WHERE (code_return = :intCodeReturn)
INTO :intCount, :userChange, :chTypePayment, :rSumma;

if (intCount > 0) then begin
    INSERT INTO return_register_cache
           ( code_return,
             number_receipt,
             date_receipt,
             number_cashier,
             number_cash_register,
             model_cash_register,
             user_change)
    VALUES (:intCodeReturn,
            :chNumberReceipt,
            :chDateReceipt,
            :chNumberCashier,
            :chNumberCashRegister,
            :chModelCashRegister,
            :userChange);

   IF (chTypePayment = 'NC') THEN
      UPDATE attrib
      SET cassa_credit = cassa_credit - :rSumma
      WHERE code_attrib = 1;
   ELSE IF (chTypePayment = 'B1') THEN
      UPDATE attrib
      SET cassa_card = cassa_card - :rSumma
      WHERE code_attrib = 1;
   ELSE
      UPDATE attrib
      SET cassa = cassa - :rSumma
      WHERE code_attrib = 1;

   UPDATE return_cache
   SET status_transfer = '0'
   WHERE code_return = :intCodeReturn;   
end

END^


ALTER PROCEDURE WRITESHIFTLOG (
    IDWORKPLACE INTEGER,
    CODEPRIVAT INTEGER,
    CHTYPE VARCHAR(2),
    CHVIEW VARCHAR(2))
AS
declare variable intCodeSubgroup INTEGER;
declare variable CodeFirm INTEGER;
declare variable CodeWarehouseNew INTEGER;
declare variable rCassa NUMERIC(15, 2);
declare variable rTimeNow TIMESTAMP;
BEGIN

SELECT code_subgroup, company_problem_invoice, warehouse_problem_invoice, cassa
FROM attrib
WHERE (code_attrib = 1)
INTO :intCodeSubgroup,
     :CodeFirm,
     :CodeWarehouseNew,
     :rCassa;

/*
if (CodeWarehouse <> 0) then
   CodeWarehouseNew = :CodeWarehouse;

if (NOT ((chType = '00') AND (chView = '01'))) THEN
   rCassa = 0;
*/

rTimeNow = CURRENT_TIMESTAMP;

if ((chType = '00') AND (chView = '00')) then
   UPDATE attrib
   SET date_begin_shift = :rTimeNow
   WHERE code_attrib = 1;

if ((chType = '00') AND (chView = '01')) then
   UPDATE attrib
   SET next_number_check = 1,
       begin_cassa = cassa,
       cassa_credit = 0,
       date_begin_shift = NULL,
       date_end_shift = :rTimeNow
   WHERE code_attrib = 1;
else
   rCassa = 0;   

INSERT INTO cash_shift_log(code_subgroup, date_cash_shift_log, id_workplace, code_firm_company, code_warehouse, code_privat, type_cash_shift_log, view_cash_shift_log, cassa)
VALUES(:intCodeSubgroup, :rTimeNow, :IdWorkPlace, :CodeFirm, :CodeWarehouseNew, :CodePrivat, :chType, :chView, :rCassa);

END^


ALTER PROCEDURE WRITEZREPORT (
    CHNUMBERCASHREGISTER VARCHAR(50),
    RSUMREPORT NUMERIC(15,2),
    RSUMREPORTCASH NUMERIC(15,2),
    RSUMCREDIT NUMERIC(15,2),
    RRETURN NUMERIC(15,2),
    RRETURNCASH NUMERIC(15,2),
    RRETURNCREDIT NUMERIC(15,2),
    RINPUT NUMERIC(15,2),
    ROUTPUT NUMERIC(15,2),
    CHDATEREPORT TIMESTAMP,
    CODEWAREHOUSE INTEGER,
    RSUMCARD NUMERIC(15,2),
    RRETURNCARD NUMERIC(15,2))
RETURNS (
    RESULT INTEGER)
AS
declare variable intCodeFirm INTEGER;
declare variable intCodeSubgroup INTEGER;
declare variable intCodePrivat INTEGER;
declare variable intCodeNumberCash INTEGER;
declare variable intCodeZReport INTEGER;
declare variable rCassa NUMERIC (15, 2);
declare variable rCassaCredit NUMERIC (15, 2);
declare variable rCassaCard NUMERIC (15, 2);
BEGIN

SELECT company_problem_invoice, code_subgroup, cassa, cassa_credit, cassa_card
FROM attrib
WHERE code_attrib = 1
INTO :intCodeFirm,
     :intCodeSubgroup,
     :rCassa,
     :rCassaCredit,
     :rCassaCard;

SELECT code_privat
FROM current_init
WHERE code_init = 1
INTO :intCodePrivat;

SELECT MIN(code_register_cash_register)
FROM register_cash_register
WHERE serial_number_cash_register = :chNumberCashRegister
INTO :intCodeNumberCash;

if (:intCodeNumberCash IS NULL) then
   RESULT = -1;
ELSE
BEGIN
   intCodeZReport = GEN_ID(gen_code_zreport, 1);

   INSERT INTO cash_register_report(
   code_cash_register_report,
   code_subgroup,
   code_firm_company,
   code_warehouse,
   number_cash_register_report,
   time_cash_register_report,
   sum_cash_register_report,
   sum_ready_money,
   sum_ready_credit,
   return_sum_cash,
   return_sum_ready_money,
   return_sum_ready_credit,
   serviceinput,
   serviceoutput,
   user_change,
   cassa,
   cassa_credit,
   cassa_card,
   sum_ready_card,
   return_sum_ready_card)
   VALUES(:intCodeZReport,
          :intCodeSubgroup,
          :intCodeFirm,
          :CodeWarehouse,
          :intCodeNumberCash,
          :chDateReport,
          :rSumReport,
          :rSumReportCash,
          :rSumCredit,
          :rReturn,
          :rReturnCash,
          :rReturnCredit,
          :rInput,
          :rOutput,
          :intCodePrivat,
          :rCassa,
          :rCassaCredit,
          :rCassaCard,
          :rSumCard,
          :rReturnCard);

   RESULT = :intCodeZReport;
END

SUSPEND;

END^


ALTER PROCEDURE WRITEZREPORT_TAX (
    CODE_REPORT_IN INTEGER,
    Z_ZVIT_NUM INTEGER,
    CHNUMBERCASHREGISTER VARCHAR(50),
    CODE_OPERATION INTEGER,
    ZVIT_SUM_A DOUBLE PRECISION,
    ZVIT_SUM_B DOUBLE PRECISION,
    ZVIT_SUM_V DOUBLE PRECISION,
    ZVIT_SUM_G DOUBLE PRECISION,
    ZVIT_SUM_D DOUBLE PRECISION,
    ZVIT_SUM_E DOUBLE PRECISION)
RETURNS (
    INTCODENUMBERCASH INTEGER,
    CODE_REPORT INTEGER)
AS
declare variable tax_group_x integer;
declare variable code_rec_x integer;
declare variable idx integer;
begin
 SELECT MIN(code_register_cash_register)
 FROM register_cash_register
 WHERE serial_number_cash_register = :chNumberCashRegister
 INTO :intCodeNumberCash;

 IF ((:intCodeNumberCash IS NULL) OR (:Z_ZVIT_NUM IS NULL)) THEN BEGIN
   CODE_REPORT = -1;
 END ELSE BEGIN
  IF ((:CODE_REPORT_IN=-1) OR (:CODE_REPORT_IN IS NULL)) THEN BEGIN
     CODE_REPORT_IN=GEN_ID(gen_code_zreport, 1);
  END

  /* --= CODE_OPERATION: =-- */
  /* 0. TURNOVER             */
  /* 1. TAX_SUM              */
  /* 2. RETURN_TURNOVER      */
  /* 3. RETURN_TAX_SUM       */
  IF (CODE_OPERATION=0) THEN BEGIN
   IDX=1;
   WHILE (IDX<=6) DO BEGIN
    INSERT INTO Z_REPORT_TAX_GROUP
     (CODE_REPORT,
      CODE_REC,
      TAX_GROUP,
      TURNOVER,
      TAX_SUM,
      RETURN_TURNOVER,
      RETURN_TAX_SUM,
      Z_ZVIT_NUM,
      CODENUMBERCASH)
    VALUES(
      :CODE_REPORT_IN,
      null,
      :IDX,
      null,
      null,
      null,
      null,
      :Z_ZVIT_NUM,
      :IntCodeNumberCash);
    IDX=:IDX+1;
   END
  END

 if (:CODE_OPERATION=0) then begin /*TURNOVER*/
  FOR SELECT Z.CODE_REC,Z.TAX_GROUP
      FROM Z_REPORT_TAX_GROUP Z
      WHERE Z.CODE_REPORT=:CODE_REPORT_IN
      ORDER BY Z.TAX_GROUP
      INTO :CODE_REC_X,:TAX_GROUP_X
  DO BEGIN
      IF (:TAX_GROUP_X=1) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_A WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=2) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_B WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=3) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_V WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=4) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_G WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=5) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_D WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=6) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TURNOVER=:ZVIT_SUM_E WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END

  END
 END ELSE
 if (:CODE_OPERATION=1) then begin /*RETURN_TURNOVER*/
  FOR SELECT Z.CODE_REC,Z.TAX_GROUP
      FROM Z_REPORT_TAX_GROUP Z
      WHERE Z.CODE_REPORT=:CODE_REPORT_IN
      ORDER BY Z.TAX_GROUP
      INTO :CODE_REC_X,:TAX_GROUP_X
  DO BEGIN
      IF (:TAX_GROUP_X=1) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_A WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=2) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_B WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=3) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_V WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=4) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_G WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=5) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_D WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=6) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TURNOVER=:ZVIT_SUM_E WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END
  END
 END ELSE
 if (:CODE_OPERATION=2) then begin /*TAX_SUM*/
  FOR SELECT Z.CODE_REC,Z.TAX_GROUP
      FROM Z_REPORT_TAX_GROUP Z
      WHERE Z.CODE_REPORT=:CODE_REPORT_IN
      ORDER BY Z.TAX_GROUP
      INTO :CODE_REC_X,:TAX_GROUP_X
  DO BEGIN
      IF (:TAX_GROUP_X=1) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_A WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=2) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_B WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=3) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_V WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=4) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_G WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=5) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_D WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=6) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET TAX_SUM=:ZVIT_SUM_E WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END
  END
 END ELSE
 IF (:CODE_OPERATION=3) THEN BEGIN /*RETURN_TAX_SUM*/
  FOR SELECT Z.CODE_REC,Z.TAX_GROUP
      FROM Z_REPORT_TAX_GROUP Z
      WHERE Z.CODE_REPORT=:CODE_REPORT_IN
      ORDER BY Z.TAX_GROUP
      INTO :CODE_REC_X,:TAX_GROUP_X
  DO BEGIN
      IF (:TAX_GROUP_X=1) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_A WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=2) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_B WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=3) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_V WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X=4) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_G WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X  =5) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_D WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END ELSE
      IF (:TAX_GROUP_X  =6) THEN BEGIN
         UPDATE Z_REPORT_TAX_GROUP SET RETURN_TAX_SUM=:ZVIT_SUM_E WHERE CODE_REC=:CODE_REC_X AND CODE_REPORT=:CODE_REPORT_IN;
      END
  END
 END
 CODE_REPORT=:CODE_REPORT_IN;
 END
  SUSPEND;
end^



SET TERM ; ^


/******************************************************************************/
/***                                 Roles                                  ***/
/******************************************************************************/

CREATE ROLE REFRESH_SERVICE;


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE ACCOUNT_CLIENT
'рахунки клієнтів, F - фірм і P - фізичних осіб';

DESCRIBE TABLE ADDITION_SIGN
'додаткові признаки';

DESCRIBE TABLE ADDITION_UNIT
'Фактично ця таблиця містить додаткові дані по унікальній парі:
ТОВАР+ОДИНИЦЯ ВИМІРУ
WARES+UNIT_DIMENSION';

DESCRIBE TABLE APPLICATION_OPTIONS
'Налаштування кольорів, фактично мона використати цю табличку в своїх меркантільних цілях :)))';

DESCRIBE TABLE ATTRIB
'Містить 1 рекорд з ЗНАЧЕННЯМИ різних ПАРАМЕТРІВ
(з яких я розумію тільки декілька штучок)';

DESCRIBE TABLE CALCULATION_CACHE
'рахунок по замовленню';

DESCRIBE TABLE CALCULATION_CREDIT_CARD_CACHE
'це дані по кредитній карточці';

DESCRIBE TABLE CASH_REGISTER_REPORT
'мабуть це Z-звіт';

DESCRIBE TABLE CASH_SHIFT_LOG
'часові проміжкі коли працювала каса';

DESCRIBE TABLE CASSA_OPERATION
'внесення та вилучення готівки на касі, поідеї';

DESCRIBE TABLE CHOSEN_GROUP_WARES
'організація груп і підгруп, поки що не розібрався досконаліше';

DESCRIBE TABLE CITY
'міста і селища';

DESCRIBE TABLE DEALER
'магазини';

DESCRIBE TABLE DEPARTMENT
'Департаменти до яких належать товари (кондитерка, мясо, виробництво, алкоголь) (код:682 - 692, номера:101-111)';

DESCRIBE TABLE DISCOUNT_CARD
'містить дисконтні карткі (нехватає даних- чия це карточка, адреса, телефон, т.д.)';

DESCRIBE TABLE FIRMS
'дані про Клієнти-фірми';

DESCRIBE TABLE GROUP_WARES
'групи товарів';

DESCRIBE TABLE MANAGER
'тут мабуть якісь манагіри записані';

DESCRIBE TABLE OPTS_ITEM_VALUES
'неясно що це';

DESCRIBE TABLE OPTS_OPTION_ITEMS
'зберігаються опції для різних програмних моментів';

DESCRIBE TABLE ORDER_CLIENT_CACHE
'містить   Шапки чеків';

DESCRIBE TABLE PRICE_DEALER
'ціни на товари по магазинах';

DESCRIBE TABLE PRICE_PROPOCITION
'мабуть це ціни на акційні товари';

DESCRIBE TABLE PRIVAT
'дані про Клієнти-Фізичні особи';

DESCRIBE TABLE REGISTER_CASH_REGISTER
'перелік касових апаратів';

DESCRIBE TABLE REPOSIT
'бред!!!
містить SQL Запроси - що вони роблять - непанятно, більшість не пашуть в силу невірного синтаксиса';

DESCRIBE TABLE SHOP_DEPARTMENT_WARES
'розподіл товарів по відділах(департаментах)';

DESCRIBE TABLE SHOP_PRICE_SUPPLIER
'вхідні ціни поставщиків і номера прихідних документів';

DESCRIBE TABLE SHOP_SPECPROPOSITION_TIME
'табличка з часовими проміжками коли починає діяти спецпропозиція - з 23:00 до 0:00';

DESCRIBE TABLE SPA_EVENTS_AUDIT
'список подій які потрапляють в аудіт';

DESCRIBE TABLE SPA_INSPECTOR
'список якихось пос-інспекторів';

DESCRIBE TABLE SPA_PROFILES
'Список Назв профілів-користувачів (це зручно )';

DESCRIBE TABLE SPA_SECURITY_LIST
'Схоже на те що у цій табличці записані назви вікон та програм які були запущені
(або які дозволені для запуску???)';

DESCRIBE TABLE STATE_ALL
'містить назви dll-ок';

DESCRIBE TABLE UNIT_DIMENSION
'Табличка містить одиниці виміру (базові там якось окремо виділені?)';

DESCRIBE TABLE V_SPA_EVENTS_MONITOR
'події які використовуються у інспекторі';

DESCRIBE TABLE WARES_ORDER_CACHE
'Містить записи по реалізації кожної позиції товара і зсилку на Шапку Чека';

DESCRIBE TABLE WARES_PARAMETERS_SUBGROUP
'бар''єр дисконту по кожній позиції товару';

DESCRIBE TABLE WARES_WITH_FRACTIONAL_UNIT
'містить просто коди товарів, якихось (в даному випадку тупо якийсь хліб, навіть не власного виробництва)';

DESCRIBE TABLE Z_REPORT_TAX_GROUP
'щось пов''язане зі Z-звітами';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE FUNCTION MD5_HASH
'VERSION=1000';

DESCRIBE FUNCTION RUN_SHELL
'VERSION=1000';

DESCRIBE FUNCTION TICKCOUNT
'VERSION=1000';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE ADDGROUPINGWHENWRITECALC
'select < GETRETURNWARES < GETWARESWITHPRICE';

DESCRIBE PROCEDURE ADDWARESTOORDER
'INSERT < GETCOEFFICIENT';

DESCRIBE PROCEDURE ADDWARESTORETURN
'INSERT,UPDATE < GETCOEFFICIENT < V_WARES_ORDER_FOR_RETURN';

DESCRIBE PROCEDURE DELETERETURN
'DELETE';

DESCRIBE PROCEDURE FILLCAPTIONORDER
'INSERT';

DESCRIBE PROCEDURE FILLCAPTIONRETURN
'INSERT';

DESCRIBE PROCEDURE FRONTOFFICECHANGEDATEORDER
'update';

DESCRIBE PROCEDURE FRONTOFFICEDELETEORDER
'DELETE,update';

DESCRIBE PROCEDURE FRONTOFFICEWRITEORDER
'INSERT,update';

DESCRIBE PROCEDURE FRONTOFFICEWRITERECEIPT
'INSERT,update';

DESCRIBE PROCEDURE INITPARAMETERS
'update';

DESCRIBE PROCEDURE MY_MICRO_PROC
'VERSION=1000;';

DESCRIBE PROCEDURE NEW_FRONTOFFICEWRITEORDER
'VERSION=1001';

DESCRIBE PROCEDURE PS_FR_SYNC
'Скрипт синхронізації ТП та Фронта';

DESCRIBE PROCEDURE SAVEAPPERRORS
'INSERT';

DESCRIBE PROCEDURE UPDATEOPTIONS
'INSERT,update';

DESCRIBE PROCEDURE UPDREPOSITQUERY
'INSERT,update';

DESCRIBE PROCEDURE WRITEOPERATION
'INSERT,update';

DESCRIBE PROCEDURE WRITEOUTINVOICE
'INSERT,update';

DESCRIBE PROCEDURE WRITERETURNRECEIPT
'INSERT,update';

DESCRIBE PROCEDURE WRITESHIFTLOG
'INSERT,update';

DESCRIBE PROCEDURE WRITEZREPORT
'INSERT';



/* Fields descriptions */

DESCRIBE FIELD CODE_CLIENT TABLE ACCOUNT_CLIENT
'код клієнта';

DESCRIBE FIELD CODE_CURRENCY TABLE ACCOUNT_CLIENT
'код валюти';

DESCRIBE FIELD CODE_FIRM_COMPANY TABLE ACCOUNT_CLIENT
'код нашої фірми';

DESCRIBE FIELD TYPE_CLIENT TABLE ACCOUNT_CLIENT
'F - фірма
P - фізична особа';

DESCRIBE FIELD ACCOUNT TABLE ACCOUNT_CLIENT
'сума на рахунку';

DESCRIBE FIELD DML_DATETIME TABLE ACCOUNT_CLIENT
'дата модифікації';

DESCRIBE FIELD CODE_UNIT TABLE ADDITION_UNIT
'Зсилка на тиблицю UNIT_DIMENSION - одиниці виміру';

DESCRIBE FIELD CODE_WARES TABLE ADDITION_UNIT
'Зсикла на таблицю WARES -товари';

DESCRIBE FIELD COEFFICIENT TABLE ADDITION_UNIT
'Коефіцієнт перерахунку в базову одиницю виміру(?????)';

DESCRIBE FIELD DEFAULT_UNIT TABLE ADDITION_UNIT
'Y- Одиниця виміру по замовчуванню (базова?)
N- Ні';

DESCRIBE FIELD SIGN_ACTIVITY TABLE ADDITION_UNIT
'Y - Активне (???)';

DESCRIBE FIELD BAR_CODE TABLE ADDITION_UNIT
'Штрихкод звязки ТОВАР+ОДИНИЦЯ ВИМІРУ';

DESCRIBE FIELD CHECK_FIND_BAR_CODE TABLE ADDITION_UNIT
'Y- штрих код встановлено';

DESCRIBE FIELD DESCRIPTION TABLE ADDITION_UNIT
'фігурують значення:
DESCRIPTION,COUNT
1)1       - 1шт
2)кг      - 523шт
3)пл      - 1шт
4)<null>  - 190696шт';

DESCRIBE FIELD SIGN_LOCKING TABLE ADDITION_UNIT
'Y  - заборонена розфасовання на дрібніші одиниці виміру?????
N  - дозволена????';

DESCRIBE FIELD WEIGHT TABLE ADDITION_UNIT
'Висота';

DESCRIBE FIELD WIDTH TABLE ADDITION_UNIT
'Ширина';

DESCRIBE FIELD HEIGHT TABLE ADDITION_UNIT
'Вага';

DESCRIBE FIELD LENGT_ TABLE ADDITION_UNIT
'Довжина???';

DESCRIBE FIELD REPORT_UNIT TABLE ADDITION_UNIT
'ШО ЦЕ ??????';

DESCRIBE FIELD DML_DATETIME TABLE ADDITION_UNIT
'можливо таймстамп останньої модифікації';

DESCRIBE FIELD CODE_SUBGROUP TABLE ATTRIB
'Код нашої підгрупи (це такаж глобальна фішка як і код магазину? тобто одна підгрупа на весь магазин?)';

DESCRIBE FIELD CODE_SHOP TABLE ATTRIB
'Код магазину';

DESCRIBE FIELD CODE_CLIENT TABLE ATTRIB
'Код клієнта (якого ще клієнта?)';

DESCRIBE FIELD CODE_DEPARTMENT TABLE DEPARTMENT
'Код деапартаменту 101-111';

DESCRIBE FIELD CODE_SUBGROUP TABLE DEPARTMENT
'Код підгрупи - фактично =36';

DESCRIBE FIELD NUMBER_DEPARTMENT TABLE DEPARTMENT
'Номер департаменту';

DESCRIBE FIELD NAME_DEPARTMENT TABLE DEPARTMENT
'Назва департаменту';

DESCRIBE FIELD SIGN_ACTIVITY TABLE DEPARTMENT
'признак активності даного департаменту (а смисл?)';

DESCRIBE FIELD DML_DATETIME TABLE DEPARTMENT
'дата останньої модифікації';

DESCRIBE FIELD CODE_DISCOUNT_CARD TABLE DISCOUNT_CARD
'код дисконтної карточкі';

DESCRIBE FIELD CODE_SUBGROUP TABLE DISCOUNT_CARD
'код підгрупи';

DESCRIBE FIELD NAME_DISCOUNT_CARD TABLE DISCOUNT_CARD
'назва дисконтної карточкі';

DESCRIBE FIELD PERCENT_DISCOUNT_CARD TABLE DISCOUNT_CARD
'це процент знижкі
якщо процент знижкі мінусовий - то мабуть це націнка';

DESCRIBE FIELD SUM_DISCOUNT_CARD TABLE DISCOUNT_CARD
'сума чека після якої починає діяти ця дисконтна карточка???????';

DESCRIBE FIELD SIGN_ACTIVITY TABLE DISCOUNT_CARD
'Y -  активна карточка';

DESCRIBE FIELD CODE_DISCOUNT_CARD_GROUP TABLE DISCOUNT_CARD
'код дисконтної групи (яку табличку дивитись з кодами всіх груп???)';

DESCRIBE FIELD FIXED_DISCOUNT TABLE DISCOUNT_CARD
'Y - ???????';

DESCRIBE FIELD PERIOD_OF_VALIDITY TABLE DISCOUNT_CARD
'період валідності у днях з моменту створення карточкі???';

DESCRIBE FIELD DML_DATETIME TABLE DISCOUNT_CARD
'тайм стамп створення дисконтної карточкі';

DESCRIBE FIELD PRICE TABLE MY_TEMP_ORDER
'ціна без ПДВ';

DESCRIBE FIELD PRICE_CATALOG TABLE MY_TEMP_ORDER
'ціна у каталозі без ПДВ';

DESCRIBE FIELD CODE_ORDER TABLE ORDER_CLIENT_CACHE
'Унікальний Код чеку';

DESCRIBE FIELD CODE_SUBGROUP TABLE ORDER_CLIENT_CACHE
'підгрупа в межах магазину, фактично вона одна на весь магазин';

DESCRIBE FIELD NUMBER_ORDER TABLE ORDER_CLIENT_CACHE
'Номер якогось ордера';

DESCRIBE FIELD DATE_ORDER TABLE ORDER_CLIENT_CACHE
'Дата створення ордера';

DESCRIBE FIELD VARIETY_ORDER TABLE ORDER_CLIENT_CACHE
'фактично єдине значення яку тут фігурує = O';

DESCRIBE FIELD TYPE_ORDER TABLE ORDER_CLIENT_CACHE
'паходу завжди значення рівне = O';

DESCRIBE FIELD TYPE_PAYMENT TABLE ORDER_CLIENT_CACHE
'паходу тип оплати, фігурують значення N - 153349 шт, та NC - 10301 шт';

DESCRIBE FIELD TYPE_VAT TABLE ORDER_CLIENT_CACHE
'паходу тип ПДВ (завжди=IN)';

DESCRIBE FIELD CODE_CLIENT TABLE ORDER_CLIENT_CACHE
'код клієнта з відповідної табличкі, залежно від типу клієнта';

DESCRIBE FIELD TYPE_CLIENT TABLE ORDER_CLIENT_CACHE
'P - фізична особа, абичний смертний человечишка
F - юридична особа, фірма';

DESCRIBE FIELD DATE_PAYMENT TABLE ORDER_CLIENT_CACHE
'дата оплати';

DESCRIBE FIELD CODE_DEALER TABLE ORDER_CLIENT_CACHE
'код магазину який продав, фактично один і той самий';

DESCRIBE FIELD DISCOUNT TABLE ORDER_CLIENT_CACHE
'думаю що не використовується тому що це поле завжди містить значення = 0.00';

DESCRIBE FIELD PER_PP TABLE ORDER_CLIENT_CACHE
'PER_PP    COUNT
  0.00    10319 шт
100.00    153331 шт
чимось нагадує поле TYPE_PAYMENT';

DESCRIBE FIELD CODE_MANAGER TABLE ORDER_CLIENT_CACHE
'код манагера, покищо незнаю що це значить, тим більше незнаю навіщо він в документі';

DESCRIBE FIELD ID_WORKPLACE TABLE ORDER_CLIENT_CACHE
'ID_WORKPLACE    COUNT
1114    36375 шт
1914    127275 шт
нічого не нагадує,нажаль';

DESCRIBE FIELD CODE_PRICE_PROPOCITION TABLE PRICE_PROPOCITION
'код пропозиції, (у яких таблицях використовується?)';

DESCRIBE FIELD CODE_WARES TABLE PRICE_PROPOCITION
'код товара';

DESCRIBE FIELD CODE_SUBGROUP TABLE PRICE_PROPOCITION
'код підгрупи = 36';

DESCRIBE FIELD CAT_SPECPROPOSITION_ID TABLE PRICE_PROPOCITION
'категорія спец.пропозиції = 262';

DESCRIBE FIELD CUBIC TABLE PRICE_PROPOCITION
'незнаю що це, = 10.00';

DESCRIBE FIELD MARKUP TABLE PRICE_PROPOCITION
'незнаю що це, = 25.00';

DESCRIBE FIELD PRICE_PROPOCITION TABLE PRICE_PROPOCITION
'акційна ціна, або ціна пропозиції';

DESCRIBE FIELD CODE_CURRENCY TABLE PRICE_PROPOCITION
'незнаю що це, = 0';

DESCRIBE FIELD DML_DATETIME TABLE PRICE_PROPOCITION
'дата модифікації';

DESCRIBE FIELD CODE_REGISTER_CASH_REGISTER TABLE REGISTER_CASH_REGISTER
'код касового апарата';

DESCRIBE FIELD CODE_SUBGROUP TABLE REGISTER_CASH_REGISTER
'код підгрупи = 36';

DESCRIBE FIELD CODE_COMPANY TABLE REGISTER_CASH_REGISTER
'код компанії';

DESCRIBE FIELD NUMBER_CASH_REGISTER TABLE REGISTER_CASH_REGISTER
' номер касового апарата (де використовується покищо невідомо)';

DESCRIBE FIELD SERIAL_NUMBER_CASH_REGISTER TABLE REGISTER_CASH_REGISTER
'серійний номер касового апарата - апарат походу сам видає цей номер';

DESCRIBE FIELD MODEL_CASH_REGISTER TABLE REGISTER_CASH_REGISTER
'модель касового апаратика, поідеї десь має бути табличка зі всіма можливими моделями касових апаратів';

DESCRIBE FIELD DML_DATETIME TABLE REGISTER_CASH_REGISTER
'дата модифікації';

DESCRIBE FIELD CODE_OBJECT TABLE SPA_SECURITY_LIST
'код об"єкта';

DESCRIBE FIELD CODE_PARENT_OBJECT TABLE SPA_SECURITY_LIST
'код предка';

DESCRIBE FIELD NAME_OBJECT TABLE SPA_SECURITY_LIST
'коротка назва вікна форми';

DESCRIBE FIELD REAL_NAME_OBJECT TABLE SPA_SECURITY_LIST
'довга назва вікна форми - по суті Caption';

DESCRIBE FIELD TYPE_OBJECT TABLE SPA_SECURITY_LIST
'Тип об''єкта:
F- форма
M - фіг його знає- може аплікация?';

DESCRIBE FIELD CODE_SPOSUSER TABLE SPA_USERS
'Код касира';

DESCRIBE FIELD USER_NAME TABLE SPA_USERS
'Логін касира';

DESCRIBE FIELD SIGN_ACTIVITY TABLE SPA_USERS
'Y  - Активний ????
N  - Заблокований';

DESCRIBE FIELD DATE_BEGIN TABLE SPA_USERS
'Дата з якої цей логін починає діяти';

DESCRIBE FIELD DATE_END TABLE SPA_USERS
'Дата після якої логін перестає діяти';

DESCRIBE FIELD CODE_PRIVAT TABLE SPA_USERS
'приватний код користувача???';

DESCRIBE FIELD PSWD TABLE SPA_USERS
'хеш пароля (або просто тупо заархівований пароль)';

DESCRIBE FIELD CODE_PROFILE TABLE SPA_USERS
'коди типу профіля,
поідеї у
касирів = 461
адмінів = 462
ревізор = 341
т.д.
а яку тибличку дивитись для детальнішого ознайомлення?';

DESCRIBE FIELD CODE_SHOP TABLE SPA_USERS
'код магазину';

DESCRIBE FIELD CODE_SUBGROUP TABLE SPA_USERS
'куд підгрупи';

DESCRIBE FIELD REFRESH_TYPE TABLE TEST_TIMETOREFRESH
'''1'' - отримати з сервера довідники
''2'' - відіслати на сервер чеки';

DESCRIBE FIELD DESCRIPTION TABLE UNIT_DIMENSION
'Фігурують такі значення:
DESCRIPTION, COUNT
1)кг       - 1шт
2)<null>   - 65шт';

DESCRIBE FIELD SIGN_DIVISIONAL TABLE UNIT_DIMENSION
'Y  ????? - признак ділимості?????
N  ?????';

DESCRIBE FIELD REUSABLE_CONTAINER TABLE UNIT_DIMENSION
'значення завжди - N';

DESCRIBE FIELD CODE_WARES_REUSABLE_CONTAINER TABLE UNIT_DIMENSION
'значення завжди <null>';

DESCRIBE FIELD DML_DATETIME TABLE UNIT_DIMENSION
'якаийсь тайм стамп,
може таймстамп останньої модифікації';

DESCRIBE FIELD CODE_UNIT TABLE WARES
'Базова од. виміру';

DESCRIBE FIELD MIN_QUANTITY TABLE WARES
'Мін. кількість - всюди 1';

DESCRIBE FIELD TYPE_ITEM TABLE WARES_CATALOG
'''D''-(directory) папка,''W''-(wares) товар';

DESCRIBE FIELD SIGN_ACTIVE TABLE WARES_CATALOG
'''Y''-активно';

DESCRIBE FIELD CODE_CONTRACT TABLE WARES_CONTRACT_OF_PRICE
'ПУСТО';

DESCRIBE FIELD CODE_ORDER TABLE WARES_ORDER_CACHE
'Зсилка на Шапку Чека в табличці CODE_ORDER';

DESCRIBE FIELD CODE_WARES TABLE WARES_ORDER_CACHE
'КОД товара в табличці WARES';

DESCRIBE FIELD QUANTITY TABLE WARES_ORDER_CACHE
'Кількість ТОВАРА в одиницях CODE_UNIT';

DESCRIBE FIELD CODE_UNIT TABLE WARES_ORDER_CACHE
'Містить код ОДИНИЦІ ВИМІРУ товара в таблиці UNIT_DIMENSION';

DESCRIBE FIELD PRICE TABLE WARES_ORDER_CACHE
'Ціна по якій реально відбулась реалізація';

DESCRIBE FIELD PRICE_CATALOG TABLE WARES_ORDER_CACHE
'Ціна продажна але Ціна реалізації може бути меншою';

DESCRIBE FIELD VAT TABLE WARES_ORDER_CACHE
'ПДВ, містить значення:
0.00
0.20';

DESCRIBE FIELD ADD_GROUPING TABLE WARES_ORDER_CACHE
'0, 1 - ПДВ 20%
   2 - ПДВ 0%
   3 - Без ПДВ
реально зустрічаються лише значення 0 та 3';

DESCRIBE FIELD PRICE_SCHEMA TABLE WARES_ORDER_CACHE
'реально зустрічаються записи в КОЖНОМУ рекорді:
1)По цене спецпредложения свыше 10.000 пач
2)По цене спецпредложения свыше 10.000 шт
3)ТТЦ + Со скидкой: 0.00%
4)Ціна + Со скидкой: 0.00%
виникає питання - НАФІГА ?';

DESCRIBE FIELD DEALER_PRICEPROP TABLE WARES_ORDER_CACHE
'містить значення:
P - по цене спец предложения
D - обична цена
по суті замінює попередню колонку PRICE_SCHEMA';

DESCRIBE FIELD REC_NO TABLE WARES_ORDER_CACHE
'порядковий номер кожної товарної позиції в межах даного чеку';

DESCRIBE FIELD DISCOUNT TABLE WARES_ORDER_CACHE
'завжди = 0, незалежно від того була знижка чи ні
я думаю що воно не використовується';

DESCRIBE FIELD QUANTITY_IN_BASIS_RET TABLE WARES_ORDER_CACHE
'Кількість в базових одиницях, походу вираховуються з таблиці UNIT_DIMENSION';

DESCRIBE FIELD USER_CHANGE TABLE WARES_ORDER_CACHE
'Айдішка касира, який вніс зміни, або фактично створив цей запис';

DESCRIBE FIELD DATE_CHANGE TABLE WARES_ORDER_CACHE
'Дата зміни/створення запису';



/* Parameters descriptions */

DESCRIBE PARAMETER MICRO_PROC_RESULT PROCEDURE MY_MICRO_PROC
'=0 no action, =1 ok action';

