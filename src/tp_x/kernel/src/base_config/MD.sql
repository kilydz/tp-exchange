
/******************************************************************************/
/***                         User Defined Functions                         ***/
/******************************************************************************/

DECLARE EXTERNAL FUNCTION ABSRIZN
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_AbsRizn' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION AROUND
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Around' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION AROUND3
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Around3' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION AROUNDIN
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_AroundIN' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION CALCPRICEPDV
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_CalcPricePDV' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION CALCSUM
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_CalcSum' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION CALCSUMPDV
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    DOUBLE PRECISION,
    INTEGER,
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_CalcSumPDV' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION CAN_MINUS

    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_CanMinus' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION DECPART
    DOUBLE PRECISION
    RETURNS CSTRING(4)
    ENTRY_POINT '_DecPart' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION FIRSTCHAR
    CSTRING(30)
    RETURNS CSTRING(2)
    ENTRY_POINT '_FirstChar' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION FIRSTDAY
    CSTRING(12)
    RETURNS CSTRING(12)
    ENTRY_POINT '_FirstDay' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION GENDOCNUM
    CSTRING(4),
    INTEGER
    RETURNS CSTRING(14) FREE_IT
    ENTRY_POINT '_GenDocNum' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION GENNOMNUM
    INTEGER,
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_GenNomNum' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION GETINDEX
    CSTRING(10000),
    INTEGER
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_GetIndex' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION GETLENGHT
    CSTRING(254)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_GetLenght' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION INTPART
    DOUBLE PRECISION
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_IntPart' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION ISINLISTSTR
    CSTRING(10000),
    CSTRING(20)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_IsInListStr' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION ISSTRNUM
    CSTRING(256)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_IsStrNum' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION MAX2
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Max2' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION MIN2
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Min2' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION MINUS
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Minus' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION MULTI
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Multi' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION OBJECT

    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_Sklad' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION PARTPDV
    INTEGER
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_PartPDV' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION PLUS
    DOUBLE PRECISION,
    DOUBLE PRECISION
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_Plus' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION SLASHPARSER
    CSTRING(10000),
    INTEGER
    RETURNS CSTRING(256)
    ENTRY_POINT '_SlashParser' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION STRUPPER
    CSTRING(256)
    RETURNS CSTRING(256)
    ENTRY_POINT '_StrUpper' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION STRUPPER1
    CSTRING(256)
    RETURNS CSTRING(256) FREE_IT
    ENTRY_POINT '_StrUpper1' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION TOSIX
    CSTRING(7)
    RETURNS CSTRING(7)
    ENTRY_POINT '_ToSix' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION WCODE
    CSTRING(27)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_WCode' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION WINCODE
    CSTRING(27)
    RETURNS CSTRING(7)
    ENTRY_POINT '_WInCode' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION WISCODE
    CSTRING(27)
    RETURNS INTEGER BY VALUE
    ENTRY_POINT '_WIsCode' MODULE_NAME 'MainUDF.dll';


DECLARE EXTERNAL FUNCTION WWEIGHT
    CSTRING(27)
    RETURNS DOUBLE PRECISION BY VALUE
    ENTRY_POINT '_WWeight' MODULE_NAME 'MainUDF.dll';




/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_AO_RECORD_ID;
SET GENERATOR GEN_AO_RECORD_ID TO 238;

CREATE GENERATOR GEN_AUTH_ID;
SET GENERATOR GEN_AUTH_ID TO 422;

CREATE GENERATOR GEN_AUTOORDER_ID;
SET GENERATOR GEN_AUTOORDER_ID TO 59;

CREATE GENERATOR GEN_BANKS_ID;
SET GENERATOR GEN_BANKS_ID TO 355;

CREATE GENERATOR GEN_BARCODE_ID;
SET GENERATOR GEN_BARCODE_ID TO 85121;

CREATE GENERATOR GEN_CITY_ID;
SET GENERATOR GEN_CITY_ID TO 0;

CREATE GENERATOR GEN_CLIENTACCOUNT_ID;
SET GENERATOR GEN_CLIENTACCOUNT_ID TO 702;

CREATE GENERATOR GEN_CLIENTS_CARD;
SET GENERATOR GEN_CLIENTS_CARD TO 1019688;

CREATE GENERATOR GEN_CLIENTS_ID;
SET GENERATOR GEN_CLIENTS_ID TO 19178;

CREATE GENERATOR GEN_CONFIGS_ID;
SET GENERATOR GEN_CONFIGS_ID TO 64;

CREATE GENERATOR GEN_CONFIG_ID;
SET GENERATOR GEN_CONFIG_ID TO 0;

CREATE GENERATOR GEN_DISCONT_ID;
SET GENERATOR GEN_DISCONT_ID TO 6;

CREATE GENERATOR GEN_DISC_LIST_ID;
SET GENERATOR GEN_DISC_LIST_ID TO 2;

CREATE GENERATOR GEN_DOCGOODS_ID;
SET GENERATOR GEN_DOCGOODS_ID TO 1387;

CREATE GENERATOR GEN_DOCRECLOG_ID;
SET GENERATOR GEN_DOCRECLOG_ID TO 55;

CREATE GENERATOR GEN_DOCRECORD_ID;
SET GENERATOR GEN_DOCRECORD_ID TO 0;

CREATE GENERATOR GEN_DOCREC_ID;
SET GENERATOR GEN_DOCREC_ID TO 1829;

CREATE GENERATOR GEN_DOCREC_LOG_ID;
SET GENERATOR GEN_DOCREC_LOG_ID TO 253;

CREATE GENERATOR GEN_DOCUMENTS_ID;
SET GENERATOR GEN_DOCUMENTS_ID TO 1430;

CREATE GENERATOR GEN_E1C_LOG_DEBDOCS_ID;
SET GENERATOR GEN_E1C_LOG_DEBDOCS_ID TO 0;

CREATE GENERATOR GEN_E1C_LOG_DRAFTS_ID;
SET GENERATOR GEN_E1C_LOG_DRAFTS_ID TO 0;

CREATE GENERATOR GEN_GOODS_ID;
SET GENERATOR GEN_GOODS_ID TO 1;

CREATE GENERATOR GEN_GROUPS_ID;
SET GENERATOR GEN_GROUPS_ID TO 0;

CREATE GENERATOR GEN_GRPC_ID;
SET GENERATOR GEN_GRPC_ID TO 2;

CREATE GENERATOR GEN_GRP_ID;
SET GENERATOR GEN_GRP_ID TO 2;

CREATE GENERATOR GEN_JOBS_ID;
SET GENERATOR GEN_JOBS_ID TO 8;

CREATE GENERATOR GEN_KARDCODE;
SET GENERATOR GEN_KARDCODE TO 1081016;

CREATE GENERATOR GEN_KARDS_ID;
SET GENERATOR GEN_KARDS_ID TO 31535;

CREATE GENERATOR GEN_KARDS_ZVIT_LOG_ID;
SET GENERATOR GEN_KARDS_ZVIT_LOG_ID TO 4;

CREATE GENERATOR GEN_LAST_NOMEN_CODE;
SET GENERATOR GEN_LAST_NOMEN_CODE TO 300001;

CREATE GENERATOR GEN_MAKER_ID;
SET GENERATOR GEN_MAKER_ID TO 1;

CREATE GENERATOR GEN_MANAGER_ID;
SET GENERATOR GEN_MANAGER_ID TO 16;

CREATE GENERATOR GEN_NEW_TABLE_ID;
SET GENERATOR GEN_NEW_TABLE_ID TO 9;

CREATE GENERATOR GEN_NOMEN_CODE;
SET GENERATOR GEN_NOMEN_CODE TO 132;

CREATE GENERATOR GEN_NOMEN_ID;
SET GENERATOR GEN_NOMEN_ID TO 0;

CREATE GENERATOR GEN_NOM_BARS_SYNC_ID;
SET GENERATOR GEN_NOM_BARS_SYNC_ID TO 120748;

CREATE GENERATOR GEN_NOM_BAR_ID;
SET GENERATOR GEN_NOM_BAR_ID TO 94623;

CREATE GENERATOR GEN_NOM_KAS_ID;
SET GENERATOR GEN_NOM_KAS_ID TO 3172;

CREATE GENERATOR GEN_OBJECTS_ID;
SET GENERATOR GEN_OBJECTS_ID TO 2;

CREATE GENERATOR GEN_ORDERS_ID;
SET GENERATOR GEN_ORDERS_ID TO 0;

CREATE GENERATOR GEN_PACK_ID;
SET GENERATOR GEN_PACK_ID TO 13;

CREATE GENERATOR GEN_PAYMENT_ID;
SET GENERATOR GEN_PAYMENT_ID TO 0;

CREATE GENERATOR GEN_PEREPLATA_ID;
SET GENERATOR GEN_PEREPLATA_ID TO 0;

CREATE GENERATOR GEN_PERIODS_ID;
SET GENERATOR GEN_PERIODS_ID TO 1;

CREATE GENERATOR GEN_PERSON_ID;
SET GENERATOR GEN_PERSON_ID TO 0;

CREATE GENERATOR GEN_PRICEJOURNAL_ID;
SET GENERATOR GEN_PRICEJOURNAL_ID TO 103;

CREATE GENERATOR GEN_PRICE_ID;
SET GENERATOR GEN_PRICE_ID TO 0;

CREATE GENERATOR GEN_REGIONS_ID;
SET GENERATOR GEN_REGIONS_ID TO 17;

CREATE GENERATOR GEN_REGION_ID;
SET GENERATOR GEN_REGION_ID TO 0;

CREATE GENERATOR GEN_REQUESTS_ID;
SET GENERATOR GEN_REQUESTS_ID TO 0;

CREATE GENERATOR GEN_RESTS_ID;
SET GENERATOR GEN_RESTS_ID TO 30915;

CREATE GENERATOR GEN_REVISION_ID;
SET GENERATOR GEN_REVISION_ID TO 1;

CREATE GENERATOR GEN_REV_RECORDS_ID;
SET GENERATOR GEN_REV_RECORDS_ID TO 169;

CREATE GENERATOR GEN_REV_TMP_ID;
SET GENERATOR GEN_REV_TMP_ID TO 696;

CREATE GENERATOR GEN_RIGHTS_GRP_ID;
SET GENERATOR GEN_RIGHTS_GRP_ID TO 105;

CREATE GENERATOR GEN_RIGHTS_ID;
SET GENERATOR GEN_RIGHTS_ID TO 490;

CREATE GENERATOR GEN_ROLL_TAX_ID;
SET GENERATOR GEN_ROLL_TAX_ID TO 0;

CREATE GENERATOR GEN_RST_ID;
SET GENERATOR GEN_RST_ID TO 3;

CREATE GENERATOR GEN_SI_ID;
SET GENERATOR GEN_SI_ID TO 13;

CREATE GENERATOR GEN_SPECIALS_GROUPS_ID;
SET GENERATOR GEN_SPECIALS_GROUPS_ID TO 3;

CREATE GENERATOR GEN_STAFF_ID;
SET GENERATOR GEN_STAFF_ID TO 18;

CREATE GENERATOR GEN_STAFF_NUM;
SET GENERATOR GEN_STAFF_NUM TO 5;

CREATE GENERATOR GEN_STATE_ID;
SET GENERATOR GEN_STATE_ID TO 0;

CREATE GENERATOR GEN_TAXDOCS_ID;
SET GENERATOR GEN_TAXDOCS_ID TO 0;

CREATE GENERATOR GEN_TYPECLIENT_ID;
SET GENERATOR GEN_TYPECLIENT_ID TO 1;

CREATE GENERATOR GEN_T_ACCESS_ID;
SET GENERATOR GEN_T_ACCESS_ID TO 2;

CREATE GENERATOR GEN_T_ACTION_ID;
SET GENERATOR GEN_T_ACTION_ID TO 3;

CREATE GENERATOR GEN_T_CALCULATIONS_ID;
SET GENERATOR GEN_T_CALCULATIONS_ID TO 9;

CREATE GENERATOR GEN_T_CALC_RECORDS_ID;
SET GENERATOR GEN_T_CALC_RECORDS_ID TO 16;

CREATE GENERATOR GEN_T_CLIENTS_PERSONS_INT_ID;
SET GENERATOR GEN_T_CLIENTS_PERSONS_INT_ID TO 0;

CREATE GENERATOR GEN_T_CLIENTS_SYNC_ID;
SET GENERATOR GEN_T_CLIENTS_SYNC_ID TO 0;

CREATE GENERATOR GEN_T_CLIENTS_TMP_ID;
SET GENERATOR GEN_T_CLIENTS_TMP_ID TO 22;

CREATE GENERATOR GEN_T_DECREASE_ID;
SET GENERATOR GEN_T_DECREASE_ID TO 3;

CREATE GENERATOR GEN_T_DOCREC_ORDERS_INT_ID;
SET GENERATOR GEN_T_DOCREC_ORDERS_INT_ID TO 0;

CREATE GENERATOR GEN_T_EVENT_TYPES_ID;
SET GENERATOR GEN_T_EVENT_TYPES_ID TO 0;

CREATE GENERATOR GEN_T_HAPPY_CHECK_ID;
SET GENERATOR GEN_T_HAPPY_CHECK_ID TO 6;

CREATE GENERATOR GEN_T_JOBS_ID;
SET GENERATOR GEN_T_JOBS_ID TO 0;

CREATE GENERATOR GEN_T_MARKUPS_ID;
SET GENERATOR GEN_T_MARKUPS_ID TO 0;

CREATE GENERATOR GEN_T_MARKUP_RECORDS_ID;
SET GENERATOR GEN_T_MARKUP_RECORDS_ID TO 166;

CREATE GENERATOR GEN_T_ORDERS_ID;
SET GENERATOR GEN_T_ORDERS_ID TO 0;

CREATE GENERATOR GEN_T_PACTS_ID;
SET GENERATOR GEN_T_PACTS_ID TO 6;

CREATE GENERATOR GEN_T_PAYMENTS_ID;
SET GENERATOR GEN_T_PAYMENTS_ID TO 6;

CREATE GENERATOR GEN_T_PAYS_ID;
SET GENERATOR GEN_T_PAYS_ID TO 17;

CREATE GENERATOR GEN_T_POSTS_ID;
SET GENERATOR GEN_T_POSTS_ID TO 0;

CREATE GENERATOR GEN_T_PRODUCTION_DOCS_ID;
SET GENERATOR GEN_T_PRODUCTION_DOCS_ID TO 50;

CREATE GENERATOR GEN_T_PRODUCTION_RECS_ID;
SET GENERATOR GEN_T_PRODUCTION_RECS_ID TO 87;

CREATE GENERATOR GEN_T_REC_FILLINGS_ID;
SET GENERATOR GEN_T_REC_FILLINGS_ID TO 131;

CREATE GENERATOR GEN_T_RIGHTS_GRP_ID;
SET GENERATOR GEN_T_RIGHTS_GRP_ID TO 101;

CREATE GENERATOR GEN_T_RIGHTS_ID;
SET GENERATOR GEN_T_RIGHTS_ID TO 96;

CREATE GENERATOR GEN_T_SCALES_ID;
SET GENERATOR GEN_T_SCALES_ID TO 9;

CREATE GENERATOR GEN_T_SYNC_TS_ID;
SET GENERATOR GEN_T_SYNC_TS_ID TO 1;

CREATE GENERATOR GEN_T_TMP_NOMENS_ID;
SET GENERATOR GEN_T_TMP_NOMENS_ID TO 11;

CREATE GENERATOR GEN_T_TMP_NOMEN_GROUPS_ID;
SET GENERATOR GEN_T_TMP_NOMEN_GROUPS_ID TO 0;

CREATE GENERATOR GEN_T_TMP_NOM_BAR_ID;
SET GENERATOR GEN_T_TMP_NOM_BAR_ID TO 11;

CREATE GENERATOR GEN_T_TYPE_SCALES_ID;
SET GENERATOR GEN_T_TYPE_SCALES_ID TO 1;

CREATE GENERATOR GEN_T_USERS_ID;
SET GENERATOR GEN_T_USERS_ID TO 100;

CREATE GENERATOR GEN_USERS_ID;
SET GENERATOR GEN_USERS_ID TO 215;

CREATE GENERATOR GEN_WEIGHT_CODE_ID;
SET GENERATOR GEN_WEIGHT_CODE_ID TO 4;

CREATE GENERATOR IBE$LOG_TABLES_GEN;
SET GENERATOR IBE$LOG_TABLES_GEN TO 0;

CREATE GENERATOR IBE$REPORT_ID_GEN;
SET GENERATOR IBE$REPORT_ID_GEN TO 3;

CREATE GENERATOR IBE$VERSION_HISTORY_ID_GEN;
SET GENERATOR IBE$VERSION_HISTORY_ID_GEN TO 8586;

CREATE GENERATOR REESTR_GEN_ID;
SET GENERATOR REESTR_GEN_ID TO 3;

CREATE GENERATOR TMP_GEN;
SET GENERATOR TMP_GEN TO 773;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION BAD_LIKE_TYPE 'Таке перетворення документів неможливе';

CREATE EXCEPTION CANT_DEL_GRP 'Неможливо видалити непорожню групу';

CREATE EXCEPTION EX_BAD_BARCODE 'Увага, введено невірний штрихкод (наявні літери, або довжина > 14 цифр)';

CREATE EXCEPTION EX_BAD_DATE 'Дата попала в закритий період';

CREATE EXCEPTION EX_MODIF_NOM_WITH_W3 'Заборонені маніпуляції зі зведеним товаром';

CREATE EXCEPTION EX_NOT_LOCK 'Є невідвантажені документи';

CREATE EXCEPTION EX_NO_UNIQUE_SIGNATURE 'Не унікальний цифровий ключ';

CREATE EXCEPTION FUCK_YOU 'Дана група є системною, видалення заборонено';

CREATE EXCEPTION GET_ERROR 'Fatal Error: Could not read DataBase';

CREATE EXCEPTION LOW_REST 'Не вистачає товару';

CREATE EXCEPTION MINUS_SALE 'Не можна продавати товар в мінус';

CREATE EXCEPTION NOM_BAR_EXIST 'Штрихкод вже існує';

CREATE EXCEPTION NONE_GOODS 'На дану номенклатуру не заведено жодної аналітичної карточки!';

CREATE EXCEPTION NOT_DEL_SYS_RECORD 'Не можна видаляти системний запис';

CREATE EXCEPTION NOT_EDIT_SYS_RECORD 'Не можна редагувати системний запис';

CREATE EXCEPTION PERIOD_EXIST 'Даний період вже закритий';

CREATE EXCEPTION TEST1 'TEST1';

CREATE EXCEPTION TEST2 'TEST2';

CREATE EXCEPTION USER_ISNOTADMIN 'Ви не маєте права виконувати дану операцію';

CREATE EXCEPTION ZERO_GOOD_INPRICE 'Неможна створювати аналітичну карточку з нульовою вхідною ціною!';

CREATE EXCEPTION ZERO_GOOD_KILK 'Неможна вносити товар з нульовою кількістю!';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE AOG_AO_RECORD_CREATE (
    AUTOORDER_ID INTEGER,
    NOMEN_ID INTEGER,
    GRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AOG_AO_RECORDS_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    AO_RECORD_ID INTEGER,
    AOR_NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    AOR_BEGIN DOUBLE PRECISION,
    AOR_ARRIVAL DOUBLE PRECISION,
    AOR_CHARGE DOUBLE PRECISION,
    AOR_END DOUBLE PRECISION,
    AOR_MIN_REST DOUBLE PRECISION,
    AOR_REC_ORDER DOUBLE PRECISION,
    AOR_ORDERED DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AOG_AUTOORDER_CREATE
RETURNS (
    AUTOORDER_ID INTEGER,
    AO_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AOG_AUTOORDER_DEL (
    AUTOORDER_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AOG_AUTOORDER_UPDATE (
    AUTOORDER_ID INTEGER,
    NOTE VARCHAR(30),
    CLIENT_ID INTEGER,
    STAFF_ID INTEGER,
    ANALYSED_DAYS INTEGER,
    ORDERED_DAYS INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AOG_AUTOORDER_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    AO_CONDITIONS SMALLINT,
    AO_DATE DATE,
    AO_NOTE VARCHAR(30),
    AO_CLIENT_ID INTEGER,
    AO_CLIENT_NAME VARCHAR(50),
    AO_STAFF_ID INTEGER,
    AO_STAFF_NAME VARCHAR(25),
    AO_ANALYSED_DAYS SMALLINT,
    AO_ORDERED_DAYS SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AOG_AUTOORDERS_VIEW (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    AUTOORDER_ID INTEGER,
    AO_CONDITIONS SMALLINT,
    AO_DATE DATE,
    AO_NOTE VARCHAR(30),
    AO_CLIENT_ID INTEGER,
    AO_CLIENT_NAME VARCHAR(50),
    AO_STAFF_ID INTEGER,
    AO_STAFF_NAME VARCHAR(25),
    AO_ANALYSED_DAYS SMALLINT,
    AO_ORDERED_DAYS SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AOG_CORECTED_GEN_AO
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AOG_CORECTED_GEN_AOR
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE AOG_GRP_VIEW (
    GRP_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    NOMEN_ID INTEGER,
    MIN_REST DOUBLE PRECISION,
    BEGIN_K DOUBLE PRECISION,
    ARRIVAL_K DOUBLE PRECISION,
    CHARGE_K DOUBLE PRECISION,
    END_K DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AOG_NOMEN_VIEW (
    NOMEN_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    BEGIN_K DOUBLE PRECISION,
    ARRIVAL_K DOUBLE PRECISION,
    CHARGE_K DOUBLE PRECISION,
    END_K DOUBLE PRECISION,
    DATE_D DATE,
    CHECK_K DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AUTO_KARD (
    ST INTEGER,
    EN INTEGER)
RETURNS (
    SH_NAM INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE AVTO_KLIENT (
    ST INTEGER,
    EN INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE CREATE_DOC (
    VDOC_MARK VARCHAR(10),
    VOBJECTS INTEGER,
    VTYPEPAY INTEGER,
    VTYPEDOC INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE DROP_P_REYESTR_POD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RDOCUMENT_NUM VARCHAR(14),
    RCLIENT VARCHAR(40),
    RSUM_OUT_PDV DOUBLE PRECISION,
    RKILK_NAKL INTEGER,
    RSUM_OUT DOUBLE PRECISION,
    DATE_S DATE,
    DATE_E DATE,
    S_SKLAD VARCHAR(50),
    DOC_DATE DATE,
    IPN VARCHAR(20),
    NUM INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE DROP_S_DOCREC_VIEW_NAKL (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE DROP_S_ROLLTAXDOCS (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPESPAY VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_DATE DATE,
    TAX_DATE DATE,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    OPLATA_TYPE VARCHAR(30),
    DST_NAME VARCHAR(50),
    SUM_OUT DOUBLE PRECISION,
    SUM_VAT DOUBLE PRECISION,
    SUM_OUT_VAT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE E1C_CREDDOCS (
    IS_DOCS INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    IS_DOC INTEGER,
    DOC_NUM VARCHAR(14))
RETURNS (
    DOCDATE DATE,
    PARTNER VARCHAR(50),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(50),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    BANKNAME VARCHAR(40),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY INTEGER,
    SUMWITHVAT DOUBLE PRECISION,
    SUMVAT DOUBLE PRECISION,
    SUMDOC DOUBLE PRECISION,
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCID INTEGER,
    ISTAX INTEGER,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUM_VAT DOUBLE PRECISION,
    TAXSUMVAT DOUBLE PRECISION,
    TAXSUM DOUBLE PRECISION,
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE E1C_DEBDOCS (
    IS_DOCS INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    IS_DOC INTEGER,
    DOC_NUM VARCHAR(14))
RETURNS (
    DOCDATE DATE,
    PARTNER VARCHAR(50),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(50),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    BANKNAME VARCHAR(40),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY INTEGER,
    SUMIN DOUBLE PRECISION,
    SUMWITHVAT DOUBLE PRECISION,
    SUMVAT DOUBLE PRECISION,
    SUMDOC DOUBLE PRECISION,
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCID INTEGER,
    ISTAX INTEGER,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUM_VAT DOUBLE PRECISION,
    TAXSUMVAT DOUBLE PRECISION,
    TAXSUM INTEGER,
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TYPEVAT INTEGER,
    TYPEDOC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE E1C_DRAFTS (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    KASS_NUM VARCHAR(12),
    DOCDATE DATE,
    SUMOUT_VAT DOUBLE PRECISION,
    SUMOUTVAT DOUBLE PRECISION,
    SUMOUT DOUBLE PRECISION,
    SUMIN DOUBLE PRECISION,
    TYPEVAT INTEGER,
    ISEDIT INTEGER,
    TYPEPAY SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE E1C_DRAFTS_DETAIL (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    KASS_NUM VARCHAR(12),
    DOCDATE DATE,
    SUMOUT_VAT DOUBLE PRECISION,
    SUMOUTVAT DOUBLE PRECISION,
    SUMOUT DOUBLE PRECISION,
    SUMIN DOUBLE PRECISION,
    TYPEVAT INTEGER,
    TYPEPAY SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE E1C_INIT_LD_ID
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE GET_USER_ID (
    I_USER_NAME VARCHAR(12))
RETURNS (
    O_USER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE HAS_USER_RIGHT (
    I_USER_ID INTEGER,
    I_RIGHT_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_BAK_FOR_DATEX (
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VDOC_NUM VARCHAR(14))
RETURNS (
    RTYPEPDV INTEGER,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CHECK (
    VDOC INTEGER)
RETURNS (
    RTYPEPDV INTEGER,
    RKILK DOUBLE PRECISION,
    RPRICE DOUBLE PRECISION,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(26),
    RIS_WEIGHT INTEGER,
    RPERSENT DOUBLE PRECISION,
    RCODE VARCHAR(7),
    RALL_DISCOUNT_VALUE DOUBLE PRECISION,
    RNOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CHECK_ART (
    VDOC INTEGER,
    VKASSES_ID INTEGER)
RETURNS (
    RART_NUM INTEGER,
    RTYPEPDV INTEGER,
    RKILK DOUBLE PRECISION,
    RPRICE DOUBLE PRECISION,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(26),
    RIS_WEIGHT INTEGER,
    RPERSENT DOUBLE PRECISION,
    RCODE VARCHAR(7),
    RALL_DISCOUNT_VALUE DOUBLE PRECISION,
    RNOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CLOSE_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_CLOSE_DOCUM (
    VDOC_ID INTEGER,
    VTYPE_DOC INTEGER,
    VOPLATA_TYPE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_CLOSE_DOCUMENT (
    IDOCUMENT_ID INTEGER,
    ITYPE_DOC INTEGER,
    IOPLATA_TYPE INTEGER,
    IKASSES_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_COUPONS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUPON_EAN_ID BIGINT,
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CREATE_BAK (
    VDOC_NUM VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CREATE_BAK_V1 (
    VDOC_NUM VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CREATE_DOC
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_CREATE_DOC_V1
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DEL_DOCREC (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RDOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DEL_DOCREC_V1 (
    VDOCREC_ID INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DISCONT (
    VKARDCODE VARCHAR(16))
RETURNS (
    RNAME VARCHAR(50),
    RPROCENT DOUBLE PRECISION,
    RCLIENTS_ID INTEGER,
    RDISCONT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DISCONT_HARD (
    VDOCUMENT_ID INTEGER,
    VSUMA_FULL DOUBLE PRECISION)
RETURNS (
    RDISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOC_REC (
    VDOC_ID INTEGER,
    VPERCENT DOUBLE PRECISION,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RDOCREC_ID INTEGER,
    RDOCUMENT_ID INTEGER,
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RPRICE DOUBLE PRECISION,
    RKILK DOUBLE PRECISION,
    RIS_WEIGHT INTEGER,
    RNOMEN_CODE VARCHAR(7))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOC_SUM (
    VDOC_ID INTEGER,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOC_SUM_ALL (
    VDOC_ID INTEGER,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RPERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOC_SUM_ALL_1 (
    VDOC_ID INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION,
    RPERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOCREC_SUM (
    VDOCREC_ID INTEGER,
    VPERCENT DOUBLE PRECISION,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUMMA_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOCREC_VIEW (
    VDOC_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
RETURNS (
    RSUM DOUBLE PRECISION,
    RDOCREC_ID INTEGER,
    RDOCUMENT_ID INTEGER,
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RPRICE DOUBLE PRECISION,
    RKILK DOUBLE PRECISION,
    RIS_WEIGHT INTEGER,
    RNOMEN_CODE VARCHAR(7))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_DOCUMENTS_VIEW (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12))
RETURNS (
    RDOC_ID INTEGER,
    RDOC_NUM VARCHAR(14),
    RDOC_LOCK SMALLINT,
    RBLOK SMALLINT,
    RDOCSUM DOUBLE PRECISION,
    ROPLATA_TYPE INTEGER,
    RTYPE_DOC INTEGER,
    RTIME TIME)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_EXP_RST
RETURNS (
    RST_ID INTEGER,
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER,
    REST DOUBLE PRECISION,
    REST_SUM DOUBLE PRECISION,
    LAST_INPRICE DOUBLE PRECISION,
    TS TIMESTAMP,
    HAS_GOODS SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_INS_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_INS_DOCREC_V1 (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RKILK DOUBLE PRECISION,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT,
    RIS_IN_DISCOUNT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_LAST_DOCUM
RETURNS (
    RDOC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_LIST_DOC (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12),
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RDOC_ID INTEGER,
    RDOC_NUM VARCHAR(14),
    RDOC_LOCK SMALLINT,
    RBLOK SMALLINT,
    RDOCSUM DOUBLE PRECISION,
    ROPLATA_TYPE INTEGER,
    RTYPE_DOC INTEGER,
    RTIME TIME)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_LIST_DOC_SUM (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12),
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RDOCSUM DOUBLE PRECISION,
    RDOCSUM_K DOUBLE PRECISION,
    RDOC_CONT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_NOMEN_REST (
    VNOMEN_ID INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SEL_TOVAR_BY_CODE (
    VINP_FILTER VARCHAR(27))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER,
    RKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SEL_TOVAR_BY_NAME (
    VINP_FILTER VARCHAR(40))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SEL_TOVAR_BY_NAME_FILTER (
    VINP_FILTER VARCHAR(40),
    VFILTER VARCHAR(40))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SEL_TOVAR_BY_NOMEN_ID (
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RIS_WEIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SET_COUPON (
    IDOCUMENT_ID INTEGER,
    ICOUPON_EAN_ID BIGINT)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SET_DISCONT (
    VDOC_ID INTEGER,
    VDISCONT_ID INTEGER,
    VCLIENTS_ID INTEGER,
    VDISC_PERCENT DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_SYNC_CLOSE_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_SYNC_CLOSE_DOCUMENT (
    IDOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE KAS_SYNC_EXP_CHECK_RECS (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODATE_CR DATE,
    OTIME_CR TIME,
    OUSER_CR VARCHAR(50),
    ODISC_PERSENT DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OIS_IN_DISCOUNT SMALLINT,
    OUSER_CONFIRM VARCHAR(155),
    OTS TIMESTAMP,
    OCOUPON_EAN_ID BIGINT,
    OSKU_QUANTITY DOUBLE PRECISION,
    ODISCOUNT_VALUE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_EXP_CHECKS
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    ODOC_NUM VARCHAR(14),
    ODOC_MARK VARCHAR(14),
    OTYPEDOC_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE_CR DATE,
    ODOC_SUM DOUBLE PRECISION,
    ODOC_LOCK SMALLINT,
    OUSER_NAME VARCHAR(50),
    OBLOK INTEGER,
    OAUTH_ID INTEGER,
    ODISCONT_ID INTEGER,
    ODISC_PERSENT DOUBLE PRECISION,
    OLOCK_DATE DATE,
    OOPLATA_STATE SMALLINT,
    OOPLATA_TYPE SMALLINT,
    OTIME_CR TIME,
    ODELAY_PAY INTEGER,
    ONOTARIZATION VARCHAR(50),
    OKARDS_ID INTEGER,
    OTIME_FIX TIME,
    OKASSES_ID INTEGER,
    OMAKER_ID INTEGER,
    ORESERVING_TIME SMALLINT,
    OPREW_DOCUMENT_ID INTEGER,
    OTS TIMESTAMP,
    OLIGHT SMALLINT,
    OCOUPON_EAN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOC_DEL (
    IDOCUMENT_ID INTEGER,
    IDOC_DATE DATE,
    IDOC_NUM VARCHAR(14),
    IDOC_MARK VARCHAR(14),
    ITYPEDOC_ID INTEGER,
    IOBJECTS_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IDOC_LOCK SMALLINT,
    IUSER_NAME VARCHAR(12),
    IDISCONT_ID INTEGER,
    IDISC_PERSENT DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP)
RETURNS (
    OREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOC_REC (
    IDOCUMENT_ID INTEGER,
    IDOCREC_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDATE_CR DATE,
    ITIME_CR TIME,
    IUSER_CR VARCHAR(50),
    IDISC_PERSENT DOUBLE PRECISION,
    ITYPEPDV_ID INTEGER,
    ITYPEPDV_PDV DOUBLE PRECISION,
    IINSUM_PDV DOUBLE PRECISION,
    IINSUM DOUBLE PRECISION,
    IIS_IN_DISCOUNT SMALLINT,
    IUSER_CONFIRM VARCHAR(155),
    ITS TIMESTAMP,
    ICOUPON_EAN_ID BIGINT,
    ISKU_QUANTITY DOUBLE PRECISION,
    IDISCOUNT_VALUE DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOCREC_DEL (
    IDOCREC_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOCREC_LOG (
    IDOCUMENT_ID INTEGER,
    IDOC_NUM VARCHAR(14),
    IDOC_DATE DATE,
    ITYPEDOC_ID INTEGER,
    ICLIENTS_ID INTEGER,
    IDOCREC_ID INTEGER,
    INOMEN_ID INTEGER,
    IPRICE DOUBLE PRECISION,
    IKILK_OLD DOUBLE PRECISION,
    IKILK_NEW DOUBLE PRECISION,
    ITYPE_UPD SMALLINT,
    IUSER_CRT VARCHAR(12),
    IDATE_CRT TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOCREC_TMP (
    IDOCREC_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_SYNC_IMP_DOCUMENT (
    IDOCUMENT_ID INTEGER,
    IDOC_DATE DATE,
    IDOC_NUM VARCHAR(14),
    IDOC_MARK VARCHAR(14),
    ITYPEDOC_ID INTEGER,
    IOBJECTS_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IDATE_CR DATE,
    IDOC_SUM DOUBLE PRECISION,
    IDOC_LOCK SMALLINT,
    IUSER_NAME VARCHAR(50),
    IBLOK INTEGER,
    IAUTH_ID INTEGER,
    IDISCONT_ID INTEGER,
    IDISC_PERSENT DOUBLE PRECISION,
    ILOCK_DATE DATE,
    IOPLATA_STATE SMALLINT,
    IOPLATA_TYPE SMALLINT,
    ITIME_CR TIME,
    IDELAY_PAY INTEGER,
    INOTARIZATION VARCHAR(50),
    IKARDS_ID INTEGER,
    ITIME_FIX TIME,
    IKASSES_ID INTEGER,
    IMAKER_ID INTEGER,
    IRESERVING_TIME SMALLINT,
    IPREW_DOCUMENT_ID INTEGER,
    ITS TIMESTAMP,
    ILIGHT SMALLINT,
    ICOUPON_EAN_ID BIGINT,
    ISTORE_DOC_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_UPD_DOCREC (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE KAS_UPD_DOCREC_V1 (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RKILK DOUBLE PRECISION,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT,
    RIS_IN_DISCOUNT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_HAS_USER_ACCESS (
    I_USER_ID INTEGER,
    I_ACCESS_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_INVOICES_LIST (
    ILIST_ID VARCHAR(10000))
RETURNS (
    OINVOICE_ID INTEGER,
    OQ_HEADER VARCHAR(256),
    OQ_RECORDS VARCHAR(256),
    OQ_UPD_AFTER VARCHAR(256),
    OFRF_FILTER VARCHAR(64),
    OFRF_DESCRIPTOR VARCHAR(256),
    OACCESS_ID INTEGER,
    ORIGHTS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_IS_ACCESS_GRANDED (
    I_ACCESS_ID INTEGER,
    I_RIGHTS_GRP_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_REEST_DEL (
    DAT1 DATE,
    DAT2 DATE)
RETURNS (
    RE_NUM INTEGER,
    RE_DAT DATE,
    RE_USE VARCHAR(12),
    D_DOK_NUM VARCHAR(14),
    D_DOK_SUM DOUBLE PRECISION,
    D_CLI VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_REESTR_ADD (
    DOCUMENT_ID INTEGER)
RETURNS (
    REZULT CHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_REYESTR_POD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RDOCUMENT_NUM VARCHAR(14),
    RCLIENT VARCHAR(40),
    RSUM_OUT_PDV DOUBLE PRECISION,
    RKILK_NAKL INTEGER,
    RSUM_OUT DOUBLE PRECISION,
    DATE_S DATE,
    DATE_E DATE,
    S_SKLAD VARCHAR(50),
    DOC_DATE DATE,
    IPN VARCHAR(20),
    NUM INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_SELECT_ACCESS (
    I_RIGHTS_GRP_ID INTEGER)
RETURNS (
    O_ACCESS_ID INTEGER,
    O_NAME VARCHAR(120),
    O_PARENT INTEGER,
    O_IMAGE_INDEX INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE P_STAFF_UPD (
    STAFF_ID INTEGER,
    STAFF_NUM VARCHAR(7),
    SURNAME VARCHAR(20),
    NAME VARCHAR(20),
    PATRONYMIC VARCHAR(20),
    DATE_BIRTH DATE,
    JOB_START DATE,
    JOB_END DATE,
    PASPORT VARCHAR(10),
    VIDANO VARCHAR(30),
    JOB INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PA_ADMIN_RIGHTS_SET
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PA_GET_USER_ID (
    I_USER_NAME VARCHAR(12))
RETURNS (
    O_USER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_GROUP_DEL (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_GROUP_INS (
    INAME VARCHAR(50))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_GROUP_UPD (
    IID INTEGER,
    INAME VARCHAR(50))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_GROUP_VIEW (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_GROUPS_VIEW
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_HAS_USER_ACCESS (
    IUSER_ID INTEGER,
    IACCESS_ID INTEGER)
RETURNS (
    ORESULT INTEGER,
    OACCESS_NAME VARCHAR(120))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_HAS_USER_ACCESS_V1 (
    I_USER_ID INTEGER,
    I_ACCESS_ID INTEGER)
RETURNS (
    O_RESULT INTEGER,
    O_ACCESS_NAME VARCHAR(120))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USER_DEL (
    IUSER_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USER_INS (
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USER_INS_V1 (
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3),
    ISIGNATURE VARCHAR(128))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USER_UPD (
    IID INTEGER,
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USER_VIEW (
    IUSER_ID INTEGER)
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OSURNAME VARCHAR(50),
    OFIRST_NAME VARCHAR(50),
    OSECOND_NAME VARCHAR(50),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USERS_FROM_GROUP (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PA_USERS_VIEW
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_CITY_INS (
    INAME VARCHAR(40),
    IREGION_ID INTEGER,
    ICITY_TYPE SMALLINT)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_CITY_UPD (
    IID INTEGER,
    INAME VARCHAR(40),
    IREGION_ID INTEGER,
    ICITY_TYPE SMALLINT)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENTS_CODE VARCHAR(7),
    OSHORTNAME VARCHAR(30),
    ONAME VARCHAR(50),
    OFULL_NAME VARCHAR(83),
    OTYPECLIENT_ID INTEGER,
    OTYPECLIENT VARCHAR(40),
    OADDRESS VARCHAR(50),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_CLIENTS_VIEW (
    IZKPO VARCHAR(20))
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENTS_CODE VARCHAR(7),
    OSHORTNAME VARCHAR(30),
    ONAME VARCHAR(50),
    OFULL_NAME VARCHAR(83),
    OTYPECLIENT_ID INTEGER,
    OTYPECLIENT VARCHAR(40),
    OADDRESS VARCHAR(50),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OZKPO VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_POST_INS (
    INAME VARCHAR(40))
RETURNS (
    OPOST_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_POST_UPD (
    IPOST_ID INTEGER,
    INAME VARCHAR(40))
RETURNS (
    OPOST_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_POST_VIEW (
    IPOST_ID INTEGER)
RETURNS (
    OPOST_ID INTEGER,
    ONAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_POSTS_VIEW
RETURNS (
    OPOST_ID INTEGER,
    ONAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_REGION_DEL (
    IREGION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_REGION_INS (
    INAME VARCHAR(40),
    ISTATE_ID INTEGER)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_REGION_UPD (
    IID INTEGER,
    INAME VARCHAR(40),
    ISTATE_ID INTEGER)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_STATE_DEL (
    ISTATE_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_STATE_INS (
    INAME VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PC_STATE_UPD (
    IID INTEGER,
    INAME VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000))
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_LOG_EDIT (
    IDOCDATE DATE,
    ITYPEVAT SMALLINT,
    ISUMWITHVAT NUMERIC(9,2),
    ISUMVAT NUMERIC(9,2),
    ISUMDOC NUMERIC(9,2),
    ISUMIN NUMERIC(9,2),
    IDOCMARCK VARCHAR(14),
    IDOCUMENT_ID INTEGER,
    IISTAX SMALLINT,
    ITAXNUM VARCHAR(20),
    ITAXDATE DATE,
    ITAXSUMWITHVAT NUMERIC(9,2),
    ITAXSUMVAT NUMERIC(9,2),
    ITAXSUM NUMERIC(9,2),
    ITYPEPAY INTEGER)
RETURNS (
    OISEDIT1 INTEGER,
    OISEDIT2 INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_PERIODIC_ADD (
    IPERIODIC_ID DATE,
    IFINAL_DATE DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PE_1C_PERIODICS_VIEW
RETURNS (
    OPERIODIC_ID DATE,
    OSUM_X DOUBLE PRECISION,
    OFINAL_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_SUMS_1 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_SUMS_1_WITHOUT_PDV (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_SUMS_2 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER,
    SUMREAL NUMERIC(9,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PE_1C_V1 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER,
    OIS_FINAL SMALLINT,
    SUMREAL NUMERIC(9,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_CALCULATION
RETURNS (
    OCALCULATION_ID INTEGER,
    OCALC_NOMEN_ID INTEGER,
    OCALC_NOMEN_CODE VARCHAR(7),
    OCALC_NOMEN_NAME VARCHAR(40),
    OREC_NOMEN_ID INTEGER,
    OREC_NOMEN_CODE VARCHAR(7),
    OREC_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_CLIENT_HEADER (
    ICLIENT_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OOBJECT_NAME VARCHAR(50),
    OOBJECT_SHOT_NAME VARCHAR(30),
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHOT_NAME VARCHAR(30),
    ODATE0 DATE,
    ODATE1 DATE,
    OOBJECT_ADRESS VARCHAR(50),
    OCLIENT_ADRESS VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DEBITORKA (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DEBITORKA_CLNT_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    ONOMEN_NAME VARCHAR(40),
    OPAY_ID VARCHAR(14),
    OTYPE_PAY_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OIN_DEBT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DEBITORKA_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DISCOUNT_RALASE (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OKARDCODE VARCHAR(13),
    ONAME VARCHAR(50),
    OPERCENT DOUBLE PRECISION,
    ODOC_DATE DATE,
    ODOC_TIME TIME,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DOC_DEL (
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    ONOMEN_CODE VARCHAR(7),
    OCLIENT_NAME VARCHAR(50),
    OOBJECT_NAME VARCHAR(50),
    ONOMEN_NAME VARCHAR(40),
    OTYPEPDV_NAME VARCHAR(40),
    OTYPEDOC_NAME VARCHAR(30),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OUSER_NAME VARCHAR(12),
    OUSER_FULL_NAME VARCHAR(155),
    OUSER_DOCREC_NAME VARCHAR(12),
    ODOCUMENT_ID INTEGER,
    OWHATDO VARCHAR(30),
    ODOC_DATE DATE,
    ODOC_NUM VARCHAR(14),
    ODOC_MARK VARCHAR(14),
    OUSER_CONFIRM VARCHAR(155))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DOCREC_SUM_TYPY_PDV (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION,
    TYPE_PDV INTEGER)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DOCUMENTS_PERIOD (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER,
    ITYPE_PDV INTEGER)
RETURNS (
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OCLIENT_NAME VARCHAR(50),
    OINSUM DOUBLE PRECISION,
    OOUTSUM DOUBLE PRECISION,
    OMARKUP DOUBLE PRECISION,
    ODISCOUNT_SUM DOUBLE PRECISION,
    OPDV_SUM DOUBLE PRECISION,
    OOUTSUM_PDV DOUBLE PRECISION,
    OSTORE_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_DOCUMENTS_PERIOD_HEADER (
    DOCUMENT_ID INTEGER,
    DATE0 DATE,
    DATE1 DATE,
    ITYPE_PDV INTEGER)
RETURNS (
    ODATE0 DATE,
    ODATE1 DATE,
    OEND_INSUM DOUBLE PRECISION,
    OEND_OUTSUM DOUBLE PRECISION,
    OROZH_INSUM DOUBLE PRECISION,
    OROZH_OUTSUM DOUBLE PRECISION,
    OPRIH_INSUM DOUBLE PRECISION,
    OPRIH_OUTSUM DOUBLE PRECISION,
    OBEGIN_INSUM DOUBLE PRECISION,
    OBEGIN_OUTSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_INVOICE_PAYS_DEBT (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER,
    OPAY_ID INTEGER,
    OAMOUNT_DAYS SMALLINT,
    OREAL_DEBT_SUM DOUBLE PRECISION,
    OFORMAL_DEBT_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_INVOICE_PAYS_KRED (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER,
    OPAY_ID INTEGER,
    OAMOUNT_DAYS SMALLINT,
    OREAL_DEBT_SUM DOUBLE PRECISION,
    OFORMAL_DEBT_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_KARDS_RALASE (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OKARDCODE VARCHAR(13),
    ONAME VARCHAR(50),
    OPROCENT DOUBLE PRECISION,
    OSUMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_KREDITORKA (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_KREDITORKA_CLNT_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    ONOMEN_NAME VARCHAR(40),
    OPAY_ID VARCHAR(14),
    OTYPE_PAY_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OIN_DEBT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_KREDITORKA_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_LIGHTS (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OLOGIN VARCHAR(12),
    ONAME VARCHAR(170),
    ONOT_GOOD_COUNT INTEGER,
    OINDIFFERENTLY_COUNT INTEGER,
    OGOOD_COUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_LIST_CHARGES (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODATEX_NAME VARCHAR(26),
    ONOMEN_NAME VARCHAR(50),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OSI_NAME VARCHAR(12),
    ODR_KILK DOUBLE PRECISION,
    ODR_IN_SUM DOUBLE PRECISION,
    ODR_SUM_OUT DOUBLE PRECISION,
    ODR_NATSINKA DOUBLE PRECISION,
    ODR_PDV DOUBLE PRECISION,
    ODR_SUM_OUT_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_MAKER (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OMAKER_NAME VARCHAR(40),
    OSUM_TD2 DOUBLE PRECISION,
    OSUM_TD2_PDV DOUBLE PRECISION,
    OKILK_TD2 DOUBLE PRECISION,
    OSUM_TD17 DOUBLE PRECISION,
    OSUM_TD17_PDV DOUBLE PRECISION,
    OKILK_TD17 DOUBLE PRECISION,
    ODELTA_SUM DOUBLE PRECISION,
    ODELTA_SUM_PDV DOUBLE PRECISION,
    ODELTA_KILK DOUBLE PRECISION,
    OMAKER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NILSEN (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    BARCODE VARCHAR(27),
    BARNAME VARCHAR(50),
    STOCK NUMERIC(10,2),
    SALESITEM NUMERIC(10,2),
    PRICE NUMERIC(10,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NILSEN_V1 (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    BARCODE VARCHAR(27),
    BARNAME VARCHAR(50),
    STOCK NUMERIC(10,2),
    SALESITEM NUMERIC(10,2),
    PRICE NUMERIC(10,2),
    GRP_ID INTEGER,
    GRP_FULLNAME VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMEN_REV (
    IDATE0 DATE,
    IDATE1 DATE,
    IGRP_ID INTEGER)
RETURNS (
    OW3_NOMEN_ID INTEGER,
    ONOMEN_MANE VARCHAR(50),
    ONOMEN_CODE VARCHAR(7),
    OIS_VISIBLE INTEGER,
    ORGP_NAME VARCHAR(255),
    OGRP_ID INTEGER,
    OREST DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMEN_WITH_BARCODE (
    ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OBARCODE VARCHAR(27))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMENREPORT (
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    ODOC_MARK VARCHAR(14),
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    ODATE_CR DATE,
    OZKPO VARCHAR(20),
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OIN_SUMALL DOUBLE PRECISION,
    OIN_SUMALLPDV DOUBLE PRECISION,
    OINCOMINGDOC_SUM_TARE DOUBLE PRECISION,
    OINCOMINGDOC_SUM_NOTPDV DOUBLE PRECISION,
    OINCOMINGDOC_SUM_PDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV_TARE DOUBLE PRECISION,
    OOUTGOINGDOC_SUM_NOTPDV DOUBLE PRECISION,
    OOUT_SUM_TAX_OUTPDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMENREPORT_MARKUPS (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMENSRESTS (
    IDATE DATE)
RETURNS (
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_NOMENZVIT (
    IDATE DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    OSUM DOUBLE PRECISION,
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OMARKUPDOC DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE (
    IDATE0 DATE,
    IDATE1 DATE,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_MAKER (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPRIHOD_K NUMERIC(15,2),
    ORASHOD_K NUMERIC(15,2),
    OPRIHOD_S NUMERIC(15,2),
    ORASHOD_S_PDV NUMERIC(15,2),
    OIN_SUM NUMERIC(15,2),
    ONACINKA NUMERIC(15,2),
    OPDV NUMERIC(15,2),
    ORASHOD_S NUMERIC(15,2),
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    OPRIHOD_S_PDV NUMERIC(15,2))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NILSEN (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    P_K DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    E_K DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    B_S_OUT DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    E_S_OUT DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN_ACTION (
    DATE_IN DATE,
    DATE_OUT DATE,
    DATE_IN1 DATE,
    DATE_OUT1 DATE,
    ACTION_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    B_K1 DOUBLE PRECISION,
    P_K1 DOUBLE PRECISION,
    P_S_IN1 DOUBLE PRECISION,
    P_S_OUT1 DOUBLE PRECISION,
    R_K1 DOUBLE PRECISION,
    R_S_IN1 DOUBLE PRECISION,
    R_S_VAT1 DOUBLE PRECISION,
    R_S_OUT1 DOUBLE PRECISION,
    E_K1 DOUBLE PRECISION,
    E_S_IN1 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN_HEADER (
    DOCUMENT_ID INTEGER,
    DATE0 DATE,
    DATE1 DATE)
RETURNS (
    ODEB_SUM0 DOUBLE PRECISION,
    OREALIZ_SUM DOUBLE PRECISION,
    OPAY_SUM DOUBLE PRECISION,
    OPOVERN_SUM DOUBLE PRECISION,
    ODATE0 DATE,
    ODATE1 DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN_PERIOD (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OTYPE_DOC_NAME VARCHAR(30),
    OTYPE_PAY_NAME VARCHAR(30),
    ODOC_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN_V1 (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_NOMEN_V2 (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    E_S_IN DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASE_SALES (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_RALASETYPEPDV_BYGROUP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER,
    RPER_NAC_OFIC DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_REGISTER_INVOICES_OUT (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODATE DATE,
    ONUMBER VARCHAR(14),
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    ONATSINKA DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_REPORT_DETAIL (
    IREPORT_ID INTEGER)
RETURNS (
    OLABEL VARCHAR(100),
    ODESCRIPT VARCHAR(50),
    OTYPE SMALLINT,
    OPOSITION INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_REPORTS_VIEW
RETURNS (
    OREPORT_ID INTEGER,
    ONAME VARCHAR(50),
    ODESCRIPT VARCHAR(1024),
    OFIELDS_CNT INTEGER,
    OPARAMS_CNT INTEGER,
    OIS_ENABLED SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PR_REVISION_LIST (
    IDATE DATE)
RETURNS (
    OGRP_CODE INTEGER,
    OGRP_NAME VARCHAR(40),
    ONOMEN_CODE VARCHAR(7),
    OBARCODE VARCHAR(27),
    ONOMEN_NAME VARCHAR(40),
    OSI_NAME VARCHAR(12),
    OKILK_OLD DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OSUM_PROGRAM DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OSUM_REAL DOUBLE PRECISION,
    OKILK_RIZN DOUBLE PRECISION,
    OSUM_RIZN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_BARCODES_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OCODE VARCHAR(27))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_ISBLOCK (
    IREVISION_ID INTEGER)
RETURNS (
    OIS_BLOCK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_NOM_BARS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OBARCODE_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_NOMENS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    ONAME VARCHAR(40),
    OIS_DIVIDEND SMALLINT,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OIN_PRICE_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_REV_RECORD_UPD (
    IREV_RECORD_ID INTEGER,
    IKILK_NEW DOUBLE PRECISION,
    IFLAG SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PRV_REV_RECORDS_VIEW_IMP (
    IREVISION_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER,
    OREVISION_ID INTEGER,
    ONOMEN_ID INTEGER,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_REVISION_DETAIL (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OKILK_RIZN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_REVISION_UPD (
    IREVISION_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PRV_REVISION_VIEW (
    IREVISION_ID INTEGER,
    ILIST VARCHAR(10000))
RETURNS (
    OREVISION_ID INTEGER,
    OIS_BLOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OIS_INLBD SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_REVISIONS_VIEW (
    ILIST VARCHAR(10000))
RETURNS (
    OREVISION_ID INTEGER,
    OIS_BLOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OIS_INLBD SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PRV_REVISIONS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    OREVISION_ID INTEGER,
    OREVISION_DATE DATE,
    OTOKEN VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_ACCOUNT_INS (
    ICLIENT_ID INTEGER,
    IACCOUNT_NUM VARCHAR(20),
    IBANK_ID INTEGER)
RETURNS (
    OACCOUNT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_ACCOUNT_UPD (
    IACCOUNT_ID INTEGER,
    IACCOUNT_NUM VARCHAR(20),
    IBANK_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_ACCOUNTS_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OACCOUNT_NUM VARCHAR(20),
    OBANK_NAME VARCHAR(40),
    OMFO VARCHAR(20),
    OACCOUNT_ID INTEGER,
    OBANK_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_CREATE_TD1 (
    ILIST_OF_ID VARCHAR(1000))
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_CREATE_TD1_INFO (
    ILIST_OF_ID VARCHAR(1000))
RETURNS (
    OMESSAGE VARCHAR(256))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_DEL_REPEAT_RECS (
    IAUTOORDER_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_AO_DEL_ZERO_RECS (
    IAUTOORDER_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_AO_RECORD_DEL (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORD_GRP_INS (
    AUTOORDER_ID INTEGER,
    GRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_AO_RECORD_INS (
    IAUTOORDER_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORD_VIEW (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORD_VIEW_V1 (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORDS_PRINT (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION,
    OBARCODE VARCHAR(20),
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORDS_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AO_RECORDS_VIEW_V1 (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDER_DEL (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDER_DETAIL (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OAUTOORDER_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN_K DOUBLE PRECISION,
    OARRIVAL_K DOUBLE PRECISION,
    OCHARGE_K DOUBLE PRECISION,
    OEND_K DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDER_FIX (
    IAUTOORDER_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_AUTOORDER_HEADER_VIEW (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(30),
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OAUTOORDER_ID INTEGER,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_ADRESS VARCHAR(50),
    OCLIENT_PHONE VARCHAR(24),
    OOBJECT_NAME VARCHAR(50),
    OOBJECT_ADRESS VARCHAR(50),
    OOBJECT_PHONE VARCHAR(24),
    ODATE_IN DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDER_INS (
    ITOKEN VARCHAR(30),
    ICLIENT_ID INTEGER,
    ILIABLE_ID INTEGER,
    IANALYSED INTEGER,
    IORDERED INTEGER)
RETURNS (
    OAUTOORDER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDER_VIEW (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(30),
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OCLIENT_NAME VARCHAR(50),
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OAUTOORDER_ID INTEGER,
    OIN_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_AUTOORDERS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(30),
    OAUTOORDER_ID INTEGER,
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OCLIENT_NAME VARCHAR(50),
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OIN_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_BANK_DEL (
    IBANK_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_BANK_INS (
    INAME VARCHAR(40),
    IMFO VARCHAR(20))
RETURNS (
    OBANK_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_BARCODE_INS (
    IBARCODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
RETURNS (
    OBARCODE_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_BARCODE_UPD (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_BARCODES_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OBARCODE VARCHAR(27),
    OOUT_PRICE DOUBLE PRECISION,
    OBARCODE_TYPE_ID INTEGER,
    OTYPE_NAME VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALC_RECORD_DEL (
    ICALC_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALC_RECORD_INS (
    ICALCULATION_ID INTEGER,
    INOMEN_ID INTEGER,
    IINPUT_QUANTITY DOUBLE PRECISION,
    INETTO DOUBLE PRECISION)
RETURNS (
    OCALC_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALC_RECORD_UPD (
    ICALC_RECORD_ID INTEGER,
    IINPUT_QUANTITY DOUBLE PRECISION,
    INETTO DOUBLE PRECISION)
RETURNS (
    OCALC_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALC_RECORD_VIEW (
    ICALC_RECORD_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OINPUT_QUANTITY DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALC_RECORDS_VIEW (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OINPUT_QUANTITY DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_DEL (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_HEADER (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODATEX_NAME VARCHAR(26),
    OTYPEPDV_ID INTEGER,
    OBRUTTO DOUBLE PRECISION,
    OSI_ID INTEGER,
    OOUT_PRICE DOUBLE PRECISION,
    OSG_ID INTEGER,
    OSI_NAME VARCHAR(12),
    OOBJECT_NAME VARCHAR(50),
    OIN_PRICE DOUBLE PRECISION,
    OIN_PRICE_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_INFO (
    ICALCULATION_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_INS (
    INOMEN_ID INTEGER,
    IOUTPUT_QUANTITY DOUBLE PRECISION)
RETURNS (
    OCALCULATION_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_PRINT (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    OBRUTTO DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODATEX_NAME VARCHAR(26),
    OTYPEPDV_ID INTEGER,
    ONOM_BRUTTO DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OSG_ID INTEGER,
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION,
    OLAST_IN_KILK DOUBLE PRECISION,
    OSI_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_UPD (
    ICALCULATION_ID INTEGER,
    IOUTPUT_QUANTITY DOUBLE PRECISION)
RETURNS (
    OCALCULATION_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATION_VIEW (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CALCULATIONS_VIEW (
    IGRP_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_DEL (
    ICLIENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_DETAIL (
    ICLIENT_ID INTEGER)
RETURNS (
    OACCOUNT_ID INTEGER,
    OACCOUNT_NUM VARCHAR(20),
    ONAME VARCHAR(40),
    OMFO VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_INS (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20))
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_INS_V1 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50))
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_INS_V2 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50),
    IEMAIL VARCHAR(60))
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_INS_V3 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50),
    IEMAIL VARCHAR(60),
    IDISC_PERCENT DOUBLE PRECISION,
    IAMOUNT_DAYS SMALLINT,
    IPOSSIBLE_DEBT DOUBLE PRECISION,
    IIS_VISIBLE INTEGER)
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_SYNC_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_TMP_DEL (
    ICLIENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_TMP_INS (
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    INOTE VARCHAR(512))
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_TMP_LIKE_INS (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_TMP_UPD (
    ICLIENT_ID INTEGER,
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    INOTE VARCHAR(512))
RETURNS (
    OCLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_TMP_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ODATE_LAST_MODEFICATION DATE,
    OTYPECLIENT_NAME VARCHAR(40),
    ONOTE VARCHAR(512))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_UNITE (
    ICLIENT0_ID INTEGER,
    ICLIENT1_ID INTEGER)
RETURNS (
    OENABLED INTEGER,
    OMESSAGE VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_UNITE_INFO (
    ICLIENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    ODELIV_ADDR VARCHAR(50),
    OZKPO VARCHAR(20),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_LINK_VIEW
RETURNS (
    W3_CLIENT_ID INTEGER,
    TYPECLIENT_ID INTEGER,
    NAME VARCHAR(50),
    ADRESS VARCHAR(50),
    ZKPO VARCHAR(20),
    IS_PDV SMALLINT,
    IS_ACTIVE SMALLINT,
    DATE_LAST_MODEFICATION DATE,
    IS_VISIBLE SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_SYNC_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_SYNC_VIEW_1 (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_TMP_VIEW
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ODATE_LAST_MODEFICATION DATE,
    OTYPECLIENT_NAME VARCHAR(40),
    ONOTE VARCHAR(512))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_CLIENTS_VIEW_1 (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    ODELIV_ADDR VARCHAR(50),
    OZKPO VARCHAR(20),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_ARTICLE_INS (
    ISKU_EAN_ID BIGINT,
    ICOUPON_EAN_ID BIGINT,
    IDISCOUNT_VALUE DOUBLE PRECISION,
    ISKU_NAME VARCHAR(40),
    ISKU_QUANTITY DOUBLE PRECISION,
    IPRODUCER VARCHAR(40),
    IPRODUCER_OKPO VARCHAR(20),
    ITRADE_MARK VARCHAR(40),
    IUNIT_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OSKU_EAN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_DISCOUNT_INS (
    IID INTEGER,
    IDESCRIPTION VARCHAR(512))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_PROP_INS (
    ICOUPON_EAN_ID BIGINT,
    ISTART_DATE DATE,
    IEND_DATE DATE,
    IDISCOUNT_ID INTEGER)
RETURNS (
    OCOUPON_EAN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_PROP_STATUS (
    ICOUPON_EAN_ID BIGINT,
    IDOCUMENT_ID INTEGER)
RETURNS (
    OIS_CORRECT INTEGER,
    OSUM DOUBLE PRECISION,
    OSKU_QUANTITY DOUBLE PRECISION,
    ODISCOUNT_VALUE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_RECALC_QUANTITY (
    IDOCUMENT_ID INTEGER,
    ICOUPON_EAN_ID BIGINT)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_SALES_EXPORT
RETURNS (
    OID INTEGER,
    OPURCHASE_DATE DATE,
    OCHECK_NUMBER VARCHAR(14),
    OPOS_ID VARCHAR(24),
    OSHOP_ID INTEGER,
    OSKU_EAN_ID BIGINT,
    OSKU_QUANTITY DOUBLE PRECISION,
    OSKU_START_PRICE DOUBLE PRECISION,
    OSKU_SALE_PRICE DOUBLE PRECISION,
    OCOUPON_EAN_ID BIGINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_SHOPS_EXPORT
RETURNS (
    OID INTEGER,
    OSHOP_NAME VARCHAR(50),
    OSHOP_ADDRESS VARCHAR(50),
    OSHOP_DESCRIPTION VARCHAR(512),
    ONETWORK_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_COUPON_UNIT_INS (
    IID INTEGER,
    IDESCRIPTION VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DECREASE_INS (
    IDECR_NAME VARCHAR(256),
    IDECR_VALUE DOUBLE PRECISION,
    IDECR_TYPE_ID INTEGER)
RETURNS (
    ODECR_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DECREASES_VIEW
RETURNS (
    ODECR_ID INTEGER,
    ODECR_NAME VARCHAR(256),
    ODECR_VALUE DOUBLE PRECISION,
    ODECR_TYPE_NAME VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOC_AUTOORDERS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODOC_SUM_OUT DOUBLE PRECISION,
    ODOC_SUM_OUT_PDV DOUBLE PRECISION,
    OAO_SUM_OUT_PDV DOUBLE PRECISION,
    ODOC_SUM_IN DOUBLE PRECISION,
    ODOC_SUM_IN_PDV DOUBLE PRECISION,
    OAO_SUM_IN_PDV DOUBLE PRECISION,
    OAO_LAST_INPRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOC_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    BORG DOUBLE PRECISION,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    OROLL_TAX_ID INTEGER,
    OAUTH_NAME VARCHAR(40),
    OAUTH_NUM VARCHAR(12),
    OAUTH_DATE DATE,
    OUSERNAME VARCHAR(60),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DELIV_ADDR_S VARCHAR(50),
    DELIV_ADDR_D VARCHAR(50),
    BASE_REESTR_ID INTEGER,
    BASE_REESTR_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_PRINT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    OSG_ID INTEGER,
    P_IN_SUM DOUBLE PRECISION,
    P_IN_SUM_VAT DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    REAL_DISC_PERCENT DOUBLE PRECISION,
    PRICE_BY_DATE DOUBLE PRECISION,
    BAR_CODE VARCHAR(30),
    W3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_SUM (
    DOCREC_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD1_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD1_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD1_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD10_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD10_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD10_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD15_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD15_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD15_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD17_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD17_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD17_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD17_UPD_V1 (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD2_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD2_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD2_INS_V1 (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION,
    IGOODS_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD2_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD2_UPD_V1 (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION,
    IGOODS_ID INTEGER)
RETURNS (
    OKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD4_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD6_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD6_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD6_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD7_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD7_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCREC_TD7_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_CREATE_LIKE (
    IDOCUMENT_ID INTEGER,
    ITYPEDOC_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OENABLED INTEGER,
    OMESSAGE VARCHAR(128))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_DEL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_FIX (
    DOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_DOCUMENT_INFO (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_INS (
    ITOKEN VARCHAR(14),
    IDOC_NUM VARCHAR(14),
    IDOC_DATE DATE,
    ICLIENT_ID INTEGER,
    IOBJECT_ID INTEGER,
    ILIABLE_ID INTEGER,
    IPERSENT DOUBLE PRECISION,
    ITYPEDOC_ID INTEGER,
    ITYPEPAY_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_INS_OR_UPD_TD16 (
    IDOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_DOCUMENT_LIKE_TYPES (
    ITYPEDOC_ID INTEGER)
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_NUMBER
RETURNS (
    ODOC_NUM VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_RECORD_VIEW (
    IDOCREC_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_RECORD_VIEW_V1 (
    IDOCREC_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OLAST_INPRICE DOUBLE PRECISION,
    OAVG_MARKUP DOUBLE PRECISION,
    OOUT_PRICE_MARKUP DOUBLE PRECISION,
    ONOM_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_RECORDS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_RECORDS_VIEW_V1 (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OLAST_INPRICE DOUBLE PRECISION,
    OAVG_MARKUP DOUBLE PRECISION,
    OOUT_PRICE_MARKUP DOUBLE PRECISION,
    ONOM_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_TD1_GRP_INS (
    IDOCUMENT_ID INTEGER,
    IGRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_DOCUMENT_UNITE_INFO (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENT_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    OIS_PRINT_TAX SMALLINT,
    OSTAFFNAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENTS_BY_NOMEN (
    INOMEN_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(10000),
    IPAYS VARCHAR(10000),
    IISPAYS VARCHAR(10000))
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OKARDS_ID INTEGER,
    OKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENTS_DETAIL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OSHORT_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENTS_PRICES (
    IDOCUMENT_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_DOCUMENTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(10000),
    IPAYS VARCHAR(10000),
    IISPAYS VARCHAR(10000))
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    OIS_PRINT_TAX SMALLINT,
    OSTAFFNAME VARCHAR(40),
    OCLIENTS_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OZKPO VARCHAR(20),
    OW3_CLIENTS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_GET_ALL_SUMS (
    IDOCREC_ID INTEGER,
    IPERCENT0 DOUBLE PRECISION,
    IPERCENT1 DOUBLE PRECISION)
RETURNS (
    OSUM_PDV DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION,
    OIN_SUM_PDV DOUBLE PRECISION,
    OOUT_SUM_PDV DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_GET_HAPPY_CHECK (
    ISUM DOUBLE PRECISION)
RETURNS (
    OUSED INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_GET_ORDERED (
    IDOCUMENTS_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OAOR_ORDERED DOUBLE PRECISION,
    OIS_WEIGHT INTEGER,
    OKILK DOUBLE PRECISION,
    OCOUNT_NOT_AO_DOCREC INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_GET_SUM (
    IDOCREC_ID INTEGER,
    IPERCENT0 DOUBLE PRECISION,
    IPERCENT1 DOUBLE PRECISION)
RETURNS (
    OSUM_PDV DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_GET_YESNO
RETURNS (
    ID INTEGER,
    NAME VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_INPRICE_BY_DATE (
    INOMEN_ID INTEGER,
    IDATE DATE)
RETURNS (
    OPRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_KARD_DEL (
    IKARD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_KARD_DETAIL (
    IKARD_ID INTEGER,
    ICOUNT INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOCNUM VARCHAR(14),
    OSUM_PDV NUMERIC(9,2),
    OPERCENT DOUBLE PRECISION,
    OIN_SUM_PDV NUMERIC(9,2),
    ODOC_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_KARD_INS (
    IDISCONT_ID INTEGER,
    ICLIENT_ID INTEGER,
    IKARDCODE VARCHAR(13),
    IKARD_NAME VARCHAR(50),
    IIS_BLOCK INTEGER)
RETURNS (
    OKARD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_KARD_VIEW (
    IKARDS_ID INTEGER)
RETURNS (
    OKARDS_ID INTEGER,
    ODISCONT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OKARDCODE VARCHAR(13),
    OKAS_NAME VARCHAR(50),
    OIS_BLOCK SMALLINT,
    OSHORT_NAME VARCHAR(30),
    ONAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OPHONE VARCHAR(24),
    OPERCENT DOUBLE PRECISION,
    OEMAIL VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_KARDS_VIEW
RETURNS (
    OKARDS_ID INTEGER,
    ODISCONT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OKARDCODE VARCHAR(13),
    OKAS_NAME VARCHAR(50),
    OIS_BLOCK SMALLINT,
    OSHORT_NAME VARCHAR(30),
    ONAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OPHONE VARCHAR(24),
    OPERCENT DOUBLE PRECISION,
    OEMAIL VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_LC_DOC_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(10000),
    ODOCUMENT_ID INTEGER,
    ODELIV_ADDR_D VARCHAR(50),
    ODELIV_ADDR_S VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_LC_DOCREC_PRINT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    OLC_NOMEN_NAME VARCHAR(255),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_LC_PACT_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(1000))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_LIABLE_INS (
    ISURNAME VARCHAR(20),
    INAME VARCHAR(20),
    IPATRONYMIC VARCHAR(20),
    IIS_RESPONSIBLE INTEGER)
RETURNS (
    OLIABLE_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_LIGHT_INS_OR_UPD (
    IDOCUMENT_ID INTEGER,
    ILIGHT SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_LINK_CLIENT_SYNC (
    ICLIENT_SYNK_ID_LIST VARCHAR(1000),
    IW3_CLIENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_LINK_NOMEN_SYNC (
    INOMEN_SYNK_ID_LIST VARCHAR(1000),
    IW3_NOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_MAKER_INS (
    IMAKER_NAME VARCHAR(40))
RETURNS (
    OMAKER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_DEL (
    IMARKUP_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_DETAIL (
    IMARKUP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_DOCUMENT_INS (
    IDOCUMENT_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP DOUBLE PRECISION)
RETURNS (
    OMARKUP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_DOCUMENT_INS_V1 (
    IDOCUMENT_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP_TYPE INTEGER,
    IMARKUP DOUBLE PRECISION)
RETURNS (
    OMARKUP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_INS (
    ITOKEN VARCHAR(14))
RETURNS (
    OMARKUP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_PRINT (
    IMARKUP_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    OUSER_NAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_AROUND (
    IMARKUP_RECORD_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_DEL (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_INS (
    IMARKUP_ID INTEGER,
    INOMEN_ID INTEGER,
    IMARKUP DOUBLE PRECISION,
    IMARKUP_AROUND_ID SMALLINT)
RETURNS (
    OMARKUP_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_PRINT (
    IMARKUP_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OOUT_PRICE_OLD DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_VIEW (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORD_VIEW_V1 (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORDS_VIEW (
    IMARKUP_ID INTEGER)
RETURNS (
    OMARKUP_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_RECORDS_VIEW_V1 (
    IMARKUP_ID INTEGER)
RETURNS (
    OMARKUP_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUP_VIEW (
    IMARKUP_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUPS_PRICES (
    IMARKUP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MARKUPS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    OPRINT_CNT INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MOVING_BY_CLIENT (
    IDATE0 DATE,
    IDATE1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MOVING_BY_KARD (
    IDATE0 DATE,
    IDATE1 DATE,
    IKARD_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_MOVING_BY_NOMEN (
    IDATE0 DATE,
    IDATE1 DATE,
    INOMEN_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    ODOCREC_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION,
    ODISCOUNT DOUBLE PRECISION,
    OSTAFF VARCHAR(65))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_BY_GRUP (
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_DEL (
    INOMEN_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_DETAIL (
    INOMEN_ID INTEGER)
RETURNS (
    OGRP_NAME VARCHAR(40),
    OSG_NAME VARCHAR(30),
    OTYPEPDV_NAME VARCHAR(45),
    OPDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_DETAIL_GOODS (
    INOMEN_ID INTEGER,
    ICOUNT INTEGER)
RETURNS (
    OGOODS_ID INTEGER,
    OCLIENT_NAME VARCHAR(50),
    ODOC_NUM VARCHAR(14),
    OIN_PRICE_PDV DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ODOC_MARK VARCHAR(14),
    ODOC_DATE DATE,
    OIN_SUM_PDV DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS_V1 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS_V2 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS_V3 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS_V4 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER,
    ITYPE_NOMEN SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_INS_V5 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER,
    ITYPE_NOMEN SMALLINT,
    IIS_IN_DISCOUNT SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIKE_INS (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LINK_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_RECORD_VIEW (
    INOMEN_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_RECORD_VIEW_V1 (
    INOMEN_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_0 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_0_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_0_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_1_V1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_1_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_1_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_2_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_2_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_V1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_LIST_VIEW_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_SYNC_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_UNITE (
    INOMEN0_ID INTEGER,
    INOMEN1_ID INTEGER)
RETURNS (
    OENABLED INTEGER,
    OMESSAGE VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_UNITE_INFO (
    INOMEN_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_VIEW_V2 (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMEN_VIEW_V3 (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_LINK_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_LINK_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_LINK_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_LINK_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_PRICES (
    INOMENS_LIST VARCHAR(1000))
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_SYNC_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_SYNC_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_SYNC_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_SYNC_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_0_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_0_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_1_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_1_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_2_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_2_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENS_VIEW_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_NOMENZVIT_P1 (
    IDATE DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    OSUM DOUBLE PRECISION,
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OMARKUPDOC DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PACT_DEL (
    IPACT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PACT_INS (
    ITOKEN VARCHAR(14),
    ICLIENT_ID INTEGER,
    IPACT_SUM DOUBLE PRECISION,
    IPACT_SUM_PDV DOUBLE PRECISION,
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PACT_VIEW (
    IPACT_ID INTEGER)
RETURNS (
    OPACT_ID INTEGER,
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OCLIENT_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    OPACT_SUM DOUBLE PRECISION,
    OPACT_SUM_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHORTNAME VARCHAR(30),
    ODOCUMENT_NUM VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PACTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPACT_ID INTEGER,
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OCLIENT_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    OPACT_SUM DOUBLE PRECISION,
    OPACT_SUM_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHORTNAME VARCHAR(30),
    ODOCUMENT_NUM VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAY_DEL (
    IPAY_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAY_INS (
    IPAY_TYPE_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    IPAY_SUM DOUBLE PRECISION,
    IPAY_DATE DATE)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAY_UPD (
    IPAY_ID INTEGER,
    IPAY_TYPE_ID INTEGER,
    IPAY_SUM DOUBLE PRECISION,
    IPAY_DATE DATE)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAY_VIEW (
    IPAY_ID INTEGER)
RETURNS (
    OID INTEGER,
    OPAY_TYPE_ID INTEGER,
    OPAY_TYPE_NAME VARCHAR(50),
    ODOCUMENT_ID INTEGER,
    OPAY_SUM DOUBLE PRECISION,
    OPAY_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_DEL (
    IPAYMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_INS (
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IPAY_DATE DATE)
RETURNS (
    OPAYMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_REC_INS (
    IPAYMENT_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ICATEGORY VARCHAR(1),
    INOTE VARCHAR(20),
    IDOCDATE DATE,
    IFOUNDATION VARCHAR(20),
    ISUMA DOUBLE PRECISION)
RETURNS (
    OPAYMENT_REC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_REC_VIEW (
    IPAYMENT_REC_ID INTEGER)
RETURNS (
    OPAYMENT_REC_ID INTEGER,
    OPAYMENT_ID INTEGER,
    ONOM INTEGER,
    OCLIENT_ID INTEGER,
    ONOTE VARCHAR(20),
    ODOCDATE DATE,
    OFOUNDATION VARCHAR(20),
    OSUMA DOUBLE PRECISION,
    OCATEGORY VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_RECORD_DEL (
    IPAYMENT_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_RECS_VIEW (
    IPAYMENT_ID INTEGER)
RETURNS (
    OPAYMENT_REC_ID INTEGER,
    OPAYMENT_ID INTEGER,
    ONOM INTEGER,
    OCLIENT_ID INTEGER,
    ONOTE VARCHAR(20),
    ODOCDATE DATE,
    OFOUNDATION VARCHAR(20),
    OSUMA DOUBLE PRECISION,
    OCATEGORY VARCHAR(1))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENT_VIEW (
    IPAYMENT_ID INTEGER)
RETURNS (
    OPAYMENT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    OPAY_DATE DATE,
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYMENTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPAYMENT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    OPAY_DATE DATE,
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PAYS_RECALC (
    IDOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_PAYS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OID INTEGER,
    OPAY_TYPE_ID INTEGER,
    OPAY_TYPE_NAME VARCHAR(50),
    ODOCUMENT_ID INTEGER,
    OPAY_SUM DOUBLE PRECISION,
    OPAY_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_CLIENTS_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_DECREASE_VIEW (
    IDECR_ID INTEGER)
RETURNS (
    ODECR_ID INTEGER,
    ODECR_NAME VARCHAR(256),
    ODECR_VALUE DOUBLE PRECISION,
    ODECR_TYPE_NAME VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_LIABLE_VIEW (
    ILIABLE_ID INTEGER)
RETURNS (
    OLIABLE_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(30),
    OJOB_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_LIABLES_VIEW
RETURNS (
    OLIABLE_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(30),
    OJOB_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_MAKER_VIEW (
    IMAKER_ID INTEGER)
RETURNS (
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_POPUP_MAKERS_VIEW
RETURNS (
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRICE_BY_DATE (
    INOMEN_ID INTEGER,
    IDATE DATE)
RETURNS (
    OPRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRICE_JOURNAL (
    IDATE1 DATE,
    IDATE2 DATE,
    INOMEN_ID INTEGER)
RETURNS (
    ODATE_TIME TIMESTAMP,
    OOUT_PRICE DOUBLE PRECISION,
    OUSER_NAME VARCHAR(12),
    ONAME VARCHAR(60))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCT_REC_SET_COUNT (
    IPRODUCTION_REC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_PRODUCT_REC_TD1_INS (
    IPRODUCTION_DOC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCT_REC_TD2_INS (
    IPRODUCTION_DOC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCT_REC_TD2_UPD (
    IPRODUCTION_REC_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_DEL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_FIX (
    IPRODUCTION_DOC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_HEADER (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    AUTH_NAME VARCHAR(80),
    DOC_MARK VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_INFO (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_INS (
    ITYPEDOC_ID INTEGER,
    INOTE VARCHAR(14),
    IDATE DATE)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOC_VIEW (
    IID INTEGER)
RETURNS (
    OID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OIN_SUMM DOUBLE PRECISION,
    OTYPE_DOC_NAME VARCHAR(60),
    ONOTE VARCHAR(14),
    OTYPE_DOC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOCREC_PRINT (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION,
    OPRICE1 DOUBLE PRECISION,
    ONOMEN_ID1 INTEGER,
    ONOMEN_NAME1 VARCHAR(40),
    OSI_NAME1 VARCHAR(12),
    OCOUNT0 DOUBLE PRECISION,
    OPRICE0 DOUBLE PRECISION,
    ONOMEN_NAME0 VARCHAR(40),
    OSI_NAME0 VARCHAR(12),
    ONOMEN_ID0 INTEGER,
    OCOUNT1 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOCS_DETAIL (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OPRODUCTION_REC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_DOCS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000))
RETURNS (
    OID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OIN_SUMM DOUBLE PRECISION,
    OTYPE_DOC_NAME VARCHAR(60),
    ONOTE VARCHAR(14),
    OTYPE_DOC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_REC_DEL (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_REC_DETAIL (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_REC_INFO (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_REC_VIEW (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_PRODUCTION_RECS_VIEW (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REALIS_BY_DOCUMENT (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REALIS_BY_DOCUMENT_SG (
    IDOCUMENT_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISPECIALS_GROUPS_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REC_FILLING_DEL (
    IREC_FILLING_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REC_FILLING_INS (
    IPRODUCTION_REC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OREC_FILLING_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REC_FILLING_UPD (
    IREC_FILLING_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OREC_FILLING_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REC_FILLING_VIEW (
    IREC_FILLING_ID INTEGER)
RETURNS (
    OREC_FILLING_ID INTEGER,
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REC_FILLINGS_VIEW (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OREC_FILLING_ID INTEGER,
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_RECULC_GRP_FULLNAME (
    IGRP_ID INTEGER,
    IGRP_FULLNAME VARCHAR(1000),
    IPREW_GRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_RECULC_GRP_FULLNAMES
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_REV_REC_CRY (
    IREVISION_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_REV_RECORD_GRP_INS (
    IREVISION_ID INTEGER,
    IGRP_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REV_RECORD_INS (
    IREVISION_ID INTEGER,
    INOMEN_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REV_RECORD_VIEW (
    IREV_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE_PDV DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REV_RECORDS_VIEW (
    IREVISION_ID INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OPRICE_IN_PDV DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OTYPE_PDV_ID INTEGER,
    OPDV DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_DEL (
    IREVISION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_FIX (
    REVISION_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_REVISION_INS (
    ITOKEN VARCHAR(14),
    IDATE DATE)
RETURNS (
    OREVISION_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_NOMEN_EXPORT (
    IREVISION_ID INTEGER)
RETURNS (
    OBARCODE CHAR(30),
    ONOMEN_NAME CHAR(50),
    OKILK_OLD CHAR(9),
    OKILK_NEW CHAR(9),
    ONOMEN_CODE VARCHAR(7),
    OERROR_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_NOMEN_IMPORT (
    IREVISION_ID INTEGER,
    IBARCODE VARCHAR(30),
    IKILK_NEW DOUBLE PRECISION,
    IMODE INTEGER)
RETURNS (
    OERROR_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_VIEW (
    IREVISION_ID INTEGER)
RETURNS (
    OREVISION_LOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OUSER_CREATE VARCHAR(55),
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OUSER_LOCK VARCHAR(55),
    ODATE_LOCK DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_VIEW_V1 (
    IREVISION_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(55),
    OUSER_FIX VARCHAR(55),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISION_VIEW_V2 (
    IREVISION_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(60),
    OUSER_FIX VARCHAR(60),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISIONS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(55),
    OUSER_FIX VARCHAR(55),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVISIONS_VIEW_V1 (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(60),
    OUSER_FIX VARCHAR(60),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_REVVISION_DETAIL (
    IREVISION_ID INTEGER)
RETURNS (
    OREV_RECORDS_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OPRICE_IN_PDV DOUBLE PRECISION,
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OSUM_IN_OLD DOUBLE PRECISION,
    OSUM_IN_PDV_OLD DOUBLE PRECISION,
    OSUM_IN_NEW DOUBLE PRECISION,
    OSUM_IN_PDV_NEW DOUBLE PRECISION,
    OSUM_OUT_OLD DOUBLE PRECISION,
    OSUM_OUT_PDV_OLD DOUBLE PRECISION,
    OSUM_OUT_NEW DOUBLE PRECISION,
    OSUM_OUT_PDV_NEW DOUBLE PRECISION,
    OKILK DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_ROLL_TAX_ADD (
    IDOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_ROLL_TAX_DEL (
    DAT1 DATE,
    DAT2 DATE)
RETURNS (
    RE_NUM INTEGER,
    RE_DAT DATE,
    RE_USE VARCHAR(12),
    D_DOK_NUM VARCHAR(14),
    D_DOK_SUM DOUBLE PRECISION,
    D_CLI VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_SCALE_INS (
    IIP VARCHAR(16),
    INAME VARCHAR(60),
    ITYPE_SCALE INTEGER)
RETURNS (
    OID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_SCALES_VIEW (
    IID_LIST VARCHAR(1000))
RETURNS (
    OID INTEGER,
    OIP VARCHAR(16),
    ONAME VARCHAR(60),
    OTYPE_SCALE SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_SLIV_MINUSOV (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_SW_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(1000))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TD10_CORRECT
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_TMP_BARCODE_INS (
    IBARCODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
RETURNS (
    OBARCODE_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_BARCODE_UPD (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE PS_TMP_BARCODES_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OBARCODE VARCHAR(27),
    OOUT_PRICE DOUBLE PRECISION,
    OBARCODE_TYPE_ID INTEGER,
    OTYPE_NAME VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMEN_DEL (
    INOMEN_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMEN_INS (
    ISHORT_NAME VARCHAR(24),
    IFULL_NAME VARCHAR(40),
    IDESCRIPTION VARCHAR(255),
    IMAKER_NAME VARCHAR(80),
    ITRADEMARK VARCHAR(80),
    ICODE VARCHAR(6),
    IIS_DEVIDED SMALLINT,
    IGROUP_ID INTEGER,
    ISG_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISI_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMEN_LIKE_INS (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMEN_UPD (
    INOMEN_ID INTEGER,
    ISHORT_NAME VARCHAR(24),
    IFULL_NAME VARCHAR(40),
    IDESCRIPTION VARCHAR(255),
    IMAKER_NAME VARCHAR(80),
    ITRADEMARK VARCHAR(80),
    ICODE VARCHAR(6),
    IIS_DEVIDED SMALLINT,
    IGROUP_ID INTEGER,
    ISG_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISI_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMEN_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OBARCODE_COUNT INTEGER,
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OGROUP_NAME VARCHAR(50),
    OSG_ID INTEGER,
    OSG_NAME VARCHAR(30),
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_NAME VARCHAR(40),
    OSI_ID INTEGER,
    OSI_NAME VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TMP_NOMENS_VIEW
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OBARCODE_COUNT INTEGER,
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OGROUP_NAME VARCHAR(50),
    OSG_ID INTEGER,
    OSG_NAME VARCHAR(30),
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_NAME VARCHAR(40),
    OSI_ID INTEGER,
    OSI_NAME VARCHAR(12))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TRAFFIC (
    IDATE_0 DATE,
    IDATE_1 DATE,
    IWEEK_DAYS VARCHAR(1000))
RETURNS (
    ODAY_ID DATE,
    OWEEK_DAY INTEGER,
    OHOUR INTEGER,
    OCNT INTEGER,
    OSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PS_TRAFFIC_DIM (
    IDATE_0 DATE,
    IDATE_1 DATE,
    IWEEK_DAYS VARCHAR(1000))
RETURNS (
    ODAY_ID DATE,
    OWEEK_DAY INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE PW_RALASE (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_CLIENT_DOC_LIST (
    VDATE1 DATE,
    VDATE2 DATE,
    VCLIENT_ID INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER,
    RTYPE INTEGER,
    RSUMA_PDV DOUBLE PRECISION,
    RPERCENT VARCHAR(7),
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RSUMA DOUBLE PRECISION,
    RTYPE_PROPL INTEGER,
    RDOC_LOCK SMALLINT,
    RDOC_DATE DATE,
    RIN_SUM_PDV DOUBLE PRECISION,
    RDOC_MARK VARCHAR(14),
    RCLIENTS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_DOC (
    DOCUMENT_ID INTEGER)
RETURNS (
    DATE_CR DATE,
    DOC_NUM VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_DOCSUM (
    DOCUMENT_ID INTEGER)
RETURNS (
    SUM_P_IN DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    NAME VARCHAR(30),
    SUM_OUT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_NAKL_N (
    DOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    NOMER_P INTEGER,
    AUTH_NAME VARCHAR(80),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    BORG DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_TOVARINDOC (
    DATE_START DATE,
    DATE_END DATE,
    NOMENID INTEGER)
RETURNS (
    KODTOVARA VARCHAR(7),
    KILK DOUBLE PRECISION,
    TVARNAME VARCHAR(40),
    MAKERS VARCHAR(40),
    PRICES DOUBLE PRECISION,
    DATE_CR DATE,
    USER_CR VARCHAR(12),
    TIME_CR TIME,
    OBJECTS_ID INTEGER,
    DOCREC_ID INTEGER,
    DOC_NUM VARCHAR(15),
    TYPE_DOC INTEGER,
    DOCUMENT_ID INTEGER,
    SUMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE R_ZVITPROP_DETAL_K (
    S_DATA DATE,
    E_DATE DATE,
    TYPP_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    POKIPEC VARCHAR(40),
    VIDPOVIDAL VARCHAR(40),
    DOC_SUM_PDV DOUBLE PRECISION,
    PROPLATA DOUBLE PRECISION,
    DATA_S DATE,
    DATA_E DATE,
    PEYNAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RC_RALASE (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RC_RALASE_DR (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER,
    RMAKER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RC_RALASE_DR_MANAGER (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VMANAGER_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RC_RALASE_INMINUS (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RNOMEN_NAME VARCHAR(40),
    RNOMEN_CODE VARCHAR(7))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RC_RALASE_VIDPOV (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER,
    RSTAFF_NAME VARCHAR(30),
    RPRIHOD_S_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RP_PRICE_GRP (
    VGRP_ID INTEGER,
    VDATE_TIME TIMESTAMP)
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RP_PRICE_INGRP (
    VGRP_ID INTEGER,
    VDATE_TIME TIMESTAMP,
    VWITH_0 INTEGER,
    VSKLAD_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RREST DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RP_PRICE_JOURNAL (
    VDATE1 DATE,
    VDATE2 DATE,
    VNOMEN_ID INTEGER)
RETURNS (
    RDATE_TIME TIMESTAMP,
    ROUT_PRICE DOUBLE PRECISION,
    RUSER_NAME VARCHAR(12),
    RNAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_RALASE (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_RALASE_GOOD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGOODS_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_RALASE_GRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_RALASE_INGRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_RALASE_NOMEN (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RR_REST_PERIOD (
    DATE_IN DATE,
    DATE_OUT DATE,
    OBJECT_ID INTEGER)
RETURNS (
    BEGIN_S_PDV DOUBLE PRECISION,
    END_S_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_ACTION_RALASE (
    IACTION_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE,
    IBEFOREDATE0 DATE,
    IBEFOREDATE1 DATE)
RETURNS (
    OW3_NOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OB_K DOUBLE PRECISION,
    OR_K DOUBLE PRECISION,
    OR_S_MAR DOUBLE PRECISION,
    OR_S_OUT DOUBLE PRECISION,
    OE_K DOUBLE PRECISION,
    OB_K1 DOUBLE PRECISION,
    OR_K1 DOUBLE PRECISION,
    OR_S_MAR1 DOUBLE PRECISION,
    OR_S_OUT1 DOUBLE PRECISION,
    OE_K1 DOUBLE PRECISION,
    OD_K DOUBLE PRECISION,
    OD_S_MAR DOUBLE PRECISION,
    OD_S_OUT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_DOCUMENTS (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    DOCUMENT_ID INTEGER,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(40),
    DOC_DATE DATE,
    DOC_NUM VARCHAR(14),
    CLIENT_NAME VARCHAR(50),
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_PROFITABILITY_REST (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_ABC (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10),
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_ABC_1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_ABC_2 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_ABC_3 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_COPY (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    RGRP_ID VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_LIST (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID VARCHAR(10000))
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_LIST_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID VARCHAR(10000),
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_MANAGER (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    MANAGER_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_MANAGER_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    MANAGER_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_SG (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    SG_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_SG_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    SG_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RS_RALASE_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RV_RALASE_GOOD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGOODS_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RSTAFF_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RV_RALASE_GRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RV_RALASE_INGRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE RV_RALASE_NOMEN (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_AUTH_CREATE (
    V_AUTH_DATE DATE,
    V_AUTH_NUM VARCHAR(12),
    V_AUTH_NAME VARCHAR(40))
RETURNS (
    R_AUTH_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_BARCODE_ATTACH (
    VBARCODE_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RIS_EXIST INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_BARCODE_CREATE (
    VCODE VARCHAR(27))
RETURNS (
    RBARCODE_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_BARCODE_DELETE (
    VCODE VARCHAR(27),
    VNOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_CINNIK (
    VLIST VARCHAR(10000))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RINTP INTEGER,
    RDECP VARCHAR(4),
    RNOMEN_CODE VARCHAR(7),
    RSI_NAME VARCHAR(12),
    RBARCODE VARCHAR(27),
    ROUTPRICE DOUBLE PRECISION,
    RDATEX_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_CINNIK_PEREOCINKA (
    VLIST VARCHAR(10000))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RINTP0 INTEGER,
    RDECP0 VARCHAR(4),
    RINTP INTEGER,
    RDECP VARCHAR(4),
    RNOMEN_CODE VARCHAR(7),
    RDATEX_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_CLIENT_UNIT (
    VCLIENT0_ID INTEGER,
    VCLIENT1_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOC_CINNIK (
    DOCUMENT_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_CLOSE (
    FLAG SMALLINT,
    DOCUMENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOC_CREATE (
    VTYPEDOC INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_DELETE (
    DOC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOC_LOCK_PREPARE (
    DOCID INTEGER)
RETURNS (
    FLAG INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_SET_EXTRA (
    DOCUMENT_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOC_VIEW (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPES VARCHAR(10000),
    PAYS VARCHAR(10000),
    ISPAYS VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    DOC_SUM_OUT DOUBLE PRECISION,
    DOC_SUM_OUT_PDV DOUBLE PRECISION,
    DOC_SUM_IN DOUBLE PRECISION,
    DOC_SUM_IN_PDV DOUBLE PRECISION,
    DOC_LOCK SMALLINT,
    STAFF_NAME VARCHAR(30),
    DISC_PERSENT DOUBLE PRECISION,
    LOCK_DATE DATE,
    OPLATA_STATE INTEGER,
    OPLATA_TYPE VARCHAR(30),
    BLOK INTEGER,
    TIME_CR TIME,
    NOTARIZATION VARCHAR(12),
    KARDS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_VIEW_G (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    CLIENTS_ID INTEGER,
    OBJECT_ID INTEGER,
    SRC_NAME VARCHAR(30),
    DST_NAME VARCHAR(30),
    DOC_SUMIN_PDV DOUBLE PRECISION,
    DOC_SUMIN DOUBLE PRECISION,
    DOC_IN_PDV DOUBLE PRECISION,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_SUM_PDV DOUBLE PRECISION,
    OPLATA_TYPE INTEGER,
    DOC_MARK VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_VIEW_ID (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER,
    SRC_NAME VARCHAR(30),
    SRC_ISPDV INTEGER,
    DST_NAME VARCHAR(30),
    DST_ISPDV INTEGER,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P VARCHAR(10),
    DOC_LOCK SMALLINT,
    AUTH_ID INTEGER,
    AUTH_NAME VARCHAR(80),
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    DISC_PERSENT DOUBLE PRECISION,
    TYPEDISCOUNT VARCHAR(20),
    LOCK_DATE DATE,
    DISCOUNT_ID INTEGER,
    DES_SUMDOC VARCHAR(4),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DELAY_PAY INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOC_VIEW_ID_N (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCGOODS_CREATE (
    DOCGOODS_ID INTEGER,
    GOODS_ID INTEGER,
    DOCREC_ID INTEGER,
    KILK DOUBLE PRECISION)
RETURNS (
    R_DOCGOODS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCGOODS_VIEW_ID (
    DOCREC_ID INTEGER)
RETURNS (
    GOODS_ID INTEGER,
    REST DOUBLE PRECISION,
    KILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_CLIUPD (
    DOCUMENT_ID INTEGER,
    CLIENT_ID INTEGER,
    TYPEDOC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOCREC_CREATE (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION,
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION)
RETURNS (
    DOCREC_ID INTEGER,
    VKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_DEL (
    DOCREC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOCREC_KILKUPD (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    OBJECT_ID INTEGER,
    CLIENTS_ID INTEGER,
    OUT_PRICE DOUBLE PRECISION,
    VKILK NUMERIC(9,3),
    IN_KILK NUMERIC(9,3),
    VTYPE_DOC INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOCREC_PRICEUPD (
    DOCREC_ID INTEGER,
    PRICE DOUBLE PRECISION,
    TYPEDOC_ID INTEGER,
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_DOCREC_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_UPDATE (
    DOCREC_ID INTEGER,
    KILK NUMERIC(9,3),
    OUT_PRICE DOUBLE PRECISION)
RETURNS (
    VKILK DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_VIEW (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_VIEW_1 (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_VIEW_G (
    DOCUMENT_ID INTEGER,
    TYPEDOC_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    SUM_PDV_IN DOUBLE PRECISION,
    GENERAL_PRICE DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_VIEW_ID (
    DOCREC_ID INTEGER)
RETURNS (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    IN_PRICE DOUBLE PRECISION,
    IN_PRICE_PDV DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_DOCREC_VIEW_NAKL1 (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_FAKTURA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RCLIENT_NAME VARCHAR(50),
    ROBJECT_NAME VARCHAR(50),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24),
    RZKPO VARCHAR(20),
    RNUMPDV VARCHAR(20),
    RIPN VARCHAR(20),
    RDOC_NUM VARCHAR(14),
    RACCOUNT VARCHAR(20),
    RNAME VARCHAR(40),
    RMFO VARCHAR(20),
    RDOC_DATE DATE,
    OTYPEPROP_NAME VARCHAR(40))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_GET_NOMCODE (
    GROUP_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_GRP_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RPREWGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_KILL_MINEX (
    OBJECTS_ID INTEGER)
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    D_PRICE DOUBLE PRECISION,
    G_PRICE DOUBLE PRECISION,
    TYPEDOC_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_KILLER_MINUSOV (
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_KILLER_SELECT (
    FLAG INTEGER,
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    GOODS_ID INTEGER,
    GOODS_REST DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_MAKER_CREATE (
    MAKER_NAME VARCHAR(40))
RETURNS (
    MAKER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_MAKER_UPDATE (
    MAKER_ID INTEGER,
    MAKER_NAME VARCHAR(40))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_NAC_DOC (
    VDOCUMENT_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_NAC_DOCREC (
    VDOCREC_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_PAYMENT_SUMMA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOC_SUMMA DOUBLE PRECISION,
    RPAY_SUMMA DOUBLE PRECISION,
    RTYPEDOC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_PAYMENT_VIEW (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RPAYMENT_ID INTEGER,
    RSUMMA DOUBLE PRECISION,
    RPAY_DATE DATE,
    RTYPEPAY_ID INTEGER,
    RTYPEPAY_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_PRICE_EDIT (
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7),
    GRP_FULLNAME VARCHAR(200),
    NOMEN_NAME VARCHAR(40),
    TYPEVAT_NAME VARCHAR(48),
    REST DOUBLE PRECISION,
    PRICE_IN_VAT DOUBLE PRECISION,
    PRICE_OUT_VAT DOUBLE PRECISION,
    TYPEVAT_ID INTEGER,
    TYPEVAT_VAT DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_PRN_FAKTURA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RCLIENT_NAME VARCHAR(50),
    ROBJECT_NAME VARCHAR(50),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24),
    RZKPO VARCHAR(20),
    RNUMPDV VARCHAR(20),
    RIPN VARCHAR(20),
    RDOC_NUM VARCHAR(14),
    RACCOUNT VARCHAR(20),
    RNAME VARCHAR(40),
    RMFO VARCHAR(20),
    RDOC_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_PRN_RECEIPT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    AUTH_NAME VARCHAR(80),
    DOC_MARK VARCHAR(14))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_PRN_RECEIPT_DTL (
    DOCUMENT_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    TARA_NAME VARCHAR(12),
    KILK DOUBLE PRECISION,
    PRICE_IN DOUBLE PRECISION,
    PRICE_IN_VAT DOUBLE PRECISION,
    PRICE_OUT DOUBLE PRECISION,
    PRICE_OUT_VAT DOUBLE PRECISION,
    BAR_CODE VARCHAR(30),
    ODATEX_NAME VARCHAR(26))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_RECALC_MINUSOV
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_RECEIPT_CLIENT (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    SHORTNAME VARCHAR(30),
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_PDV_IN DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_REV_RECORDS_VIEW (
    VREVISION_ID INTEGER)
RETURNS (
    REV_RECORDS_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK_OLD DOUBLE PRECISION,
    KILK_NEW DOUBLE PRECISION,
    PRICE_IN DOUBLE PRECISION,
    PRICE_IN_PDV DOUBLE PRECISION,
    PRICE_OUT DOUBLE PRECISION,
    PRICE_OUT_PDV DOUBLE PRECISION,
    SUM_IN_OLD DOUBLE PRECISION,
    SUM_IN_PDV_OLD DOUBLE PRECISION,
    SUM_IN_NEW DOUBLE PRECISION,
    SUM_IN_PDV_NEW DOUBLE PRECISION,
    SUM_OUT_OLD DOUBLE PRECISION,
    SUM_OUT_PDV_OLD DOUBLE PRECISION,
    SUM_OUT_NEW DOUBLE PRECISION,
    SUM_OUT_PDV_NEW DOUBLE PRECISION,
    KILK DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_RT_DOCREC_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION,
    ISPDV INTEGER)
RETURNS (
    SUM_OUT_VAT_6 DOUBLE PRECISION,
    SUM_OUT_VAT_7 DOUBLE PRECISION,
    SUM_OUT_8 DOUBLE PRECISION,
    SUM_OUT_11 DOUBLE PRECISION,
    SUM_OUT_VAT_15 DOUBLE PRECISION,
    SUM_OUT_16 DOUBLE PRECISION,
    SUM_VAT_17 DOUBLE PRECISION,
    SUM_OUT_18 DOUBLE PRECISION,
    SUM_VAT_19 DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_RT_DOCS (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPESPAY VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    TAX_NUM INTEGER,
    DOC_DATE DATE,
    DST_NAME VARCHAR(50),
    IPN VARCHAR(20),
    SUM_OUT_VAT_6 DOUBLE PRECISION,
    SUM_OUT_VAT_7 DOUBLE PRECISION,
    SUM_OUT_8 DOUBLE PRECISION,
    SUM_OUT_11 DOUBLE PRECISION,
    SUM_OUT_VAT_15 DOUBLE PRECISION,
    SUM_OUT_16 DOUBLE PRECISION,
    SUM_VAT_17 DOUBLE PRECISION,
    SUM_OUT_18 DOUBLE PRECISION,
    SUM_VAT_19 DOUBLE PRECISION,
    OPLATA_TYPE VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_RT_UPDATE (
    DOCUMENT_ID INTEGER,
    TD_NUMBER VARCHAR(30),
    TD_DATE DATE,
    TD_SUM DOUBLE PRECISION,
    TD_SUM_VAT DOUBLE PRECISION,
    TD_SUM_WITH_VAT DOUBLE PRECISION)
RETURNS (
    REESTR_ID INTEGER,
    EVENT_SP INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_SEL_TOVAR_BY_CODE (
    VINP_FILTER VARCHAR(27))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_BARC VARCHAR(27))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE S_SLIV_MINUSOV (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_SLIV_MINUSOV_1 (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_SLIV_MINUSOV_FULL (
    VNOMEN_ID_0 INTEGER,
    VNOMEN_ID_1 INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE S_STAFF_VIEW
RETURNS (
    STAFF_ID INTEGER,
    STAFF_NUM VARCHAR(7),
    FULL_NAME VARCHAR(30),
    JOBS_NAME VARCHAR(30))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE SP_CINA (
    OBJEKTS INTEGER,
    NOMENSID INTEGER)
RETURNS (
    INPRISES DOUBLE PRECISION,
    NOMENCODE VARCHAR(7),
    NOMENNAME VARCHAR(40),
    OUTPRISES DOUBLE PRECISION,
    NACINKA DOUBLE PRECISION,
    PROCANTNAC DOUBLE PRECISION,
    GOODSID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_DOC_CREATE (
    VDOC_MARK VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_DOCREC_CREATE (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE T_GRP_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RGRP_FULL_NAME VARCHAR(250),
    OMAKER_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CHILDS_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(200),
    RPREW_GRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CHILDS_LINK (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RGRP_FULL_NAME VARCHAR(250))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CHILDS_LIST (
    VGRP_ID VARCHAR(10000))
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RSHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CHILDS_SHELFS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RSHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CREATE_CHILD (
    VGRP_ID INTEGER,
    VNAME VARCHAR(40),
    VCODE INTEGER,
    VSHELF DOUBLE PRECISION)
RETURNS (
    RGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_CREATE_CHILD_V1 (
    IPREW_GRP_ID INTEGER,
    INAME VARCHAR(40),
    ICODE INTEGER,
    IMAKER_ID INTEGER)
RETURNS (
    OGRP_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_DELETE (
    VGRP_ID INTEGER)
RETURNS (
    RSUCS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_FULLNAME (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_FULLNAME VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_IS_LAST_LEVEL (
    IGRP_ID INTEGER)
RETURNS (
    OIS_LAST_LEVEL SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_MANAGER (
    VMANAGER_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RSHELF DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRP_RECALC
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE T_GRPC_CHILDS (
    VGRPC_ID INTEGER)
RETURNS (
    RGRPC_ID INTEGER,
    RGRPC_NAME VARCHAR(40),
    RPREW_GRPC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRPC_CREATE_CHILD (
    VGRPC_ID INTEGER,
    VNAME VARCHAR(40))
RETURNS (
    RGRPC_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRPC_DELETE (
    VGRPC_ID INTEGER)
RETURNS (
    RSUCS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_GRPC_FULLNAME (
    VGRPC_ID INTEGER)
RETURNS (
    RGRPC_FULLNAME VARCHAR(200))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE T_IMPORT_GOODS_VOL (
    DOCUMENT_ID INTEGER,
    NOMEN_CODE INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TMP_FIX_DR6 (
    IDOCREC_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_DEL_BAD_CLIENTS
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENT_NAME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE TOOLS_INIT_PJ
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_MOVE_REST (
    GOODS_ID1 INTEGER,
    GOODS_ID2 INTEGER)
RETURNS (
    RESULT VARCHAR(120))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE TOOLS_NULL_DG
RETURNS (
    DOCREC_ID INTEGER,
    DOCGOODS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE TOOLS_NULL_DR (
    MIN_DR_ID INTEGER,
    MAX_DR_ID INTEGER)
RETURNS (
    DG_ID INTEGER,
    DR_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE TOOLS_NULL_RST
RETURNS (
    RST_ID INTEGER,
    NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE TOOLS_RECALC_REST (
    NOMEN_CODE VARCHAR(7))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_RECALC_RST (
    INOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_SET_CURENT_CLIENTS_TYPE
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_SET_TS
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_SET_W3_CLIENTS_ID_BY_ZKPO
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_SLIV_MINUSOV (
    INOMEN_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE TOOLS_UNITE_CLIENTS_BY_ZKPO
RETURNS (
    OCLIENT_ID0 INTEGER,
    OCLIENT_ID1 INTEGER,
    OCLIENT_NAME0 VARCHAR(50),
    OCLIENT_NAME1 VARCHAR(50),
    OZKPO0 VARCHAR(20),
    OZKPO1 VARCHAR(20))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_DISCONT_UPD (
    VDISCONT_ID INTEGER,
    VPERSENT DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE W_GROUP_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RGRPCODE INTEGER,
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION,
    RINSUMMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_GROUP_ZVIT_V1 (
    IDATE1 DATE,
    IDATE2 DATE)
RETURNS (
    OGRPCODE INTEGER,
    ODATE_ID DATE,
    OO_INSUMMA DOUBLE PRECISION,
    OO_SUMMA DOUBLE PRECISION,
    OI_SUMMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_IMPORT_MAKER (
    IMAKER_ID INTEGER,
    INAME VARCHAR(40))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE W_KARDS_EXP
RETURNS (
    RKARDCODE VARCHAR(13),
    RDISCONT_ID INTEGER,
    RBLOCK SMALLINT,
    RNAME VARCHAR(50),
    RSURNAME VARCHAR(30),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_KARDS_UPD (
    VKARDCODE VARCHAR(13),
    VDISCONT_ID INTEGER,
    VBLOCK SMALLINT,
    VNAME VARCHAR(50))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE W_KARDS_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RKARDCODE VARCHAR(16),
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_KARDS_ZVIT_V1
RETURNS (
    RKARDCODE VARCHAR(16),
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE W_RALASE_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RCODE INTEGER,
    RDATE_ID DATE,
    RO_KILK DOUBLE PRECISION,
    RO_SUMMA DOUBLE PRECISION,
    RO_INSUMMA DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_CHECK_MARKUP (
    IDAYS_CNT INTEGER)
RETURNS (
    OOBJ_NAME VARCHAR(50),
    ODOC_DATE DATE,
    OTIME_CR TIME,
    OCLT_NAME VARCHAR(50),
    OKARDCODE VARCHAR(13),
    OPROCENT DOUBLE PRECISION,
    OFIRST_GRP_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    ONOMEN_NAME VARCHAR(40),
    OMAKER_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OSUM DOUBLE PRECISION,
    OMARKUP DOUBLE PRECISION,
    OGRP_FULL_NAME VARCHAR(200),
    ODOCREC_ID INTEGER,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_CLIENTS_TMP
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ONOTE VARCHAR(512))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DEACTIVATE_CLIENTS
RETURNS (
    OW3_CLIENT_ID INTEGER,
    OSET_ACTIVE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_DR (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OREAL_NOMEN_ID INTEGER,
    OO_INSUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_DR_V1 (
    IDATE DATE,
    INOMEN_ID INTEGER)
RETURNS (
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_DR_V2 (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OREAL_NOMEN_ID INTEGER,
    OO_INSUM_PDV DOUBLE PRECISION,
    OTYPEDOC_ID INTEGER,
    ODOCUMENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_RECURSION (
    INOMEN_ID INTEGER,
    IE_KILK DOUBLE PRECISION,
    IE_SUM DOUBLE PRECISION,
    IE_SUM_PDV DOUBLE PRECISION,
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ODATE DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_RST
RETURNS (
    ONOMEN_ID INTEGER,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_V1 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_V2 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM_PDV DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DINAMICS_V3 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OTYPEDOC_ID INTEGER,
    ODOC_KILK DOUBLE PRECISION,
    ODOC_SUM DOUBLE PRECISION,
    ODOC_INSUM DOUBLE PRECISION,
    ODOC_SUM_PDV DOUBLE PRECISION,
    ODOC_CNT INTEGER,
    OOBJECT_ID INTEGER,
    OIS_PRIHID SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DOC_HDR (
    IDAYS_CNT INTEGER)
RETURNS (
    ODOC_ID INTEGER,
    ODAY_ID DATE,
    OCLIENT_ID INTEGER,
    OOBJECT_ID INTEGER,
    OTYPEPAY_ID INTEGER,
    ODOC_MARK VARCHAR(14),
    ODOC_NUM VARCHAR(14),
    OW3CLIENT_ID INTEGER,
    OW3OBJECT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DOC_REC (
    IDAYS_CNT INTEGER)
RETURNS (
    ODOC_ID INTEGER,
    ONOMEN_ID INTEGER,
    OTYPEPDV_ID SMALLINT,
    OKILK DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_DOCUMENTS (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODATE_DOC DATE,
    ODOC_NUM VARCHAR(14),
    OTYPEDOC_ID INTEGER,
    OZKPO VARCHAR(20),
    OIPN VARCHAR(20),
    ONAME VARCHAR(50),
    OKARDCODE VARCHAR(13),
    ONOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OTYPEPDW_ID INTEGER,
    OIS_PRIHID SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_STATICS
RETURNS (
    ONOMEN_ID INTEGER,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OIN_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_STATICS_V1
RETURNS (
    ONOMEN_ID INTEGER,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OREST_SUM DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OIN_DATE DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_CHECKS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_NUM VARCHAR(14),
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DEL_DOCGOODS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCGOODS_ID INTEGER,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DEL_DOCRECS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCREC_ID INTEGER,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DEL_DOCUMENTS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DEL_GOODS (
    IDELTA TIMESTAMP)
RETURNS (
    OGOODS_ID INTEGER,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DOCGOODS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCGOODS_ID INTEGER,
    OGOODS_ID INTEGER,
    ODOCREC_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OINPRICE DOUBLE PRECISION,
    OINPRICE_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DOCRECS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCREC_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OOUTSUM_PDV DOUBLE PRECISION,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_DOCUMENTS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    OTYPEDOC_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OW3_OBJECTS_ID INTEGER,
    OW3_CLIENTS_ID INTEGER,
    ODOC_LOCK SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    OOPLATA_STATE SMALLINT,
    OOPLATA_TYPE SMALLINT,
    OKARDS_ID INTEGER,
    OTIME_FIX TIME,
    OKASSES_ID INTEGER,
    OMAKER_ID INTEGER,
    OTS DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_GOODS (
    IDELTA TIMESTAMP)
RETURNS (
    OGOODS_ID INTEGER,
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    OGOODS_REST DOUBLE PRECISION,
    OGOODS_INPRICE DOUBLE PRECISION,
    OCLIENTS_ID INTEGER,
    OW3_CLIENTS_ID INTEGER,
    ODOC_DATE DATE,
    OTS DATE,
    OGOODS_INPRICE_WO_PDV DOUBLE PRECISION)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_LOG
RETURNS (
    OVISIBLE_CNT INTEGER,
    OSYNC_CNT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_LOG_DISC
RETURNS (
    OACTIVE INTEGER,
    OBLOCK INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_LOG_V1
RETURNS (
    OVISIBLE_CNT INTEGER,
    OSYNC_CNT INTEGER,
    OCLIENT_VISIBLE_CNT INTEGER,
    OCLIENT_SYNC_CNT INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_SYNC_SEANS
RETURNS (
    OSYNC_ID INTEGER,
    ODOCUMENT_ID_MIN INTEGER,
    ODOCUMENT_ID_MAX INTEGER,
    ODOCREC_ID_MIN INTEGER,
    ODOCREC_ID_MAX INTEGER,
    ODOCGOODS_ID_MIN INTEGER,
    ODOCGOODS_ID_MAX INTEGER,
    OGOODS_ID_MIN INTEGER,
    OGOODS_ID_MAX INTEGER,
    OTS_LOW DATE,
    OTS_HIGHT DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_TMP_NOM_BARS
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(27))
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_EXPORT_TMP_NOMENS
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OSG_ID INTEGER,
    OTYPEPDV_ID INTEGER,
    OSI_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE PROCEDURE WW_IMPORT_AO_RECORDS (
    IAO_RECORD_ID INTEGER,
    IAUTOORDER_ID INTEGER,
    INOMEN_ID INTEGER,
    IAOR_BEGIN DOUBLE PRECISION,
    IAOR_ARRIVAL DOUBLE PRECISION,
    IAOR_CHARGE DOUBLE PRECISION,
    IAOR_END DOUBLE PRECISION,
    IAOR_MIN_REST DOUBLE PRECISION,
    IAOR_ORDERED DOUBLE PRECISION,
    IAOR_AVG_KILK DOUBLE PRECISION,
    IRECOM_ORDER DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_AUTOORDERS (
    IAUTOORDER_ID INTEGER,
    ICONDITIONS SMALLINT,
    IAO_DATE DATE,
    INOTE VARCHAR(30),
    ICLIENT_ID INTEGER,
    IANALYSED_DAYS SMALLINT,
    IORDERED_DAYS SMALLINT,
    IUSE_PERIOD SMALLINT,
    IDATE0 DATE,
    IDATE1 DATE,
    IDATE_INPUT DATE)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_BARCODES (
    IBARCODE_ID INTEGER,
    ICODE VARCHAR(27))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_CLIENTS (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_CLIENTS_DEL (
    ICLIENT_ID INTEGER,
    IUNITED_CLIENT_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_CLIENTS_SYNC (
    IW3_CLIENT_ID INTEGER,
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE_LC INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_CLIENTS_V1 (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER,
    IIS_MARKED INTEGER,
    IIPN VARCHAR(20),
    INUM_PDV VARCHAR(20))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_CLIENTS_V2 (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER,
    IIS_MARKED INTEGER,
    IIPN VARCHAR(20),
    INUM_PDV VARCHAR(20),
    ICLIENT_TYPE_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_GRPS (
    IGRP_ID INTEGER,
    IGRP_NAME VARCHAR(40),
    IPREW_GRP_ID INTEGER,
    IGRP_FULL_NAME VARCHAR(250))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_HAPPY_CHECK (
    OID INTEGER,
    OHAPPY_DATE DATE,
    OHAPPY_TIME TIME,
    OHAPPY_SUM0 DOUBLE PRECISION,
    OHAPPY_SUM1 DOUBLE PRECISION,
    OIS_USED INTEGER,
    OUSE_TIME TIMESTAMP)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_MAKERS (
    IMAKER_ID INTEGER,
    INAME VARCHAR(40))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOM_BARS (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IIS_DELETED INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOM_BARS_V1 (
    ICODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IIS_DELETED INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMEN_PRM (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMEN_PRM_V1 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMEN_PRM_V2 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMEN_PRM_V3 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION,
    IACTION_ID SMALLINT,
    IOPT_REST DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMEN_PRM_V4 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION,
    IACTION_ID SMALLINT,
    IOPT_REST DOUBLE PRECISION)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMENS (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMENS_1 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    IMAKER_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMENS_2 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    IMAKER_ID INTEGER,
    ICODE VARCHAR(7),
    IGRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMENS_V1 (
    INOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ICODE VARCHAR(7),
    IGRP_ID INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_NOMENS_V2 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    ICATEGORY SMALLINT)
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_PROPERTYS (
    ITYPEPROP_ID INTEGER,
    INAME VARCHAR(40),
    ISHORT_NAME VARCHAR(10))
AS
BEGIN
  EXIT;
END^


CREATE PROCEDURE WW_IMPORT_SYNC_TS (
    ITS_DOCUMENTS DATE,
    ITS_DOCREC DATE,
    ITS_GOODS DATE,
    ITS_DOCGOODS DATE,
    ITS_DEL_DOCGOODS DATE,
    ITS_DEL_DOCREC DATE,
    ITS_DEL_GOODS DATE,
    ITS_DEL_DOCUMENTS DATE,
    ITS_CHECK DATE)
AS
BEGIN
  EXIT;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE AO_RECORDS (
    AO_RECORD_ID          INTEGER NOT NULL,
    AOR_AUTOORDER_ID      INTEGER,
    AOR_NOMEN_ID          INTEGER,
    AOR_BEGIN             DOUBLE PRECISION,
    AOR_ARRIVAL           DOUBLE PRECISION,
    AOR_CHARGE            DOUBLE PRECISION,
    AOR_END               DOUBLE PRECISION,
    AOR_MIN_REST          DOUBLE PRECISION,
    AOR_ORDERED           DOUBLE PRECISION,
    AOR_CREATE_DATE       TIMESTAMP,
    AOR_CREATE_USER       VARCHAR(12),
    AOR_UPDATE_DATE       TIMESTAMP,
    AOR_UPDATE_USER       VARCHAR(12),
    AOR_MIDDLDAILY_SALES  DOUBLE PRECISION,
    AOR_DAYS_WAS          INTEGER,
    AOR_CHECK             DOUBLE PRECISION
);


CREATE TABLE AUTH (
    AUTH_ID    INTEGER NOT NULL,
    AUTH_DATE  DATE,
    AUTH_NUM   VARCHAR(12),
    AUTH_NAME  VARCHAR(40) COLLATE PXW_CYRL
);


CREATE TABLE AUTOORDERS (
    AUTOORDER_ID      INTEGER NOT NULL,
    AO_CONDITIONS     SMALLINT,
    AO_DATE           DATE,
    AO_NOTE           VARCHAR(30) COLLATE PXW_CYRL,
    AO_CLIENT_ID      INTEGER,
    AO_STAFF_ID       INTEGER,
    AO_ANALYSED_DAYS  SMALLINT,
    AO_ORDERED_DAYS   SMALLINT,
    AO_CREATE_DATE    TIMESTAMP,
    AO_CREATE_USER    VARCHAR(12),
    AO_UPDATE_DATE    TIMESTAMP,
    AO_UPDATE_USER    VARCHAR(12),
    IS_BLOCK          SMALLINT,
    AO_USE_PERIOD     SMALLINT DEFAULT 0 NOT NULL,
    AO_DATE0          DATE,
    AO_DATE1          DATE,
    DOCUMENT_ID       INTEGER,
    USER_ID           INTEGER,
    PRINT_CNT         INTEGER NOT NULL,
    DATE_IN           DATE DEFAULT 'today',
    W3_AUTOORDER_ID   INTEGER
);


CREATE TABLE BANKS (
    BANKS_ID  INTEGER NOT NULL,
    NAME      VARCHAR(40) COLLATE PXW_CYRL,
    MFO       VARCHAR(20) COLLATE PXW_CYRL
);


CREATE TABLE BARCODE (
    BARCODE_ID   INTEGER NOT NULL,
    CODE         VARCHAR(27) COLLATE PXW_CYRL,
    TYPECODE_ID  INTEGER,
    CODE_INT     BIGINT
);


CREATE TABLE CITIES (
    CITY_ID    INTEGER NOT NULL,
    CITY_NAME  VARCHAR(40) COLLATE PXW_CYRL,
    CITY_TYPE  SMALLINT DEFAULT 0,
    REGION_ID  INTEGER DEFAULT 0
);


CREATE TABLE CLIENTACCOUNT (
    ACCOUNT_ID       INTEGER NOT NULL,
    BANKS_ID         INTEGER,
    ACCOUNT_NUM      VARCHAR(20),
    ACCOUNT_GENERAL  INTEGER,
    CLIENTS_ID       INTEGER
);


CREATE TABLE CLIENTS (
    CLIENTS_ID     INTEGER NOT NULL,
    CLIENTS_CODE   VARCHAR(7) NOT NULL COLLATE PXW_CYRL,
    SHORTNAME      VARCHAR(30) COLLATE PXW_CYRL,
    NAME           VARCHAR(50) NOT NULL COLLATE PXW_CYRL,
    TYPECLIENT_ID  INTEGER,
    DATECREATE     DATE,
    CREATOR        VARCHAR(20),
    DATEUPDATE     DATE,
    USERUPDATE     VARCHAR(12),
    TIMEUPDATE     TIME,
    ZKPO           VARCHAR(20),
    ISPDV          INTEGER,
    IPN            VARCHAR(20),
    NUMPDV         VARCHAR(20),
    ADRESS         VARCHAR(50) COLLATE PXW_CYRL,
    PHONE          VARCHAR(24),
    GRPC_ID        INTEGER,
    CLOSED         INTEGER,
    IS_OPT         SMALLINT,
    DATE_UGODY     DATE,
    DIRECTOR       VARCHAR(40) COLLATE PXW_CYRL,
    NUM_UGODY      VARCHAR(20) COLLATE PXW_CYRL,
    TYPEPROP_ID    SMALLINT,
    DELIV_ADDR     VARCHAR(50) COLLATE PXW_CYRL,
    EMAIL          VARCHAR(60) COLLATE PXW_CYRL,
    DISC_PERCENT   DOUBLE PRECISION DEFAULT 0 NOT NULL,
    AMOUNT_DAYS    SMALLINT DEFAULT 0 NOT NULL,
    POSSIBLE_DEBT  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    IS_ACTIVE      SMALLINT DEFAULT 1 NOT NULL,
    W3_CLIENT_ID   INTEGER,
    IS_VISIBLE     SMALLINT DEFAULT 1 NOT NULL,
    IS_EXIST       SMALLINT DEFAULT 1 NOT NULL,
    TS             TIMESTAMP NOT NULL
);


CREATE TABLE DISC_LIST (
    DISC_LIST_ID  INTEGER NOT NULL,
    S_D           DOUBLE PRECISION NOT NULL,
    D_D           DOUBLE PRECISION NOT NULL
);


CREATE TABLE DISCONT (
    DISCONT_ID  INTEGER NOT NULL,
    PROCENT     DOUBLE PRECISION NOT NULL,
    TIPDISCONT  VARCHAR(20) NOT NULL COLLATE PXW_CYRL,
    TS          TIMESTAMP NOT NULL
);


CREATE TABLE DISCONT_AUTO (
    SUMMA       DOUBLE PRECISION,
    DISCONT_ID  INTEGER
);


CREATE TABLE DOC_DEL (
    DOCUMENT_ID   INTEGER NOT NULL,
    DOC_DATE      DATE,
    DOC_NUM       VARCHAR(14),
    DOC_MARK      VARCHAR(14) COLLATE PXW_CYRL,
    TYPEDOC_ID    INTEGER,
    OBJECTS_ID    INTEGER,
    CLIENTS_ID    INTEGER,
    STAFF_ID      INTEGER,
    DOC_LOCK      SMALLINT,
    USER_NAME     VARCHAR(12),
    DISCONT_ID    INTEGER,
    DISC_PERSENT  DOUBLE PRECISION,
    USER_CR       VARCHAR(12),
    DATE_CR       TIMESTAMP
);


CREATE TABLE DOCGOODS (
    DOCGOODS_ID  INTEGER NOT NULL,
    GOODS_ID     INTEGER,
    DOCREC_ID    INTEGER,
    KILK         DOUBLE PRECISION,
    INPRICE      DOUBLE PRECISION,
    INPRICE_PDV  DOUBLE PRECISION,
    INSUM        DOUBLE PRECISION,
    INSUM_PDV    DOUBLE PRECISION,
    TS           TIMESTAMP
);


CREATE TABLE DOCREC (
    DOCREC_ID       INTEGER NOT NULL,
    DOCUMENT_ID     INTEGER NOT NULL,
    NOMEN_ID        INTEGER NOT NULL,
    KILK            DOUBLE PRECISION NOT NULL,
    PRICE           DOUBLE PRECISION NOT NULL,
    DATE_CR         DATE,
    TIME_CR         TIME,
    USER_CR         VARCHAR(12),
    DISC_PERSENT    DOUBLE PRECISION,
    TYPEPDV_ID      INTEGER NOT NULL,
    TYPEPDV_PDV     DOUBLE PRECISION NOT NULL,
    INSUM_PDV       DOUBLE PRECISION,
    INSUM           DOUBLE PRECISION,
    IS_IN_DISCOUNT  SMALLINT DEFAULT 1 NOT NULL,
    USER_CONFIRM    VARCHAR(155),
    TS              TIMESTAMP,
    REC_FILL_ID     INTEGER
);


CREATE TABLE DOCREC_DEL (
    DOCREC_ID     INTEGER NOT NULL,
    DOCUMENT_ID   INTEGER,
    NOMEN_ID      INTEGER,
    KILK          DOUBLE PRECISION,
    PRICE         DOUBLE PRECISION,
    USER_CR       VARCHAR(12),
    DATE_CR       TIMESTAMP,
    USER_CONFIRM  VARCHAR(155)
);


CREATE TABLE DOCREC_LOG (
    DOCREC_LOG_ID  INTEGER NOT NULL,
    DOCUMENT_ID    INTEGER,
    DOC_NUM        VARCHAR(14) COLLATE PXW_CYRL,
    DOC_DATE       DATE,
    TYPEDOC_ID     INTEGER,
    CLIENTS_ID     INTEGER,
    DOCREC_ID      INTEGER,
    NOMEN_ID       INTEGER,
    PRICE          DOUBLE PRECISION,
    KILK_OLD       DOUBLE PRECISION,
    KILK_NEW       DOUBLE PRECISION,
    TYPE_UPD       SMALLINT,
    USER_CRT       VARCHAR(12),
    DATE_CRT       TIMESTAMP,
    USER_CONFIRM   VARCHAR(155)
);


CREATE TABLE DOCREC_TMP (
    DOCREC_ID     INTEGER NOT NULL,
    DOCUMENT_ID   INTEGER,
    NOMEN_ID      INTEGER,
    KILK          DOUBLE PRECISION,
    PRICE         DOUBLE PRECISION,
    USER_CR       VARCHAR(12),
    DATE_CR       TIMESTAMP,
    USER_CONFIRM  VARCHAR(155)
);


CREATE TABLE DOCUMENTS (
    DOCUMENT_ID       INTEGER NOT NULL,
    DOC_DATE          DATE,
    DOC_NUM           VARCHAR(14) NOT NULL,
    DOC_MARK          VARCHAR(14) COLLATE PXW_CYRL,
    TYPEDOC_ID        INTEGER,
    OBJECTS_ID        INTEGER,
    CLIENTS_ID        INTEGER,
    STAFF_ID          INTEGER,
    DATE_CR           DATE,
    DOC_SUM           DOUBLE PRECISION,
    DOC_LOCK          SMALLINT,
    USER_NAME         VARCHAR(12),
    BLOK              INTEGER NOT NULL,
    AUTH_ID           INTEGER,
    DISCONT_ID        INTEGER,
    DISC_PERSENT      DOUBLE PRECISION,
    LOCK_DATE         DATE,
    OPLATA_STATE      SMALLINT,
    OPLATA_TYPE       SMALLINT,
    TIME_CR           TIME,
    DELAY_PAY         INTEGER,
    NOTARIZATION      VARCHAR(12),
    KARDS_ID          INTEGER,
    TIME_FIX          TIME,
    KASSES_ID         INTEGER,
    MAKER_ID          INTEGER,
    RESERVING_TIME    SMALLINT DEFAULT 0 NOT NULL,
    PREW_DOCUMENT_ID  INTEGER,
    TS                TIMESTAMP DEFAULT 'now',
    NOTE              VARCHAR(30)
);


CREATE TABLE E1C_LOG_CREDDOCS (
    DOCUMENT_ID       INTEGER NOT NULL,
    DOC_DATE          DATE,
    PARTNER           VARCHAR(100) COLLATE PXW_CYRL,
    DOC_SUM           DOUBLE PRECISION,
    DOC_SUM_VAT       DOUBLE PRECISION,
    DOC_SUM_WITH_VAT  DOUBLE PRECISION,
    DOC_NUM           VARCHAR(14) COLLATE PXW_CYRL,
    DOC_MARCK         VARCHAR(14) COLLATE PXW_CYRL,
    IS_TAX            SMALLINT,
    TAX_NUM           VARCHAR(20) COLLATE PXW_CYRL,
    TAX_DATE          DATE,
    TAX_SUM           DOUBLE PRECISION,
    TAX_SUM_VAT       DOUBLE PRECISION,
    TAX_SUM_WITH_VAT  DOUBLE PRECISION,
    USER_CR           VARCHAR(12),
    DATE_CR           TIMESTAMP,
    USER_UPD          VARCHAR(12),
    DATE_UPD          TIMESTAMP
);


CREATE TABLE E1C_LOG_DEBDOCS (
    E1C_LOG_DEBDOCS_ID  INTEGER NOT NULL,
    DOCUMENT_ID         INTEGER,
    DOC_DATE            DATE,
    PARTNER             VARCHAR(100) COLLATE PXW_CYRL,
    DOC_SUM             DOUBLE PRECISION,
    DOC_SUM_VAT         DOUBLE PRECISION,
    DOC_SUM_WITH_VAT    DOUBLE PRECISION,
    DOC_NUM             VARCHAR(14) COLLATE PXW_CYRL,
    DOC_MARCK           VARCHAR(14) COLLATE PXW_CYRL,
    IS_TAX              SMALLINT,
    TYPEVAT_ID          SMALLINT,
    TAX_NUM             VARCHAR(20) COLLATE PXW_CYRL,
    TAX_DATE            DATE,
    TAX_SUM             DOUBLE PRECISION,
    TAX_SUM_VAT         DOUBLE PRECISION,
    TAX_SUM_WITH_VAT    DOUBLE PRECISION,
    USER_CR             VARCHAR(12),
    DATE_CR             TIMESTAMP,
    USER_UPD            VARCHAR(12),
    DATE_UPD            TIMESTAMP,
    DOC_SUM_IN          DOUBLE PRECISION
);


CREATE TABLE E1C_LOG_DRAFTS (
    E1C_LOG_DRAFTS_ID  INTEGER NOT NULL,
    DOCDATE            DATE NOT NULL,
    TYPEVAT            SMALLINT NOT NULL,
    KASS_NUM           SMALLINT,
    DOCS_SUM_WITH_VAT  DOUBLE PRECISION,
    DOCS_SUM_VAT       DOUBLE PRECISION,
    DOCS_SUM           DOUBLE PRECISION,
    DOCS_SUMIN         DOUBLE PRECISION,
    USER_CR            VARCHAR(12),
    DATE_CR            TIMESTAMP,
    USER_UPD           VARCHAR(12),
    DATE_UPD           TIMESTAMP,
    TYPEPAY            SMALLINT
);


CREATE TABLE GOODS (
    GOODS_ID       INTEGER NOT NULL,
    NOMEN_ID       INTEGER,
    OBJECTS_ID     INTEGER NOT NULL,
    GOODS_BALANCE  DOUBLE PRECISION,
    GOODS_REST     DOUBLE PRECISION,
    GOODS_INPRICE  DOUBLE PRECISION,
    CLIENTS_ID     INTEGER NOT NULL,
    DOC_DATE       DATE,
    TS             TIMESTAMP
);


CREATE TABLE GRP (
    GRP_ID        INTEGER NOT NULL,
    GRP_NAME      VARCHAR(40) COLLATE PXW_CYRL,
    PREW_GRP_ID   INTEGER,
    CNT           INTEGER,
    GRP_CODE      INTEGER,
    GRP_FULLNAME  VARCHAR(200) COLLATE PXW_CYRL,
    MANAGER_ID    INTEGER,
    SHELF         DOUBLE PRECISION,
    MAKER_ID      INTEGER
);


CREATE TABLE GRPC (
    GRPC_ID       INTEGER NOT NULL,
    GRPC_NAME     VARCHAR(40) COLLATE PXW_CYRL,
    PREW_GRPC_ID  INTEGER,
    GRPC_CODE     INTEGER
);


CREATE TABLE IBE$LOG_BLOB_FIELDS (
    LOG_TABLES_ID   INTEGER NOT NULL,
    FIELD_NAME      VARCHAR(31) NOT NULL,
    OLD_CHAR_VALUE  VARCHAR(32000),
    NEW_CHAR_VALUE  VARCHAR(32000),
    OLD_BLOB_VALUE  BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    NEW_BLOB_VALUE  BLOB SUB_TYPE 0 SEGMENT SIZE 80
);


CREATE TABLE IBE$LOG_FIELDS (
    LOG_TABLES_ID  INTEGER NOT NULL,
    FIELD_NAME     VARCHAR(31) NOT NULL,
    OLD_VALUE      VARCHAR(255),
    NEW_VALUE      VARCHAR(255)
);


CREATE TABLE IBE$LOG_KEYS (
    LOG_TABLES_ID  INTEGER NOT NULL,
    KEY_FIELD      VARCHAR(31) NOT NULL,
    KEY_VALUE      VARCHAR(255)
);


CREATE TABLE IBE$LOG_TABLES (
    ID          INTEGER NOT NULL,
    TABLE_NAME  VARCHAR(31) NOT NULL,
    OPERATION   VARCHAR(1) NOT NULL,
    DATE_TIME   TIMESTAMP NOT NULL,
    USER_NAME   VARCHAR(31) NOT NULL
);


CREATE TABLE IBE$REPORTS (
    IBE$REPORT_ID         INTEGER NOT NULL,
    IBE$REPORT_PARENT_ID  INTEGER NOT NULL,
    IBE$REPORT_NAME       VARCHAR(100) NOT NULL,
    IBE$REPORT_SOURCE     BLOB SUB_TYPE 30 SEGMENT SIZE 100,
    IBE$REPORT_RIGHTS     BLOB SUB_TYPE 30 SEGMENT SIZE 100,
    IBE$REPORT_IS_REPORT  SMALLINT DEFAULT 0 NOT NULL
);


CREATE TABLE IBE$SCRIPTS (
    IBE$SCRIPT_NAME           VARCHAR(64) CHARACTER SET UNICODE_FSS NOT NULL,
    IBE$SCRIPT_TYPE           VARCHAR(15) CHARACTER SET UNICODE_FSS NOT NULL,
    IBE$SCRIPT_SOURCE         BLOB SUB_TYPE 1 SEGMENT SIZE 1024,
    IBE$SCRIPT_BLR            BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_DESCRIPTION    BLOB SUB_TYPE 1 SEGMENT SIZE 1024,
    IBE$SCRIPT_STATE          VARCHAR(15) CHARACTER SET UNICODE_FSS DEFAULT 'INVALID' NOT NULL,
    IBE$SCRIPT_ACTION_ID      INTEGER,
    IBE$SCRIPT_FORM           BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_PARAM_HISTORY  BLOB SUB_TYPE 0 SEGMENT SIZE 1024,
    IBE$SCRIPT_ADD_DATA       BLOB SUB_TYPE 1 SEGMENT SIZE 1024
);


CREATE TABLE IBE$VERSION_HISTORY (
    IBE$VH_ID           INTEGER NOT NULL,
    IBE$VH_MODIFY_DATE  TIMESTAMP NOT NULL,
    IBE$VH_USER_NAME    VARCHAR(31),
    IBE$VH_OBJECT_TYPE  SMALLINT NOT NULL,
    IBE$VH_OBJECT_NAME  VARCHAR(31) NOT NULL,
    IBE$VH_HEADER       VARCHAR(32000),
    IBE$VH_BODY         BLOB SUB_TYPE 0 SEGMENT SIZE 80,
    IBE$VH_DESCRIPTION  BLOB SUB_TYPE 1 SEGMENT SIZE 80
);


CREATE TABLE JOBS (
    JOBS_ID    INTEGER NOT NULL,
    JOBS_NAME  VARCHAR(30) COLLATE PXW_CYRL
);


CREATE TABLE KARDS (
    KARDS_ID    INTEGER NOT NULL,
    DISCONT_ID  INTEGER NOT NULL,
    CLIENTS_ID  INTEGER NOT NULL,
    PIN         INTEGER NOT NULL,
    DATE_CR     DATE,
    CREATOR     VARCHAR(12),
    KARDCODE    VARCHAR(13) NOT NULL,
    NAME        VARCHAR(50) COLLATE PXW_CYRL,
    IS_BLOCK    SMALLINT,
    TS          TIMESTAMP NOT NULL
);


CREATE TABLE KASSES (
    KASSES_ID  INTEGER NOT NULL,
    CNT        INTEGER,
    RN         VARCHAR(24) COLLATE PXW_CYRL,
    TS         TIMESTAMP NOT NULL
);


CREATE TABLE MAKER (
    MAKER_ID    INTEGER NOT NULL,
    MAKER_NAME  VARCHAR(40) NOT NULL COLLATE PXW_CYRL,
    COLOR       INTEGER
);


CREATE TABLE MANAGER (
    MANAGER_ID    INTEGER NOT NULL,
    MANAGER_NAME  VARCHAR(20) COLLATE PXW_CYRL
);


CREATE TABLE NOM_BAR (
    NOM_BAR_ID       INTEGER NOT NULL,
    NOMEN_ID         INTEGER,
    BARCODE_ID       INTEGER,
    OUT_PRICE        DOUBLE PRECISION,
    BARCODE_TYPE_ID  INTEGER,
    CODE_INT         BIGINT,
    TS               TIMESTAMP NOT NULL
);


CREATE TABLE NOM_KAS (
    NOM_KAS_ID  INTEGER NOT NULL,
    NOMEN_ID    INTEGER NOT NULL,
    KASSES_ID   INTEGER NOT NULL,
    ART_NUM     INTEGER,
    OUT_PRICE   DOUBLE PRECISION NOT NULL
);


CREATE TABLE NOMEN (
    NOMEN_ID            INTEGER NOT NULL,
    NOMEN_CODE          VARCHAR(7) NOT NULL,
    NOMEN_NAME          VARCHAR(40) NOT NULL COLLATE PXW_CYRL,
    DATEX_NAME          VARCHAR(26) NOT NULL COLLATE PXW_CYRL,
    TYPEPDV_ID          INTEGER NOT NULL,
    IS_WEIGHT           SMALLINT NOT NULL,
    BRUTTO              NUMERIC(9,3) NOT NULL,
    SI_ID               INTEGER NOT NULL,
    OUT_PRICE           DOUBLE PRECISION NOT NULL,
    GRP_ID              INTEGER,
    SG_ID               INTEGER,
    MINKILK             DOUBLE PRECISION,
    IS_ACTIVE           SMALLINT,
    IS_VISIBLE          SMALLINT,
    MAKER_ID            INTEGER,
    DECREASE_ID         INTEGER,
    W3_NOMEN_ID         INTEGER,
    IS_EXIST            SMALLINT DEFAULT 1 NOT NULL,
    TYPE_NOMEN          SMALLINT DEFAULT 0 NOT NULL,
    IS_IN_DISCOUNT      SMALLINT DEFAULT 1 NOT NULL,
    CATEGORY            SMALLINT DEFAULT 0 NOT NULL,
    IS_MARKUP_BLOCK     SMALLINT DEFAULT 0 NOT NULL,
    RECOMMENDED_MARKUP  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    IS_OUTPRICE_BLOCK   SMALLINT DEFAULT 0 NOT NULL,
    ACTION_ID           SMALLINT DEFAULT 0 NOT NULL,
    TS                  TIMESTAMP NOT NULL
);


CREATE TABLE OBJECTS (
    OBJECTS_ID        INTEGER NOT NULL,
    OBJECTS_NAME      VARCHAR(50) COLLATE PXW_CYRL,
    M_SALE            VARCHAR(1) NOT NULL COLLATE PXW_CYRL,
    CLIENTS_ID        INTEGER,
    AROUND_PRICE_PDV  INTEGER
);


CREATE TABLE PAYMENT (
    PAYMENT_ID   INTEGER NOT NULL,
    DOCUMENT_ID  INTEGER,
    TYPEPAY_ID   INTEGER,
    SUMMA        DOUBLE PRECISION,
    PAY_DATE     DATE
);


CREATE TABLE PRICE (
    PRICE_ID    INTEGER NOT NULL,
    DISCONT_ID  SMALLINT,
    NOMEN_ID    INTEGER,
    PRICE       NUMERIC(9,3)
);


CREATE TABLE PRICEJOURNAL (
    PRICEJOURNAL_ID  INTEGER NOT NULL,
    NOMEN_ID         INTEGER,
    DATE_TIME        TIMESTAMP,
    OUT_PRICE        DOUBLE PRECISION,
    USER_NAME        VARCHAR(12)
);


CREATE TABLE REESTR (
    REESTR_ID        INTEGER NOT NULL,
    DOCUMENT_ID      INTEGER,
    DATA             TIMESTAMP,
    USER_CR          VARCHAR(12),
    TD_NUMBER        VARCHAR(30) COLLATE PXW_CYRL,
    TD_DATE          DATE,
    TD_SUM           DOUBLE PRECISION,
    TD_SUM_VAT       DOUBLE PRECISION,
    TD_SUM_WITH_VAT  DOUBLE PRECISION,
    TD_TYPE          SMALLINT,
    DATE_CR          TIMESTAMP,
    USER_UPD         VARCHAR(12),
    DATE_UPD         TIMESTAMP
);


CREATE TABLE REGIONS (
    REGION_ID    INTEGER NOT NULL,
    REGION_NAME  VARCHAR(40),
    STATE_ID     INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE REV_RECORDS (
    REV_RECORDS_ID  INTEGER NOT NULL,
    REVISION_ID     INTEGER,
    NOMEN_ID        INTEGER,
    PRICE_IN_PDV    DOUBLE PRECISION,
    PRICE_OUT_PDV   DOUBLE PRECISION,
    KILK_OLD        DOUBLE PRECISION,
    KILK_NEW        DOUBLE PRECISION,
    DATE_CREATE     DATE,
    TIME_CREATE     TIME,
    USER_CREATE     VARCHAR(12),
    DATE_UPDATE     DATE,
    TIME_UPDATE     TIME,
    USER_UPDATE     VARCHAR(12)
);


CREATE TABLE REV_TMP (
    REV_TMP_ID   INTEGER NOT NULL,
    NOMEN_ID     INTEGER,
    NOMEN_NAM    VARCHAR(40),
    NOMEN_COD    VARCHAR(7),
    RNOMEN_BARC  VARCHAR(27),
    SKILK        DOUBLE PRECISION,
    FKILK        DOUBLE PRECISION,
    DAT_CR       TIMESTAMP,
    PRICE_IN     DOUBLE PRECISION,
    PRICE_OUT    DOUBLE PRECISION
);


CREATE TABLE REVISION (
    REVISION_ID    INTEGER NOT NULL,
    REVISION_DATE  DATE,
    REVISION_LOCK  SMALLINT,
    OBJECTS_ID     INTEGER,
    DATE_CREATE    DATE,
    TIME_CREATE    TIME,
    USER_CREATE    VARCHAR(12),
    DATE_UPDATE    DATE,
    TIME_UPDATE    TIME,
    USER_UPDATE    VARCHAR(12),
    DATE_LOCK      DATE,
    USER_LOCK      VARCHAR(12),
    REVISION_MARK  VARCHAR(40) COLLATE PXW_CYRL,
    IS_BLOCK       SMALLINT
);


CREATE TABLE RST (
    RST_ID        INTEGER NOT NULL,
    NOMEN_ID      INTEGER NOT NULL,
    OBJECTS_ID    INTEGER NOT NULL,
    REST          DOUBLE PRECISION,
    REST_SUM      DOUBLE PRECISION,
    LAST_INPRICE  DOUBLE PRECISION,
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE SI (
    SI_ID    INTEGER NOT NULL,
    SI_NAME  VARCHAR(12) COLLATE PXW_CYRL
);


CREATE TABLE SPECIALS_GROUPS (
    SG_ID    INTEGER NOT NULL,
    SG_NAME  VARCHAR(30) COLLATE PXW_CYRL
);


CREATE TABLE STAFF (
    STAFF_ID     INTEGER NOT NULL,
    STAFF_NUM    VARCHAR(7) COLLATE PXW_CYRL,
    SURNAME      VARCHAR(20) COLLATE PXW_CYRL,
    NAME         VARCHAR(20) COLLATE PXW_CYRL,
    PATRONYMIC   VARCHAR(20) COLLATE PXW_CYRL,
    DATE_BIRTH   DATE,
    JOBS_ID      INTEGER,
    RESPONSIBLE  SMALLINT,
    JOB_START    DATE,
    JOB_END      DATE,
    PASPORT      VARCHAR(10),
    VIDANO       VARCHAR(30) COLLATE PXW_CYRL
);


CREATE TABLE STATES (
    STATE_ID    INTEGER NOT NULL,
    STATE_NAME  VARCHAR(40) COLLATE PXW_CYRL
);


CREATE TABLE T_1C_LOG (
    DOCUMENT_ID    INTEGER,
    DOCDATE        DATE,
    TYPEDOC        SMALLINT,
    TAXPAYERN      VARCHAR(20),
    SINGLETAXN     VARCHAR(20),
    IPN            VARCHAR(24),
    BANKNAME       VARCHAR(100),
    BANKNUM        VARCHAR(20),
    PAYACCOUNT     VARCHAR(20),
    ISTAXPAY       SMALLINT,
    TYPEVAT        SMALLINT,
    TYPEPAY        SMALLINT,
    SUMWITHVAT     NUMERIC(9,2),
    SUMVAT         NUMERIC(9,2),
    SUMDOC         NUMERIC(9,2),
    SUMIN          NUMERIC(9,2),
    DOCNUM         VARCHAR(14),
    DOCMARCK       VARCHAR(14),
    ISTAX          SMALLINT,
    TAXNUM         VARCHAR(20),
    TAXDATE        DATE,
    TAXSUMWITHVAT  NUMERIC(9,2),
    TAXSUMVAT      NUMERIC(9,2),
    TAXSUM         NUMERIC(9,2),
    USER_UPD       VARCHAR(12),
    DATE_UPD       TIMESTAMP,
    USER_CR        VARCHAR(12),
    DATE_CR        TIMESTAMP,
    SUMREAL        NUMERIC(9,2)
);


CREATE TABLE T_1C_PERIODICS (
    PERIODIC_ID  DATE NOT NULL,
    SUM_X        DOUBLE PRECISION,
    FINAL_DATE   DATE
);


CREATE TABLE T_ACCESS (
    ACCESS_ID  INTEGER NOT NULL,
    NAME       VARCHAR(120),
    PARENT     INTEGER,
    TS         TIMESTAMP NOT NULL
);


CREATE TABLE T_ACTION (
    ID        INTEGER NOT NULL,
    NAME      VARCHAR(20) NOT NULL,
    ORDER_NO  INTEGER
);


CREATE TABLE T_BARCODE_TYPES (
    BARCODE_TYPE_ID  INTEGER NOT NULL,
    TYPE_NAME        VARCHAR(20) COLLATE PXW_CYRL,
    DESCRIPTION      BLOB SUB_TYPE 1 SEGMENT SIZE 1024
);


CREATE TABLE T_CALC_RECORDS (
    CALC_RECORD_ID  INTEGER NOT NULL,
    CALCULATION_ID  INTEGER,
    NOMEN_ID        INTEGER,
    INPUT_QUANTITY  DOUBLE PRECISION,
    NETTO           DOUBLE PRECISION
);


CREATE TABLE T_CALCULATIONS (
    CALCULATION_ID   INTEGER NOT NULL,
    NOMEN_ID         INTEGER,
    OUTPUT_QUANTITY  DOUBLE PRECISION,
    BLOK             INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE T_CATEGORIES (
    CATEGORY_ID  INTEGER NOT NULL,
    NAME         VARCHAR(50)
);


CREATE TABLE T_CLIENTS_SYNC (
    W3_CLIENT_ID            INTEGER NOT NULL,
    TYPECLIENT_ID           INTEGER NOT NULL,
    NAME                    VARCHAR(50),
    ADRESS                  VARCHAR(50),
    ZKPO                    VARCHAR(20),
    IS_PDV                  SMALLINT DEFAULT 1 NOT NULL,
    IS_ACTIVE               SMALLINT DEFAULT 1 NOT NULL,
    DATE_LAST_MODEFICATION  DATE NOT NULL,
    IS_VISIBLE              SMALLINT DEFAULT 1 NOT NULL
);


CREATE TABLE T_CLIENTS_TMP (
    CLIENT_ID               INTEGER NOT NULL,
    TYPECLIENT_ID           INTEGER NOT NULL,
    NAME                    VARCHAR(50),
    ADRESS                  VARCHAR(100),
    ZKPO                    VARCHAR(20),
    IS_PDV                  SMALLINT DEFAULT 1 NOT NULL,
    IS_ACTIVE               SMALLINT DEFAULT 1 NOT NULL,
    DATE_LAST_MODEFICATION  DATE NOT NULL,
    NOTE                    VARCHAR(512)
);


CREATE TABLE T_CONFIGS (
    CONFIG_ID  INTEGER,
    MODULE     VARCHAR(64),
    MARKER     VARCHAR(64),
    DESCIPT    VARCHAR(1024) COLLATE PXW_CYRL,
    TS         TIMESTAMP NOT NULL
);


CREATE TABLE T_COUPON_ARTICLES (
    SKU_EAN_ID      BIGINT NOT NULL,
    COUPON_EAN_ID   BIGINT NOT NULL,
    DISCOUNT_VALUE  DOUBLE PRECISION NOT NULL,
    SKU_NAME        VARCHAR(40) NOT NULL,
    SKU_QUANTITY    DOUBLE PRECISION NOT NULL,
    PRODUCER        VARCHAR(40),
    PRODUCER_OKPO   VARCHAR(20),
    TRADE_MARK      VARCHAR(40),
    UNIT_ID         INTEGER,
    NOMEN_ID        INTEGER,
    TS              TIMESTAMP NOT NULL
);


CREATE TABLE T_COUPON_DISCOUNTS (
    ID                    INTEGER NOT NULL,
    DISCOUNT_DESCRIPTION  VARCHAR(512),
    TS                    TIMESTAMP NOT NULL
);


CREATE TABLE T_COUPON_PROPS (
    COUPON_EAN_ID  BIGINT NOT NULL,
    START_DATE     DATE NOT NULL,
    END_DATE       DATE NOT NULL,
    DISCOUNT_ID    INTEGER NOT NULL,
    TS             TIMESTAMP NOT NULL
);


CREATE TABLE T_COUPON_UNITS (
    ID                INTEGER NOT NULL,
    UNIT_DESCRIPTION  VARCHAR(40) NOT NULL,
    TS                TIMESTAMP NOT NULL
);


CREATE TABLE T_DECR_TYPE (
    DECR_TYPE_ID  INTEGER NOT NULL,
    NAME          VARCHAR(100)
);


CREATE TABLE T_DECREASE (
    DECR_ID       INTEGER NOT NULL,
    DECR_NAME     VARCHAR(256),
    DECR_VALUE    NUMERIC(5,3),
    DECR_TYPE_ID  INTEGER DEFAULT 0
);


CREATE TABLE T_DEL_DOCGOODS (
    DOCGOODS_ID  INTEGER NOT NULL,
    TS           TIMESTAMP
);


CREATE TABLE T_DEL_DOCRECS (
    DOCREC_ID  INTEGER NOT NULL,
    TS         TIMESTAMP
);


CREATE TABLE T_DEL_DOCUMENTS (
    DOCUMENT_ID  INTEGER NOT NULL,
    TS           TIMESTAMP
);


CREATE TABLE T_DEL_GOODS (
    GOODS_ID  INTEGER NOT NULL,
    TS        TIMESTAMP
);


CREATE TABLE T_DOC_PROP (
    DOCUMENT_ID    INTEGER NOT NULL,
    COUPON_EAN_ID  BIGINT NOT NULL
);


CREATE TABLE T_DOCUMENT_AUTOORDER (
    DOCUMENTS_ID  INTEGER NOT NULL,
    AUTOORDER_ID  INTEGER NOT NULL
);


CREATE TABLE T_DOCUMENTS_PRM (
    DOCUMENT_ID  INTEGER NOT NULL,
    LIGHT        SMALLINT
);


CREATE TABLE T_DR_PROP (
    DOCREC_ID       INTEGER NOT NULL,
    COUPON_EAN_ID   BIGINT NOT NULL,
    SKU_QUANTITY    DOUBLE PRECISION NOT NULL,
    DISCOUNT_VALUE  DOUBLE PRECISION NOT NULL
);


CREATE TABLE T_GRPS_SYNC (
    GRP_ID        INTEGER NOT NULL,
    GRP_NAME      VARCHAR(40) COLLATE PXW_CYRL,
    PREW_GRP_ID   INTEGER,
    GRP_FULLNAME  VARCHAR(200) COLLATE PXW_CYRL
);


CREATE TABLE T_HAPPY_CHECK (
    ID          INTEGER NOT NULL,
    HAPPY_DATE  DATE NOT NULL,
    HAPPY_TIME  TIME NOT NULL,
    HAPPY_SUM0  DOUBLE PRECISION NOT NULL,
    HAPPY_SUM1  DOUBLE PRECISION NOT NULL,
    IS_USED     INTEGER,
    USE_TIME    TIMESTAMP
);


CREATE TABLE T_INVOICE_TYPES (
    TYPEDOC_ID     INTEGER NOT NULL,
    INVOICE_TYPES  VARCHAR(64) NOT NULL
);


CREATE TABLE T_INVOICES (
    INVOICE_ID      INTEGER NOT NULL,
    Q_HEADER        VARCHAR(256) COLLATE PXW_CYRL,
    Q_RECORDS       VARCHAR(256) COLLATE PXW_CYRL,
    Q_UPD_AFTER     VARCHAR(256) COLLATE PXW_CYRL,
    FRF_FILTER      VARCHAR(64),
    FRF_DESCRIPTOR  VARCHAR(256) COLLATE PXW_CYRL,
    ACCESS_ID       INTEGER
);


CREATE TABLE T_KARDS_ZVIT_LOG (
    REC_ID     INTEGER NOT NULL,
    DATE_ZVIT  DATE NOT NULL,
    TIME_ZVIT  TIME NOT NULL
);


CREATE TABLE T_MARKUP_AROUNDS (
    MARKUP_AROUND_ID  INTEGER NOT NULL,
    AROUND_NAME       VARCHAR(40),
    ORDER_ID          SMALLINT
);


CREATE TABLE T_MARKUP_RECORDS (
    MARKUP_RECORD_ID  INTEGER NOT NULL,
    MARKUP_ID         INTEGER NOT NULL,
    NOMEN_ID          INTEGER,
    IN_PRICE          DOUBLE PRECISION NOT NULL,
    IN_PRICE_OLD      DOUBLE PRECISION,
    OUT_PRICE         DOUBLE PRECISION,
    TIME_INS          TIMESTAMP,
    TIME_UPD          TIMESTAMP,
    USER_INS_ID       INTEGER,
    USER_UPD_ID       INTEGER,
    REST              DOUBLE PRECISION,
    DOCREC_ID         INTEGER,
    OUT_PRICE_OLD     DOUBLE PRECISION,
    DATE_UPD          DATE
);


CREATE TABLE T_MARKUPS (
    MARKUP_ID    INTEGER NOT NULL,
    IS_FIXED     SMALLINT,
    IS_BLOCK     SMALLINT,
    TOKEN        VARCHAR(14) COLLATE PXW_CYRL,
    TIME_INS     TIMESTAMP,
    TIME_UPD     TIMESTAMP,
    TIME_FIX     TIMESTAMP,
    USER_INS_ID  INTEGER,
    USER_UPD_ID  INTEGER,
    USER_FIX_ID  INTEGER,
    PRINT_CNT    INTEGER
);


CREATE TABLE T_NOM_BARS_SYNC (
    NOM_BAR_ID   INTEGER NOT NULL,
    W3_NOMEN_ID  INTEGER,
    CODE_INT     BIGINT
);


CREATE TABLE T_NOMEN_PARAMS (
    NOMEN_PARAMS_ID  INTEGER NOT NULL,
    PAKAGE_ID        INTEGER
);


CREATE TABLE T_NOMENS_LOG (
    NOMEN_ID      INTEGER NOT NULL,
    NEW_NOMEN_ID  INTEGER,
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE T_NOMENS_SYNC (
    W3_NOMEN_ID   INTEGER NOT NULL,
    CODE          VARCHAR(7) NOT NULL,
    NAME          VARCHAR(40) NOT NULL COLLATE PXW_CYRL,
    EKKA_NAME     VARCHAR(26) NOT NULL COLLATE PXW_CYRL,
    RECEIPT_DATE  DATE,
    GRP_ID        INTEGER
);


CREATE TABLE T_PACTS (
    PACT_ID           INTEGER NOT NULL,
    TOKEN             VARCHAR(14),
    DATE_BEGIN        DATE NOT NULL,
    DATE_END          DATE NOT NULL,
    CLIENT_ID         INTEGER NOT NULL,
    DOCUMENT_ID       INTEGER,
    PACT_SUM          DOUBLE PRECISION,
    PACT_SUM_PDV      DOUBLE PRECISION,
    MONTH_SUM         DOUBLE PRECISION,
    IS_MONTH_PERCENT  SMALLINT DEFAULT 0
);


CREATE TABLE T_PAKAGES (
    PAKAGE_ID   INTEGER NOT NULL,
    FULL_NAME   VARCHAR(40),
    SHORT_NAME  VARCHAR(10)
);


CREATE TABLE T_PAYMENT_RECS (
    ID          INTEGER NOT NULL,
    PAYMENT_ID  INTEGER NOT NULL,
    CLIENTS_ID  INTEGER NOT NULL,
    CATEGORY    VARCHAR(1) DEFAULT 'A' NOT NULL,
    NOTE        VARCHAR(20),
    DOCDATE     DATE DEFAULT 'today' NOT NULL,
    FOUNDATION  VARCHAR(20),
    SUMA        DOUBLE PRECISION NOT NULL
);


CREATE TABLE T_PAYMENTS (
    ID          INTEGER NOT NULL,
    CLIENTS_ID  INTEGER NOT NULL,
    STAFF_ID    INTEGER NOT NULL,
    PAY_DATE    DATE DEFAULT 'today' NOT NULL,
    IS_BLOCK    SMALLINT DEFAULT 0 NOT NULL
);


CREATE TABLE T_PAYS (
    PAY_ID       INTEGER NOT NULL,
    PAY_TYPE_ID  INTEGER NOT NULL,
    DOCUMENT_ID  INTEGER,
    PAY_SUM      DOUBLE PRECISION NOT NULL,
    PAY_DATE     DATE NOT NULL,
    DATE_CRT     DATE DEFAULT 'NOW' NOT NULL,
    BILL_ID      INTEGER
);


CREATE TABLE T_POSTS (
    POST_ID  INTEGER NOT NULL,
    NAME     VARCHAR(40)
);


CREATE TABLE T_PRODUCTION_DOCS (
    ID                      INTEGER NOT NULL,
    TYPE_PRODUCTION_DOC_ID  SMALLINT NOT NULL,
    "DATE"                  DATE NOT NULL,
    DOC_LOCK                SMALLINT DEFAULT 0 NOT NULL,
    BLOK                    SMALLINT DEFAULT 0 NOT NULL,
    CREATE_USER_ID          INTEGER,
    UPDATE_USER_ID          INTEGER,
    NOTE                    VARCHAR(14)
);


CREATE TABLE T_PRODUCTION_RECS (
    ID                 INTEGER NOT NULL,
    PRODUCTION_DOC_ID  INTEGER NOT NULL,
    NOMEN_ID           INTEGER NOT NULL,
    "COUNT"            DOUBLE PRECISION NOT NULL,
    DOCREC_ID          INTEGER
);


CREATE TABLE T_REC_FILLINGS (
    ID                 INTEGER NOT NULL,
    NOMEN_ID           INTEGER NOT NULL,
    "COUNT"            DOUBLE PRECISION NOT NULL,
    IN_PRICE           DOUBLE PRECISION NOT NULL,
    PRODUCTION_REC_ID  INTEGER NOT NULL,
    DOCREC_ID          INTEGER
);


CREATE TABLE T_REPORTCAPTIONS (
    REPORTCAPTION_ID  INTEGER NOT NULL,
    CAPTIONPOSITION   INTEGER,
    REPORT_ID         INTEGER NOT NULL,
    CAPTION           VARCHAR(20),
    DESCRIPTION       VARCHAR(50) COLLATE PXW_CYRL,
    FOOTER_OP         VARCHAR(3)
);


CREATE TABLE T_REPORTFIELDS (
    T_REPORTFIELD_ID  INTEGER NOT NULL,
    NAME              VARCHAR(10),
    FIELDPOSITION     INTEGER,
    REPORT_ID         INTEGER,
    TYPENAME          VARCHAR(10),
    LABEL             VARCHAR(30),
    DESCRIPTION       VARCHAR(50),
    SUMMATION         VARCHAR(10),
    QUERY             VARCHAR(255)
);


CREATE TABLE T_REPORTS (
    REPORT_ID  INTEGER NOT NULL,
    NAME       VARCHAR(50),
    QUERY      VARCHAR(5000),
    DESCRIPT   VARCHAR(1024),
    ACCESS_ID  INTEGER
);


CREATE TABLE T_RIGHTS (
    RIGHT_ID       INTEGER NOT NULL,
    ACCESS_ID      INTEGER,
    RIGHTS_GRP_ID  INTEGER,
    TS             TIMESTAMP NOT NULL
);


CREATE TABLE T_RIGHTS_GRP (
    RIGHT_GRP_ID  INTEGER NOT NULL,
    NAME          VARCHAR(50),
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE T_ROLL_TAX (
    ROLL_TAX_ID      INTEGER NOT NULL,
    DOCUMENT_ID      INTEGER,
    DATA             TIMESTAMP,
    USER_CR          VARCHAR(12),
    TD_NUMBER        VARCHAR(30) COLLATE PXW_CYRL,
    TD_DATE          DATE,
    TD_SUM           DOUBLE PRECISION,
    TD_SUM_VAT       DOUBLE PRECISION,
    TD_SUM_WITH_VAT  DOUBLE PRECISION,
    TD_TYPE          SMALLINT,
    DATE_CR          TIMESTAMP,
    USER_UPD         VARCHAR(12),
    DATE_UPD         TIMESTAMP
);


CREATE TABLE T_SCALES (
    ID          INTEGER NOT NULL,
    IP          VARCHAR(16) NOT NULL,
    NAME        VARCHAR(60),
    TYPE_SCALE  INTEGER NOT NULL
);


CREATE TABLE T_SIS (
    SI_ID  INTEGER NOT NULL,
    NAME   VARCHAR(12) COLLATE PXW_CYRL
);


CREATE TABLE T_SYNC_TS (
    SYNC_ID           INTEGER NOT NULL,
    TS_DOCUMENTS      TIMESTAMP,
    TS_DOCREC         TIMESTAMP,
    TS_GOODS          TIMESTAMP,
    TS_DOCGOODS       TIMESTAMP,
    TS_DEL_DOCGOODS   TIMESTAMP,
    TS_DEL_DOCREC     TIMESTAMP,
    TS_DEL_GOODS      TIMESTAMP,
    TS_DEL_DOCUMENTS  TIMESTAMP,
    SYNC_TS           TIMESTAMP,
    DOCUMENT_ID_MIN   INTEGER,
    DOCUMENT_ID_MAX   INTEGER,
    DOCREC_ID_MIN     INTEGER,
    DOCREC_ID_MAX     INTEGER,
    DOCGOODS_ID_MIN   INTEGER,
    DOCGOODS_ID_MAX   INTEGER,
    GOODS_ID_MIN      INTEGER,
    GOODS_ID_MAX      INTEGER,
    TS_LOW            TIMESTAMP,
    TS_HIGHT          TIMESTAMP,
    TS_CHECK          TIMESTAMP
);


CREATE TABLE T_TMP_NOM_BAR (
    NOM_BAR_ID       INTEGER NOT NULL,
    NOMEN_ID         INTEGER,
    BARCODE_ID       INTEGER,
    OUT_PRICE        DOUBLE PRECISION,
    BARCODE_TYPE_ID  INTEGER
);


CREATE TABLE T_TMP_NOMEN_GROUPS (
    NOMEN_GROUP_ID  INTEGER NOT NULL,
    NAME            VARCHAR(50)
);


CREATE TABLE T_TMP_NOMENS (
    NOMEN_ID                INTEGER NOT NULL,
    SHORT_NAME              VARCHAR(24),
    FULL_NAME               VARCHAR(40),
    DESCRIPTION             VARCHAR(255),
    MAKER_NAME              VARCHAR(80),
    TRADEMARK               VARCHAR(80),
    CODE                    VARCHAR(6),
    IS_DEVIDED              SMALLINT,
    GROUP_ID                INTEGER,
    SG_ID                   INTEGER,
    TYPEPDV_ID              INTEGER,
    SI_ID                   INTEGER,
    DATE_LAST_MODEFICATION  DATE
);


CREATE TABLE T_TYPE_PRODUCT_DOC (
    ID    INTEGER NOT NULL,
    NAME  VARCHAR(60)
);


CREATE TABLE T_TYPE_SCALES (
    ID          INTEGER NOT NULL,
    NAME        VARCHAR(100),
    IS_VISIBLE  SMALLINT DEFAULT 1 NOT NULL
);


CREATE TABLE T_USERS (
    USER_ID           INTEGER NOT NULL,
    USER_LOGIN        VARCHAR(12) NOT NULL,
    USER_KEYWORD      VARCHAR(20) NOT NULL,
    RIGHTS_GRP_ID     INTEGER,
    USER_SURNAME      VARCHAR(50),
    USER_FIRST_NAME   VARCHAR(50),
    USER_SECOND_NAME  VARCHAR(50),
    NICK              VARCHAR(3),
    LAST_DOC          INTEGER,
    SIGNATURE         VARCHAR(128),
    TS                TIMESTAMP NOT NULL
);


CREATE TABLE TYPECLIENT (
    TYPECLIENT_ID    INTEGER NOT NULL,
    TYPECLIENT_NAME  VARCHAR(40) COLLATE PXW_CYRL,
    TS               TIMESTAMP NOT NULL
);


CREATE TABLE TYPEDOC (
    TYPEDOC_ID    INTEGER NOT NULL,
    TYPEDOC_NAME  VARCHAR(30) COLLATE PXW_CYRL,
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE TYPEPAY (
    TYPEPAY_ID    INTEGER NOT NULL,
    TYPEPAY_NAME  VARCHAR(30),
    PAY_LEVEL     SMALLINT,
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE TYPEPDV (
    TYPEPDV_ID    INTEGER NOT NULL,
    TYPEPDV_NAME  VARCHAR(40) COLLATE PXW_CYRL,
    PDV           DOUBLE PRECISION,
    TS            TIMESTAMP NOT NULL
);


CREATE TABLE TYPEPROP (
    TYPEPROP_ID  INTEGER NOT NULL,
    NAME         VARCHAR(100),
    SHORT_NAME   VARCHAR(10) COLLATE PXW_CYRL
);


CREATE TABLE WEIGHT_CODE (
    WEIGHT_CODE_ID  INTEGER NOT NULL,
    CODE            INTEGER
);




/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE RST ADD CONSTRAINT UNQ_RST UNIQUE (NOMEN_ID, OBJECTS_ID);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE AO_RECORDS ADD CONSTRAINT PK_AO_RECORDS PRIMARY KEY (AO_RECORD_ID);
ALTER TABLE AUTH ADD CONSTRAINT PK_AUTH PRIMARY KEY (AUTH_ID);
ALTER TABLE AUTOORDERS ADD CONSTRAINT PK_AUTOORDERS PRIMARY KEY (AUTOORDER_ID);
ALTER TABLE BANKS ADD CONSTRAINT PK_BANKS PRIMARY KEY (BANKS_ID);
ALTER TABLE BARCODE ADD CONSTRAINT PK_BARCODE PRIMARY KEY (BARCODE_ID);
ALTER TABLE CITIES ADD CONSTRAINT FK_CITIES PRIMARY KEY (CITY_ID);
ALTER TABLE CLIENTACCOUNT ADD CONSTRAINT PK_CLIENTACCOUNT PRIMARY KEY (ACCOUNT_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT PK_CLIENTS PRIMARY KEY (CLIENTS_ID);
ALTER TABLE DISCONT ADD CONSTRAINT PK_DISCONT PRIMARY KEY (DISCONT_ID);
ALTER TABLE DISC_LIST ADD PRIMARY KEY (DISC_LIST_ID);
ALTER TABLE DOCGOODS ADD CONSTRAINT PK_DOCGOODS PRIMARY KEY (DOCGOODS_ID);
ALTER TABLE DOCREC ADD CONSTRAINT PK_DOCREC PRIMARY KEY (DOCREC_ID);
ALTER TABLE DOCREC_DEL ADD PRIMARY KEY (DOCREC_ID);
ALTER TABLE DOCREC_LOG ADD CONSTRAINT FK_DOCREC_LOG PRIMARY KEY (DOCREC_LOG_ID);
ALTER TABLE DOCREC_TMP ADD PRIMARY KEY (DOCREC_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT PK_DOCUMENTS PRIMARY KEY (DOCUMENT_ID);
ALTER TABLE DOC_DEL ADD PRIMARY KEY (DOCUMENT_ID);
ALTER TABLE E1C_LOG_CREDDOCS ADD CONSTRAINT FK_E1C_LOG_CREDDOCS PRIMARY KEY (DOCUMENT_ID);
ALTER TABLE E1C_LOG_DEBDOCS ADD PRIMARY KEY (E1C_LOG_DEBDOCS_ID);
ALTER TABLE E1C_LOG_DRAFTS ADD CONSTRAINT FK_E1C_LOG_DRAFTS PRIMARY KEY (E1C_LOG_DRAFTS_ID);
ALTER TABLE GOODS ADD CONSTRAINT PK_GOODS PRIMARY KEY (GOODS_ID);
ALTER TABLE GRP ADD PRIMARY KEY (GRP_ID);
ALTER TABLE GRPC ADD PRIMARY KEY (GRPC_ID);
ALTER TABLE IBE$LOG_TABLES ADD PRIMARY KEY (ID);
ALTER TABLE IBE$REPORTS ADD PRIMARY KEY (IBE$REPORT_ID);
ALTER TABLE IBE$VERSION_HISTORY ADD PRIMARY KEY (IBE$VH_ID);
ALTER TABLE JOBS ADD CONSTRAINT PK_JOBS PRIMARY KEY (JOBS_ID);
ALTER TABLE KARDS ADD CONSTRAINT PK_KARDS PRIMARY KEY (KARDS_ID);
ALTER TABLE KASSES ADD CONSTRAINT FK_KASSES PRIMARY KEY (KASSES_ID);
ALTER TABLE MAKER ADD CONSTRAINT PK_MAKER PRIMARY KEY (MAKER_ID);
ALTER TABLE MANAGER ADD PRIMARY KEY (MANAGER_ID);
ALTER TABLE NOMEN ADD CONSTRAINT PK_NOMEN PRIMARY KEY (NOMEN_ID);
ALTER TABLE NOM_BAR ADD PRIMARY KEY (NOM_BAR_ID);
ALTER TABLE NOM_KAS ADD CONSTRAINT FK_NOM_KAS PRIMARY KEY (NOM_KAS_ID);
ALTER TABLE OBJECTS ADD CONSTRAINT PK_OBJECTS PRIMARY KEY (OBJECTS_ID);
ALTER TABLE PAYMENT ADD CONSTRAINT FK_PAYMENT PRIMARY KEY (PAYMENT_ID);
ALTER TABLE PRICE ADD CONSTRAINT PK_PRICE PRIMARY KEY (PRICE_ID);
ALTER TABLE PRICEJOURNAL ADD PRIMARY KEY (PRICEJOURNAL_ID);
ALTER TABLE REESTR ADD PRIMARY KEY (REESTR_ID);
ALTER TABLE REGIONS ADD CONSTRAINT FK_REGIONS PRIMARY KEY (REGION_ID);
ALTER TABLE REVISION ADD PRIMARY KEY (REVISION_ID);
ALTER TABLE REV_RECORDS ADD PRIMARY KEY (REV_RECORDS_ID);
ALTER TABLE REV_TMP ADD CONSTRAINT FK_REV_TMP PRIMARY KEY (REV_TMP_ID);
ALTER TABLE RST ADD CONSTRAINT FK_RST PRIMARY KEY (RST_ID);
ALTER TABLE SI ADD CONSTRAINT PK_SI PRIMARY KEY (SI_ID);
ALTER TABLE SPECIALS_GROUPS ADD CONSTRAINT FK_SPECIALS_GROUPS PRIMARY KEY (SG_ID);
ALTER TABLE STAFF ADD CONSTRAINT PK_STAFF PRIMARY KEY (STAFF_ID);
ALTER TABLE STATES ADD CONSTRAINT FK_STATES PRIMARY KEY (STATE_ID);
ALTER TABLE TYPECLIENT ADD CONSTRAINT PK_TYPECLIENT PRIMARY KEY (TYPECLIENT_ID);
ALTER TABLE TYPEDOC ADD CONSTRAINT PK_TYPEDOC PRIMARY KEY (TYPEDOC_ID);
ALTER TABLE TYPEPAY ADD CONSTRAINT PK_TYPEPAY PRIMARY KEY (TYPEPAY_ID);
ALTER TABLE TYPEPDV ADD CONSTRAINT PK_TYPEPDV PRIMARY KEY (TYPEPDV_ID);
ALTER TABLE TYPEPROP ADD CONSTRAINT FK_TYPEPROP PRIMARY KEY (TYPEPROP_ID);
ALTER TABLE T_1C_PERIODICS ADD CONSTRAINT PK_T_1C_PERIODICS PRIMARY KEY (PERIODIC_ID);
ALTER TABLE T_ACCESS ADD CONSTRAINT PK_T_ACCESS PRIMARY KEY (ACCESS_ID);
ALTER TABLE T_ACTION ADD CONSTRAINT PK_T_ACTION PRIMARY KEY (ID);
ALTER TABLE T_BARCODE_TYPES ADD CONSTRAINT FK_T_BARCODE_TYPES PRIMARY KEY (BARCODE_TYPE_ID);
ALTER TABLE T_CALCULATIONS ADD CONSTRAINT PK_T_CALCULATIONS PRIMARY KEY (CALCULATION_ID);
ALTER TABLE T_CALC_RECORDS ADD CONSTRAINT PK_T_CALC_RECORDS PRIMARY KEY (CALC_RECORD_ID);
ALTER TABLE T_CATEGORIES ADD CONSTRAINT PK_T_CATEGORIES PRIMARY KEY (CATEGORY_ID);
ALTER TABLE T_CLIENTS_SYNC ADD CONSTRAINT PK_T_CLIENTS_SYNC PRIMARY KEY (W3_CLIENT_ID);
ALTER TABLE T_CLIENTS_TMP ADD CONSTRAINT PK_T_CLIENTS_TMP PRIMARY KEY (CLIENT_ID);
ALTER TABLE T_COUPON_ARTICLES ADD CONSTRAINT PK_T_COUPON_ARTICLES PRIMARY KEY (SKU_EAN_ID, COUPON_EAN_ID);
ALTER TABLE T_COUPON_DISCOUNTS ADD CONSTRAINT PK_T_COUPON_DISCOUNTS PRIMARY KEY (ID);
ALTER TABLE T_COUPON_PROPS ADD CONSTRAINT PK_T_COUPON_PROPS PRIMARY KEY (COUPON_EAN_ID);
ALTER TABLE T_COUPON_UNITS ADD CONSTRAINT PK_T_COUPON_UNITS PRIMARY KEY (ID);
ALTER TABLE T_DECREASE ADD CONSTRAINT PK_T_DECREASE PRIMARY KEY (DECR_ID);
ALTER TABLE T_DECR_TYPE ADD CONSTRAINT PK_T_DECR_TYPE PRIMARY KEY (DECR_TYPE_ID);
ALTER TABLE T_DEL_DOCGOODS ADD CONSTRAINT PK_T_DEL_DOCGOODS PRIMARY KEY (DOCGOODS_ID);
ALTER TABLE T_DEL_DOCRECS ADD CONSTRAINT PK_T_DEL_DOCRECS PRIMARY KEY (DOCREC_ID);
ALTER TABLE T_DEL_DOCUMENTS ADD CONSTRAINT PK_T_DEL_DOCUMENTS PRIMARY KEY (DOCUMENT_ID);
ALTER TABLE T_DEL_GOODS ADD CONSTRAINT PK_T_DEL_GOODS PRIMARY KEY (GOODS_ID);
ALTER TABLE T_DOCUMENTS_PRM ADD CONSTRAINT PK_T_DOCUMENTS_PRM PRIMARY KEY (DOCUMENT_ID);
ALTER TABLE T_DOCUMENT_AUTOORDER ADD CONSTRAINT PK_T_DOCUMENT_AUTOORDER PRIMARY KEY (DOCUMENTS_ID, AUTOORDER_ID);
ALTER TABLE T_DOC_PROP ADD CONSTRAINT PK_T_DOC_PROP PRIMARY KEY (DOCUMENT_ID, COUPON_EAN_ID);
ALTER TABLE T_DR_PROP ADD CONSTRAINT PK_T_DR_PROP PRIMARY KEY (COUPON_EAN_ID, DOCREC_ID);
ALTER TABLE T_GRPS_SYNC ADD CONSTRAINT FK_T_GRPS_SYNC PRIMARY KEY (GRP_ID);
ALTER TABLE T_HAPPY_CHECK ADD CONSTRAINT PK_T_HAPPY_CHECK PRIMARY KEY (ID);
ALTER TABLE T_INVOICES ADD CONSTRAINT PK_T_INVOICES PRIMARY KEY (INVOICE_ID);
ALTER TABLE T_INVOICE_TYPES ADD CONSTRAINT PK_T_INVOICE_TYPES PRIMARY KEY (TYPEDOC_ID);
ALTER TABLE T_KARDS_ZVIT_LOG ADD CONSTRAINT PK_T_KARDS_ZVIT_LOG PRIMARY KEY (REC_ID);
ALTER TABLE T_MARKUPS ADD CONSTRAINT FK_T_MARKUPS PRIMARY KEY (MARKUP_ID);
ALTER TABLE T_MARKUP_AROUNDS ADD CONSTRAINT FK_T_MARKUP_AROUNDS PRIMARY KEY (MARKUP_AROUND_ID);
ALTER TABLE T_MARKUP_RECORDS ADD CONSTRAINT FK_T_MARKUP_RECORDS PRIMARY KEY (MARKUP_RECORD_ID);
ALTER TABLE T_NOMENS_SYNC ADD CONSTRAINT FK_T_NOMENS_SYNC PRIMARY KEY (W3_NOMEN_ID);
ALTER TABLE T_NOMEN_PARAMS ADD CONSTRAINT FK_T_NOMEN_PARAMS PRIMARY KEY (NOMEN_PARAMS_ID);
ALTER TABLE T_NOM_BARS_SYNC ADD CONSTRAINT FK_T_NOM_BARS_SYNC PRIMARY KEY (NOM_BAR_ID);
ALTER TABLE T_PACTS ADD CONSTRAINT PK_T_PACTS PRIMARY KEY (PACT_ID);
ALTER TABLE T_PAYMENTS ADD CONSTRAINT PK_T_PAYMENTS PRIMARY KEY (ID);
ALTER TABLE T_PAYMENT_RECS ADD CONSTRAINT PK_T_PAYMENT_RECS PRIMARY KEY (ID);
ALTER TABLE T_PAYS ADD CONSTRAINT PK_T_PAYS PRIMARY KEY (PAY_ID);
ALTER TABLE T_POSTS ADD CONSTRAINT PK_T_POSTS PRIMARY KEY (POST_ID);
ALTER TABLE T_PRODUCTION_DOCS ADD CONSTRAINT PK_T_PRODUCTION_DOCS PRIMARY KEY (ID);
ALTER TABLE T_PRODUCTION_RECS ADD CONSTRAINT PK_T_PRODUCTION_RECS PRIMARY KEY (ID);
ALTER TABLE T_REC_FILLINGS ADD CONSTRAINT PK_T_REC_FILLINGS PRIMARY KEY (ID);
ALTER TABLE T_REPORTCAPTIONS ADD CONSTRAINT FK_T_REPORTCAPTIONS PRIMARY KEY (REPORTCAPTION_ID);
ALTER TABLE T_REPORTFIELDS ADD CONSTRAINT FK_T_REPORTFIELDS PRIMARY KEY (T_REPORTFIELD_ID);
ALTER TABLE T_REPORTS ADD CONSTRAINT FK_T_REPORTS PRIMARY KEY (REPORT_ID);
ALTER TABLE T_RIGHTS ADD CONSTRAINT PK_T_RIGHTS PRIMARY KEY (RIGHT_ID);
ALTER TABLE T_RIGHTS_GRP ADD CONSTRAINT PK_T_RIGHTS_GRP PRIMARY KEY (RIGHT_GRP_ID);
ALTER TABLE T_ROLL_TAX ADD PRIMARY KEY (ROLL_TAX_ID);
ALTER TABLE T_SCALES ADD CONSTRAINT PK_T_SCALES PRIMARY KEY (ID);
ALTER TABLE T_SYNC_TS ADD CONSTRAINT PK_T_SYNC_TS PRIMARY KEY (SYNC_ID);
ALTER TABLE T_TMP_NOMENS ADD CONSTRAINT PK_T_TMP_NOMENS PRIMARY KEY (NOMEN_ID);
ALTER TABLE T_TMP_NOMEN_GROUPS ADD CONSTRAINT PK_T_TMP_NOMEN_GROUPS PRIMARY KEY (NOMEN_GROUP_ID);
ALTER TABLE T_TMP_NOM_BAR ADD CONSTRAINT PK_T_TMP_NOM_BAR PRIMARY KEY (NOM_BAR_ID);
ALTER TABLE T_TYPE_PRODUCT_DOC ADD CONSTRAINT PK_T_TYPE_PRODUCT_DOC PRIMARY KEY (ID);
ALTER TABLE T_TYPE_SCALES ADD CONSTRAINT PK_T_TYPE_SCALES PRIMARY KEY (ID);
ALTER TABLE T_USERS ADD CONSTRAINT PK_T_USERS PRIMARY KEY (USER_ID);
ALTER TABLE WEIGHT_CODE ADD PRIMARY KEY (WEIGHT_CODE_ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE AO_RECORDS ADD CONSTRAINT FK_AO_RECORDS FOREIGN KEY (AOR_AUTOORDER_ID) REFERENCES AUTOORDERS (AUTOORDER_ID);
ALTER TABLE CITIES ADD CONSTRAINT FK_CITIES_REGIONS FOREIGN KEY (REGION_ID) REFERENCES REGIONS (REGION_ID);
ALTER TABLE CLIENTACCOUNT ADD CONSTRAINT FK_CLIENTACCOUNT_BANKS FOREIGN KEY (BANKS_ID) REFERENCES BANKS (BANKS_ID);
ALTER TABLE CLIENTACCOUNT ADD CONSTRAINT FK_CLIENTACCOUNT_CLIENTS FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_GRPC FOREIGN KEY (GRPC_ID) REFERENCES GRPC (GRPC_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_TYPECLIENT FOREIGN KEY (TYPECLIENT_ID) REFERENCES TYPECLIENT (TYPECLIENT_ID);
ALTER TABLE CLIENTS ADD CONSTRAINT FK_CLIENTS_TYPEPROP FOREIGN KEY (TYPEPROP_ID) REFERENCES TYPEPROP (TYPEPROP_ID);
ALTER TABLE DISCONT_AUTO ADD CONSTRAINT FK_DISCONT_AUTO_DISCONT FOREIGN KEY (DISCONT_ID) REFERENCES DISCONT (DISCONT_ID);
ALTER TABLE DOCGOODS ADD CONSTRAINT FK_DOCGOODS_DOCREC FOREIGN KEY (DOCREC_ID) REFERENCES DOCREC (DOCREC_ID);
ALTER TABLE DOCGOODS ADD CONSTRAINT FK_DOCGOODS_GOODS FOREIGN KEY (GOODS_ID) REFERENCES GOODS (GOODS_ID);
ALTER TABLE DOCREC ADD CONSTRAINT FK_DOCREC_DOCUMENTS FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE DOCREC ADD CONSTRAINT FK_DOCREC_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE DOCREC ADD CONSTRAINT FK_DOCREC_TYPEPDV FOREIGN KEY (TYPEPDV_ID) REFERENCES TYPEPDV (TYPEPDV_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_2 FOREIGN KEY (PREW_DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_AUTH FOREIGN KEY (AUTH_ID) REFERENCES AUTH (AUTH_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_CLIENTS FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_KARDS FOREIGN KEY (KARDS_ID) REFERENCES KARDS (KARDS_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_OBJECTS FOREIGN KEY (OBJECTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE DOCUMENTS ADD CONSTRAINT FK_DOCUMENTS_STAFF FOREIGN KEY (STAFF_ID) REFERENCES STAFF (STAFF_ID);
ALTER TABLE GOODS ADD CONSTRAINT FK_GOODS_CLIENTS FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE GOODS ADD CONSTRAINT FK_GOODS_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE GOODS ADD CONSTRAINT FK_GOODS_OBJECTS FOREIGN KEY (OBJECTS_ID) REFERENCES OBJECTS (OBJECTS_ID);
ALTER TABLE GRP ADD CONSTRAINT FK_GRP_MANAGER FOREIGN KEY (MANAGER_ID) REFERENCES MANAGER (MANAGER_ID);
ALTER TABLE GRP ADD CONSTRAINT FK_GRP_PREW_GRP FOREIGN KEY (PREW_GRP_ID) REFERENCES GRP (GRP_ID);
ALTER TABLE GRPC ADD CONSTRAINT FK_GRPC_PREW_GRPC FOREIGN KEY (PREW_GRPC_ID) REFERENCES GRPC (GRPC_ID);
ALTER TABLE KARDS ADD CONSTRAINT FK_KARDS_CLIENTS FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE KARDS ADD CONSTRAINT FK_KARDS_DISCONT FOREIGN KEY (DISCONT_ID) REFERENCES DISCONT (DISCONT_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN FOREIGN KEY (GRP_ID) REFERENCES GRP (GRP_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN_DECREASE FOREIGN KEY (DECREASE_ID) REFERENCES T_DECREASE (DECR_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN_MAKER FOREIGN KEY (MAKER_ID) REFERENCES MAKER (MAKER_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN_SG FOREIGN KEY (SG_ID) REFERENCES SPECIALS_GROUPS (SG_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN_SI FOREIGN KEY (SI_ID) REFERENCES SI (SI_ID);
ALTER TABLE NOMEN ADD CONSTRAINT FK_NOMEN_TYPEPDV FOREIGN KEY (TYPEPDV_ID) REFERENCES TYPEPDV (TYPEPDV_ID);
ALTER TABLE NOM_BAR ADD CONSTRAINT FK_NOM_BAR FOREIGN KEY (BARCODE_ID) REFERENCES BARCODE (BARCODE_ID);
ALTER TABLE NOM_BAR ADD CONSTRAINT FK_NOM_BAR_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE NOM_KAS ADD CONSTRAINT FK_NOM_KAS_KASSES FOREIGN KEY (KASSES_ID) REFERENCES KASSES (KASSES_ID);
ALTER TABLE NOM_KAS ADD CONSTRAINT FK_NOM_KAS_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE OBJECTS ADD CONSTRAINT FK_OBJECTS_CLIENTS FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE PAYMENT ADD CONSTRAINT FK_PAYMENT_SOCUMENTS FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE PAYMENT ADD CONSTRAINT FK_PAYMENT_TYPEPAY FOREIGN KEY (TYPEPAY_ID) REFERENCES TYPEPAY (TYPEPAY_ID);
ALTER TABLE PRICE ADD CONSTRAINT FK_PRICE_DISCONT FOREIGN KEY (DISCONT_ID) REFERENCES DISCONT (DISCONT_ID);
ALTER TABLE PRICE ADD CONSTRAINT FK_PRICE_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE PRICEJOURNAL ADD CONSTRAINT FK_PRICEJOURNAL_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE REESTR ADD CONSTRAINT FK_REESTR FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE REGIONS ADD CONSTRAINT FK_REGIONS_STATES FOREIGN KEY (STATE_ID) REFERENCES STATES (STATE_ID);
ALTER TABLE REVISION ADD CONSTRAINT FK_REVISION_OBJECTS FOREIGN KEY (OBJECTS_ID) REFERENCES OBJECTS (OBJECTS_ID);
ALTER TABLE REV_RECORDS ADD CONSTRAINT FK_REV_RECORDS_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE REV_RECORDS ADD CONSTRAINT FK_REV_RECORDS_REVISION FOREIGN KEY (REVISION_ID) REFERENCES REVISION (REVISION_ID);
ALTER TABLE RST ADD CONSTRAINT FK_RST_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE RST ADD CONSTRAINT FK_RST_OBJECTS FOREIGN KEY (OBJECTS_ID) REFERENCES OBJECTS (OBJECTS_ID);
ALTER TABLE T_CALCULATIONS ADD CONSTRAINT FK_T_CALCULATIONS_TO_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE T_CALC_RECORDS ADD CONSTRAINT FK_T_CR_TO_CALCULATION FOREIGN KEY (CALCULATION_ID) REFERENCES T_CALCULATIONS (CALCULATION_ID);
ALTER TABLE T_CALC_RECORDS ADD CONSTRAINT FK_T_CR_TO_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE T_CLIENTS_SYNC ADD CONSTRAINT FK_T_CLIENTS_SYNC_2 FOREIGN KEY (TYPECLIENT_ID) REFERENCES TYPECLIENT (TYPECLIENT_ID);
ALTER TABLE T_CLIENTS_TMP ADD CONSTRAINT FK_T_CLIENTS_TMP_2 FOREIGN KEY (TYPECLIENT_ID) REFERENCES TYPECLIENT (TYPECLIENT_ID);
ALTER TABLE T_COUPON_ARTICLES ADD CONSTRAINT FK_T_COUPON_ARTICLES_1 FOREIGN KEY (COUPON_EAN_ID) REFERENCES T_COUPON_PROPS (COUPON_EAN_ID);
ALTER TABLE T_COUPON_ARTICLES ADD CONSTRAINT FK_T_COUPON_ARTICLES_UNIT FOREIGN KEY (UNIT_ID) REFERENCES T_COUPON_UNITS (ID);
ALTER TABLE T_COUPON_PROPS ADD CONSTRAINT FK_T_COUPON_PROPS_DISCOUNT FOREIGN KEY (DISCOUNT_ID) REFERENCES T_COUPON_DISCOUNTS (ID);
ALTER TABLE T_DECREASE ADD CONSTRAINT FK_T_DECREASE_DECR_TYPE FOREIGN KEY (DECR_TYPE_ID) REFERENCES T_DECR_TYPE (DECR_TYPE_ID);
ALTER TABLE T_DOCUMENTS_PRM ADD CONSTRAINT FK_T_DOCUMENTS_PRM_DOC FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE T_DOCUMENT_AUTOORDER ADD CONSTRAINT FK_T_DOCUMENT_AUTOORDER_1 FOREIGN KEY (DOCUMENTS_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE T_DOCUMENT_AUTOORDER ADD CONSTRAINT FK_T_DOCUMENT_AUTOORDER_2 FOREIGN KEY (AUTOORDER_ID) REFERENCES AUTOORDERS (AUTOORDER_ID);
ALTER TABLE T_DOC_PROP ADD CONSTRAINT FK_T_DOC_PROP_DOC FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE T_DOC_PROP ADD CONSTRAINT FK_T_DOC_PROP_PROP FOREIGN KEY (COUPON_EAN_ID) REFERENCES T_COUPON_PROPS (COUPON_EAN_ID);
ALTER TABLE T_DR_PROP ADD CONSTRAINT FK_T_DR_PROP_DOCREC FOREIGN KEY (DOCREC_ID) REFERENCES DOCREC (DOCREC_ID);
ALTER TABLE T_DR_PROP ADD CONSTRAINT FK_T_DR_PROP_PROP FOREIGN KEY (COUPON_EAN_ID) REFERENCES T_COUPON_PROPS (COUPON_EAN_ID);
ALTER TABLE T_GRPS_SYNC ADD CONSTRAINT FK_T_GRPS_SYNC_PREW_GRP FOREIGN KEY (PREW_GRP_ID) REFERENCES T_GRPS_SYNC (GRP_ID);
ALTER TABLE T_INVOICES ADD CONSTRAINT FK_T_INVOICES_ACCESS FOREIGN KEY (ACCESS_ID) REFERENCES T_ACCESS (ACCESS_ID);
ALTER TABLE T_INVOICE_TYPES ADD CONSTRAINT FK_T_INVOICE_TYPES_TD FOREIGN KEY (TYPEDOC_ID) REFERENCES TYPEDOC (TYPEDOC_ID);
ALTER TABLE T_MARKUP_RECORDS ADD CONSTRAINT FK_T_MARKUP_RECORDS_MARKUPS FOREIGN KEY (MARKUP_ID) REFERENCES T_MARKUPS (MARKUP_ID);
ALTER TABLE T_MARKUP_RECORDS ADD CONSTRAINT FK_T_MARKUP_RECORDS_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE T_NOMENS_SYNC ADD CONSTRAINT FK_T_NOMENS_SYNC_GRP FOREIGN KEY (GRP_ID) REFERENCES T_GRPS_SYNC (GRP_ID);
ALTER TABLE T_PACTS ADD CONSTRAINT FK_T_PACTS_CLIENTS FOREIGN KEY (CLIENT_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE T_PACTS ADD CONSTRAINT FK_T_PACTS_DOCUMENTS FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE T_PAYMENTS ADD CONSTRAINT FK_T_PAYMENTS_2 FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE T_PAYMENTS ADD CONSTRAINT FK_T_PAYMENTS_3 FOREIGN KEY (STAFF_ID) REFERENCES STAFF (STAFF_ID);
ALTER TABLE T_PAYMENT_RECS ADD CONSTRAINT FK_T_PAYMENT_RECS_1 FOREIGN KEY (PAYMENT_ID) REFERENCES T_PAYMENTS (ID);
ALTER TABLE T_PAYMENT_RECS ADD CONSTRAINT FK_T_PAYMENT_RECS_3 FOREIGN KEY (CLIENTS_ID) REFERENCES CLIENTS (CLIENTS_ID);
ALTER TABLE T_PAYS ADD CONSTRAINT FK_T_PAYS_DOCUMENTS FOREIGN KEY (DOCUMENT_ID) REFERENCES DOCUMENTS (DOCUMENT_ID);
ALTER TABLE T_PAYS ADD CONSTRAINT FK_T_PAYS_TYPEPAY FOREIGN KEY (PAY_TYPE_ID) REFERENCES TYPEPAY (TYPEPAY_ID);
ALTER TABLE T_PRODUCTION_RECS ADD CONSTRAINT FK_T_PRODUCTION_RECS_2 FOREIGN KEY (DOCREC_ID) REFERENCES DOCREC (DOCREC_ID);
ALTER TABLE T_PRODUCTION_RECS ADD CONSTRAINT FK_T_PRODUCTION_RECS_DOC FOREIGN KEY (PRODUCTION_DOC_ID) REFERENCES T_PRODUCTION_DOCS (ID);
ALTER TABLE T_PRODUCTION_RECS ADD CONSTRAINT FK_T_PRODUCTION_RECS_NOMEN FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE T_REC_FILLINGS ADD CONSTRAINT FK_T_REC_FILLINGS_2 FOREIGN KEY (DOCREC_ID) REFERENCES DOCREC (DOCREC_ID);
ALTER TABLE T_REC_FILLINGS ADD CONSTRAINT FK_T_REC_FILLINGS_NOM FOREIGN KEY (NOMEN_ID) REFERENCES NOMEN (NOMEN_ID);
ALTER TABLE T_REC_FILLINGS ADD CONSTRAINT FK_T_REC_FILLINGS_REC FOREIGN KEY (PRODUCTION_REC_ID) REFERENCES T_PRODUCTION_RECS (ID);
ALTER TABLE T_REPORTCAPTIONS ADD CONSTRAINT FK_T_REPORTCAPTIONS_REPORTS FOREIGN KEY (REPORT_ID) REFERENCES T_REPORTS (REPORT_ID);
ALTER TABLE T_REPORTFIELDS ADD CONSTRAINT FK_T_REPORTFIELDS_REPORTS FOREIGN KEY (REPORT_ID) REFERENCES T_REPORTS (REPORT_ID);
ALTER TABLE T_RIGHTS ADD CONSTRAINT FK_T_RIGHTS_TO_T_ACCESS FOREIGN KEY (ACCESS_ID) REFERENCES T_ACCESS (ACCESS_ID);
ALTER TABLE T_RIGHTS ADD CONSTRAINT FK_T_RIGHTS_TO_T_RIGHTS_GRP FOREIGN KEY (RIGHTS_GRP_ID) REFERENCES T_RIGHTS_GRP (RIGHT_GRP_ID);
ALTER TABLE T_SCALES ADD CONSTRAINT FK_T_SCALES_1 FOREIGN KEY (TYPE_SCALE) REFERENCES T_TYPE_SCALES (ID);
ALTER TABLE T_TMP_NOMENS ADD CONSTRAINT FK_T_TMP_NOMENS_TO_GROUPS FOREIGN KEY (GROUP_ID) REFERENCES T_TMP_NOMEN_GROUPS (NOMEN_GROUP_ID);
ALTER TABLE T_TMP_NOMENS ADD CONSTRAINT FK_T_TMP_NOMENS_TO_SG FOREIGN KEY (SG_ID) REFERENCES SPECIALS_GROUPS (SG_ID);
ALTER TABLE T_TMP_NOMENS ADD CONSTRAINT FK_T_TMP_NOMENS_TO_SI FOREIGN KEY (SI_ID) REFERENCES SI (SI_ID);
ALTER TABLE T_TMP_NOMENS ADD CONSTRAINT FK_T_TMP_NOMENS_TO_TYPEPDV FOREIGN KEY (TYPEPDV_ID) REFERENCES TYPEPDV (TYPEPDV_ID);
ALTER TABLE T_TMP_NOM_BAR ADD CONSTRAINT FK_T_TMP_NOM_BAR_TO_BARCODE FOREIGN KEY (BARCODE_ID) REFERENCES BARCODE (BARCODE_ID);
ALTER TABLE T_TMP_NOM_BAR ADD CONSTRAINT FK_T_TMP_NOM_BAR_TO_TN FOREIGN KEY (NOMEN_ID) REFERENCES T_TMP_NOMENS (NOMEN_ID);
ALTER TABLE T_USERS ADD CONSTRAINT FK_T_USERS_RIGHT FOREIGN KEY (RIGHTS_GRP_ID) REFERENCES T_RIGHTS_GRP (RIGHT_GRP_ID);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX BARCODE_CODE_INT ON BARCODE (CODE_INT);
CREATE UNIQUE INDEX BARCODE_IDX1 ON BARCODE (CODE);
CREATE INDEX CLIENTS_IDX1 ON CLIENTS (CLIENTS_CODE, ZKPO, ISPDV, IPN, NUMPDV, TYPECLIENT_ID);
CREATE INDEX CLIENTS_IDX2 ON CLIENTS (DATECREATE, DATEUPDATE, TIMEUPDATE, USERUPDATE, CREATOR, CLIENTS_CODE);
CREATE INDEX DISCONT_IDX1 ON DISCONT (DISCONT_ID, PROCENT, TIPDISCONT);
CREATE INDEX DISCONT_AUTO_IDX1 ON DISCONT_AUTO (SUMMA);
CREATE INDEX DOCREC_DATE ON DOCREC (DATE_CR);
CREATE DESCENDING INDEX DOCUMENTS_IDX1 ON DOCUMENTS (DOC_DATE);
CREATE INDEX DOCUMENTS_IDX2 ON DOCUMENTS (USER_NAME);
CREATE INDEX DOCUMENTS_IDX3 ON DOCUMENTS (PREW_DOCUMENT_ID);
CREATE INDEX DOCUMENTS_TYPEDOC ON DOCUMENTS (TYPEDOC_ID);
CREATE INDEX GOODS_IDX1 ON GOODS (NOMEN_ID, CLIENTS_ID, DOC_DATE);
CREATE INDEX IBE$LOG_BLOB_FIELDS_IDX1 ON IBE$LOG_BLOB_FIELDS (LOG_TABLES_ID);
CREATE INDEX IBE$LOG_FIELDS_IDX1 ON IBE$LOG_FIELDS (LOG_TABLES_ID);
CREATE INDEX IBE$LOG_KEYS_IDX1 ON IBE$LOG_KEYS (LOG_TABLES_ID);
CREATE INDEX IBE$SCRIPTS_BY_ACTION_ID ON IBE$SCRIPTS (IBE$SCRIPT_ACTION_ID);
CREATE UNIQUE INDEX IBE$SCRIPTS_BY_NAME ON IBE$SCRIPTS (IBE$SCRIPT_NAME);
CREATE INDEX JOBS_IDX1 ON JOBS (JOBS_ID, JOBS_NAME);
CREATE INDEX KARDS_IDX1 ON KARDS (KARDS_ID, DISCONT_ID, CLIENTS_ID);
CREATE UNIQUE INDEX KARDS_IDX3 ON KARDS (KARDCODE);
CREATE INDEX NOMEN_IDX1 ON NOMEN (NOMEN_NAME);
CREATE INDEX NOMEN_IDX2 ON NOMEN (NOMEN_CODE);
CREATE INDEX NOMEN_IDX3 ON NOMEN (W3_NOMEN_ID);
CREATE INDEX NOM_BAR_CODE_INT ON NOM_BAR (CODE_INT);
CREATE UNIQUE INDEX NOM_BAR_IDX1 ON NOM_BAR (NOMEN_ID, BARCODE_ID);
CREATE UNIQUE INDEX NOM_KAS_IDX1 ON NOM_KAS (NOMEN_ID, KASSES_ID);
CREATE INDEX STAFF1 ON STAFF (STAFF_NUM, SURNAME, NAME, PASPORT);
CREATE INDEX STAFF2 ON STAFF (DATE_BIRTH, JOB_START);
CREATE INDEX TYPEDOC_IDX1 ON TYPEDOC (TYPEDOC_ID, TYPEDOC_NAME);
CREATE UNIQUE INDEX T_CONFIGS_IDX1 ON T_CONFIGS (CONFIG_ID, MODULE);
CREATE INDEX T_COUPON_ARTICLES_DOUBLE ON T_COUPON_ARTICLES (COUPON_EAN_ID, NOMEN_ID);
CREATE INDEX T_COUPON_ARTICLES_NOMEN_ID ON T_COUPON_ARTICLES (NOMEN_ID);
CREATE UNIQUE INDEX T_INVOICES_IDX1 ON T_INVOICES (INVOICE_ID);
CREATE INDEX T_MARKUPS_IDX1 ON T_MARKUPS (TOKEN);
CREATE INDEX T_MARKUP_RECORDS_IDX1 ON T_MARKUP_RECORDS (NOMEN_ID, DATE_UPD);
CREATE INDEX T_NOM_BARS_SYNC_CODE_INT ON T_NOM_BARS_SYNC (CODE_INT);
CREATE INDEX T_NOM_BARS_SYNC_CODE_INT_NOMEN ON T_NOM_BARS_SYNC (W3_NOMEN_ID, CODE_INT);
CREATE UNIQUE INDEX T_SCALES_IP_UNIC ON T_SCALES (IP);
CREATE UNIQUE INDEX T_USERS_IDX1 ON T_USERS (USER_LOGIN);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: AO_RECORDS_BI0 */
CREATE TRIGGER AO_RECORDS_BI0 FOR AO_RECORDS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (new.ao_record_id is null) then
  new.ao_record_id=gen_id(gen_ao_record_id, 1);
 new.aor_create_date='NOW';
 new.aor_create_user=user;
 new.aor_update_date='NOW';
 new.aor_update_user=user;
end
^


/* Trigger: AO_RECORDS_BU0 */
CREATE TRIGGER AO_RECORDS_BU0 FOR AO_RECORDS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.aor_update_date='NOW';
 new.aor_update_user=user;
end
^


/* Trigger: AUTH_BI_BI */
CREATE TRIGGER AUTH_BI_BI FOR AUTH
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.AUTH_ID IS NULL) THEN
    NEW.AUTH_ID = GEN_ID(GEN_AUTH_ID,1);
END
^


/* Trigger: AUTOORDERS_BI0 */
CREATE TRIGGER AUTOORDERS_BI0 FOR AUTOORDERS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (new.autoorder_id is null) then
  new.autoorder_id=gen_id(gen_autoorder_id, 1);
 if (new.ao_date is null) then
  new.ao_date='TODAY';
 if (new.ao_conditions is null) then
  new.ao_conditions=0;
 new.ao_create_date='NOW';
 new.ao_create_user=user;
 new.ao_update_date='NOW';
 new.ao_update_user=user;
end
^


/* Trigger: AUTOORDERS_BIU0 */
CREATE TRIGGER AUTOORDERS_BIU0 FOR AUTOORDERS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.print_cnt is null) then new.print_cnt = 0;
end
^


/* Trigger: AUTOORDERS_BU0 */
CREATE TRIGGER AUTOORDERS_BU0 FOR AUTOORDERS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.ao_update_date='NOW';
 new.ao_update_user=user;
end
^


/* Trigger: BANKS_BI_BI */
CREATE TRIGGER BANKS_BI_BI FOR BANKS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.BANKS_ID IS NULL) THEN
    NEW.BANKS_ID = GEN_ID(GEN_BANKS_ID,1);
END
^


/* Trigger: BARCODE_BIU0 */
CREATE TRIGGER BARCODE_BIU0 FOR BARCODE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  new.code_int = cast(new.code as bigint);
  when any do
  begin
    exception ex_bad_barcode;
  end
end
^


/* Trigger: BARCODE_BI_BI */
CREATE TRIGGER BARCODE_BI_BI FOR BARCODE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.BARCODE_ID IS NULL) THEN
    NEW.BARCODE_ID = GEN_ID(GEN_BARCODE_ID,1);
END
^


/* Trigger: CITIES_BD0 */
CREATE TRIGGER CITIES_BD0 FOR CITIES
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.city_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: CITIES_BI0 */
CREATE TRIGGER CITIES_BI0 FOR CITIES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.city_id is null) then new.city_id = gen_id(gen_city_id, 1);
end
^


/* Trigger: CITIES_BU0 */
CREATE TRIGGER CITIES_BU0 FOR CITIES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.city_id = 0) then exception not_edit_sys_record;
end
^


/* Trigger: CLIENTACCOUNT_BI_BI */
CREATE TRIGGER CLIENTACCOUNT_BI_BI FOR CLIENTACCOUNT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ACCOUNT_ID IS NULL) THEN
    NEW.ACCOUNT_ID = GEN_ID(GEN_CLIENTACCOUNT_ID,1);
END
^


/* Trigger: CLIENTS_BIU */
CREATE TRIGGER CLIENTS_BIU FOR CLIENTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
BEGIN
  IF ((NEW.AMOUNT_DAYS IS NULL)or(NEW.AMOUNT_DAYS < 0)) THEN
    NEW.AMOUNT_DAYS = 0;

  IF ((NEW.DISC_PERCENT IS NULL)or(NEW.DISC_PERCENT < 0)) THEN
    NEW.DISC_PERCENT = 0; else
  IF (NEW.DISC_PERCENT > 100) THEN
    NEW.DISC_PERCENT = 100;

  IF ((NEW.possible_debt IS NULL)or(NEW.possible_debt < 0)) THEN
    NEW.possible_debt = 0;
END
^


/* Trigger: CLIENTS_BIU10 */
CREATE TRIGGER CLIENTS_BIU10 FOR CLIENTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: CLIENTS_BI_BI */
CREATE TRIGGER CLIENTS_BI_BI FOR CLIENTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.CLIENTS_ID IS NULL) THEN
      NEW.CLIENTS_ID = GEN_ID(GEN_CLIENTS_ID,1);
    NEW.creator = USER;
    NEW.datecreate = 'TODAY';
    NEW.clients_code = GEN_ID(GEN_CLIENTS_CARD,1);
    NEW.date_ugody = 'TODAY';

    if (new.typeprop_id is null) then
      new.typeprop_id = 0;
END
^


/* Trigger: CLIENTS_UP */
CREATE TRIGGER CLIENTS_UP FOR CLIENTS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  NEW.userupdate = USER;
  NEW.dateupdate = 'TODAY';
  NEW.timeupdate = 'NOW';

/*  if (((old.typeclient_id = 1) and (new.typeclient_id <> 1)) or ((old.typeclient_id <> 1) and (new.typeclient_id = 1))) then
    new.typeclient_id = old.typeclient_id; */
end
^


/* Trigger: DISCONT_BIU10 */
CREATE TRIGGER DISCONT_BIU10 FOR DISCONT
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: DISCONT_BI_BI */
CREATE TRIGGER DISCONT_BI_BI FOR DISCONT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.DISCONT_ID IS NULL) THEN
    NEW.DISCONT_ID = GEN_ID(GEN_DISCONT_ID,1);
  if (new.tipdiscont is null) then
    new.tipdiscont = '';
END
^


/* Trigger: DISC_LIST_BI_BI */
CREATE TRIGGER DISC_LIST_BI_BI FOR DISC_LIST
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.DISC_LIST_ID IS NULL) THEN
    NEW.DISC_LIST_ID = GEN_ID(GEN_DISC_LIST_ID,1);
END
^


/* Trigger: DOCGOODS_AD0 */
CREATE TRIGGER DOCGOODS_AD0 FOR DOCGOODS
ACTIVE AFTER DELETE POSITION 0
AS
BEGIN
  update docrec dr
    set DR.INSUM = minus(DR.INSUM, OLD.INSUM)
   where dr.docrec_id = old.docrec_id;
END
^


/* Trigger: DOCGOODS_AD4 */
CREATE TRIGGER DOCGOODS_AD4 FOR DOCGOODS
ACTIVE AFTER DELETE POSITION 4
AS
begin
  insert into T_DEL_DOCGOODS(docgoods_id)
     values(old.docgoods_id);
end
^


/* Trigger: DOCGOODS_AI0 */
CREATE TRIGGER DOCGOODS_AI0 FOR DOCGOODS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  /*------------------------------------------------------*/
  update docrec dr
    set DR.INSUM = plus(DR.INSUM, NEW.INSUM)
   where dr.docrec_id = new.docrec_id;
end
^


/* Trigger: DOCGOODS_BIU5 */
CREATE TRIGGER DOCGOODS_BIU5 FOR DOCGOODS
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: DOCGOODS_BI_BI */
CREATE TRIGGER DOCGOODS_BI_BI FOR DOCGOODS
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE P_TPDV_ID INTEGER;
BEGIN
  IF (NEW.DOCGOODS_ID IS NULL) THEN
    NEW.DOCGOODS_ID = GEN_ID(GEN_DOCGOODS_ID,1);
  /*------------------------------------------------------*/
  select g.goods_inprice, N.TYPEPDV_ID
    from goods g,
         NOMEN N
    where g.goods_id = new.goods_id AND
          N.NOMEN_ID = G.NOMEN_ID
    INTO NEW.INPRICE_PDV, :P_TPDV_ID;
 /* SELECT DT.INPRICE, DT.INSUM_PDV, DT.INSUM
   FROM S_DG_TR(NEW.INPRICE_PDV, NEW.KILK, :P_TPDV_ID) DT
   INTO , NEW.INSUM_PDV, NEW.INSUM;*/
 NEW.INPRICE=CALCSUM(NEW.INPRICE_PDV, 0.000, 0, :P_TPDV_ID, 6);
 NEW.INSUM_PDV=multi(NEW.INPRICE_PDV, NEW.KILK);
 NEW.INSUM=multi(NEW.INPRICE, NEW.KILK);

END
^


/* Trigger: DOCGOODS_BU0 */
CREATE TRIGGER DOCGOODS_BU0 FOR DOCGOODS
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE P_TPDV_ID INTEGER;
BEGIN
  if (old.goods_id <> new.goods_id) then BEGIN
   select g.goods_inprice, N.TYPEPDV_ID
     from goods g,
          NOMEN N
     where g.goods_id = new.goods_id AND
           N.NOMEN_ID=G.NOMEN_ID
    INTO NEW.INPRICE_PDV, :P_TPDV_ID;
   NEW.INPRICE=CALCSUM(NEW.INPRICE_PDV, 0.000, 0, :P_TPDV_ID, 6);
  END
  /*------------------------------------------------------*/
  if ((new.inprice_pdv <> old.inprice_pdv) or (new.kilk <> old.kilk) or (old.inprice_pdv is null)) then BEGIN
   select g.goods_inprice, N.TYPEPDV_ID
     from goods g,
          NOMEN N
     where g.goods_id = new.goods_id AND
           N.NOMEN_ID=G.NOMEN_ID
    INTO NEW.INPRICE_PDV, :P_TPDV_ID;
    NEW.INPRICE=CALCSUM(NEW.INPRICE_PDV, 0.000, 0, :P_TPDV_ID, 6);
    NEW.INSUM_PDV=multi(NEW.INPRICE_PDV, NEW.KILK);
    NEW.INSUM=multi(NEW.INPRICE, NEW.KILK);
  END

  /*------------------------------------------------------*/
  if ((new.insum_pdv <> old.insum_pdv) or (NEW.INSUM <> OLD.INSUM)) then begin
    update docrec dr
      set DR.INSUM = minus(plus(DR.INSUM, NEW.INSUM), OLD.INSUM)
     where dr.docrec_id = new.docrec_id;
  end
END
^


/* Trigger: DOCRECS_BIU5 */
CREATE TRIGGER DOCRECS_BIU5 FOR DOCREC
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: DOCREC_AD4 */
CREATE TRIGGER DOCREC_AD4 FOR DOCREC
ACTIVE AFTER DELETE POSITION 4
AS
begin
  insert into T_DEL_DOCRECS(docrec_id)
     values(old.docrec_id);
end
^


/* Trigger: DOCREC_BD0 */
CREATE TRIGGER DOCREC_BD0 FOR DOCREC
ACTIVE BEFORE DELETE POSITION 0
as
begin
  INSERT INTO DOCREC_TMP(DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE, USER_CR, DATE_CR, user_confirm)
   VALUES (OLD.DOCREC_ID, OLD.DOCUMENT_ID, OLD.NOMEN_ID, OLD.KILK, OLD.PRICE, user, 'NOW', old.user_confirm);
  delete from docgoods d
    where d.kilk = 0.0 and
          d.docrec_id = old.docrec_id;
  delete from t_dr_prop
   where docrec_id = old.docrec_id;
end
^


/* Trigger: DOCREC_BI_BI */
CREATE TRIGGER DOCREC_BI_BI FOR DOCREC
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE P_INSUM DOUBLE PRECISION;
BEGIN
 IF (NEW.DOCREC_ID IS NULL) THEN new.DOCREC_ID = GEN_ID(GEN_DOCREC_ID,1);
/*  new.price = around(new.price);*/
  if (new.time_cr is null) then  new.time_cr = 'now';
  if (new.date_cr is null) then  new.date_cr = 'today';
  if (new.user_cr is null) then  new.user_cr = user;
  if (new.insum_pdv is null) then new.insum_pdv = 0.00;
  if (new.insum is null) then new.insum = 0.00;
/*  new.insum = calcsum(new.insum_pdv, 0.0, new.typepdv_pdv, new.typepdv_id, 6);*/
  P_INSUM=NEW.INSUM;
  NEW.INSUM_PDV=CALCSUMPDV(P_INSUM, 0.000, NEW.TYPEPDV_PDV, NEW.TYPEPDV_ID, 6);
END
^


/* Trigger: DOCREC_BU0 */
CREATE TRIGGER DOCREC_BU0 FOR DOCREC
ACTIVE BEFORE UPDATE POSITION 0
as
DECLARE VARIABLE DOC_NUM VARCHAR(14);
DECLARE VARIABLE DOC_DATE DATE;
DECLARE VARIABLE CLIENTS_ID INTEGER;
DECLARE VARIABLE OBJECTS_ID INTEGER;
DECLARE VARIABLE TYPEDOC_ID INTEGER;
begin
  if (new.insum_pdv is null) then new.insum_pdv = 0.00;
  if (new.insum is null) then new.insum = 0.00;
  IF ((NEW.INSUM<>OLD.INSUM) OR (NEW.TYPEPDV_ID<>OLD.TYPEPDV_ID)) THEN
   NEW.INSUM_PDV=CALCSUMPDV(NEW.INSUM, 0.000, NEW.TYPEPDV_PDV, NEW.TYPEPDV_ID, 6);
/*  if ((new.insum_pdv <> old.insum_pdv) or ((new.typepdv_id <> old.typepdv_id))) then
    new.insum = calcsum(new.insum_pdv, 0.0, new.typepdv_pdv, new.typepdv_id, 6);*/

  /* Фіксування видалених записів */
  if (old.kilk > new.kilk) then
  begin
    select d.doc_num, d.doc_date, d.clients_id, d.objects_id, d.typedoc_id
     from documents d
     where d.document_id = old.document_id
     into :doc_num, :doc_date, :clients_id, :objects_id, :typedoc_id;
    if (:clients_id = 1) then clients_id = objects_id;
    insert into docrec_log (document_id, doc_num, doc_date, typedoc_id, clients_id, docrec_id,
        nomen_id, price, kilk_old, kilk_new, type_upd, user_confirm)
      values (new.document_id, :doc_num, :doc_date, :typedoc_id, :clients_id, new.docrec_id,
          new.nomen_id, new.price, old.kilk, new.kilk, 2, new.user_confirm);
  end
  /* ------------------------ */
end
^


/* Trigger: DOCREC_DEL_BI0 */
CREATE TRIGGER DOCREC_DEL_BI0 FOR DOCREC_DEL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 NEW.USER_CR=USER;
 NEW.DATE_CR='NOW';
END
^


/* Trigger: DOCREC_LOG_BI0 */
CREATE TRIGGER DOCREC_LOG_BI0 FOR DOCREC_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.docrec_log_id is null) then new.docrec_log_id = gen_id(gen_docrec_log_id, 1);
  new.user_crt = user;
  new.date_crt = 'NOW';
end
^


/* Trigger: DOCUMENTS_AD4 */
CREATE TRIGGER DOCUMENTS_AD4 FOR DOCUMENTS
ACTIVE AFTER DELETE POSITION 4
AS
begin
  insert into t_del_documents(document_id)
     values(old.document_id);
end
^


/* Trigger: DOCUMENTS_AIU2 */
CREATE TRIGGER DOCUMENTS_AIU2 FOR DOCUMENTS
ACTIVE AFTER UPDATE POSITION 2
AS
begin
  if  (((new.doc_lock != old.doc_lock))and
      (new.typedoc_id in (4, 7, 14) and
       new.clients_id = 1)) then
  begin
    execute procedure ps_document_ins_or_upd_td16(new.document_id);
  end

  if ((new.doc_lock != old.doc_lock)and
      (new.doc_lock = 2)and(new.typedoc_id = 1)) then
    execute procedure ps_document_ins_or_upd_td16(new.document_id);
end
^


/* Trigger: DOCUMENTS_AU0 */
CREATE TRIGGER DOCUMENTS_AU0 FOR DOCUMENTS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if ((old.doc_lock <> new.doc_lock) and (new.typedoc_id not in (4, 11))) then
    execute procedure PS_PAYS_RECALC(new.document_id);
end
^


/* Trigger: DOCUMENTS_AU2 */
CREATE TRIGGER DOCUMENTS_AU2 FOR DOCUMENTS
ACTIVE AFTER UPDATE POSITION 2
AS
begin
  if ((new.typedoc_id = 6)and(new.doc_lock > 0)) then
  begin
    update docrec dr
       set dr.price = dr.insum_pdv/dr.kilk
     where dr.document_id = new.document_id;
  end
end
^


/* Trigger: DOCUMENTS_BD0 */
CREATE TRIGGER DOCUMENTS_BD0 FOR DOCUMENTS
ACTIVE BEFORE DELETE POSITION 0
as
declare variable count_docrec integer;
declare variable docrec_id integer;
declare variable nomen_id integer;
declare variable kilk double precision;
declare variable price double precision;
declare variable puser_confirm varchar(155);
begin
 count_docrec=0;
 select count(dr.docrec_id) from docrec_tmp dr
  where dr.document_id = old.document_id
   into count_docrec;

 if (:count_docrec > 0) then
 begin
   insert into doc_del (document_id, doc_date, doc_num, doc_mark, typedoc_id, objects_id, clients_id, staff_id, user_name, discont_id, disc_persent)
   values (old.document_id, old.doc_date, old.doc_num, old.doc_mark, old.typedoc_id, old.objects_id, old.clients_id, old.staff_id, old.user_name, old.discont_id, old.disc_persent);

   for select dr1.docrec_id, dr1.nomen_id, dr1.kilk, dr1.price, dr1.user_confirm
         from docrec_tmp dr1
        where dr1.document_id = old.document_id
         into docrec_id, nomen_id, kilk, price, puser_confirm
   do begin
     delete from docrec_tmp dr2
      where dr2.docrec_id = :docrec_id;
     insert into docrec_del (docrec_id, document_id, nomen_id, kilk, price, user_confirm)
       values (:docrec_id, old.document_id, :nomen_id, :kilk, :price, :puser_confirm);
   end
 end
   delete from docrec d
    where d.kilk = 0.0 and
          d.document_id = old.document_id;
   delete from t_doc_prop
    where document_id = old.document_id;
end
^


/* Trigger: DOCUMENTS_BD2 */
CREATE TRIGGER DOCUMENTS_BD2 FOR DOCUMENTS
ACTIVE BEFORE DELETE POSITION 2
AS
begin
  if (exists(select * from documents d where d.prew_document_id = old.document_id)) then
  begin
    execute procedure ps_document_ins_or_upd_td16(old.document_id);
    delete from documents where prew_document_id = old.document_id;
  end
end
^


/* Trigger: DOCUMENTS_BD3 */
CREATE TRIGGER DOCUMENTS_BD3 FOR DOCUMENTS
ACTIVE BEFORE DELETE POSITION 3
AS
begin
  delete from t_document_autoorder da
   where da.documents_id = old.document_id;
end
^


/* Trigger: DOCUMENTS_BI0 */
CREATE TRIGGER DOCUMENTS_BI0 FOR DOCUMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.doc_date is null) then
    new.doc_date = 'today';
end
^


/* Trigger: DOCUMENTS_BIU5 */
CREATE TRIGGER DOCUMENTS_BIU5 FOR DOCUMENTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: DOCUMENTS_BI_BI */
CREATE TRIGGER DOCUMENTS_BI_BI FOR DOCUMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE TDATE_FINAL DATE;
BEGIN
  select max(p.final_date) from t_1c_periodics p
      into :tdate_final;

  if (:tdate_final is not null) then
    if (new.doc_date < :tdate_final) then
      exception EX_BAD_DATE;

  IF (NEW.DOCUMENT_ID IS NULL) THEN
    NEW.DOCUMENT_ID = GEN_ID(GEN_DOCUMENTS_ID,1);

  IF (NEW.OPLATA_STATE IS NULL) THEN NEW.OPLATA_STATE=0;
  IF (NEW.OPLATA_TYPE IS NULL) THEN NEW.OPLATA_TYPE=0;

  if (new.date_cr is null) then NEW.DATE_CR='TODAY';
  IF (NEW.user_name IS NULL) THEN NEW.USER_NAME=USER;
  if (new.time_cr is null) then NEW.TIME_CR='NOW';

/*  select rperiods_id from  r_last_period(NEW.doc_date) where
    into NEW.periods_id;*/
END
^


/* Trigger: DOCUMENTS_BU0 */
CREATE TRIGGER DOCUMENTS_BU0 FOR DOCUMENTS
ACTIVE BEFORE UPDATE POSITION 0
as
DECLARE VARIABLE P_PRICE DOUBLE PRECISION;
DECLARE VARIABLE P_GOODS_ID INTEGER;
DECLARE VARIABLE PDOCREC_ID INTEGER;
DECLARE VARIABLE PNOMEN_ID INTEGER;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PPRICE DOUBLE PRECISION;
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_ISPDV INTEGER;
DECLARE VARIABLE TDATE_FINAL DATE;
begin
    select max(p.final_date) from t_1c_periodics p
        into :tdate_final;

    if (:tdate_final is not null) then
      if (new.doc_date < :tdate_final) then
        if (new.doc_lock != old.doc_lock) then
        exception EX_BAD_DATE;

  if (new.doc_lock = 0) then NEW.lock_date = 'TODAY';
  if (new.doc_lock != old.doc_lock) then new.time_fix = 'now';
  IF (NEW.OPLATA_TYPE IS NULL) THEN NEW.OPLATA_TYPE=0;
  IF ((NEW.DISC_PERSENT<>OLD.DISC_PERSENT) AND (NEW.TYPEDOC_ID=1)) THEN BEGIN
   SELECT C.ISPDV
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=NEW.OBJECTS_ID
    INTO :P_ISPDV;
   IF (:P_ISPDV IS NULL) THEN P_ISPDV=1;
   FOR SELECT DR.PRICE, DR.NOMEN_ID, DG.GOODS_ID
        FROM DOCREC DR,
             DOCGOODS DG
        WHERE DR.DOCUMENT_ID=NEW.DOCUMENT_ID AND
              DG.DOCREC_ID=DR.DOCREC_ID
        INTO :P_PRICE, :PNOMEN_ID, :P_GOODS_ID
   DO BEGIN
   IF (:P_ISPDV=0) THEN BEGIN
     SELECT N.TYPEPDV_ID
      FROM NOMEN N
      WHERE N.NOMEN_ID=:PNOMEN_ID
      INTO :P_TYPEPDV_ID;
     P_PRICE=CALCSUMPDV(:P_PRICE, 0.000, 0.000, :P_TYPEPDV_ID, 0);
    END
    UPDATE GOODS G
     SET G.GOODS_INPRICE=:P_PRICE*(1-NEW.DISC_PERSENT)
     WHERE G.GOODS_ID=:P_GOODS_ID;
   END
  END

/* Prinyatta zalishku pri konvertaciyi z cheka v rozhidnu */
  if (((old.typedoc_id = 11) or (old.typedoc_id = 10)) and (new.typedoc_id = 2)) then
  begin
    for select dr.docrec_id, dr.nomen_id, dr.kilk, dr.price
          from docrec dr
      where dr.document_id = new.document_id
    into :pdocrec_id, :pnomen_id, :pkilk, :pprice
    do begin
      execute procedure kas_close_docrec(:pdocrec_id, :pnomen_id,
                 :pkilk, :pprice, 11);
    end
  end

/* Perenesennya dati v goodsi */
  if ((new.typedoc_id = 1) and (old.doc_lock <> new.doc_lock)) then
  begin
    for select dg.goods_id
          from docrec dr, docgoods dg
      where dr.document_id = new.document_id and
            dr.docrec_id = dg.docrec_id
    into :p_goods_id
    do begin
      update goods g
        set g.doc_date = new.doc_date
       where g.goods_id = :p_goods_id;
    end
  end
end
^


/* Trigger: DOC_DEL_BI0 */
CREATE TRIGGER DOC_DEL_BI0 FOR DOC_DEL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 NEW.USER_CR=USER;
 NEW.DATE_CR='NOW';
END
^


/* Trigger: E1C_LOG_CREDDOCS_BI0 */
CREATE TRIGGER E1C_LOG_CREDDOCS_BI0 FOR E1C_LOG_CREDDOCS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 new.user_cr = user;
 new.date_cr = 'NOW';
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: E1C_LOG_CREDDOCS_BU0 */
CREATE TRIGGER E1C_LOG_CREDDOCS_BU0 FOR E1C_LOG_CREDDOCS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: E1C_LOG_DEBDOCS_BI0 */
CREATE TRIGGER E1C_LOG_DEBDOCS_BI0 FOR E1C_LOG_DEBDOCS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (new.e1c_log_debdocs_id is null) then new.e1c_log_debdocs_id = gen_id(gen_e1c_log_debdocs_id, 1);
 new.user_cr = user;
 new.date_cr = 'NOW';
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: E1C_LOG_DEBDOCS_BU0 */
CREATE TRIGGER E1C_LOG_DEBDOCS_BU0 FOR E1C_LOG_DEBDOCS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: E1C_LOG_DRAFTS_BI0 */
CREATE TRIGGER E1C_LOG_DRAFTS_BI0 FOR E1C_LOG_DRAFTS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 if (new.e1c_log_drafts_id is null) then new.e1c_log_drafts_id = gen_id(gen_e1c_log_drafts_id, 1);
 new.user_cr = user;
 new.date_cr = 'NOW';
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: E1C_LOG_DRAFTS_BU0 */
CREATE TRIGGER E1C_LOG_DRAFTS_BU0 FOR E1C_LOG_DRAFTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: GOODS_AD0 */
CREATE TRIGGER GOODS_AD0 FOR GOODS
ACTIVE AFTER DELETE POSITION 0
AS
begin
     update rst rt
        set rt.rest = minus(rt.rest, old.goods_rest),
            rt.rest_sum = minus(rt.rest_sum, multi(old.goods_rest, old.goods_inprice))
      where rt.nomen_id   = old.nomen_id and
            rt.objects_id = old.objects_id;
end
^


/* Trigger: GOODS_AD4 */
CREATE TRIGGER GOODS_AD4 FOR GOODS
ACTIVE AFTER DELETE POSITION 4
AS
begin
  insert into T_DEL_GOODS(goods_id)
     values(old.goods_id);
end
^


/* Trigger: GOODS_AI0 */
CREATE TRIGGER GOODS_AI0 FOR GOODS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  if (new.goods_rest <> 0.000) then
    update rst rt
        set rt.rest = plus(rt.rest, new.goods_rest),
            rt.rest_sum = plus(rt.rest_sum, multi(new.goods_rest, new.goods_inprice))
      where rt.nomen_id = new.nomen_id and
            rt.objects_id = new.objects_id;

  if ((new.clients_id <> 100) and (new.goods_inprice is not null)) then
    update rst rt
        set rt.last_inprice = new.goods_inprice
      where rt.nomen_id = new.nomen_id and
            rt.objects_id = object();
end
^


/* Trigger: GOODS_AU0 */
CREATE TRIGGER GOODS_AU0 FOR GOODS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  if ((new.objects_id <> old.objects_id) or
      (new.nomen_id <> old.nomen_id) or
      (new.goods_inprice <> old.goods_inprice) or
      (new.goods_rest <> old.goods_rest)) then
  begin
    update rst rt
        set rt.rest = minus(rt.rest, old.goods_rest),
            rt.rest_sum = minus(rt.rest_sum, multi(old.goods_rest, old.goods_inprice))
      where rt.nomen_id   = old.nomen_id and
            rt.objects_id = old.objects_id;

    update rst rt
        set rt.rest = plus(rt.rest, new.goods_rest),
            rt.rest_sum = plus(rt.rest_sum, multi(new.goods_rest, new.goods_inprice))
      where rt.nomen_id   = new.nomen_id and
            rt.objects_id = new.objects_id;
  end

  if (old.goods_inprice <> new.goods_inprice) then
  begin
    update docgoods dg
      set dg.inprice_pdv = new.goods_inprice
     where dg.goods_id = new.goods_id;
    if (new.clients_id <> 100) then
      update rst rt
          set rt.last_inprice = new.goods_inprice
        where rt.nomen_id = new.nomen_id and
              rt.objects_id = new.objects_id;
  end

  if (((old.goods_inprice <> new.goods_inprice) or (old.goods_inprice is null)) and (new.clients_id <> 100)) then
    update rst rt
        set rt.last_inprice = new.goods_inprice
      where rt.nomen_id = new.nomen_id and
            rt.objects_id = object();
end
^


/* Trigger: GOODS_BI0 */
CREATE TRIGGER GOODS_BI0 FOR GOODS
ACTIVE BEFORE INSERT POSITION 0
as
begin
 if (new.goods_id is null) then new.goods_id=gen_id(gen_goods_id, 1);
 if (new.goods_inprice=0.000) then exception zero_good_inprice;
end
^


/* Trigger: GOODS_BIU5 */
CREATE TRIGGER GOODS_BIU5 FOR GOODS
ACTIVE BEFORE INSERT OR UPDATE POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: GOODS_BU0 */
CREATE TRIGGER GOODS_BU0 FOR GOODS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  /* Trigger text */
  if (new.goods_inprice=0.000) then exception zero_good_inprice;
end
^


/* Trigger: GRPC_BI_BI */
CREATE TRIGGER GRPC_BI_BI FOR GRPC
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.GRPC_ID IS NULL) THEN
    NEW.GRPC_ID = GEN_ID(GEN_GRPC_ID,1);
END
^


/* Trigger: GRP_AI0 */
CREATE TRIGGER GRP_AI0 FOR GRP
ACTIVE AFTER INSERT POSITION 0
AS
begin
    execute procedure PS_RECULC_GRP_FULLNAME(new.grp_id, '', new.grp_id);
end
^


/* Trigger: GRP_AUD0 */
CREATE TRIGGER GRP_AUD0 FOR GRP
ACTIVE AFTER UPDATE OR DELETE POSITION 0
AS
begin
  if ((new.grp_name != old.grp_name)and
     (old.grp_fullname is not null)) then
  execute procedure ps_reculc_grp_fullnames;
end
^


/* Trigger: GRP_BD0 */
CREATE TRIGGER GRP_BD0 FOR GRP
INACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.grp_id = 1) then exception fuck_you;
end
^


/* Trigger: GRP_BI_BI */
CREATE TRIGGER GRP_BI_BI FOR GRP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.GRP_ID IS NULL) THEN
    NEW.GRP_ID = GEN_ID(GEN_GRP_ID,1);
  NEW.cnt = 0;
END
^


/* Trigger: IBE$LOG_TABLES_BD */
CREATE TRIGGER IBE$LOG_TABLES_BD FOR IBE$LOG_TABLES
ACTIVE BEFORE DELETE POSITION 0
AS
BEGIN
  DELETE FROM IBE$LOG_FIELDS WHERE LOG_TABLES_ID = OLD.ID;
  DELETE FROM IBE$LOG_BLOB_FIELDS WHERE LOG_TABLES_ID = OLD.ID;
  DELETE FROM IBE$LOG_KEYS WHERE LOG_TABLES_ID = OLD.ID;
END
^


/* Trigger: IBE$VERSION_HISTORY_BI0 */
CREATE TRIGGER IBE$VERSION_HISTORY_BI0 FOR IBE$VERSION_HISTORY
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  IF (NEW.IBE$VH_ID IS NULL) THEN
    NEW.IBE$VH_ID = GEN_ID(IBE$VERSION_HISTORY_ID_GEN,1);
  NEW.IBE$VH_USER_NAME = USER;
  NEW.IBE$VH_MODIFY_DATE = 'NOW';
end
^


/* Trigger: JOBS_BI0 */
CREATE TRIGGER JOBS_BI0 FOR JOBS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 IF (NEW.JOBS_ID IS NULL) THEN NEW.JOBS_ID=GEN_ID(GEN_JOBS_ID, 1);
END
^


/* Trigger: KARDS_BIU10 */
CREATE TRIGGER KARDS_BIU10 FOR KARDS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: KARDS_BI_BI */
CREATE TRIGGER KARDS_BI_BI FOR KARDS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.KARDS_ID IS NULL) THEN
    NEW.KARDS_ID = GEN_ID(GEN_KARDS_ID,1);
  new.date_cr = 'today';
  new.creator = user;
  new.pin = 0;
  if (new.kardcode is null) then
     new.kardcode = GEN_ID(GEN_KARDCODE, 10);
  if ((new.clients_id <> 99) and (new.name is null)) then
  begin
    select c.name from clients c
        where c.clients_id = new.clients_id
      into new.name;
  end
END
^


/* Trigger: KASSES_BIU10 */
CREATE TRIGGER KASSES_BIU10 FOR KASSES
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: MAKER_BI_BI */
CREATE TRIGGER MAKER_BI_BI FOR MAKER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.MAKER_ID IS NULL) THEN
    NEW.MAKER_ID = GEN_ID(GEN_MAKER_ID,1);
END
^


/* Trigger: MANAGER_BI_BI */
CREATE TRIGGER MANAGER_BI_BI FOR MANAGER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.MANAGER_ID IS NULL) THEN
    NEW.MANAGER_ID = GEN_ID(GEN_MANAGER_ID,1);
END
^


/* Trigger: NOMEN_AD0 */
CREATE TRIGGER NOMEN_AD0 FOR NOMEN
ACTIVE AFTER DELETE POSITION 0
AS
begin
  if (not exists(select * from t_nomens_log where nomen_id = old.nomen_id)) then
  begin
    insert into t_nomens_log(nomen_id) values(old.nomen_id);
  end
end
^


/* Trigger: NOMEN_AI0 */
CREATE TRIGGER NOMEN_AI0 FOR NOMEN
ACTIVE AFTER INSERT POSITION 0
as
DECLARE VARIABLE POBJECTS_ID INTEGER;
DECLARE VARIABLE TMARKER VARCHAR(64);
begin
  insert into pricejournal(nomen_id, out_price)
    values(new.nomen_id, new.out_price);

  pobjects_id = object();
  insert into rst (nomen_id, objects_id, rest, rest_sum)
    values (new.nomen_id, :pobjects_id, 0.000, 0.00);

  select c.marker from t_configs c
      where c.config_id = 2 and
            c.module = 'store_nomen'
    into :tmarker;

  if (:tmarker = 'no') then
    insert into goods (nomen_id, objects_id, goods_rest, goods_inprice, clients_id)
        values (new.nomen_id, 1, 0, 0.01, 1);
end
^


/* Trigger: NOMEN_BIU0 */
CREATE TRIGGER NOMEN_BIU0 FOR NOMEN
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (new.w3_nomen_id is null) then
    new.w3_nomen_id = new.nomen_id;
end
^


/* Trigger: NOMEN_BIU1 */
CREATE TRIGGER NOMEN_BIU1 FOR NOMEN
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
begin
   if (new.category is null) then new.category = 0;
end
^


/* Trigger: NOMEN_BIU10 */
CREATE TRIGGER NOMEN_BIU10 FOR NOMEN
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: NOMEN_BI_BI */
CREATE TRIGGER NOMEN_BI_BI FOR NOMEN
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 IF (NEW.NOMEN_ID IS NULL) THEN
    NEW.NOMEN_ID = GEN_ID(GEN_NOMEN_ID,1);
 SELECT NOMEN_CODE
  FROM S_GET_NOMCODE(NEW.GRP_ID)
  INTO NEW.NOMEN_CODE;
 if (new.is_visible is null) then new.is_visible = 1;
 if (new.is_active is null)  then new.is_active  = 1;
 if (new.type_nomen is null) then new.type_nomen = 0;

END
^


/* Trigger: NOMEN_BU0 */
CREATE TRIGGER NOMEN_BU0 FOR NOMEN
ACTIVE BEFORE UPDATE POSITION 0
as
begin
/*  NEW.out_price = around(new.out_price);*/
 new.OUT_PRICE=new.OUT_PRICE;
 if (old.out_price <> new.out_price) then
   insert into pricejournal(nomen_id, out_price)
     values(new.nomen_id, new.out_price);
end
^


/* Trigger: NOMEN_BU_TYPE_NOMEN */
CREATE TRIGGER NOMEN_BU_TYPE_NOMEN FOR NOMEN
ACTIVE BEFORE UPDATE POSITION 2
AS
declare variable pcalc_count integer;
begin
  if ((old.type_nomen = 2)and((new.type_nomen != 2)or(new.type_nomen is null))) then
  begin
    select count(c.calculation_id)
      from t_calculations c
     where c.nomen_id = new.nomen_id
      into pcalc_count;
    if (:pcalc_count > 0) then new.type_nomen = 2;
  end
end
^


/* Trigger: NOMEN_VISIBLE_KONTROL_BU0 */
CREATE TRIGGER NOMEN_VISIBLE_KONTROL_BU0 FOR NOMEN
ACTIVE BEFORE UPDATE POSITION 1
AS
declare variable pmarker varchar(64);
begin
  if (((old.is_visible = 0)and(new.is_visible = 1))and(new.w3_nomen_id is null)) then
  begin
    select c.marker from t_configs c
     where c.config_id = 5 and
           c.module    = 'store_nomen'
      into pmarker;
    if (:pmarker = 'yes') then
      new.is_visible = 0;
  end

  if (new.w3_nomen_id is not null) then
  begin
    select c.marker
      from t_configs c
     where c.module    = 'store_nomen' and
           c.config_id = 4
      into pmarker;

    if (:pmarker = 'without_w3_only') then
    begin
      new.nomen_name = old.nomen_name;
      new.datex_name = old.datex_name;
      new.typepdv_id = old.typepdv_id;
      new.is_weight  = old.is_weight;
      new.brutto     = old.brutto;
      new.si_id      = old.si_id;
      new.sg_id      = old.sg_id;
    /*  new.is_active  = old.is_active;
      new.is_visible = old.is_visible;     */
      new.maker_id   = old.maker_id;
      new.decrease_id= old.decrease_id;
    end
  end
end
^


/* Trigger: NOMEN_W3_DEL_CONTROL */
CREATE TRIGGER NOMEN_W3_DEL_CONTROL FOR NOMEN
ACTIVE BEFORE DELETE POSITION 2
AS
declare variable pmarker varchar(64);
begin
  if (old.w3_nomen_id is not null) then
  begin
    select c.marker
      from t_configs c
     where c.module    = 'store_nomen' and
           c.config_id = 4
      into pmarker;

    if (:pmarker = 'without_w3_only') then
    begin
      exception ex_modif_nom_with_w3;
    end
  end
end
^


/* Trigger: NOM_BAR_BIU0 */
CREATE TRIGGER NOM_BAR_BIU0 FOR NOM_BAR
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
declare variable pcode_int bigint;
begin

  select code_int
    from barcode b
   where b.barcode_id = new.barcode_id
    into :pcode_int;

  new.code_int = :pcode_int;
end
^


/* Trigger: NOM_BAR_BIU10 */
CREATE TRIGGER NOM_BAR_BIU10 FOR NOM_BAR
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: NOM_BAR_BI_BI */
CREATE TRIGGER NOM_BAR_BI_BI FOR NOM_BAR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.NOM_BAR_ID IS NULL) THEN
    NEW.NOM_BAR_ID = GEN_ID(GEN_NOM_BAR_ID,1);
END
^


/* Trigger: NOM_KAS_BI */
CREATE TRIGGER NOM_KAS_BI FOR NOM_KAS
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE PCNT INTEGER;
BEGIN
  IF (NEW.NOM_KAS_ID IS NULL) THEN
    NEW.NOM_KAS_ID = GEN_ID(GEN_NOM_KAS_ID,1);
/*  select k.cnt from kasses k
    where k.kasses_id = new.kasses_id
  into :pcnt;
  pcnt = plus(:pcnt, 1);
  new.art_num = :pcnt; */
  update kasses k
      set k.cnt = new.art_num
    where k.kasses_id = new.kasses_id;
END
^


/* Trigger: OBJECTS_BI_BI */
CREATE TRIGGER OBJECTS_BI_BI FOR OBJECTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.OBJECTS_ID IS NULL) THEN
    NEW.OBJECTS_ID = GEN_ID(GEN_OBJECTS_ID,1);
  IF (NEW.AROUND_PRICE_PDV IS NULL) THEN NEW.AROUND_PRICE_PDV=100;
END
^


/* Trigger: PAYMENT_BI */
CREATE TRIGGER PAYMENT_BI FOR PAYMENT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.PAYMENT_ID IS NULL) THEN
    NEW.PAYMENT_ID = GEN_ID(GEN_PAYMENT_ID,1);
  if (new.summa is null) then new.summa = 0.00;
END
^


/* Trigger: PRICEJOURNAL_BI_BI */
CREATE TRIGGER PRICEJOURNAL_BI_BI FOR PRICEJOURNAL
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.PRICEJOURNAL_ID IS NULL) THEN
    NEW.PRICEJOURNAL_ID = GEN_ID(GEN_PRICEJOURNAL_ID,1);
  NEW.user_name = USER;
  if (new.date_time is null) then NEW.date_time = 'NOW';
END
^


/* Trigger: PRICE_BI_BI */
CREATE TRIGGER PRICE_BI_BI FOR PRICE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.PRICE_ID IS NULL) THEN
    NEW.PRICE_ID = GEN_ID(GEN_PRICE_ID,1);
END
^


/* Trigger: REESTR_BI0 */
CREATE TRIGGER REESTR_BI0 FOR REESTR
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE TYPEDOC_ID INTEGER;
begin
  if (new.reestr_id is null) then new.reestr_id = gen_id(reestr_gen_id, 1);
  if (new.td_number is null) then new.td_number = new.reestr_id;
  new.user_cr = user;
  new.date_cr = 'NOW';
  new.user_upd = user;
  new.date_upd = 'NOW';
  select d.typedoc_id
   from documents d
   where d.document_id = new.document_id
   into :typedoc_id;
  new.td_type = 0;
  if (:typedoc_id = 1) then new.td_type = 1;
  if (:typedoc_id in (2, 11)) then new.td_type = 2;
  /*???? Need cleare */ new.data = 'now';
end
^


/* Trigger: REESTR_BU0 */
CREATE TRIGGER REESTR_BU0 FOR REESTR
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE TYPEDOC_ID INTEGER;
begin
  select d.typedoc_id
   from documents d
   where d.document_id = new.document_id
   into :typedoc_id;
  new.td_type = 0;
  if (:typedoc_id = 1) then new.td_type = 1;
  if (:typedoc_id in (2, 11)) then new.td_type = 2;
  new.user_upd = user;
  new.date_upd = 'NOW';
end
^


/* Trigger: REGIONS_BD0 */
CREATE TRIGGER REGIONS_BD0 FOR REGIONS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.region_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: REGIONS_BI0 */
CREATE TRIGGER REGIONS_BI0 FOR REGIONS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.region_id is null) then new.region_id = gen_id(gen_region_id, 1);
end
^


/* Trigger: REGIONS_BU0 */
CREATE TRIGGER REGIONS_BU0 FOR REGIONS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.region_id = 0) then exception not_edit_sys_record;
end
^


/* Trigger: REVISION_BI0 */
CREATE TRIGGER REVISION_BI0 FOR REVISION
ACTIVE BEFORE INSERT POSITION 0
as
begin
 IF (NEW.REVISION_ID IS NULL) THEN NEW.REVISION_ID=GEN_ID(GEN_REVISION_ID, 1);
 NEW.DATE_CREATE='TODAY';
 NEW.TIME_CREATE='NOW';
 NEW.USER_CREATE=USER;
 NEW.DATE_UPDATE='TODAY';
 NEW.TIME_UPDATE='NOW';
 NEW.USER_UPDATE=USER;
 NEW.REVISION_LOCK=0;
end
^


/* Trigger: REVISION_BU0 */
CREATE TRIGGER REVISION_BU0 FOR REVISION
ACTIVE BEFORE UPDATE POSITION 0
as
begin
 NEW.DATE_UPDATE='TODAY';
 NEW.TIME_UPDATE='NOW';
 NEW.USER_UPDATE=USER;
 IF (NEW.REVISION_LOCK=1) THEN BEGIN
  NEW.DATE_LOCK='TODAY';
  NEW.USER_LOCK=USER;
 END
end
^


/* Trigger: REV_RECORDS_BI0 */
CREATE TRIGGER REV_RECORDS_BI0 FOR REV_RECORDS
ACTIVE BEFORE INSERT POSITION 0
as
begin
 IF (NEW.REV_RECORDS_ID IS NULL) THEN NEW.REV_RECORDS_ID=GEN_ID(GEN_REV_RECORDS_ID, 1);
 NEW.DATE_CREATE='TODAY';
 NEW.TIME_CREATE='NOW';
 NEW.USER_CREATE=USER;
 NEW.DATE_UPDATE='TODAY';
 NEW.TIME_UPDATE='NOW';
 NEW.USER_UPDATE=USER;
end
^


/* Trigger: REV_RECORDS_BU0 */
CREATE TRIGGER REV_RECORDS_BU0 FOR REV_RECORDS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
 NEW.DATE_UPDATE='TODAY';
 NEW.TIME_UPDATE='NOW';
 NEW.USER_UPDATE=USER;
end
^


/* Trigger: REV_TMP_BI */
CREATE TRIGGER REV_TMP_BI FOR REV_TMP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.REV_TMP_ID IS NULL) THEN
    NEW.REV_TMP_ID = GEN_ID(GEN_REV_TMP_ID,1);
    NEW.dat_cr = 'NOW';
END
^


/* Trigger: RST_BI */
CREATE TRIGGER RST_BI FOR RST
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.RST_ID IS NULL) THEN
    NEW.RST_ID = GEN_ID(GEN_RST_ID,1);
  if (new.last_inprice is null) then new.last_inprice= 0.00;
END
^


/* Trigger: RST_BIU10 */
CREATE TRIGGER RST_BIU10 FOR RST
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: RST_BU0 */
CREATE TRIGGER RST_BU0 FOR RST
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (new.rest != 0) then
   update nomen n set n.is_visible = 1 where nomen_id = new.nomen_id;
end
^


/* Trigger: SI_BI_BI */
CREATE TRIGGER SI_BI_BI FOR SI
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.SI_ID IS NULL) THEN
    NEW.SI_ID = GEN_ID(GEN_SI_ID,1);
END
^


/* Trigger: SPECIALS_GROUPS_BI */
CREATE TRIGGER SPECIALS_GROUPS_BI FOR SPECIALS_GROUPS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.SG_ID IS NULL) THEN
    NEW.SG_ID = GEN_ID(GEN_SPECIALS_GROUPS_ID,1);
END
^


/* Trigger: STAFF_BI0 */
CREATE TRIGGER STAFF_BI0 FOR STAFF
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 IF (NEW.STAFF_ID IS NULL) THEN
     NEW.STAFF_ID=GEN_ID(GEN_STAFF_ID, 1);
END
^


/* Trigger: STATES_BD0 */
CREATE TRIGGER STATES_BD0 FOR STATES
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.state_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: STATES_BI0 */
CREATE TRIGGER STATES_BI0 FOR STATES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.state_id is null) then new.state_id = gen_id(gen_state_id, 1);
end
^


/* Trigger: STATES_BU0 */
CREATE TRIGGER STATES_BU0 FOR STATES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.state_id = 0) then exception not_edit_sys_record;
end
^


/* Trigger: TYPECLIENT_BI0 */
CREATE TRIGGER TYPECLIENT_BI0 FOR TYPECLIENT
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
 IF (NEW.TYPECLIENT_ID IS NULL) THEN NEW.TYPECLIENT_ID=GEN_ID(GEN_TYPECLIENT_ID, 1);
END
^


/* Trigger: TYPECLIENT_BIU10 */
CREATE TRIGGER TYPECLIENT_BIU10 FOR TYPECLIENT
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: TYPEDOC_BIU10 */
CREATE TRIGGER TYPEDOC_BIU10 FOR TYPEDOC
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: TYPEPAY_BIU10 */
CREATE TRIGGER TYPEPAY_BIU10 FOR TYPEPAY
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: TYPEPDV_BIU10 */
CREATE TRIGGER TYPEPDV_BIU10 FOR TYPEPDV
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_1C_LOG_BI0 */
CREATE TRIGGER T_1C_LOG_BI0 FOR T_1C_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
begin
 new.user_cr = user;
 new.date_cr = 'NOW';
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: T_1C_LOG_BU0 */
CREATE TRIGGER T_1C_LOG_BU0 FOR T_1C_LOG
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
 new.user_upd = user;
 new.date_upd = 'NOW';
end
^


/* Trigger: T_ACCESS_BIU10 */
CREATE TRIGGER T_ACCESS_BIU10 FOR T_ACCESS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_ACTION_BI */
CREATE TRIGGER T_ACTION_BI FOR T_ACTION
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_T_ACTION_ID,1);
END
^


/* Trigger: T_CALCULATIONS_BI */
CREATE TRIGGER T_CALCULATIONS_BI FOR T_CALCULATIONS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CALCULATION_ID IS NULL) THEN
    NEW.CALCULATION_ID = GEN_ID(GEN_T_CALCULATIONS_ID,1);
END
^


/* Trigger: T_CALCULATIONS_TYPE_NOMEN */
CREATE TRIGGER T_CALCULATIONS_TYPE_NOMEN FOR T_CALCULATIONS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
declare variable ptype_nomen smallint;
begin
  select type_nomen from nomen
   where nomen_id = new.nomen_id
    into ptype_nomen;

  if ((:ptype_nomen != 2)or(:ptype_nomen is null)) then
   update nomen
      set type_nomen = 2
    where nomen_id = new.nomen_id;
end
^


/* Trigger: T_CALC_RECORDS_BI */
CREATE TRIGGER T_CALC_RECORDS_BI FOR T_CALC_RECORDS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CALC_RECORD_ID IS NULL) THEN
    NEW.CALC_RECORD_ID = GEN_ID(GEN_T_CALC_RECORDS_ID,1);
END
^


/* Trigger: T_CLIENTS_SYNC_BI0 */
CREATE TRIGGER T_CLIENTS_SYNC_BI0 FOR T_CLIENTS_SYNC
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  NEW.DATE_LAST_MODEFICATION = 'TODAY';
  IF (NEW.IS_PDV IS NULL) THEN
    NEW.IS_PDV = 1;
  IF (NEW.IS_ACTIVE IS NULL) THEN
    NEW.IS_ACTIVE = 1;
  IF (NEW.is_visible IS NULL) THEN
    NEW.is_visible = 1;
end
^


/* Trigger: T_CLIENTS_SYNC_BU0 */
CREATE TRIGGER T_CLIENTS_SYNC_BU0 FOR T_CLIENTS_SYNC
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  NEW.DATE_LAST_MODEFICATION = 'TODAY';
end
^


/* Trigger: T_CLIENTS_TMP_BI */
CREATE TRIGGER T_CLIENTS_TMP_BI FOR T_CLIENTS_TMP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CLIENT_ID IS NULL) THEN
    NEW.CLIENT_ID = GEN_ID(GEN_T_CLIENTS_TMP_ID,1);
  NEW.DATE_LAST_MODEFICATION = 'TODAY';
  IF (NEW.IS_PDV IS NULL) THEN
    NEW.IS_PDV = 1;
  IF (NEW.IS_ACTIVE IS NULL) THEN
    NEW.IS_ACTIVE = 1;
END
^


/* Trigger: T_CLIENTS_TMP_BU0 */
CREATE TRIGGER T_CLIENTS_TMP_BU0 FOR T_CLIENTS_TMP
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  NEW.DATE_LAST_MODEFICATION = 'TODAY';
end
^


/* Trigger: T_CONFIGS_BIU10 */
CREATE TRIGGER T_CONFIGS_BIU10 FOR T_CONFIGS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_COUPON_ARTICLES_BIU10 */
CREATE TRIGGER T_COUPON_ARTICLES_BIU10 FOR T_COUPON_ARTICLES
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_COUPON_DISCOUNTS_BIU10 */
CREATE TRIGGER T_COUPON_DISCOUNTS_BIU10 FOR T_COUPON_DISCOUNTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_COUPON_PROPS_BIU10 */
CREATE TRIGGER T_COUPON_PROPS_BIU10 FOR T_COUPON_PROPS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_COUPON_UNITS_BIU10 */
CREATE TRIGGER T_COUPON_UNITS_BIU10 FOR T_COUPON_UNITS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_DECREASE_BI0 */
CREATE TRIGGER T_DECREASE_BI0 FOR T_DECREASE
ACTIVE BEFORE INSERT POSITION 0
AS
begin
   IF (NEW.decr_id IS NULL) THEN
     NEW.decr_id = GEN_ID(GEN_T_DECREASE_ID,1);
   if (new.decr_type_id is null) then
     new.decr_type_id = 0;
end
^


/* Trigger: T_DEL_DOCGOODS_BI5 */
CREATE TRIGGER T_DEL_DOCGOODS_BI5 FOR T_DEL_DOCGOODS
ACTIVE BEFORE INSERT POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_DEL_DOCRECS_BI5 */
CREATE TRIGGER T_DEL_DOCRECS_BI5 FOR T_DEL_DOCRECS
ACTIVE BEFORE INSERT POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_DEL_DOCUMENTS_BI5 */
CREATE TRIGGER T_DEL_DOCUMENTS_BI5 FOR T_DEL_DOCUMENTS
ACTIVE BEFORE INSERT POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_DEL_GOODS_BI5 */
CREATE TRIGGER T_DEL_GOODS_BI5 FOR T_DEL_GOODS
ACTIVE BEFORE INSERT POSITION 5
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_DOC_PROP_AD0 */
CREATE TRIGGER T_DOC_PROP_AD0 FOR T_DOC_PROP
ACTIVE AFTER DELETE POSITION 0
AS
declare variable pdocrec_id integer;
begin
  for select dr.docrec_id from docrec dr
       where dr.document_id = old.document_id
        into pdocrec_id
  do begin
    delete from t_dr_prop dp
     where dp.docrec_id = :pdocrec_id and
           dp.coupon_ean_id = old.coupon_ean_id;
  end
end
^


/* Trigger: T_DR_PROP_AD0 */
CREATE TRIGGER T_DR_PROP_AD0 FOR T_DR_PROP
ACTIVE AFTER DELETE POSITION 0
AS
declare variable pdocument_id integer;
declare variable psum double precision;
begin
  if (old.sku_quantity > 0) then
  begin
    select document_id from docrec
     where docrec_id = old.docrec_id
      into pdocument_id;

    select osum from ps_coupon_recalc_quantity(:pdocument_id, old.coupon_ean_id)
      into psum;
  end
end
^


/* Trigger: T_HAPPY_CHECK_BI */
CREATE TRIGGER T_HAPPY_CHECK_BI FOR T_HAPPY_CHECK
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  if (new.id is null) then
    new.id = gen_id(gen_t_happy_check_id,1);
  if (new.is_used is null) then new.is_used = 0;
  if (new.is_used = 1) then new.use_time = 'now';
END
^


/* Trigger: T_KARDS_ZVIT_LOG_BI */
CREATE TRIGGER T_KARDS_ZVIT_LOG_BI FOR T_KARDS_ZVIT_LOG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.rec_id is null) then
    new.rec_id = gen_id(gen_kards_zvit_log_id,1);
end
^


/* Trigger: T_MARKUPS_BI0 */
CREATE TRIGGER T_MARKUPS_BI0 FOR T_MARKUPS
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  IF (NEW.MARKUP_ID IS NULL) THEN
    NEW.MARKUP_ID = GEN_ID(GEN_T_MARKUPS_ID,1);
  IF (NEW.PRINT_CNT IS NULL) THEN NEW.PRINT_CNT = 0;
  new.time_ins = 'now';
  new.print_cnt = 0;

    select u.user_id from t_users u
        where u.user_login = user
      into new.user_ins_id;
end
^


/* Trigger: T_MARKUPS_BU0 */
CREATE TRIGGER T_MARKUPS_BU0 FOR T_MARKUPS
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE TMARKUP_RECORD_ID INTEGER;
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TREST DOUBLE PRECISION;
DECLARE VARIABLE TOUT_PRICE DOUBLE PRECISION;
DECLARE VARIABLE TOUT_PRICE_OLD DOUBLE PRECISION;
DECLARE VARIABLE TDOCREC_ID INTEGER;
DECLARE VARIABLE TCURRENT_REST DOUBLE PRECISION;
begin
  if (old.is_fixed <> new.is_fixed) then
  begin
    new.time_fix = 'now';
    select u.user_id from t_users u
        where u.user_login = user
      into new.user_fix_id;

  end
  else
  begin
    new.time_upd = 'now';
    select u.user_id from t_users u
        where u.user_login = user
      into new.user_upd_id;
  end

  if (((old.is_fixed = 0) or (old.is_fixed is null)) and (new.is_fixed <> 0)) then
  begin
    for select mr.markup_record_id, mr.docrec_id, mr.nomen_id, mr.out_price from t_markup_records mr
        where mr.markup_id = new.markup_id
      into :tmarkup_record_id, :tdocrec_id, :tnomen_id, :tout_price
    do begin
      select r.rest from rst r
          where r.objects_id = 1 and
                r.nomen_id = :tnomen_id
        into :trest;

      if (:tdocrec_id is not null) then
      begin
        tcurrent_rest = 0.00;
        select sum(g.goods_rest) from docgoods dg, goods g
            where dg.docrec_id = :tdocrec_id and
                  dg.goods_id = g.goods_id
          into :tcurrent_rest;
        trest = minus(:trest, :tcurrent_rest);
      end

      select n.out_price from nomen n
          where n.nomen_id = :tnomen_id
        into :tout_price_old;

      update t_markup_records mr
          set mr.rest = :trest,
              mr.out_price_old = :tout_price_old
        where mr.markup_record_id = :tmarkup_record_id;
      update nomen n
          set n.out_price = :tout_price
        where n.nomen_id = :tnomen_id;

      tdocrec_id = null;
    end
  end
end
^


/* Trigger: T_MARKUP_RECORDS_BI */
CREATE TRIGGER T_MARKUP_RECORDS_BI FOR T_MARKUP_RECORDS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.MARKUP_RECORD_ID IS NULL) THEN
    NEW.MARKUP_RECORD_ID = GEN_ID(GEN_T_MARKUP_RECORDS_ID,1);

  new.time_ins = 'now';
  select u.user_id from t_users u
      where u.user_login = user
    into new.user_ins_id;

  if (new.time_upd is not null) then
    new.date_upd = cast(new.time_upd as date);
END
^


/* Trigger: T_MARKUP_RECORDS_BU0 */
CREATE TRIGGER T_MARKUP_RECORDS_BU0 FOR T_MARKUP_RECORDS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  new.time_upd = 'now';
  select u.user_id from t_users u
      where u.user_login = user
    into new.user_upd_id;

  if (new.time_upd is not null) then
    new.date_upd = cast(new.time_upd as date);
end
^


/* Trigger: T_NOMENS_LOG_BIU0 */
CREATE TRIGGER T_NOMENS_LOG_BIU0 FOR T_NOMENS_LOG
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_NOMENS_SYNC_BI0 */
CREATE TRIGGER T_NOMENS_SYNC_BI0 FOR T_NOMENS_SYNC
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.receipt_date is null) then
    new.receipt_date = 'today';
end
^


/* Trigger: T_NOM_BARS_SYNC_BI0 */
CREATE TRIGGER T_NOM_BARS_SYNC_BI0 FOR T_NOM_BARS_SYNC
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  if (new.nom_bar_id is null) then
    new.nom_bar_id = gen_id(gen_nom_bars_sync_id, 1);
end
^


/* Trigger: T_PACTS_BI */
CREATE TRIGGER T_PACTS_BI FOR T_PACTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.PACT_ID IS NULL) THEN
    NEW.PACT_ID = GEN_ID(GEN_T_PACTS_ID,1);
  if (new.date_begin is null) then new.date_begin = 'today';
  if (new.date_end is null) then new.date_end = 'today';
END
^


/* Trigger: T_PAYMENTS_BI */
CREATE TRIGGER T_PAYMENTS_BI FOR T_PAYMENTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_T_PAYMENTS_ID,1);
END
^


/* Trigger: T_PAYMENT_RECS_BI */
CREATE TRIGGER T_PAYMENT_RECS_BI FOR T_PAYMENT_RECS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ID IS NULL) THEN
    NEW.ID = GEN_ID(GEN_NEW_TABLE_ID,1);
END
^


/* Trigger: T_PAYS_AD0 */
CREATE TRIGGER T_PAYS_AD0 FOR T_PAYS
ACTIVE AFTER DELETE POSITION 0
AS
begin
  execute procedure PS_PAYS_RECALC(old.document_id);
end
^


/* Trigger: T_PAYS_AI0 */
CREATE TRIGGER T_PAYS_AI0 FOR T_PAYS
ACTIVE AFTER INSERT POSITION 0
AS
begin
  execute procedure PS_PAYS_RECALC(new.document_id);
end
^


/* Trigger: T_PAYS_AU0 */
CREATE TRIGGER T_PAYS_AU0 FOR T_PAYS
ACTIVE AFTER UPDATE POSITION 0
AS
begin
  execute procedure PS_PAYS_RECALC(new.document_id);
end
^


/* Trigger: T_PAYS_BI */
CREATE TRIGGER T_PAYS_BI FOR T_PAYS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.PAY_ID IS NULL) THEN
    NEW.PAY_ID = GEN_ID(GEN_T_PAYS_ID,1);
END
^


/* Trigger: T_POSTS_BD0 */
CREATE TRIGGER T_POSTS_BD0 FOR T_POSTS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.post_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: T_POSTS_BI */
CREATE TRIGGER T_POSTS_BI FOR T_POSTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.POST_ID IS NULL) THEN
    NEW.POST_ID = GEN_ID(GEN_T_POSTS_ID,1);
END
^


/* Trigger: T_POSTS_BU0 */
CREATE TRIGGER T_POSTS_BU0 FOR T_POSTS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if (old.post_id = 0) then exception not_edit_sys_record;
end
^


/* Trigger: T_PRODUCTION_DOCS_BI */
CREATE TRIGGER T_PRODUCTION_DOCS_BI FOR T_PRODUCTION_DOCS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_t_PRODUCTION_docs_id,1);

  select u.user_id from t_users u
   where u.user_login = user
    into new.create_user_id;
end
^


/* Trigger: T_PRODUCTION_DOCS_BU0 */
CREATE TRIGGER T_PRODUCTION_DOCS_BU0 FOR T_PRODUCTION_DOCS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  select u.user_id from t_users u
   where u.user_login = user
    into new.update_user_id;
end
^


/* Trigger: T_PRODUCTION_RECS_BI */
CREATE TRIGGER T_PRODUCTION_RECS_BI FOR T_PRODUCTION_RECS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_t_PRODUCTION_recs_id,1);

end
^


/* Trigger: T_REC_FILLINGS_BI */
CREATE TRIGGER T_REC_FILLINGS_BI FOR T_REC_FILLINGS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_t_rec_fillings_id,1);
end
^


/* Trigger: T_RIGHTS_BI */
CREATE TRIGGER T_RIGHTS_BI FOR T_RIGHTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.RIGHT_ID IS NULL) THEN
    NEW.RIGHT_ID = GEN_ID(GEN_T_RIGHTS_ID,1);
END
^


/* Trigger: T_RIGHTS_BIU10 */
CREATE TRIGGER T_RIGHTS_BIU10 FOR T_RIGHTS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_RIGHTS_GRP_BI */
CREATE TRIGGER T_RIGHTS_GRP_BI FOR T_RIGHTS_GRP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.RIGHT_GRP_ID IS NULL) THEN
    NEW.RIGHT_GRP_ID = GEN_ID(GEN_T_RIGHTS_GRP_ID,1);
END
^


/* Trigger: T_RIGHTS_GRP_BIU10 */
CREATE TRIGGER T_RIGHTS_GRP_BIU10 FOR T_RIGHTS_GRP
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: T_ROLL_TAX_BI0 */
CREATE TRIGGER T_ROLL_TAX_BI0 FOR T_ROLL_TAX
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE TYPEDOC_ID INTEGER;
begin
  if (new.ROLL_TAX_id is null) then new.ROLL_TAX_id = gen_id(gen_ROLL_TAX_id, 1);
  new.user_cr = user;
  new.date_cr = 'NOW';
  new.user_upd = user;
  new.date_upd = 'NOW';
  select d.typedoc_id
   from documents d
   where d.document_id = new.document_id
   into :typedoc_id;
  new.td_type = 0;
  if (:typedoc_id = 1) then new.td_type = 1;
  if (:typedoc_id in (2, 11)) then new.td_type = 2;
  /*???? Need cleare */ new.data = 'now';
end
^


/* Trigger: T_ROLL_TAX_BU0 */
CREATE TRIGGER T_ROLL_TAX_BU0 FOR T_ROLL_TAX
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE TYPEDOC_ID INTEGER;
begin
  select d.typedoc_id
   from documents d
   where d.document_id = new.document_id
   into :typedoc_id;
  new.td_type = 0;
  if (:typedoc_id = 1) then new.td_type = 1;
  if (:typedoc_id in (2, 11)) then new.td_type = 2;
  new.user_upd = user;
  new.date_upd = 'NOW';
end
^


/* Trigger: T_SCALES_BI */
CREATE TRIGGER T_SCALES_BI FOR T_SCALES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_t_scales_id,1);
end
^


/* Trigger: T_SYNC_TS_BI */
CREATE TRIGGER T_SYNC_TS_BI FOR T_SYNC_TS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.SYNC_ID IS NULL) THEN
    NEW.SYNC_ID = GEN_ID(GEN_T_SYNC_TS_ID,1);
END
^


/* Trigger: T_SYNC_TS_BI5 */
CREATE TRIGGER T_SYNC_TS_BI5 FOR T_SYNC_TS
ACTIVE BEFORE INSERT POSITION 5
AS
begin
  new.sync_ts = 'now';
end
^


/* Trigger: T_TMP_NOMENS_BI */
CREATE TRIGGER T_TMP_NOMENS_BI FOR T_TMP_NOMENS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.NOMEN_ID IS NULL) THEN
    NEW.NOMEN_ID = GEN_ID(GEN_T_TMP_NOMENS_ID,1);
END
^


/* Trigger: T_TMP_NOMENS_BIU0 */
CREATE TRIGGER T_TMP_NOMENS_BIU0 FOR T_TMP_NOMENS
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  new.date_last_modefication = 'today';
end
^


/* Trigger: T_TMP_NOMEN_GROUPS_BD0 */
CREATE TRIGGER T_TMP_NOMEN_GROUPS_BD0 FOR T_TMP_NOMEN_GROUPS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.nomen_group_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: T_TMP_NOMEN_GROUPS_BI */
CREATE TRIGGER T_TMP_NOMEN_GROUPS_BI FOR T_TMP_NOMEN_GROUPS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.NOMEN_GROUP_ID IS NULL) THEN
    NEW.NOMEN_GROUP_ID = GEN_ID(GEN_T_TMP_NOMEN_GROUPS_ID,1);
END
^


/* Trigger: T_TMP_NOMEN_GROUPS_BU0 */
CREATE TRIGGER T_TMP_NOMEN_GROUPS_BU0 FOR T_TMP_NOMEN_GROUPS
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  if(old.nomen_group_id = 0) then exception not_edit_sys_record;
end
^


/* Trigger: T_TMP_NOM_BAR_BI */
CREATE TRIGGER T_TMP_NOM_BAR_BI FOR T_TMP_NOM_BAR
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.NOM_BAR_ID IS NULL) THEN
    NEW.NOM_BAR_ID = GEN_ID(GEN_T_TMP_NOM_BAR_ID,1);
END
^


/* Trigger: T_TYPE_SCALES_BI */
CREATE TRIGGER T_TYPE_SCALES_BI FOR T_TYPE_SCALES
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_t_type_scales_id,1);
end
^


/* Trigger: T_USERS_BD0 */
CREATE TRIGGER T_USERS_BD0 FOR T_USERS
ACTIVE BEFORE DELETE POSITION 0
AS
begin
  if (old.user_id = 0) then exception not_del_sys_record;
end
^


/* Trigger: T_USERS_BI */
CREATE TRIGGER T_USERS_BI FOR T_USERS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.USER_ID IS NULL) THEN
    NEW.USER_ID = GEN_ID(GEN_T_USERS_ID,1);
  new.last_doc = 1;
END
^


/* Trigger: T_USERS_BIU1 */
CREATE TRIGGER T_USERS_BIU1 FOR T_USERS
ACTIVE BEFORE INSERT OR UPDATE POSITION 1
AS
begin
  if ((new.signature != old.signature)and
      (new.signature is not null)and
      (new.signature != '')and
      exists(select * from t_users u
              where u.signature = new.signature and
                    u.user_id  != new.user_id)
                    ) then
     exception EX_NO_UNIQUE_SIGNATURE;
end
^


/* Trigger: T_USERS_BIU10 */
CREATE TRIGGER T_USERS_BIU10 FOR T_USERS
ACTIVE BEFORE INSERT OR UPDATE POSITION 10
AS
begin
  new.ts = 'now';
end
^


/* Trigger: WEIGHT_CODE_BI_BI */
CREATE TRIGGER WEIGHT_CODE_BI_BI FOR WEIGHT_CODE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.WEIGHT_CODE_ID IS NULL) THEN
    NEW.WEIGHT_CODE_ID = GEN_ID(GEN_WEIGHT_CODE_ID,1);
END
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE AOG_AO_RECORD_CREATE (
    AUTOORDER_ID INTEGER,
    NOMEN_ID INTEGER,
    GRP_ID INTEGER)
AS
declare variable p_flag_id smallint;
declare variable p_date_in date;
declare variable p_date_out date;
declare variable p_begin double precision;
declare variable p_arrival double precision;
declare variable p_charge double precision;
declare variable p_end double precision;
declare variable p_min_rest double precision;
declare variable p_nomen_id integer;
declare variable p_analysed_days integer;
declare variable p_ordered_days integer;
declare variable p_ordered double precision;
begin
 p_flag_id = 0; /* not add */
 if (:nomen_id  is null) then nomen_id  = 0;
 if (:grp_id    is null) then grp_id    = 0;
 if (:nomen_id <> 0)     then p_flag_id = 1; /* add the good */
  else if (:grp_id <> 0) then p_flag_id = 2; /* add the all group */
 select ao.ao_date, ao.ao_date - ao.ao_analysed_days, ao.ao_analysed_days,
        ao.ao_ordered_days
   from autoorders ao
  where ao.autoorder_id = :autoorder_id
   into p_date_out, p_date_in, p_analysed_days, p_ordered_days;
 if (:p_date_out        is null) then p_flag_id         = 0;
 if (:p_analysed_days   is null) then p_analysed_days   = 0;
 if (:p_ordered_days    is null) then p_ordered_days    = 0;
 /* add the good ------------------------------------------------------------ */
 if (:p_flag_id = 1) then
 begin
  select n.minkilk
    from nomen n
   where n.nomen_id = :nomen_id
    into p_min_rest;
  if (:p_min_rest is null) then p_min_rest = 0.000;
  select sum(nv.begin_k), sum(nv.arrival_k), sum(nv.charge_k), sum(nv.end_k)
    from aog_nomen_view(:nomen_id, :p_date_in, :p_date_out) nv
    into p_begin, p_arrival, p_charge, p_end;
  if (:p_begin      is null) then p_begin   = 0.000;
  if (:p_arrival    is null) then p_arrival = 0.000;
  if (:p_charge     is null) then p_charge  = 0.000;
  if (:p_end        is null) then p_end     = 0.000;
  if (:p_analysed_days = 0)  then begin p_ordered = 0.000; end
   else begin
    p_ordered=((:p_charge / :p_analysed_days) * :p_ordered_days) - :p_end + :p_min_rest;
   end
  if (:p_ordered < 0.000) then p_ordered = 0.000;
  p_ordered = cast(around(:p_ordered/100)*100 as integer);
  insert into ao_records (aor_autoorder_id, aor_nomen_id, aor_begin, aor_arrival,
                          aor_charge, aor_end, aor_min_rest, aor_ordered)
   values (:autoorder_id, :nomen_id, :p_begin, :p_arrival,
           :p_charge,  :p_end,  :p_min_rest, :p_ordered);
 end
 /* add the all group ------------------------------------------------------- */
 if (:p_flag_id = 2) then
 begin
  for select nv.nomen_id, nv.min_rest, sum(nv.begin_k), sum(nv.arrival_k), sum(nv.charge_k), sum(nv.end_k)
        from aog_grp_view(:grp_id, :p_date_in, :p_date_out) nv
       group by nv.nomen_id, nv.min_rest
        into p_nomen_id, p_min_rest, p_begin, p_arrival, p_charge, p_end
  do begin
   if (:p_min_rest  is null) then p_min_rest    = 0.000;
   if (:p_begin     is null) then p_begin       = 0.000;
   if (:p_arrival   is null) then p_arrival     = 0.000;
   if (:p_charge    is null) then p_charge      = 0.000;
   if (:p_end       is null) then p_end         = 0.000;
   if (:p_analysed_days = 0) then begin p_ordered = 0.000; end
    else begin
     p_ordered=((:p_charge / :p_analysed_days) * :p_ordered_days) - :p_end + :p_min_rest;
    end
   if (:p_ordered < 0.000) then p_ordered = 0.000;
   p_ordered = cast(around(:p_ordered/100)*100 as integer);
   insert into ao_records (aor_autoorder_id, aor_nomen_id, aor_begin, aor_arrival,
                           aor_charge, aor_end, aor_min_rest, aor_ordered)
    values (:autoorder_id, :p_nomen_id, :p_begin, :p_arrival,
            :p_charge,  :p_end,  :p_min_rest, :p_ordered);
  end
 end
end^


ALTER PROCEDURE AOG_AO_RECORDS_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    AO_RECORD_ID INTEGER,
    AOR_NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    AOR_BEGIN DOUBLE PRECISION,
    AOR_ARRIVAL DOUBLE PRECISION,
    AOR_CHARGE DOUBLE PRECISION,
    AOR_END DOUBLE PRECISION,
    AOR_MIN_REST DOUBLE PRECISION,
    AOR_REC_ORDER DOUBLE PRECISION,
    AOR_ORDERED DOUBLE PRECISION)
AS
declare variable p_analysed_days integer;
declare variable p_ordered_days integer;
begin
 select ao.ao_analysed_days, ao.ao_ordered_days
   from autoorders ao
  where ao.autoorder_id = :autoorder_id
   into p_analysed_days, p_ordered_days;

 if (:p_analysed_days is null) then p_analysed_days = 0;
 if (:p_ordered_days  is null) then p_ordered_days = 0;

 for select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered
      from ao_records aor left join nomen n on aor.aor_nomen_id=n.nomen_id
     where aor.aor_autoorder_id = :autoorder_id
      into ao_record_id, aor_nomen_id, nomen_code, nomen_name,
           aor_begin, aor_arrival, aor_charge, aor_end,
           aor_min_rest, aor_ordered
 do begin
  if (:aor_charge   is null) then aor_charge    = 0.000;
  if (:aor_end      is null) then aor_end       = 0.000;
  if (:aor_min_rest is null) then aor_min_rest  = 0.000;
  if (:p_analysed_days = 0)  then begin aor_rec_order = 0.000; end
   else begin
    aor_rec_order=((:aor_charge / :p_analysed_days) * :p_ordered_days) - :aor_end + :aor_min_rest;
   end
  aor_rec_order = cast(around(:aor_rec_order/100)*100 as integer);
  if (:aor_ordered is null) then aor_ordered = :aor_rec_order;
  suspend;
 end
end^


ALTER PROCEDURE AOG_AUTOORDER_CREATE
RETURNS (
    AUTOORDER_ID INTEGER,
    AO_DATE DATE)
AS
begin
 autoorder_id = gen_id(gen_autoorder_id, 1);
 insert into autoorders (autoorder_id)
  values (:autoorder_id);
 select ao.ao_date
  from autoorders ao
  where ao.autoorder_id = :autoorder_id
  into :ao_date;
 suspend;
end^


ALTER PROCEDURE AOG_AUTOORDER_DEL (
    AUTOORDER_ID INTEGER)
AS
begin
 delete from ao_records aor
  where aor.aor_autoorder_id=:autoorder_id;
 delete from autoorders ao
  where ao.autoorder_id=:autoorder_id;
end^


ALTER PROCEDURE AOG_AUTOORDER_UPDATE (
    AUTOORDER_ID INTEGER,
    NOTE VARCHAR(30),
    CLIENT_ID INTEGER,
    STAFF_ID INTEGER,
    ANALYSED_DAYS INTEGER,
    ORDERED_DAYS INTEGER)
AS
begin
 update autoorders ao
  set ao.ao_note = :note,
      ao.ao_client_id = :client_id,
      ao.ao_staff_id = :staff_id, 
      ao.ao_analysed_days = :analysed_days,
      ao.ao_ordered_days = :ordered_days
  where ao.autoorder_id = :autoorder_id;
end^


ALTER PROCEDURE AOG_AUTOORDER_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    AO_CONDITIONS SMALLINT,
    AO_DATE DATE,
    AO_NOTE VARCHAR(30),
    AO_CLIENT_ID INTEGER,
    AO_CLIENT_NAME VARCHAR(50),
    AO_STAFF_ID INTEGER,
    AO_STAFF_NAME VARCHAR(25),
    AO_ANALYSED_DAYS SMALLINT,
    AO_ORDERED_DAYS SMALLINT)
AS
begin
 select ao.ao_conditions, ao.ao_date, ao.ao_note,
        ao.ao_client_id, c.name, ao.ao_staff_id,
        ao.ao_analysed_days, ao.ao_ordered_days,
        s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
  from autoorders ao
       left join clients c on ao.ao_client_id = c.clients_id
       left join staff s on ao.ao_staff_id = s.staff_id
  where ao.autoorder_id=:autoorder_id
  into :ao_conditions, :ao_date, :ao_note,
       :ao_client_id, :ao_client_name, :ao_staff_id,
       :ao_analysed_days, :ao_ordered_days, :ao_staff_name;
 if (:ao_conditions is null) then ao_conditions = 0;
 if (:ao_analysed_days is null) then ao_analysed_days = 0;
 if (:ao_ordered_days is null) then ao_ordered_days = 0;
 if (:ao_client_id is null) then ao_client_name = 'Не вказано';
 if (:ao_staff_id is null) then ao_staff_name = 'Не вказано';
 suspend;
end^


ALTER PROCEDURE AOG_AUTOORDERS_VIEW (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    AUTOORDER_ID INTEGER,
    AO_CONDITIONS SMALLINT,
    AO_DATE DATE,
    AO_NOTE VARCHAR(30),
    AO_CLIENT_ID INTEGER,
    AO_CLIENT_NAME VARCHAR(50),
    AO_STAFF_ID INTEGER,
    AO_STAFF_NAME VARCHAR(25),
    AO_ANALYSED_DAYS SMALLINT,
    AO_ORDERED_DAYS SMALLINT)
AS
begin
  /* Procedure Text */
 for select ao.autoorder_id, ao.ao_conditions, ao.ao_date, ao.ao_note,
            ao.ao_client_id, c.name, ao.ao_staff_id,
            ao.ao_analysed_days, ao.ao_ordered_days,
            s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
      from autoorders ao
           left join clients c on ao.ao_client_id = c.clients_id
           left join staff s on ao.ao_staff_id = s.staff_id
      where ao.ao_date between :date_in and :date_out
      order by ao.autoorder_id
      into :autoorder_id, :ao_conditions, :ao_date, :ao_note,
           :ao_client_id, :ao_client_name, :ao_staff_id,
           :ao_analysed_days, :ao_ordered_days, :ao_staff_name
 do begin
  if (:ao_conditions is null) then ao_conditions = 0;
  if (:ao_analysed_days is null) then ao_analysed_days = 0;
  if (:ao_ordered_days is null) then ao_ordered_days = 0;
  if (:ao_client_id is null) then ao_client_name = 'Не вказано';
  if (:ao_staff_id is null) then ao_staff_name = 'Не вказано';
  suspend;
 end
end^


ALTER PROCEDURE AOG_CORECTED_GEN_AO
AS
DECLARE VARIABLE P_MAX_AO_ID INTEGER;
DECLARE VARIABLE P_REAL_GEN_ID INTEGER;
begin
 p_max_ao_id=null;
 select max(ao.autoorder_id)
  from autoorders ao
  into :p_max_ao_id;
 if (:p_max_ao_id is null) then p_max_ao_id=0;
 p_real_gen_id = gen_id(gen_autoorder_id, 1);
 if (:p_max_ao_id = 0) then begin
   p_real_gen_id = gen_id(gen_autoorder_id, -:p_real_gen_id);
  end
 else begin
   p_real_gen_id = gen_id(gen_autoorder_id, :p_max_ao_id - :p_real_gen_id);
  end
end^


ALTER PROCEDURE AOG_CORECTED_GEN_AOR
AS
DECLARE VARIABLE P_MAX_AOR_ID INTEGER;
DECLARE VARIABLE P_REAL_GEN_ID INTEGER;
begin
 p_max_aor_id=null;
 select max(ao.ao_record_id)
  from ao_records ao
  into :p_max_aor_id;
 if (:p_max_aor_id is null) then p_max_aor_id=0;
 p_real_gen_id = gen_id(gen_ao_record_id, 1);
 if (:p_max_aor_id = 0) then begin
   p_real_gen_id = gen_id(gen_ao_record_id, -:p_real_gen_id);
  end
 else begin
   p_real_gen_id = gen_id(gen_ao_record_id, :p_max_aor_id - :p_real_gen_id);
  end
end^


ALTER PROCEDURE AOG_GRP_VIEW (
    GRP_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    NOMEN_ID INTEGER,
    MIN_REST DOUBLE PRECISION,
    BEGIN_K DOUBLE PRECISION,
    ARRIVAL_K DOUBLE PRECISION,
    CHARGE_K DOUBLE PRECISION,
    END_K DOUBLE PRECISION)
AS
declare variable p_date_max date;
declare variable p_doc_date date;
declare variable p_src_id integer;
declare variable p_dst_id integer;
declare variable p_kilk double precision;
begin
  for select n.nomen_id, n.minkilk, r.rest
       from t_grp_childs(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r   on n.nomen_id=r.nomen_id
      where r.objects_id = 1 and
            ((n.is_exist = 1)or(n.is_exist is null)) and
            ((n.type_nomen = 0)or(n.type_nomen is null))
       into nomen_id, min_rest, end_k
  do begin
   if (:end_k    is null) then end_k    = 0.000;
   if (:min_rest is null) then min_rest = 0.000;
   begin_k   = :end_k;
   arrival_k = 0.000;
   charge_k  = 0.000;
   suspend;
  end
  select max(d.doc_date)
    from documents d
    into p_date_max;
  if (:p_date_max < 'TODAY') then p_date_max = 'TODAY';
  for select d.doc_date, d.objects_id, d.clients_id, dr.nomen_id, dr.kilk, n.minkilk
       from (t_grp_childs(:grp_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
            join
            (documents d left join docrec dr on d.document_id = dr.document_id)
            on n.nomen_id = dr.nomen_id
       where d.doc_date between :date_in and :p_date_max and
             ((d.objects_id = 1) or (d.clients_id = 1))  and
             n.is_exist = 1
       into p_doc_date, p_src_id, p_dst_id, nomen_id, p_kilk, min_rest
  do begin
   end_k     = 0.000;
   begin_k   = 0.000;
   arrival_k = 0.000;
   charge_k  = 0.000;
   if (:min_rest is null) then min_rest = 0.000;
   if (:p_kilk is null)   then p_kilk   = 0.000;
   if (:p_doc_date > :date_out) then begin
     if (:p_dst_id = 1) then end_k = -:p_kilk;
     if (:p_src_id = 1) then end_k = :p_kilk;
    end
   else begin
     if (:p_dst_id = 1) then arrival_k = :p_kilk;
     if (:p_src_id = 1) then charge_k  = :p_kilk;
    end
   begin_k = :end_k + :charge_k - :arrival_k;
   suspend;
  end
end^


ALTER PROCEDURE AOG_NOMEN_VIEW (
    NOMEN_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    BEGIN_K DOUBLE PRECISION,
    ARRIVAL_K DOUBLE PRECISION,
    CHARGE_K DOUBLE PRECISION,
    END_K DOUBLE PRECISION,
    DATE_D DATE,
    CHECK_K DOUBLE PRECISION)
AS
declare variable P_DATE_MAX date;
declare variable P_DOC_DATE date;
declare variable P_SRC_ID integer;
declare variable P_DST_ID integer;
declare variable P_KILK double precision;
declare variable P_TYPE_DOC integer;
begin
  select r.rest from rst r
   where r.nomen_id   = :nomen_id and
         r.objects_id = 1
    into end_k;
  if (:end_k is null) then end_k = 0.000;
  begin_k   = :end_k;
  arrival_k = 0.000;
  charge_k  = 0.000;
  check_k   = 0.000;
  date_d = cast('today' as date);
  suspend;
  end_k = 0.000;
  begin_k   = 0.000;
  arrival_k = 0.000;
  charge_k  = 0.000;
  date_d = :date_in;
  check_k   = 0.000;
  suspend;
  end_k = 0.000;
  begin_k   = 0.000;
  arrival_k = 0.000;
  charge_k  = 0.000;
  check_k   = 0.000;
  date_d = :date_out;
  suspend;
  select max(d.doc_date) from documents d
    into p_date_max;
  if (:p_date_max < 'TODAY') then p_date_max = 'TODAY';
  for select d.doc_date, d.objects_id, d.clients_id, dr.kilk, d.typedoc_id
        from documents d
             left join docrec dr on d.document_id = dr.document_id
       where d.doc_date between :date_in and :p_date_max and
             --((d.objects_id = 1) or (d.clients_id = 1)) and
             dr.nomen_id = :nomen_id
        into p_doc_date, p_src_id, p_dst_id, p_kilk, p_type_doc
  do begin
    end_k     = 0.000;
    begin_k   = 0.000;
    arrival_k = 0.000;
    charge_k  = 0.000;
    check_k   = 0.000;
    if (:p_kilk is null) then p_kilk = 0.000;
    if (:p_doc_date > :date_out) then
    begin
      if (:p_dst_id = 1) then end_k = -:p_kilk;
      if (:p_src_id = 1) then end_k = :p_kilk;
    end
    else begin
      if (:p_type_doc in (2, 11)) then check_k = :p_kilk;
      if (:p_dst_id = 1) then arrival_k = :p_kilk;
      if (:p_src_id = 1) then charge_k = :p_kilk;
    end
    date_d = :p_doc_date;
    begin_k = :end_k + :charge_k - :arrival_k;
    suspend;
  end
end^


ALTER PROCEDURE AUTO_KARD (
    ST INTEGER,
    EN INTEGER)
RETURNS (
    SH_NAM INTEGER)
AS
DECLARE VARIABLE A INTEGER;
begin
a=:st;
FOR select cl.clients_id from clients cl where cl.name = '1'  into :sh_nam
 do begin
  if (:a < :en) then
  begin
   insert into kards(DISCONT_ID, CLIENTS_ID, PIN)
                values(1, :sh_nam, 9999);
    a=:a+1;
   end
 if ((:a=:en) or (:a>:en)) then
   begin
    suspend;
   end
  end
end^


ALTER PROCEDURE AVTO_KLIENT (
    ST INTEGER,
    EN INTEGER)
AS
 BEGIN EXIT; END^


ALTER PROCEDURE CREATE_DOC (
    VDOC_MARK VARCHAR(10),
    VOBJECTS INTEGER,
    VTYPEPAY INTEGER,
    VTYPEDOC INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOCNUM INTEGER;
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
begin
  /* Procedure Text */
  rdocument_id = gen_id(gen_documents_id, 1);
  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :puser_nik, :pdocnum;

  if (:puser_nik is null) then
  begin
    puser_nik = 'Sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :pdocnum;
  end
  if (:puser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :pdocnum + 1
    where upper(u.user_login) = user;
  end

  rdoc_num = gendocnum(:puser_nik, :pdocnum);

  insert into documents(document_id, doc_num, doc_mark, typedoc_id, objects_id,
     doc_lock, user_name, blok)
     values (:rdocument_id, :rdoc_num, :vdoc_mark, :vtypedoc, :vobjects,
     0, user, 1);

  suspend;
end^


ALTER PROCEDURE DROP_P_REYESTR_POD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RDOCUMENT_NUM VARCHAR(14),
    RCLIENT VARCHAR(40),
    RSUM_OUT_PDV DOUBLE PRECISION,
    RKILK_NAKL INTEGER,
    RSUM_OUT DOUBLE PRECISION,
    DATE_S DATE,
    DATE_E DATE,
    S_SKLAD VARCHAR(50),
    DOC_DATE DATE,
    IPN VARCHAR(20),
    NUM INTEGER)
AS
DECLARE VARIABLE PDOCUMENT_ID INTEGER;
begin

/*  SELECT C.ROUND_SUM
   FROM CONFIGS C
   WHERE C.USERS=USER
   INTO :P_DIG_PRICE;         */

  for select dd.document_id, dd.doc_num, dd.doc_date, c.name, c.ipn
   from documents dd, clients c
    where dd.objects_id = :vsklad_id and
          dd.doc_date between :vdate1 and :vdate2 and
          dd.clients_id = c.clients_id order by dd.doc_date
  into :pdocument_id, :rdocument_num, :doc_date, :rclient, :ipn
  do begin
    select count(rr.document_id) from reestr rr
        where rr.document_id = :pdocument_id
      into :rkilk_nakl;
    if ((:rkilk_nakl <> 0) and (:rkilk_nakl is not null)) then
    begin
      select sum(sum_out_pdv), sum(sum_out) from s_docrec_view(:pdocument_id)
        into :rsum_out_pdv, :rsum_out;
            select c.name from clients c where c.clients_id = :VSKLAD_ID into :s_sklad;
            select max(re.reestr_id) from reestr re where re.document_id=:pdocument_id into :num;
    DATE_S = VDATE1;
    DATE_E = VDATE2;
    /*  rsum_out_pdv = aroundin(rsum_out_pdv,:P_DIG_PRICE);
      rsum_out = aroundin(rsum_out,:p_dig_price);  */
      suspend;
    end
  end
end^


ALTER PROCEDURE DROP_S_DOCREC_VIEW_NAKL (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION)
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable p_disc_persent double precision;
declare variable p_typedoc_id integer;
declare variable p_maker_id integer;
declare variable p_tara_id integer;
declare variable p_objects_id integer;
declare variable p_ispdv integer;
declare variable p_nomen_pdv integer;
declare variable p_in_sum double precision;
declare variable p_in_sum_vat double precision;
declare variable typ_pdv integer;
BEGIN /*$$IBE$$    !!!!!!!УЖЕ НЕ ВИКОРИСТОВУЄТЬСЯ!!!!!!!
 SELECT D.DISC_PERSENT, D.TYPEDOC_ID, D.OBJECTS_ID
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOCUMENT_ID
  INTO :P_DISC_PERSENT, :P_TYPEDOC_ID, :P_OBJECTS_ID;

 FOR SELECT DR.DOCREC_ID, DR.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, n.typepdv_id, DR.PRICE, DR.KILK, TP.TYPEPDV_ID, TP.PDV,
            '('||CAST(CAST(DR.TYPEPDV_PDV*100 AS INTEGER) AS VARCHAR(5))||'%) '||TP.TYPEPDV_NAME, 1.00,
            S.SI_NAME, DR.TYPEPDV_ID, DR.TYPEPDV_PDV, N.IS_WEIGHT, 1, 0, N.OUT_PRICE,
            DR.DISC_PERSENT, N.TYPEPDV_ID, DR.INSUM_PDV, DR.INSUM
      FROM DOCREC DR,
           NOMEN N,
           TYPEPDV TP,
           SI S
      WHERE DR.DOCUMENT_ID=:DOCUMENT_ID AND
            DR.NOMEN_ID=N.NOMEN_ID AND
            TP.TYPEPDV_ID=DR.TYPEPDV_ID AND
            S.SI_ID=N.SI_ID
      order by DR.DOCREC_ID
      INTO :DOCREC_ID, :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME, :typ_pdv, :GENERAL_PRICE, :KILK,
           :P_TYPEPDV_ID, :P_TYPEPDV_PDV, :TYPE_PDV, :IN_PACK,
           :SI_NAME, :TYPEPDV_ID, :TYPEPDV_PDV, :IS_WEIGHT, :P_TARA_ID, :P_MAKER_ID, :NOMEN_PRICE,
           :DISC_PERSENT, :P_NOMEN_PDV, :P_IN_SUM_VAT, :P_IN_SUM
 DO BEGIN
  P_SUM_IN=:P_IN_SUM_VAT;
  SUM_PDV=0.000;
  SUM_OUT=0.000;
  OUT_PRICE=0.000;
  EXTRA_SUM=0.000;
  EXTRA_P=0.000;
  MAKER_NAME=NULL;
  P_IN_SUM_VAT=ABSRIZN(0, :P_IN_SUM_VAT);
  P_IN_SUM=ABSRIZN(0, :P_IN_SUM);

  IF (DISC_PERSENT IS NULL) THEN BEGIN
    DISC_PERSENT=:P_DISC_PERSENT;
   END

  OUT_PRICE_PDV=CALCPRICEPDV(:GENERAL_PRICE, :P_DISC_PERSENT, :DISC_PERSENT, 0);

  SUM_OUT_PDV=:OUT_PRICE_PDV*:KILK;

  IF (KILK<>0) THEN BEGIN
   P_IN_PRICE=:P_IN_SUM/:KILK;
   EXTRA_SUM=:SUM_OUT_PDV-:P_IN_SUM_VAT;

   SUM_OUT=CALCSUM(:SUM_OUT_PDV, :EXTRA_SUM, :P_TYPEPDV_PDV, :P_TYPEPDV_ID, 0);

   EXTRA_SUM=:SUM_OUT-:P_IN_SUM;
   IF (:P_SUM_IN<>0.000) THEN EXTRA_P=(:SUM_OUT*100/:P_IN_SUM)-100;

   OUT_PRICE=:SUM_OUT/:KILK;

  IF (:P_TYPEDOC_ID=1) THEN BEGIN
   SELECT C.ISPDV
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:P_OBJECTS_ID
    INTO :P_ISPDV;
   IF ((:P_ISPDV=0) AND (:P_NOMEN_PDV=3)) THEN BEGIN
      EXTRA_SUM=(:KILK*:NOMEN_PRICE) - (:SUM_OUT_PDV*1.2);
      EXTRA_P=(((:KILK*:NOMEN_PRICE)*100)/(:SUM_OUT_PDV*1.2))-100;
     END
    ELSE BEGIN
      EXTRA_SUM=(:KILK*:NOMEN_PRICE) - :SUM_OUT_PDV;
      EXTRA_P=(((:KILK*:NOMEN_PRICE)*100)/:SUM_OUT_PDV)-100;
     END
  END

  SUM_PDV=:SUM_OUT_PDV-:SUM_OUT;

  END  $$IBE$$*/ /* IF (KILK<>0) THEN */ /*$$IBE$$ 
  ELSE BEGIN
   OUT_PRICE=NULL;
   SUM_OUT=NULL;
   TYPE_PDV=NULL;
   SUM_PDV=NULL;
   SUM_OUT_PDV=NULL;
   EXTRA_SUM=NULL;
   EXTRA_P=NULL;
  END  $$IBE$$*/ /* IF (KILK<>0) ELSE */ /*$$IBE$$ 
  DISC_PERSENT=:DISC_PERSENT*100;

SUMTOV_PDV = null;
  if (:typ_pdv = 1) then
   begin
   SUMTOV_PDV =:sum_out;
   sum_out = null;
   end
   typ_pdv = -1;

  SUSPEND;
 END
 $$IBE$$*/ EXIT;
END^


ALTER PROCEDURE DROP_S_ROLLTAXDOCS (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPESPAY VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_DATE DATE,
    TAX_DATE DATE,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    OPLATA_TYPE VARCHAR(30),
    DST_NAME VARCHAR(50),
    SUM_OUT DOUBLE PRECISION,
    SUM_VAT DOUBLE PRECISION,
    SUM_OUT_VAT DOUBLE PRECISION)
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_DST_ID INTEGER;
BEGIN
  /* Procedure Text */
 FOR SELECT D.DOCUMENT_ID, D.DOC_DATE, RR.DATA, D.DOC_NUM, D.DOC_MARK,
            D.DISC_PERSENT, D.CLIENTS_ID, TP.TYPEPAY_NAME
      FROM DOCUMENTS D,
           TYPEPAY TP,
           REESTR RR
      WHERE D.OBJECTS_ID=:OBJECTS_ID AND
            D.DOC_DATE BETWEEN :DATE_IN AND :DATE_OUT AND
            ISINLISTSTR(:TYPESPAY, D.OPLATA_TYPE)=1 AND
            TP.TYPEPAY_ID=D.OPLATA_TYPE AND
            RR.DOCUMENT_ID=D.DOCUMENT_ID
      INTO :DOCUMENT_ID, :DOC_DATE, :TAX_DATE, :DOC_NUM, :DOC_MARK,
           :P_DISC_PERSENT, :P_DST_ID, :OPLATA_TYPE
 DO BEGIN
  SELECT C.NAME
   FROM CLIENTS C
   WHERE C.CLIENTS_ID=:P_DST_ID
   INTO :DST_NAME;
  SELECT DS.SUM_OUT, DS.SUM_OUT_PDV
   FROM S_DOCREC_SUM(:DOCUMENT_ID, :P_DISC_PERSENT) DS
   INTO :SUM_OUT, :SUM_OUT_VAT;
  IF (:SUM_OUT IS NULL) THEN SUM_OUT=0.000;
  IF (:SUM_OUT_VAT IS NULL) THEN SUM_OUT_VAT=0.000;
  SUM_VAT=:SUM_OUT_VAT-:SUM_OUT;
  SUSPEND;
 END
END^


ALTER PROCEDURE E1C_CREDDOCS (
    IS_DOCS INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    IS_DOC INTEGER,
    DOC_NUM VARCHAR(14))
RETURNS (
    DOCDATE DATE,
    PARTNER VARCHAR(50),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(50),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    BANKNAME VARCHAR(40),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY INTEGER,
    SUMWITHVAT DOUBLE PRECISION,
    SUMVAT DOUBLE PRECISION,
    SUMDOC DOUBLE PRECISION,
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCID INTEGER,
    ISTAX INTEGER,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUM_VAT DOUBLE PRECISION,
    TAXSUMVAT DOUBLE PRECISION,
    TAXSUM DOUBLE PRECISION,
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER)
AS
DECLARE VARIABLE P_CLIENT_ID INTEGER;
DECLARE VARIABLE P_ACCOUNT_ID INTEGER;
DECLARE VARIABLE P_REESTR_ID INTEGER;
DECLARE VARIABLE P_L_DOCDATE DATE;
DECLARE VARIABLE P_L_PARTNER VARCHAR(50);
DECLARE VARIABLE P_L_SUMWITHVAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_SUMVAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_SUMDOC DOUBLE PRECISION;
DECLARE VARIABLE P_L_DOCNUM VARCHAR(14);
DECLARE VARIABLE P_L_DOCMARCK VARCHAR(14);
DECLARE VARIABLE P_L_ISTAX INTEGER;
DECLARE VARIABLE P_L_TAXNUM VARCHAR(20);
DECLARE VARIABLE P_L_TAXDATE DATE;
DECLARE VARIABLE P_L_TAXSUM_VAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_TAXSUMVAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_TAXSUM INTEGER;
begin
  if (:is_docs = 1) then
  begin
    for select d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv,
               sum(dr.insum_pdv), sum(dr.insum)
         from documents d
              left join docrec dr on d.document_id = dr.document_id
              left join clients c on d.objects_id = c.clients_id
         where d.doc_date between :date_in and :date_out and
               d.typedoc_id = 1 and
               d.doc_lock in (1, 2)
         group by d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id,
                  c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv
         into :docid, :docdate, :docnum, :docmarck, :p_client_id,
              :partner, :partcode, :address, :taxpayern, :singletaxn, :istaxpay,
              :sumwithvat, :sumdoc
    do begin
      if (:sumwithvat is null) then sumwithvat = 0.000;
      if (:sumdoc is null) then sumdoc = 0.000;
      sumvat = :sumwithvat - :sumdoc;
      select min(ca.account_id)
       from clientaccount ca
       where ca.clients_id = :p_client_id
       into :p_account_id;
      if (not (:p_account_id is null)) then
      begin
        select b.name, b.mfo, ca.account_num
         from clientaccount ca left join banks b on ca.banks_id = b.banks_id
         where ca.account_id = :p_account_id
         into :bankname, :banknum, :payaccount;
      end
      else begin
        bankname = '';
        banknum = '';
        payaccount = '';
      end
      istax = 0;
      taxnum = null;
      taxdate = null;
      taxsum_vat = 0.000;
      taxsumvat = 0.000;
      taxsum = 0.000;
      select max(r.ROLL_TAX_ID)
       from T_ROLL_TAX r
       where r.document_id = :docid and
             r.td_type = 1
       into :p_reestr_id;
      if (:p_reestr_id is null) then p_reestr_id = 0;
      if (:p_reestr_id > 0) then istax = 1;
      select r.td_number, r.td_date, r.td_sum, r.td_sum_vat, r.td_sum_with_vat
       from T_ROLL_TAX r
       where r.ROLL_TAX_ID = :p_reestr_id
       into :taxnum, :taxdate, :taxsum,  :taxsumvat, :taxsum_vat;
      p_l_docdate = null;
      select lcd.doc_date, lcd.partner, lcd.doc_sum_with_vat, lcd.doc_sum_vat,
             lcd.doc_sum, lcd.doc_num, lcd.doc_marck, lcd.is_tax, lcd.tax_date,
             lcd.tax_num, lcd.tax_sum, lcd.tax_sum_vat, lcd.tax_sum_with_vat
       from e1c_log_creddocs lcd
       where lcd.document_id = :docid
       into :p_l_docdate, :p_l_partner, :p_l_sumwithvat, :p_l_sumvat,
            :p_l_sumdoc, :p_l_docnum, :p_l_docmarck, :p_l_istax, :p_l_taxdate,
            :p_l_taxnum, :p_l_taxsum, :p_l_taxsumvat, :p_l_taxsum_vat;
      isedit1 = 0;
      isedit2 = 0;
      if (not (:p_l_docdate is null)) then begin
       isedit1 = 1;
       isedit2 = 1;
       if (:p_l_docdate <> :docdate) then isedit1 = 2;
/*       if (:p_l_partner <> :partner) then isedit1 = 2;*/
       if (around(:p_l_sumwithvat) <> around(:sumwithvat)) then isedit1 = 2;
       if (around(:p_l_sumvat) <> around(:sumvat)) then isedit1 = 2;
       if (around(:p_l_sumdoc) <> around(:sumdoc)) then isedit1 = 2;
       if (:p_l_docnum <> :docnum) then isedit1 = 2;
       if (:p_l_docmarck <> :docmarck) then isedit1 = 2;
       if (:p_l_istax <> :istax) then isedit2 = 2;
       if (:p_l_taxdate <> :taxdate) then isedit2 = 2;
       if (:p_l_taxnum <> :taxnum) then isedit2 = 2;
       if (around(:p_l_taxsum) <> around(:taxsum)) then isedit2 = 2;
       if (around(:p_l_taxsum_vat) <> around(:taxsum_vat)) then isedit2 = 2;
       if (around(:p_l_taxsumvat) <> around(:taxsumvat)) then isedit2 = 2;
      end
      suspend;
    end
  end
  if (:is_doc = 1) then
  begin
    for select d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv,
               sum(dr.insum_pdv), sum(dr.insum)
         from documents d
              left join docrec dr on d.document_id = dr.document_id
              left join clients c on d.objects_id = c.clients_id
         where d.doc_num = :doc_num and
               d.typedoc_id = 1 and
               d.doc_lock in (1, 2)
         group by d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id,
                  c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv
         into :docid, :docdate, :docnum, :docmarck, :p_client_id,
              :partner, :partcode, :address, :taxpayern, :singletaxn, :istaxpay,
              :sumwithvat, :sumdoc
    do begin
      if (:sumwithvat is null) then sumwithvat = 0.000;
      if (:sumdoc is null) then sumdoc = 0.000;
      sumvat = :sumwithvat - :sumdoc;
      select min(ca.account_id)
       from clientaccount ca
       where ca.clients_id = :p_client_id
       into :p_account_id;
      if (not (:p_account_id is null)) then
      begin
        select b.name, b.mfo, ca.account_num
         from clientaccount ca left join banks b on ca.banks_id = b.banks_id
         where ca.account_id = :p_account_id
         into :bankname, :banknum, :payaccount;
      end
      else begin
        bankname = '';
        banknum = '';
        payaccount = '';
      end
      istax = 0;
      taxnum = null;
      taxdate = null;
      taxsum_vat = 0.000;
      taxsumvat = 0.000;
      taxsum = 0.000;
      isedit1 = 0;
      isedit2 = 0;
      select max(r.ROLL_TAX_ID)
       from T_ROLL_TAX r
       where r.document_id = :docid and
             r.td_type = 1
       into :p_reestr_id;
      if (:p_reestr_id is null) then p_reestr_id = 0;
      if (:p_reestr_id > 0) then istax = 1;
      select r.td_number, r.td_date, r.td_sum, r.td_sum_vat, r.td_sum_with_vat
       from T_ROLL_TAX r
       where r.ROLL_TAX_ID = :p_reestr_id
       into :taxnum, :taxdate, :taxsum,  :taxsumvat, :taxsum_vat;
      p_l_docdate = null;
      select lcd.doc_date, lcd.partner, lcd.doc_sum_with_vat, lcd.doc_sum_vat,
             lcd.doc_sum, lcd.doc_num, lcd.doc_marck, lcd.is_tax, lcd.tax_date,
             lcd.tax_num, lcd.tax_sum, lcd.tax_sum_vat, lcd.tax_sum_with_vat
       from e1c_log_creddocs lcd
       where lcd.document_id = :docid
       into :p_l_docdate, :p_l_partner, :p_l_sumwithvat, :p_l_sumvat,
            :p_l_sumdoc, :p_l_docnum, :p_l_docmarck, :p_l_istax, :p_l_taxdate,
            :p_l_taxnum, :p_l_taxsum, :p_l_taxsumvat, :p_l_taxsum_vat;
      isedit1 = 0;
      isedit2 = 0;
      if (not (:p_l_docdate is null)) then begin
       isedit1 = 1;
       isedit2 = 1;
       if (:p_l_docdate <> :docdate) then isedit1 = 2;
/*       if (:p_l_partner <> :partner) then isedit1 = 2;*/
       if (around(:p_l_sumwithvat) <> around(:sumwithvat)) then isedit1 = 2;
       if (around(:p_l_sumvat) <> around(:sumvat)) then isedit1 = 2;
       if (around(:p_l_sumdoc) <> around(:sumdoc)) then isedit1 = 2;
       if (:p_l_docnum <> :docnum) then isedit1 = 2;
       if (:p_l_docmarck <> :docmarck) then isedit1 = 2;
       if (:p_l_istax <> :istax) then isedit2 = 2;
       if (:p_l_taxdate <> :taxdate) then isedit2 = 2;
       if (:p_l_taxnum <> :taxnum) then isedit2 = 2;
       if (around(:p_l_taxsum) <> around(:taxsum)) then isedit2 = 2;
       if (around(:p_l_taxsum_vat) <> around(:taxsum_vat)) then isedit2 = 2;
       if (around(:p_l_taxsumvat) <> around(:taxsumvat)) then isedit2 = 2;
      end
      suspend;
    end
  end
end^


ALTER PROCEDURE E1C_DEBDOCS (
    IS_DOCS INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    IS_DOC INTEGER,
    DOC_NUM VARCHAR(14))
RETURNS (
    DOCDATE DATE,
    PARTNER VARCHAR(50),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(50),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    BANKNAME VARCHAR(40),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY INTEGER,
    SUMIN DOUBLE PRECISION,
    SUMWITHVAT DOUBLE PRECISION,
    SUMVAT DOUBLE PRECISION,
    SUMDOC DOUBLE PRECISION,
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCID INTEGER,
    ISTAX INTEGER,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUM_VAT DOUBLE PRECISION,
    TAXSUMVAT DOUBLE PRECISION,
    TAXSUM INTEGER,
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TYPEVAT INTEGER,
    TYPEDOC_ID INTEGER)
AS
declare variable p_client_id integer;
declare variable p_account_id integer;
declare variable p_insum double precision;
declare variable p_typevat_vat double precision;
declare variable p_reestr_count integer;
declare variable p_reestr_id integer;
declare variable p_l_docdate date;
declare variable p_l_partner varchar(50);
declare variable p_l_sumin double precision;
declare variable p_l_sumwithvat double precision;
declare variable p_l_sumvat double precision;
declare variable p_l_sumdoc double precision;
declare variable p_l_docnum varchar(14);
declare variable p_l_docmarck varchar(14);
declare variable p_l_istax integer;
declare variable p_l_taxnum varchar(20);
declare variable p_l_taxdate date;
declare variable p_l_taxsum_vat double precision;
declare variable p_l_taxsumvat double precision;
declare variable p_l_taxsum integer;
begin
  if (:is_docs = 1) then
  begin
    for select d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id, d.typedoc_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv, dr.typepdv_id, dr.typepdv_pdv,
               sum(gs.osum_pdv), sum(dr.insum_pdv), sum(dr.insum)
          from documents d
               left join docrec dr on d.document_id = dr.document_id
               left join clients c on d.clients_id = c.clients_id,
               ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
         where d.doc_date between :date_in and :date_out and
               d.typedoc_id in (2, 17) and
               d.doc_lock in (1, 2)
      group by d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id, d.typedoc_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv, dr.typepdv_id, dr.typepdv_pdv
          into docid, docdate, docnum, docmarck, p_client_id, typedoc_id,
               partner, partcode, address, taxpayern, singletaxn, istaxpay, typevat, p_typevat_vat,
               sumwithvat, p_insum, sumin
    do begin
      if (:typedoc_id is null) then typedoc_id = 0;
      if (:typedoc_id = 2) then typedoc_id = 1;
      if (:typedoc_id = 17) then typedoc_id = 2;
      if (:sumwithvat is null) then sumwithvat = 0.000;
      if (:p_insum is null) then p_insum = 0.000;
      sumdoc = calcsum(:sumwithvat, :sumwithvat - :p_insum, :p_typevat_vat, :typevat, 6);
      sumvat = :sumwithvat - :sumdoc;
      select min(ca.account_id)
       from clientaccount ca
       where ca.clients_id = :p_client_id
       into :p_account_id;
      if (not (:p_account_id is null)) then
      begin
        select b.name, b.mfo, ca.account_num
         from clientaccount ca left join banks b on ca.banks_id = b.banks_id
         where ca.account_id = :p_account_id
         into :bankname, :banknum, :payaccount;
      end
      else begin
        bankname = '';
        banknum = '';
        payaccount = '';
      end
      p_reestr_count = 0;
      select count(r.roll_tax_id)
       from t_ROLL_TAX r
       where r.document_id = :docid and
             r.td_type = 2
       into :p_reestr_count;
      if (:p_reestr_count is null) then p_reestr_count = 0;
      if (:p_reestr_count > 0) then begin
        istax = 1;
        select max(r.roll_tax_id)
         from t_ROLL_TAX r
         where r.document_id = :docid and
               r.td_type = 2
         into :p_reestr_id;
        select r.data
         from t_ROLL_TAX r
         where r.roll_tax_id = :p_reestr_id
         into :taxdate;
        taxnum = cast(:p_reestr_id as varchar(20));
        taxsum_vat = :sumwithvat;
        taxsumvat = :sumvat;
        taxsum = :sumdoc;
      end
      else begin
        istax = 0;
        taxnum = null;
        taxdate = null;
        taxsum_vat = 0.000;
        taxsumvat = 0.000;
        taxsum = 0.000;
      end
      p_l_docdate = null;
      select lcd.doc_date, lcd.partner, lcd.doc_sum_with_vat, lcd.doc_sum_vat,
             lcd.doc_sum, lcd.doc_num, lcd.doc_marck, lcd.is_tax, lcd.tax_date,
             lcd.tax_num, lcd.tax_sum, lcd.tax_sum_vat, lcd.tax_sum_with_vat,
             lcd.doc_sum_in
        from e1c_log_debdocs lcd
       where lcd.document_id = :docid and
             lcd.typevat_id = :typevat
        into p_l_docdate, p_l_partner, p_l_sumwithvat, p_l_sumvat,
             p_l_sumdoc, p_l_docnum, p_l_docmarck, p_l_istax, p_l_taxdate,
             p_l_taxnum, p_l_taxsum, p_l_taxsumvat, p_l_taxsum_vat,
             p_l_sumin;
      isedit1 = 0;
      isedit2 = 0;
      if (not (:p_l_docdate is null)) then begin
       isedit1 = 1;
       isedit2 = 1;
       if (:p_l_docdate <> :docdate) then isedit1 = 2;
/*       if (:p_l_partner <> :partner) then isedit1 = 2;*/
       if (around(:p_l_sumwithvat) <> around(:sumwithvat)) then isedit1 = 2;
       if (around(:p_l_sumvat) <> around(:sumvat)) then isedit1 = 2;
       if (around(:p_l_sumdoc) <> around(:sumdoc)) then isedit1 = 2;
       if (around(:p_l_sumin) <> around(:sumin)) then isedit1 = 2;
       if (:p_l_docnum <> :docnum) then isedit1 = 2;
       if (:p_l_docmarck <> :docmarck) then isedit1 = 2;
       if (:p_l_istax <> :istax) then isedit2 = 2;
       if (:p_l_taxdate <> :taxdate) then isedit2 = 2;
       if (:p_l_taxnum <> :taxnum) then isedit2 = 2;
       if (around(:p_l_taxsum) <> around(:taxsum)) then isedit2 = 2;
       if (around(:p_l_taxsum_vat) <> around(:taxsum_vat)) then isedit2 = 2;
       if (around(:p_l_taxsumvat) <> around(:taxsumvat)) then isedit2 = 2;
      end
      suspend;
    end
  end
  if (:is_doc = 1) then
  begin
    for select d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id, d.typedoc_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv, dr.typepdv_id, dr.typepdv_pdv,
               sum(gs.osum_pdv), sum(dr.insum_pdv), sum(dr.insum)
          from documents d
               left join docrec dr on d.document_id = dr.document_id
               left join clients c on d.clients_id = c.clients_id,
               ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
         where d.doc_num = :doc_num and
               d.typedoc_id in (2, 17) and
               d.doc_lock in (1, 2)
      group by d.document_id, d.doc_date, d.doc_num, d.doc_mark, c.clients_id, d.typedoc_id,
               c.name, c.zkpo, c.adress, c.numpdv, c.ipn, c.ispdv, dr.typepdv_id, dr.typepdv_pdv
          into docid, docdate, docnum, docmarck, p_client_id, typedoc_id,
               partner, partcode, address, taxpayern, singletaxn, istaxpay, typevat, p_typevat_vat,
               sumwithvat, p_insum, sumin
    do begin
      if (:typedoc_id is null) then typedoc_id = 0;
      if (:typedoc_id = 2) then typedoc_id = 1;
      if (:typedoc_id = 17) then typedoc_id = 2;
      if (:sumwithvat is null) then sumwithvat = 0.000;
      if (:p_insum is null) then p_insum = 0.000;
      sumdoc = calcsum(:sumwithvat, :sumwithvat - :p_insum, :p_typevat_vat, :typevat, 6);
      sumvat = :sumwithvat - :sumdoc;
      select min(ca.account_id)
       from clientaccount ca
       where ca.clients_id = :p_client_id
       into :p_account_id;
      if (not (:p_account_id is null)) then
      begin
        select b.name, b.mfo, ca.account_num
         from clientaccount ca left join banks b on ca.banks_id = b.banks_id
         where ca.account_id = :p_account_id
         into :bankname, :banknum, :payaccount;
      end
      else begin
        bankname = '';
        banknum = '';
        payaccount = '';
      end
      p_reestr_count = 0;
      select count(r.roll_tax_id)
       from t_ROLL_TAX r
       where r.document_id = :docid and
             r.td_type = 2
       into :p_reestr_count;
      if (:p_reestr_count is null) then p_reestr_count = 0;
      if (:p_reestr_count > 0) then begin
        istax = 1;
        select max(r.roll_tax_id)
         from t_ROLL_TAX r
         where r.document_id = :docid and
               r.td_type = 2
         into :p_reestr_id;
        select r.data
         from t_ROLL_TAX r
         where r.ROLL_TAX_id = :p_reestr_id
         into :taxdate;
        taxnum = cast(:p_reestr_id as varchar(20));
        taxsum_vat = :sumwithvat;
        taxsumvat = :sumvat;
        taxsum = :sumdoc;
      end
      else begin
        istax = 0;
        taxnum = null;
        taxdate = null;
        taxsum_vat = 0.000;
        taxsumvat = 0.000;
        taxsum = 0.000;
      end
      p_l_docdate = null;
      select lcd.doc_date, lcd.partner, lcd.doc_sum_with_vat, lcd.doc_sum_vat,
             lcd.doc_sum, lcd.doc_num, lcd.doc_marck, lcd.is_tax, lcd.tax_date,
             lcd.tax_num, lcd.tax_sum, lcd.tax_sum_vat, lcd.tax_sum_with_vat,
             lcd.doc_sum_in
        from e1c_log_debdocs lcd
       where lcd.document_id = :docid and
             lcd.typevat_id = :typevat
        into p_l_docdate, p_l_partner, p_l_sumwithvat, p_l_sumvat,
             p_l_sumdoc, p_l_docnum, p_l_docmarck, p_l_istax, p_l_taxdate,
             p_l_taxnum, p_l_taxsum, p_l_taxsumvat, p_l_taxsum_vat,
             p_l_sumin;
      isedit1 = 0;
      isedit2 = 0;
      if (not (:p_l_docdate is null)) then begin
       isedit1 = 1;
       isedit2 = 1;
       if (:p_l_docdate <> :docdate) then isedit1 = 2;
/*       if (:p_l_partner <> :partner) then isedit1 = 2;*/
       if (around(:p_l_sumwithvat) <> around(:sumwithvat)) then isedit1 = 2;
       if (around(:p_l_sumvat) <> around(:sumvat))  then isedit1 = 2;
       if (around(:p_l_sumdoc) <> around(:sumdoc))  then isedit1 = 2;
       if (around(:p_l_sumin) <> around(:sumin))    then isedit1 = 2;
       if (:p_l_docnum <> :docnum)      then isedit1 = 2;
       if (:p_l_docmarck <> :docmarck)  then isedit1 = 2;
       if (:p_l_istax <> :istax)        then isedit2 = 2;
       if (:p_l_taxdate <> :taxdate)    then isedit2 = 2;
       if (:p_l_taxnum <> :taxnum)      then isedit2 = 2;
       if (around(:p_l_taxsum) <> around(:taxsum))          then isedit2 = 2;
       if (around(:p_l_taxsum_vat) <> around(:taxsum_vat))  then isedit2 = 2;
       if (around(:p_l_taxsumvat) <> around(:taxsumvat))    then isedit2 = 2;
      end
      suspend;
    end
  end
end^


ALTER PROCEDURE E1C_DRAFTS (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    KASS_NUM VARCHAR(12),
    DOCDATE DATE,
    SUMOUT_VAT DOUBLE PRECISION,
    SUMOUTVAT DOUBLE PRECISION,
    SUMOUT DOUBLE PRECISION,
    SUMIN DOUBLE PRECISION,
    TYPEVAT INTEGER,
    ISEDIT INTEGER,
    TYPEPAY SMALLINT)
AS
DECLARE VARIABLE P_L_DOCDATE DATE;
DECLARE VARIABLE P_L_SUMOUT_VAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_SUMOUTVAT DOUBLE PRECISION;
DECLARE VARIABLE P_L_SUMOUT DOUBLE PRECISION;
DECLARE VARIABLE P_L_SUMIN DOUBLE PRECISION;
begin
  for select d.typepay, d.kass_num, d.docdate, d.typevat, sum(d.sumout_vat), sum(d.sumoutvat),
             sum(d.sumout), sum(d.sumin)
       from e1c_drafts_detail(:date_in, :date_out) d
       group by d.typepay, d.kass_num, d.docdate, d.typevat
       into :typepay, :kass_num, :docdate, :typevat, :sumout_vat, :sumoutvat,
            :sumout, :sumin
  do begin
/*    if (:typevat in (2, 3)) then typevat = 0;*/
/*    if (:typevat = 1) then typevat = 1;      */
    isedit = 0;
    p_l_docdate = null;
    select ld.docdate, ld.docs_sum_with_vat, ld.docs_sum_vat, ld.docs_sum,
           ld.docs_sumin
     from e1c_log_drafts ld
     where ld.docdate = :docdate and
           ld.typevat = :typevat and
           ld.kass_num = :kass_num and
           ld.typepay = :typepay
     into :p_l_docdate, :p_l_sumout_vat, :p_l_sumoutvat, :p_l_sumout,
          :p_l_sumin;
    if (not (:p_l_docdate is null)) then begin
     isedit = 1;
     if (around(:p_l_sumin)  <> around(:sumin)) then isedit = 2;
     if (around(:p_l_sumout) <> around(:sumout)) then isedit = 2;
     if (around(:p_l_sumout_vat) <> around(:sumout_vat)) then isedit = 2;
     if (around(:p_l_sumoutvat) <> around(:sumoutvat)) then isedit = 2;
    end
    suspend;
  end
end^


ALTER PROCEDURE E1C_DRAFTS_DETAIL (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    KASS_NUM VARCHAR(12),
    DOCDATE DATE,
    SUMOUT_VAT DOUBLE PRECISION,
    SUMOUTVAT DOUBLE PRECISION,
    SUMOUT DOUBLE PRECISION,
    SUMIN DOUBLE PRECISION,
    TYPEVAT INTEGER,
    TYPEPAY SMALLINT)
AS
declare variable p_disc_persent double precision;
declare variable p_typevat_vat double precision;
declare variable p_price double precision;
declare variable p_kilk double precision;
declare variable p_suminpdv double precision;
declare variable pdocrec_id integer;
begin
  sumout_vat = 0.000;
  sumoutvat = 0.000;
  sumout = 0.000;
  sumin = 0.000;
  for select d.oplata_type, d.user_name, d.doc_date, dr.typepdv_id, dr.typepdv_pdv, d.disc_persent,
             around(dr.price), around3(dr.kilk), dr.insum, dr.insum_pdv, dr.docrec_id
        from documents d 
             left join docrec dr on (d.document_id = dr.document_id)
       where d.doc_date between :date_in and :date_out and
             d.typedoc_id = 11 and
             d.doc_lock in (1, 2)
        into typepay, kass_num, docdate, typevat, p_typevat_vat, p_disc_persent,
             p_price, p_kilk, sumin, p_suminpdv, pdocrec_id
  do begin
   if (:p_disc_persent is null) then p_disc_persent = 0.000;
   if (:sumin is null) then sumin = 0.000;
   if (:p_suminpdv is null) then p_suminpdv = 0.000;
   select around(gs.osum_pdv) from ps_get_sum(:pdocrec_id, :p_disc_persent, 0.0) gs
     into sumout_vat;
   sumout = calcsum(:sumout_vat, (:sumout_vat - :p_suminpdv), :p_typevat_vat, :typevat, 6);
   sumoutvat = :sumout_vat - :sumout;
   if (:typevat in (2, 3)) then typevat = 0;
   if (:typevat = 1) then typevat = 1;
   suspend;
  end
end^


ALTER PROCEDURE E1C_INIT_LD_ID
AS
DECLARE VARIABLE DOCDATE DATE;
DECLARE VARIABLE TYPEVAT INTEGER;
begin
 for select ld.docdate, ld.typevat
      from e1c_log_drafts ld
      order by ld.docdate, ld.typevat
      into :docdate, :typevat
 do begin
  update e1c_log_drafts ld1
   set ld1.e1c_log_drafts_id = gen_id(gen_e1c_log_drafts_id, 1)
   where ld1.docdate = :docdate and
         ld1.typevat = :typevat;
 end
end^


ALTER PROCEDURE GET_USER_ID (
    I_USER_NAME VARCHAR(12))
RETURNS (
    O_USER_ID INTEGER)
AS
begin
  select u.user_id from t_users u where u.user_login = :i_user_name into :o_user_id;
  suspend;
end^


ALTER PROCEDURE HAS_USER_RIGHT (
    I_USER_ID INTEGER,
    I_RIGHT_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
begin
  o_result = 0;
/*  if (exists(select rgi.rg_int_id from users u, groups g, rights_groups_int rgi
             where u.user_id = :i_user_id and u.group_id = g.group_id and
                   g.group_id = rgi.group_id and
                   rgi.right_id = :i_right_id))
  then
  begin */
    o_result = 1;
/*  end */
  suspend;
end^


ALTER PROCEDURE KAS_BAK_FOR_DATEX (
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VDOC_NUM VARCHAR(14))
RETURNS (
    RTYPEPDV INTEGER,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(40))
AS
DECLARE VARIABLE PDOC_ID INTEGER;
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PINPRICE DOUBLE PRECISION;
DECLARE VARIABLE PDOCREC_ID INTEGER;
DECLARE VARIABLE PTYPEPDV_ID INTEGER;
DECLARE VARIABLE PTYPEPDV_PDV DOUBLE PRECISION;
begin
  /* Procedure Text */
  pobject_id = object();

  rmoney = around(:vkilk * :vprice);
  select rdocument_id from kas_create_bak(:vdoc_num)
    into :PDOC_ID;
  select n.typepdv_id, tp.pdv from nomen n, typepdv tp
      where n.nomen_id = :vnomen_id and
            n.typepdv_id = tp.typepdv_id
    into :ptypepdv_id, :ptypepdv_pdv;

  pdocrec_id = GEN_ID(GEN_DOCREC_ID,1);
  insert into DOCREC (DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE, typepdv_id, typepdv_pdv)
      values(:pdocrec_id, :PDOC_ID, :VNOMEN_ID, :VKILK, :VPRICE, :ptypepdv_id, :ptypepdv_pdv);

  select g.goods_id, g.goods_inprice from goods g
      where g.nomen_id = :vnomen_id and
            g.clients_id = 100 and
            g.objects_id = :pobject_id and
            around(g.goods_inprice) = around(:vprice)
    into :pgoods_id, :pinprice;
  if (:pgoods_id is null) then
  begin
    pgoods_id = gen_id(gen_goods_id, 1);
    insert into goods(goods_id, nomen_id, objects_id, goods_inprice, goods_rest, clients_id)
      values(:pgoods_id, :vnomen_id, :pobject_id, :vprice, :vkilk, 100);
  end
  else
  begin
    update goods g
        set g.goods_rest = g.goods_rest + :vkilk
      where g.goods_id = :pgoods_id;
  end
  insert into docgoods(docrec_id, goods_id, kilk)
    values(:pdocrec_id, :pgoods_id, :vkilk);

  execute procedure kas_close_docum(:pdoc_id, 4, 1);

  select n.datex_name, n.typepdv_id
        from nomen n
    where n.nomen_id = :vnomen_id
  into :rname, :rtypepdv;

  suspend;
end^


ALTER PROCEDURE KAS_CHECK (
    VDOC INTEGER)
RETURNS (
    RTYPEPDV INTEGER,
    RKILK DOUBLE PRECISION,
    RPRICE DOUBLE PRECISION,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(26),
    RIS_WEIGHT INTEGER,
    RPERSENT DOUBLE PRECISION,
    RCODE VARCHAR(7),
    RALL_DISCOUNT_VALUE DOUBLE PRECISION,
    RNOMEN_ID INTEGER)
AS
declare variable pdocrec integer;
declare variable pmoney1 double precision;
declare variable pmoney2 double precision;
declare variable pnomen integer;
declare variable pnacinka double precision;
declare variable psg_id integer;
declare variable ppersent double precision;
declare variable pis_in_discount smallint;
declare variable p_persent double precision;
begin
  pnacinka = 0.0;

  select disc_persent from documents
   where document_id = :vdoc
    into p_persent;


  for select n.nomen_code, d.docrec_id, d.nomen_id, n.datex_name, d.typepdv_id,
             Around3(d.kilk), around(d.price), n.is_weight, n.sg_id, d.is_in_discount,
             n.nomen_id
        from docrec d, nomen n
       where d.document_id = :vdoc and
             d.nomen_id = n.nomen_id
        into rcode, pdocrec, pnomen, rname, rtypepdv,
             rkilk, rprice, ris_weight, psg_id, pis_in_discount,
             rnomen_id
  do begin
    if (:pis_in_discount = 0) then
    begin
      rpersent = 0.0;
      ppersent = 0.0;
    end  else
    begin
      rpersent = around(:p_persent * 100);
      ppersent = :p_persent;
    end

    select sum(dp.sku_quantity * dp.discount_value)
      from t_dr_prop dp
     where dp.docrec_id = :pdocrec
      into rall_discount_value;

    if (:rall_discount_value is null) then rall_discount_value = 0.0;
    rmoney = around(calcpricepdv((:rkilk * :rprice - :rall_discount_value), :ppersent, 0, 6));

    if((:rtypepdv > 1) and (:psg_id = 1)) then
        rtypepdv = 4;
    if (:psg_id = 2) then
        rtypepdv = 5;

    if (:rtypepdv = 2) then
    begin
      select sum(gg.goods_inprice * dd.kilk) from docgoods dd, goods gg
       where dd.docrec_id = :pdocrec and
             gg.goods_id = dd.goods_id
        into pmoney1;

        pmoney1 = around(:pmoney1);
        pmoney2 = rmoney - :pmoney1;
        rmoney = min2(rmoney, pmoney1);

        if (:rkilk <> 0.0) then
           rprice = around(:rmoney / :rkilk);
        if (:pmoney2 > 0.0) then
           pnacinka = :pnacinka + around(:pmoney2);
        rtypepdv = 1;
      end
      suspend;
  end

  if (:pnacinka > 0.0) then
  begin
    rmoney = :pnacinka;
    rpersent = 0.00;
    rcode = '';
    rname = ' ';
    rkilk = 1;
    rprice = :pnacinka;
    rtypepdv = 2;
    suspend;
  end
end^


ALTER PROCEDURE KAS_CHECK_ART (
    VDOC INTEGER,
    VKASSES_ID INTEGER)
RETURNS (
    RART_NUM INTEGER,
    RTYPEPDV INTEGER,
    RKILK DOUBLE PRECISION,
    RPRICE DOUBLE PRECISION,
    RMONEY DOUBLE PRECISION,
    RNAME VARCHAR(26),
    RIS_WEIGHT INTEGER,
    RPERSENT DOUBLE PRECISION,
    RCODE VARCHAR(7),
    RALL_DISCOUNT_VALUE DOUBLE PRECISION,
    RNOMEN_ID INTEGER)
AS
declare variable pdocrec integer;
declare variable pnomen integer;
declare variable pmoney1 double precision;
declare variable pmoney2 double precision;
declare variable pnacinka double precision;
declare variable psg_id integer;
declare variable ppersent double precision;
declare variable pis_in_discount smallint;
declare variable p_persent double precision;
begin
  pnacinka = 0.0;

  select disc_persent from documents
   where document_id = :vdoc
    into p_persent;

  select k.cnt from kasses k
   where k.kasses_id = :vkasses_id
    into rart_num;

  for select n.nomen_code, d.docrec_id, d.nomen_id, n.datex_name, d.typepdv_id,
             Around3(d.kilk), around(d.price), n.is_weight, n.sg_id, d.is_in_discount,
             n.nomen_id
        from docrec d, nomen n
       where d.document_id = :vdoc and
             d.nomen_id = n.nomen_id
    order by d.docrec_id
        into rcode, pdocrec, pnomen, rname, rtypepdv,
             rkilk, rprice, ris_weight, psg_id, pis_in_discount,
             rnomen_id
  do begin
    rart_num = :rart_num + 1;

    if (:pis_in_discount = 0) then
    begin
      rpersent = 0.0;
      ppersent = 0.0;
    end  else
    begin
      rpersent = around(:p_persent * 100);
      ppersent = :p_persent;
    end

    select osum_pdv from ps_get_sum(:pdocrec, :ppersent, 0)
      into rmoney;

    if((:rtypepdv > 1) and (:psg_id = 1)) then
      rtypepdv = 4;
    if (:psg_id = 2) then
      rtypepdv = 5;

    if (:rtypepdv = 2) then
    begin
      select sum(gg.goods_inprice * dd.kilk) from docgoods dd, goods gg
       where dd.docrec_id = :pdocrec and
             gg.goods_id = dd.goods_id
        into pmoney1;

      pmoney1 = around(:pmoney1);
      pmoney2 = rmoney - :pmoney1;
      rmoney  = min2(rmoney, pmoney1);

      if (:rkilk <> 0.0) then
         rprice = around(:rmoney / :rkilk);
      if (:pmoney2 > 0.0) then
         pnacinka = :pnacinka + around(:pmoney2);
      rtypepdv = 1;
    end
    suspend;
  end

  if (:pnacinka > 0.0) then
  begin
    rmoney = :pnacinka;
    rpersent = 0.00;
    rcode = '';
    rname = ' ';
    rkilk = 1;
    rprice = :pnacinka;
    rtypepdv = 2;
    rart_num = :rart_num + 1;
    suspend;
  end
end^


ALTER PROCEDURE KAS_CLOSE_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
AS
declare variable pgoods_rest double precision;
declare variable pmin_kilk double precision;
declare variable pkilk double precision;
declare variable pdocgoods_id integer;
declare variable pin_kilk double precision;
declare variable pobject_id integer;
declare variable pgoods_id integer;
declare variable pcnt integer;
declare variable pdr_discount double precision;
declare variable pdoc_discount double precision;
declare variable pprice double precision;
declare variable p_goods_id integer;
declare variable p_docgoods_id integer;
begin
  pobject_id = object();
  select sum(d.kilk) from docgoods d
    where d.docrec_id = :vdoc_id
  into :pkilk;

  if (:pkilk is null) then
    pkilk = 0.0;

  pin_kilk = :vkilk;

/*------------ Aey ?ico?aieo oa ?ae?a -----------------------------*/
  if (:vtype_doc in (2, 11)) then
  begin
    if (:pkilk < :vkilk) then
    begin
      vkilk = :vkilk - :pkilk;

      for select d.docgoods_id, g.goods_id, g.goods_rest from docgoods d, goods g
        where d.docrec_id = :vdoc_id and
              g.goods_id = d.goods_id and
              g.goods_rest > 0.0
      into  :pdocgoods_id, :pgoods_id, :pgoods_rest
      do begin

        pmin_kilk = Min2(:vkilk, :pgoods_rest);

        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest - :pmin_kilk
            where g.goods_id = :pgoods_id;

          update docgoods
              set kilk = kilk + :pmin_kilk
            where docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0) then
      begin
     /* ????????? ????? ?? ??????? ?????? */
        for select gg.goods_id, gg.goods_rest from goods gg
          where    gg.nomen_id = :vnomen_id and
                   gg.objects_id = :pobject_id and
                   gg.goods_rest > 0.0
            order by gg.goods_id
        into :pgoods_id, :pgoods_rest
        do begin

          pmin_kilk = Min2(:vkilk, :pgoods_rest);

          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest - :pmin_kilk
              where g.goods_id = :pgoods_id;

            insert into docgoods (goods_id, docrec_id, kilk)
              values  (:pgoods_id, :vdoc_id, :pmin_kilk);
          end
        end
      end

      if (:vkilk > 0) then
      begin
   /* ????????? ?? ??????? ?????? ? ??????????? ????? */

        pgoods_id = null;
        select max(goods_id) from goods g
            where g.nomen_id = :vnomen_id and
                  g.objects_id = :pobject_id
          into :pgoods_id;
        update goods g
            set g.goods_rest = g.goods_rest - :vkilk
          where g.goods_id = :pgoods_id;
        insert into docgoods (goods_id, docrec_id, kilk)
          values(:pgoods_id, :vdoc_id, :vkilk);
      end
    end
/* ------------------------------------------- */
    else if (:pkilk > :vkilk) then
    begin
      vkilk = :pkilk - :vkilk;
      for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
        where    d.docrec_id = :vdoc_id and
                 d.goods_id = g.goods_id and
                 g.goods_rest < 0.0
      into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
      do begin
        pmin_kilk = Min2(:vkilk, -:pgoods_rest);
        pmin_kilk = Min2(:pkilk, :pmin_kilk);
        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest + :pmin_kilk
            where g.goods_id = :pgoods_id;
          update docgoods d
              set d.kilk = d.kilk - :pmin_kilk
            where d.docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0.0) then
      begin
        for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
          where    d.docrec_id = :vdoc_id and
                   d.goods_id = g.goods_id and
                   g.goods_rest >= 0.0
        into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
        do begin
          pmin_kilk = Min2(:vkilk, :pkilk);
          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest + :pmin_kilk
              where g.goods_id = :pgoods_id;
            update docgoods d
                set d.kilk = d.kilk - :pmin_kilk
              where d.docgoods_id = :pdocgoods_id;
          end
        end
      end
    end
  end
  else if (:vtype_doc = 4) then
  begin
    select dr.disc_persent, d.disc_persent --, calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6)
         from docrec dr, documents d
        where dr.docrec_id = :vdoc_id and
              dr.document_id = d.document_id
      into :pdr_discount, :pdoc_discount; --, :pprice;

    select count(dg.docgoods_id) from docgoods dg
      where dg.docrec_id = :vdoc_id
     into :pcnt;
    -- Last in price
    select rt.last_inprice from rst rt
      where rt.nomen_id = :vnomen_id and
            rt.objects_id = 1
    into :pprice;
/*    select calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6) from docrec dr, documents d
       where dr.document_id = d.document_id and
             dr.docrec_id = :vdoc_id
     into :vprice;*/
    if (pcnt = 0) then
    begin
      pgoods_id = gen_id(gen_goods_id, 1);
      insert into goods (goods_id, nomen_id, clients_id, objects_id, goods_rest, goods_inprice)
        values (:pgoods_id, :vnomen_id, 100, :pobject_id, :vkilk, :pprice);
      insert into docgoods(goods_id, docrec_id, kilk, inprice)
        values(:pgoods_id, :vdoc_id, :vkilk, :pprice);
    end
    else
    begin
    /*Зроблено для нового алгоритму створення повернення від покупця*/
      select dg.goods_id, dg.docgoods_id, dg.kilk
        from docgoods dg
       where dg.docrec_id = :vdoc_id
        into :p_goods_id, :p_docgoods_id, :pin_kilk;

      vkilk = :vkilk - :pin_kilk;

      update goods g
         set g.goods_rest = g.goods_rest + :vkilk
       where g.goods_id   = :p_goods_id;

      update docgoods dg
         set dg.kilk        = dg.kilk + :vkilk
       where dg.docgoods_id = :p_docgoods_id;

      execute procedure s_sliv_minusov(1, :vnomen_id);
    end
    --execute procedure ps_document_ins_or_upd_td16(:vdoc_id);
  end
  --suspend;
end^


ALTER PROCEDURE KAS_CLOSE_DOCUM (
    VDOC_ID INTEGER,
    VTYPE_DOC INTEGER,
    VOPLATA_TYPE INTEGER)
AS
DECLARE VARIABLE PDOCREC_ID INTEGER;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PNOM_ID INTEGER;
DECLARE VARIABLE PPRICE DOUBLE PRECISION;
DECLARE VARIABLE PSUM0 DOUBLE PRECISION;
DECLARE VARIABLE PSUM1 DOUBLE PRECISION;
DECLARE VARIABLE PCLOSEDOC_ID INTEGER;
DECLARE VARIABLE PMIN_SUM DOUBLE PRECISION;
begin

  for select d.docrec_id, d.nomen_id, d.kilk, d.price from docrec d
        where d.document_id = :vdoc_id
      into :pdocrec_id, :pnom_id, :pkilk, :pprice
  do begin
    execute procedure kas_close_docrec(:pdocrec_id, :pnom_id, :pkilk, :pprice, :vtype_doc);
    delete from docgoods
        where docrec_id = :pdocrec_id and
              kilk = 0.0;
  end

  delete from docrec
    where document_id = :vdoc_id and
          kilk = 0.0;

  update documents
      set oplata_type = :voplata_type
    where document_id = :vdoc_id;

end^


ALTER PROCEDURE KAS_CLOSE_DOCUMENT (
    IDOCUMENT_ID INTEGER,
    ITYPE_DOC INTEGER,
    IOPLATA_TYPE INTEGER,
    IKASSES_ID INTEGER)
AS
declare variable pdocrec_id integer;
declare variable pkilk double precision;
declare variable pnom_id integer;
declare variable pprice double precision;
begin

  for select d.docrec_id, d.nomen_id, d.kilk, d.price from docrec d
       where d.document_id = :idocument_id
        into pdocrec_id, pnom_id, pkilk, pprice
  do begin
    execute procedure kas_close_docrec(:pdocrec_id, :pnom_id, :pkilk, :pprice, :itype_doc);
    delete from docgoods
     where docrec_id = :pdocrec_id and
           kilk = 0.0;
    delete from t_dr_prop
     where docrec_id = :pdocrec_id and
           sku_quantity = 0.0;
  end

  delete from docrec
   where document_id = :idocument_id and
         kilk = 0.0;

  update documents
     set oplata_type = :ioplata_type,
         kasses_id = :ikasses_id
   where document_id = :idocument_id;

end^


ALTER PROCEDURE KAS_COUPONS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUPON_EAN_ID BIGINT,
    OSUM DOUBLE PRECISION)
AS
begin
  for select dp.coupon_ean_id from t_doc_prop dp
       where dp.document_id = :idocument_id
        into ocoupon_ean_id
  do begin
    select osum from ps_coupon_prop_status(:ocoupon_ean_id, :idocument_id)
      into osum;
    suspend;
  end
end^


ALTER PROCEDURE KAS_CREATE_BAK (
    VDOC_NUM VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOCNUM INTEGER;
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
DECLARE VARIABLE PLAST_DOC_NUM VARCHAR(14);
begin
  /* Procedure Text */
  rdocument_id = gen_id(gen_documents_id, 1);

  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :puser_nik, :pdocnum;

  if (:puser_nik is null) then
  begin
    puser_nik = 'Sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :pdocnum;
  end
  if (:puser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :pdocnum + 1
    where upper(u.user_login) = user;
  end

  plast_doc_num = gendocnum(:puser_nik, :pdocnum);

  insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
    doc_lock, user_name, blok, clients_id)
     values (:rdocument_id, :plast_doc_num, :vdoc_num, 'today', 4, 100,
    0, user, 1, object());

  suspend;
end^


ALTER PROCEDURE KAS_CREATE_BAK_V1 (
    VDOC_NUM VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOCNUM INTEGER;
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
DECLARE VARIABLE PLAST_DOC_NUM VARCHAR(14);
begin
  /* Procedure Text */
  rdocument_id = gen_id(gen_documents_id, 1);

  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :puser_nik, :pdocnum;

  if (:puser_nik is null) then
  begin
    puser_nik = 'Sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :pdocnum;
  end
  if (:puser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :pdocnum + 1
    where upper(u.user_login) = user;
  end

  plast_doc_num = gendocnum(:puser_nik, :pdocnum);

  insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
    doc_lock, user_name, blok, clients_id)
     values (:rdocument_id, :plast_doc_num, :vdoc_num, 'today', 4, 100,
    0, user, 1, object());

  suspend;
end^


ALTER PROCEDURE KAS_CREATE_DOC
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOCNUM INTEGER;
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
begin
  /* Procedure Text */
  rdocument_id = gen_id(gen_documents_id, 1);

  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :puser_nik, :pdocnum;

  if (:puser_nik is null) then
  begin
    puser_nik = 'Sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :pdocnum;
  end
  if (:puser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :pdocnum + 1
    where upper(u.user_login) = user;
  end

  rdoc_num = gendocnum(:puser_nik, :pdocnum);

  insert into documents(document_id, doc_num, doc_date, typedoc_id, objects_id,
    doc_lock, user_name, blok, clients_id, oplata_type)
     values (:rdocument_id, :rdoc_num, 'today', 11, 1,
    0, user, 1, 100, 1);

  suspend;
end^


ALTER PROCEDURE KAS_CREATE_DOC_V1
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOCNUM INTEGER;
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
begin
  /* Procedure Text */
  rdocument_id = gen_id(gen_documents_id, 1);

  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :puser_nik, :pdocnum;

  if (:puser_nik is null) then
  begin
    puser_nik = 'Sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :pdocnum;
  end
  if (:puser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :pdocnum + 1
    where upper(u.user_login) = user;
  end

  rdoc_num = gendocnum(:puser_nik, :pdocnum);

  insert into documents(document_id, doc_num, doc_date, typedoc_id, objects_id,
    doc_lock, user_name, blok, clients_id, oplata_type)
     values (:rdocument_id, :rdoc_num, 'today', 11, 1,
    0, user, 1, 100, 1);

  suspend;
end^


ALTER PROCEDURE KAS_DEL_DOCREC (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RDOCREC_ID INTEGER)
AS
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
begin
/*========== ?????? ?????? ===================================================*/
/*---------- ???????? ???????? -----------------------------------------------*/

  for select dg.goods_id, dg.kilk from docgoods dg
      where dg.docrec_id = :vdocrec_id and
            dg.kilk > 0
    into :pgoods_id, :pkilk
  do begin
    update goods g
        set g.goods_rest = g.goods_rest + :pkilk
      where g.goods_id = :pgoods_id;
  end
  delete from docgoods where docrec_id = :vdocrec_id;
  delete from docrec where docrec_id = :vdocrec_id;
end^


ALTER PROCEDURE KAS_DEL_DOCREC_V1 (
    VDOCREC_ID INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT)
AS
declare variable pgoods_id integer;
declare variable pkilk double precision;
declare variable pdocument_id integer;
declare variable psku_quantity double precision;
declare variable psuspend_count integer;
begin
  rsum = 0.0;
  rdocrec_id = :vdocrec_id;

  for select dg.goods_id, dg.kilk from docgoods dg
       where dg.docrec_id = :vdocrec_id and
             dg.kilk > 0
        into pgoods_id, pkilk
  do begin
    update goods g
       set g.goods_rest = g.goods_rest + :pkilk
     where g.goods_id = :pgoods_id;
  end

  select document_id from docrec
   where docrec_id = :vdocrec_id
    into pdocument_id;

  psuspend_count = 0;
  for select dp.sku_quantity, dp.coupon_ean_id from t_dr_prop dp
        into psku_quantity, rcoupon_ean_id
  do begin
    if (:psku_quantity > 0) then
    begin
      select osum from ps_coupon_recalc_quantity(:pdocument_id, :rcoupon_ean_id)
        into rsum;
      suspend;
      psuspend_count = :psuspend_count + 1;
    end
  end

  delete from docgoods  where docrec_id = :vdocrec_id;
  delete from t_dr_prop where docrec_id = :vdocrec_id;
  delete from docrec    where docrec_id = :vdocrec_id;
  if (:psuspend_count = 0) then suspend;

  when any do
  begin
    rdocrec_id = -1;  /* Сталася помилка*/
  end
end^


ALTER PROCEDURE KAS_DISCONT (
    VKARDCODE VARCHAR(16))
RETURNS (
    RNAME VARCHAR(50),
    RPROCENT DOUBLE PRECISION,
    RCLIENTS_ID INTEGER,
    RDISCONT_ID INTEGER)
AS
begin
  for select k.clients_id, k.name, d.discont_id, d.procent from kards k, discont d
        where   k.kardcode = :vkardcode and
                d.discont_id = k.discont_id
  into rclients_id, rname, rdiscont_id, rprocent
  do begin
    rdiscont_id = :rdiscont_id;
  end
  suspend;
end^


ALTER PROCEDURE KAS_DISCONT_HARD (
    VDOCUMENT_ID INTEGER,
    VSUMA_FULL DOUBLE PRECISION)
RETURNS (
    RDISC_PERSENT DOUBLE PRECISION)
AS
DECLARE VARIABLE PSUM_S_D DOUBLE PRECISION;
DECLARE VARIABLE PDISCONT_ID INTEGER;
begin
  /* Procedure Text */
  psum_s_d = null;
  rdisc_persent = 0.0;
  select d.discont_id, d.disc_persent from documents d
    where d.document_id = :vdocument_id
  into :pdiscont_id, :rdisc_persent;

/*  if ((:pdiscont_id = 0) or (:pdiscont_id is null)) then
  begin
    select max(dl.d_d) from disc_list dl
      where dl.s_d <= :vsuma_full
    into :rdisc_persent;
    if (:rdisc_persent is null) then rdisc_persent = 0.0;

    update documents d
        set d.disc_persent = :rdisc_persent
      where d.document_id = :vdocument_id;
  end  */
  suspend;
end^


ALTER PROCEDURE KAS_DOC_REC (
    VDOC_ID INTEGER,
    VPERCENT DOUBLE PRECISION,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RDOCREC_ID INTEGER,
    RDOCUMENT_ID INTEGER,
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RPRICE DOUBLE PRECISION,
    RKILK DOUBLE PRECISION,
    RIS_WEIGHT INTEGER,
    RNOMEN_CODE VARCHAR(7))
AS
DECLARE VARIABLE PTRUNC INTEGER;
DECLARE VARIABLE PDBL DOUBLE PRECISION;
begin
  rdocument_id = :vdoc_id;

  for select d.docrec_id, d.nomen_id, n.nomen_code, n.nomen_name, d.price, Around3(d.kilk), n.is_weight
       from docrec d, nomen n
    where d.document_id = :vdoc_id and
          d.kilk > 0.0 and
          n.nomen_id = d.nomen_id
  into :rdocrec_id, :rnomen_id, :rnomen_code, :rnomen_name, :rprice, :rkilk, :ris_weight
  do begin
    if (:vpercent is null) then
      rprice = around(rprice);
    else
      rprice = around(:rprice * (1.0 - :vpercent));

    if ((:vapparat_type = 1) or (:vapparat_type = 2)) then
    begin
      ptrunc = (:rkilk * :rprice + 0.0001) * 100;
      pdbl = ptrunc;
      rsum = pdbl / 100;
    end
    else
      rsum = around(:rkilk * :rprice);
    suspend;
  end
end^


ALTER PROCEDURE KAS_DOC_SUM (
    VDOC_ID INTEGER,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION)
AS
DECLARE VARIABLE PPERCENT DOUBLE PRECISION;
DECLARE VARIABLE PDOCREC_ID INTEGER;
DECLARE VARIABLE PSUM DOUBLE PRECISION;
DECLARE VARIABLE PSUM_FULL DOUBLE PRECISION;
begin
  rsum = 0.0;
  rsum_full = 0.0;
  select disc_persent from documents
    where document_id = :vdoc_id
  into :ppercent;

  for select d.docrec_id, Around(d.price)*d.kilk from docrec d
      where d.document_id = :vdoc_id
    into :pdocrec_id, :psum_full
  do begin
    select around(rsumma_pdv) from kas_docrec_sum(:pdocrec_id, :ppercent, :vapparat_type)
      into :psum;
    rsum_full = :rsum_full + :psum_full;
    rsum = :rsum + :psum;
  end
  suspend;
end^


ALTER PROCEDURE KAS_DOC_SUM_ALL (
    VDOC_ID INTEGER,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RPERSENT DOUBLE PRECISION)
AS
DECLARE VARIABLE PPERCENT DOUBLE PRECISION;
DECLARE VARIABLE PDOCREC_ID INTEGER;
DECLARE VARIABLE PSUM DOUBLE PRECISION;
DECLARE VARIABLE PTYPEPDV_ID INTEGER;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PPRICE DOUBLE PRECISION;
DECLARE VARIABLE PIN_SUM DOUBLE PRECISION;
begin
  rsum = 0.0;
  rin_sum = 0.0;
  rsum_full = 0.0;
  select disc_persent from documents
    where document_id = :vdoc_id
  into :ppercent;

  if (:ppercent is null) then
    ppercent = 0.0;

  select sum(dr.kilk * around(dr.price)) from docrec dr
    where dr.document_id = :vdoc_id
  into :rsum_full;
  select rdisc_persent from kas_discont_hard(:vdoc_id, :rsum_full)
    into :ppercent;

  for select dr.docrec_id, n.typepdv_id, dr.kilk, around(dr.price)
        from docrec dr, nomen n
    where dr.document_id = :vdoc_id and
          dr.nomen_id = n.nomen_id
  into :pdocrec_id, :ptypepdv_id, :pkilk, :pprice
  do begin
      select around(rsumma_pdv) from kas_docrec_sum(:pdocrec_id, :ppercent, :vapparat_type)
        into :psum;
      rsum = :rsum + :psum;

      select sum(dg.kilk * g.goods_inprice) from docgoods dg, goods g
        where dg.docrec_id = :pdocrec_id and
              g.goods_id = dg.goods_id
      into :pin_sum;
      rin_sum = :rin_sum + :pin_sum;
  end
  rpersent = :ppercent;
  suspend;
end^


ALTER PROCEDURE KAS_DOC_SUM_ALL_1 (
    VDOC_ID INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION,
    RSUM_FULL DOUBLE PRECISION,
    RPERSENT DOUBLE PRECISION)
AS
declare variable ppercent double precision;
declare variable pdocrec_id integer;
declare variable psum double precision;
begin
  select disc_persent from documents
   where document_id = :vdoc_id
    into ppercent;

  if (:ppercent is null) then ppercent = 0.0;

  select sum(dr.kilk * around(dr.price)) from docrec dr
   where dr.document_id = :vdoc_id
    into rsum_full;

  select sum(around(dv.rsum))
    from kas_docrec_view(:vdoc_id, :ppercent) dv
    into rsum;

  rpersent = :ppercent;
  suspend;
end^


ALTER PROCEDURE KAS_DOCREC_SUM (
    VDOCREC_ID INTEGER,
    VPERCENT DOUBLE PRECISION,
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RSUMMA_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE PPRICE DOUBLE PRECISION;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PTRUNC INTEGER;
DECLARE VARIABLE PDBL DOUBLE PRECISION;
begin
  select d.price, d.kilk from docrec d
    where d.docrec_id = :vdocrec_id
  into :pprice, :pkilk;

  if (:vpercent is null) then
    pprice = around(:pprice);
  else
    pprice = around(:pprice * (1.0 - :vpercent));

  if ((:vapparat_type = 1) or (:vapparat_type = 2)) then
  begin
    ptrunc = (:pkilk * :pprice + 0.0001) * 100;
    pdbl = ptrunc;
    rsumma_pdv = pdbl / 100;
  end
  else
    rsumma_pdv = around(:pkilk * :pprice);
  suspend;
end^


ALTER PROCEDURE KAS_DOCREC_VIEW (
    VDOC_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
RETURNS (
    RSUM DOUBLE PRECISION,
    RDOCREC_ID INTEGER,
    RDOCUMENT_ID INTEGER,
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RPRICE DOUBLE PRECISION,
    RKILK DOUBLE PRECISION,
    RIS_WEIGHT INTEGER,
    RNOMEN_CODE VARCHAR(7))
AS
begin
  rdocument_id = :vdoc_id;

  for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, around(dr.price),
             Around3(dr.kilk), n.is_weight
        from docrec dr
             join nomen n on n.nomen_id = dr.nomen_id
       where dr.document_id = :vdoc_id and
             dr.kilk > 0.0
        into rdocrec_id, rnomen_id, rnomen_code, rnomen_name, rprice,
             rkilk, ris_weight
  do begin
    select gs.osum_pdv from ps_get_sum(:rdocrec_id, :vpercent, 0.0) gs
      into rsum;
    suspend;
  end
end^


ALTER PROCEDURE KAS_DOCUMENTS_VIEW (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12))
RETURNS (
    RDOC_ID INTEGER,
    RDOC_NUM VARCHAR(14),
    RDOC_LOCK SMALLINT,
    RBLOK SMALLINT,
    RDOCSUM DOUBLE PRECISION,
    ROPLATA_TYPE INTEGER,
    RTYPE_DOC INTEGER,
    RTIME TIME)
AS
declare variable ppercent double precision;
begin
  for select d.document_id, d.doc_num, d.doc_lock, d.blok, d.disc_persent,
             d.oplata_type, d.typedoc_id, d.time_cr
        from documents d
       where d.user_name  = :vuser_name and
             d.doc_date   = :vdate_cr   and
             d.typedoc_id in (11, 2, 4)
        into rdoc_id, rdoc_num, rdoc_lock, rblok, ppercent,
             roplata_type, rtype_doc, rtime
  do begin
      if ((:roplata_type is null) or (:roplata_type = 0)) then
          roplata_type = 1;

      select rsum from kas_doc_sum_all_1(:rdoc_id)
        into rdocsum;

      suspend;
  end
end^


ALTER PROCEDURE KAS_EXP_RST
RETURNS (
    RST_ID INTEGER,
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER,
    REST DOUBLE PRECISION,
    REST_SUM DOUBLE PRECISION,
    LAST_INPRICE DOUBLE PRECISION,
    TS TIMESTAMP,
    HAS_GOODS SMALLINT)
AS
begin
  for select r.rst_id, r.nomen_id, r.objects_id, r.rest, r.rest_sum, r.last_inprice, r.ts
        from rst r
             inner join nomen n on n.nomen_id = r.nomen_id
       where n.is_exist = 1
        into rst_id, nomen_id, objects_id, rest, rest_sum, last_inprice, ts
  do begin
    if (exists(select * from goods g where g.nomen_id = :nomen_id)) then
      has_goods = 1;
    else
      has_goods = 0;
    suspend;
  end
end^


ALTER PROCEDURE KAS_INS_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RKILK DOUBLE PRECISION)
AS
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PREST DOUBLE PRECISION;
DECLARE VARIABLE PCAN_MINUS INTEGER;
DECLARE VARIABLE PTYPEPDV_ID INTEGER;
DECLARE VARIABLE PPDV DOUBLE PRECISION;
begin
 pobject_id = object();
 pcan_minus = can_minus();
/*========== ?????? ?????? ===================================================*/
/*---------- ???????? ???????? -----------------------------------------------*/
 rdocrec_id = gen_id(GEN_DOCREC_ID, 1);

 select n.typepdv_id, tp.pdv from nomen n, typepdv tp
     where n.nomen_id = :vnomen_id and
           tp.typepdv_id = n.typepdv_id
   into :ptypepdv_id, :ppdv;

/* rdocrec_id = 262636;*/
  if (:vtype_doc = 11) then
  begin

   if (:pcan_minus = 0) then
    begin

      if (0.0 < :vkilk) then
      begin
        select sum(g.goods_rest) from goods g
          where     g.nomen_id = :vnomen_id
                and g.objects_id = :pobject_id
        into :prest;
        prest = max2(:prest, 0);

        if (:vkilk > :prest) then
        begin
          vkilk = min2(:prest, :vkilk);
        end
      end

      execute procedure kas_close_docrec(:rdocrec_id, :vnomen_id, :vkilk, :vprice, 2);
    end

    rkilk = :vkilk;
    suspend;

    if (:vkilk > 0.0) then
        insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
          values  (:rdocrec_id, :vnomen_id, :vdoc_id, :vkilk, :vprice, :ptypepdv_id, :ppdv);
  end

/*========== ?????? ?????? ===================================================*/
/*----------  ?????????? ??? ???????------------------------------------------*/
    if (:vtype_doc = 4) then
    begin
      insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
        values  (:rdocrec_id, :vnomen_id, :vdoc_id, :vkilk, :vprice, :ptypepdv_id, :ppdv);
    end
end^


ALTER PROCEDURE KAS_INS_DOCREC_V1 (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
RETURNS (
    RDOCREC_ID INTEGER,
    RKILK DOUBLE PRECISION,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT,
    RIS_IN_DISCOUNT SMALLINT)
AS
declare variable pobject_id integer;
declare variable prest double precision;
declare variable pcan_minus integer;
declare variable ptypepdv_id integer;
declare variable ppdv double precision;
declare variable pcount integer;
declare variable psuspend_count integer;
begin
 pobject_id = object();
 pcan_minus = can_minus();
 psuspend_count = 0;
 rsum = 0;

/*---------- підготовка даних  -----------------------------------------------*/
 rdocrec_id = gen_id(GEN_DOCREC_ID, 1);

  select n.typepdv_id, tp.pdv, n.is_in_discount from nomen n, typepdv tp
   where n.nomen_id    = :vnomen_id and
         tp.typepdv_id = n.typepdv_id
    into ptypepdv_id, ppdv, ris_in_discount;
/*---------- створення запису в чекові ---------------------------------------*/
  if (:vtype_doc = 11) then
  begin
    if (:pcan_minus = 0) then
    begin
      if (0.0 < :vkilk) then
      begin
        select sum(g.goods_rest) from goods g
         where g.nomen_id = :vnomen_id and
               g.objects_id = :pobject_id
          into prest;

        prest = max2(:prest, 0);

        if (:vkilk > :prest) then
        begin
          vkilk = min2(:prest, :vkilk);
        end
      end

      execute procedure kas_close_docrec(:rdocrec_id, :vnomen_id, :vkilk, :vprice, 2);
    end

    rkilk = :vkilk;

    if (:vkilk > 0.0) then
    begin
      insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv, is_in_discount)
           values (:rdocrec_id, :vnomen_id, :vdoc_id, :vkilk, :vprice, :ptypepdv_id, :ppdv, :ris_in_discount);
      /* У випадку наявності купона, участь в акції*/
      for select dp.coupon_ean_id from t_doc_prop dp
           where dp.document_id = :vdoc_id
            into rcoupon_ean_id
      do begin
        select count(coupon_ean_id) from t_coupon_articles a
         where a.nomen_id = :vnomen_id and
               a.coupon_ean_id = :rcoupon_ean_id
          into pcount;
        if (:pcount > 0) then
        begin
          insert into t_dr_prop(docrec_id, coupon_ean_id, sku_quantity, discount_value)
              values(:rdocrec_id, :rcoupon_ean_id, 0.0, 0.0);
          select osum from ps_coupon_recalc_quantity(:vdoc_id, :rcoupon_ean_id) rq
            into rsum;
          suspend;
          psuspend_count = :psuspend_count + 1;
        end 
      end
    end
    if (:psuspend_count = 0) then suspend;
  end

/*---------- створення запису в повернення від покупця------------------------------------------*/
    if (:vtype_doc = 4) then
    begin
      insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
        values  (:rdocrec_id, :vnomen_id, :vdoc_id, :vkilk, :vprice, :ptypepdv_id, :ppdv);
    end
end^


ALTER PROCEDURE KAS_LAST_DOCUM
RETURNS (
    RDOC_ID INTEGER)
AS
begin
    select max(d.document_id)  from documents d
      where d.user_name = user
    into :rdoc_id;
    suspend;
end^


ALTER PROCEDURE KAS_LIST_DOC (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12),
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RDOC_ID INTEGER,
    RDOC_NUM VARCHAR(14),
    RDOC_LOCK SMALLINT,
    RBLOK SMALLINT,
    RDOCSUM DOUBLE PRECISION,
    ROPLATA_TYPE INTEGER,
    RTYPE_DOC INTEGER,
    RTIME TIME)
AS
DECLARE VARIABLE PPERCENT DOUBLE PRECISION;
begin

  for select d.document_id, d.DOC_NUM, d.DOC_LOCK, d.BLOK, d.disc_persent, d.oplata_type, d.typedoc_id, d.time_cr
     from DOCUMENTS d
    where       d.USER_NAME=:VUSER_NAME
           and  d.doc_date = :VDATE_CR
           and  d.TYPEDOC_ID in (11, 2, 4)
  into :RDOC_ID, :RDOC_NUM, :RDOC_LOCK, :RBLOK, :ppercent, :roplata_type, :rtype_doc, :rtime
  do begin
      if ((:roplata_type is null) or (:roplata_type = 0)) then
          roplata_type = 1;

      select rsum from kas_doc_sum(:RDOC_ID, :vapparat_type)
        into :RDOCSUM;
      suspend;
  end
end^


ALTER PROCEDURE KAS_LIST_DOC_SUM (
    VDATE_CR DATE,
    VUSER_NAME VARCHAR(12),
    VAPPARAT_TYPE INTEGER)
RETURNS (
    RDOCSUM DOUBLE PRECISION,
    RDOCSUM_K DOUBLE PRECISION,
    RDOC_CONT INTEGER)
AS
DECLARE VARIABLE PPERCENT DOUBLE PRECISION;
DECLARE VARIABLE POPLATA_TYPE INTEGER;
DECLARE VARIABLE PDOCUMENT_ID INTEGER;
DECLARE VARIABLE PDOCSUM DOUBLE PRECISION;
begin
  rdocsum = 0.0;
  rdocsum_k = 0.0;
  rdoc_cont = 0;
  for select d.document_id, d.disc_persent, d.oplata_type
     from DOCUMENTS d
    where       d.USER_NAME=:VUSER_NAME
           and  d.doc_date = :VDATE_CR
           and  d.TYPEDOC_ID in (11, 2)
  into :pdocument_id, :ppercent, :poplata_type
  do begin
      select rsum from kas_doc_sum(:pdocument_id, :vapparat_type)
        into :PDOCSUM;
      if ((:poplata_type is null) or (:poplata_type = 0) or (:poplata_type = 1)) then
        rdocsum = :rdocsum + :PDOCSUM;
      else if (:poplata_type = 2) then
        rdocsum_k = :rdocsum_k + :PDOCSUM;
      rdoc_cont = rdoc_cont + 1;
  end
  suspend;
end^


ALTER PROCEDURE KAS_NOMEN_REST (
    VNOMEN_ID INTEGER)
RETURNS (
    RSUM DOUBLE PRECISION)
AS
DECLARE VARIABLE POBJECT_ID INTEGER;
begin
  pobject_id = object();
  select r.rest from rst r
    where r.nomen_id = :vnomen_id and
          r.objects_id = :pobject_id
  into :rsum;
  suspend;
end^


ALTER PROCEDURE KAS_SEL_TOVAR_BY_CODE (
    VINP_FILTER VARCHAR(27))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER,
    RKILK DOUBLE PRECISION)
AS
declare variable pcont integer;
declare variable pobj_id integer;
declare variable piscode integer;
declare variable pcode integer;
declare variable pweight_code_id integer;
declare variable pcode_int bigint;
begin
  pobj_id = object();
  rkilk   = null;
  piscode = wiscode(:vinp_filter);
  pcode   = wcode(:vinp_filter);
  rkilk   = 1.0;
  if (:piscode=1) then
  begin
    pweight_code_id=null;
  select wc.weight_code_id from weight_code wc
      where wc.code = :pcode
    into :pweight_code_id;
    if (:pweight_code_id is not null) then
    begin
      rkilk = wweight(:vinp_filter);
      vinp_filter = wincode(:vinp_filter);
    end
  end

  for select n.nomen_id, n.nomen_name, around(n.out_price), n.nomen_code, 0, n.is_weight from nomen n
      where n.nomen_code = :VINP_FILTER  and
            ((n.is_exist = 1)or(n.is_exist is null))
    into :rnomen_id, :rnomen_name, :rout_price, :rnomen_code, :rnomen_tara_id, :ris_weight
  do begin
    select count(g.goods_id) from goods g
        where g.nomen_id = :rnomen_id and
              g.objects_id = :pobj_id
      into :pcont;
    if (:pcont > 0) then
      suspend;
  end

  begin
    pcode_int = cast(:vinp_filter as bigint);
    vinp_filter = cast(:pcode_int as varchar(27));
  when any do
  begin

  end
  end

  for select n.nomen_id, n.nomen_name, around(n.out_price), n.nomen_code, n.is_weight
        from nomen n, barcode b, nom_bar nb
      where (b.code like '0'||'%'||:VINP_FILTER or
             b.code = :VINP_FILTER)      and
            b.barcode_id = nb.barcode_id and
            n.nomen_id   = nb.nomen_id   and
            ((n.is_exist = 1)or(n.is_exist is null)) and
            ((n.type_nomen = 0)or(n.type_nomen is null)or(n.type_nomen = 2))
    into :rnomen_id, :rnomen_name, :rout_price, :rnomen_code, :ris_weight
  do begin
    select count(g.goods_id) from goods g
        where g.nomen_id = :rnomen_id and
              g.objects_id = :pobj_id
      into :pcont;
    if (:pcont > 0) then
      suspend;
  end
end^


ALTER PROCEDURE KAS_SEL_TOVAR_BY_NAME (
    VINP_FILTER VARCHAR(40))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER)
AS
declare variable pcont integer;
declare variable pobj_id integer;
begin
  pobj_id = object();
  for select n.nomen_id, n.nomen_name, around(n.out_price), n.nomen_code, 0, n.is_weight
        from nomen n
       where strupper1(n.nomen_name) like :vinp_filter and
             ((n.is_exist = 1)or(n.is_exist is null)) and
             ((n.type_nomen = 0)or(n.type_nomen is null)or(n.type_nomen = 2))
        into rnomen_id, rnomen_name, rout_price, rnomen_code, rnomen_tara_id, ris_weight
  do begin
    select count(g.goods_id) from goods g
     where g.nomen_id = :rnomen_id
      into pcont;
    if (:pcont > 0) then
      suspend;
  end
end^


ALTER PROCEDURE KAS_SEL_TOVAR_BY_NAME_FILTER (
    VINP_FILTER VARCHAR(40),
    VFILTER VARCHAR(40))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_TARA_ID INTEGER,
    RIS_WEIGHT INTEGER)
AS
declare variable pcont integer;
declare variable pobj_id integer;
begin
  pobj_id = object();
 for select n.nomen_id, n.nomen_name, around(n.out_price), n.nomen_code, 0, n.is_weight
       from nomen n
      where strupper1(n.nomen_name) like :vinp_filter and
            strupper1(n.nomen_name) like :vfilter     and
            ((n.is_exist = 1)or(n.is_exist is null))   and
            ((n.type_nomen = 0)or(n.type_nomen is null)or(n.type_nomen = 2))
    into rnomen_id, rnomen_name, rout_price, rnomen_code, rnomen_tara_id, ris_weight
  do begin
    select count(g.goods_id) from goods g
     where g.nomen_id   = :rnomen_id and
           g.objects_id = :pobj_id
      into pcont;
    if (:pcont > 0) then
      suspend;
  end
end^


ALTER PROCEDURE KAS_SEL_TOVAR_BY_NOMEN_ID (
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RNOMEN_CODE VARCHAR(7),
    RIS_WEIGHT INTEGER)
AS
begin

  select n.nomen_name, around(n.out_price), n.nomen_code, n.is_weight
    from nomen n
   where n.nomen_id = :vnomen_id
    into :rnomen_name, :rout_price, :rnomen_code, :ris_weight;
  suspend;
end^


ALTER PROCEDURE KAS_SET_COUPON (
    IDOCUMENT_ID INTEGER,
    ICOUPON_EAN_ID BIGINT)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
declare variable pcount integer;
declare variable pdocrec_id integer;
begin
  /*Створення записів в t_doc_prop*/
  select count(document_id) from t_doc_prop dp
   where dp.document_id = :idocument_id and
         dp.coupon_ean_id = :icoupon_ean_id
    into pcount;
  if (:pcount = 0) then
    insert into t_doc_prop(document_id, coupon_ean_id)
                values(:idocument_id, :icoupon_ean_id);
  /*Створення записів в t_dr_prop*/
  for select dr.docrec_id from docrec dr
       where dr.document_id = :idocument_id and
             dr.nomen_id in (select nomen_id from t_coupon_articles
                              where coupon_ean_id = :icoupon_ean_id and
                                    nomen_id is not null)
        into pdocrec_id
  do begin
    select count(docrec_id) from t_dr_prop dp
     where dp.docrec_id     = :pdocrec_id and
           dp.coupon_ean_id = :icoupon_ean_id
      into pcount;

    if (:pcount = 0) then
      insert into t_dr_prop(docrec_id, coupon_ean_id, sku_quantity, discount_value)
                values(:pdocrec_id, :icoupon_ean_id, 0.0, 0.0);
  end
  /*Встановлення коректних значень в t_dr_prop*/
  select rq.osum from ps_coupon_recalc_quantity(:idocument_id, :icoupon_ean_id) rq
    into osum;

  suspend;
end^


ALTER PROCEDURE KAS_SET_DISCONT (
    VDOC_ID INTEGER,
    VDISCONT_ID INTEGER,
    VCLIENTS_ID INTEGER,
    VDISC_PERCENT DOUBLE PRECISION)
AS
begin
    update documents d
      set d.discont_id   = :vdiscont_id,
          d.disc_persent = :vdisc_percent,
          d.clients_id   = :vclients_id
    where d.document_id  = :vdoc_id;
end^


ALTER PROCEDURE KAS_SYNC_CLOSE_DOCREC (
    VDOC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION,
    VTYPE_DOC INTEGER)
AS
declare variable pgoods_rest double precision;
declare variable pmin_kilk double precision;
declare variable pkilk double precision;
declare variable pdocgoods_id integer;
declare variable pin_kilk double precision;
declare variable pobject_id integer;
declare variable pgoods_id integer;
declare variable pcnt integer;
declare variable pdr_discount double precision;
declare variable pdoc_discount double precision;
declare variable pprice double precision;
declare variable p_goods_id integer;
declare variable p_docgoods_id integer;
begin
  pobject_id = object();
  select sum(d.kilk) from docgoods d
    where d.docrec_id = :vdoc_id
  into :pkilk;

  if (:pkilk is null) then
    pkilk = 0.0;

  pin_kilk = :vkilk;

/*------------ Aey ?ico?aieo oa ?ae?a -----------------------------*/
  if (:vtype_doc in (2, 11)) then
  begin
    if (:pkilk < :vkilk) then
    begin
      vkilk = :vkilk - :pkilk;

      for select d.docgoods_id, g.goods_id, g.goods_rest from docgoods d, goods g
        where d.docrec_id = :vdoc_id and
              g.goods_id = d.goods_id and
              g.goods_rest > 0.0
      into  :pdocgoods_id, :pgoods_id, :pgoods_rest
      do begin

        pmin_kilk = Min2(:vkilk, :pgoods_rest);

        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest - :pmin_kilk
            where g.goods_id = :pgoods_id;

          update docgoods
              set kilk = kilk + :pmin_kilk
            where docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0) then
      begin
     /* ????????? ????? ?? ??????? ?????? */
        for select gg.goods_id, gg.goods_rest from goods gg
          where    gg.nomen_id = :vnomen_id and
                   gg.objects_id = :pobject_id and
                   gg.goods_rest > 0.0
            order by gg.goods_id
        into :pgoods_id, :pgoods_rest
        do begin

          pmin_kilk = Min2(:vkilk, :pgoods_rest);

          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest - :pmin_kilk
              where g.goods_id = :pgoods_id;

            insert into docgoods (goods_id, docrec_id, kilk)
              values  (:pgoods_id, :vdoc_id, :pmin_kilk);
          end
        end
      end

      if (:vkilk > 0) then
      begin
   /* ????????? ?? ??????? ?????? ? ??????????? ????? */

        pgoods_id = null;
        select max(goods_id) from goods g
            where g.nomen_id = :vnomen_id and
                  g.objects_id = :pobject_id
          into :pgoods_id;
        update goods g
            set g.goods_rest = g.goods_rest - :vkilk
          where g.goods_id = :pgoods_id;
        insert into docgoods (goods_id, docrec_id, kilk)
          values(:pgoods_id, :vdoc_id, :vkilk);
      end
    end
/* ------------------------------------------- */
    else if (:pkilk > :vkilk) then
    begin
      vkilk = :pkilk - :vkilk;
      for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
        where    d.docrec_id = :vdoc_id and
                 d.goods_id = g.goods_id and
                 g.goods_rest < 0.0
      into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
      do begin
        pmin_kilk = Min2(:vkilk, -:pgoods_rest);
        pmin_kilk = Min2(:pkilk, :pmin_kilk);
        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest + :pmin_kilk
            where g.goods_id = :pgoods_id;
          update docgoods d
              set d.kilk = d.kilk - :pmin_kilk
            where d.docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0.0) then
      begin
        for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
          where    d.docrec_id = :vdoc_id and
                   d.goods_id = g.goods_id and
                   g.goods_rest >= 0.0
        into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
        do begin
          pmin_kilk = Min2(:vkilk, :pkilk);
          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest + :pmin_kilk
              where g.goods_id = :pgoods_id;
            update docgoods d
                set d.kilk = d.kilk - :pmin_kilk
              where d.docgoods_id = :pdocgoods_id;
          end
        end
      end
    end
  end
  else if (:vtype_doc = 4) then
  begin
    select dr.disc_persent, d.disc_persent --, calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6)
         from docrec dr, documents d
        where dr.docrec_id = :vdoc_id and
              dr.document_id = d.document_id
      into :pdr_discount, :pdoc_discount; --, :pprice;

    select count(dg.docgoods_id) from docgoods dg
      where dg.docrec_id = :vdoc_id
     into :pcnt;
    -- Last in price
    select rt.last_inprice from rst rt
      where rt.nomen_id = :vnomen_id and
            rt.objects_id = 1
    into :pprice;
/*    select calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6) from docrec dr, documents d
       where dr.document_id = d.document_id and
             dr.docrec_id = :vdoc_id
     into :vprice;*/
    if (pcnt = 0) then
    begin
      pgoods_id = gen_id(gen_goods_id, 1);
      insert into goods (goods_id, nomen_id, clients_id, objects_id, goods_rest, goods_inprice)
        values (:pgoods_id, :vnomen_id, 100, :pobject_id, :vkilk, :pprice);
      insert into docgoods(goods_id, docrec_id, kilk, inprice)
        values(:pgoods_id, :vdoc_id, :vkilk, :pprice);
    end
    else
    begin
    /*Зроблено для нового алгоритму створення повернення від покупця*/
      select dg.goods_id, dg.docgoods_id, dg.kilk
        from docgoods dg
       where dg.docrec_id = :vdoc_id
        into :p_goods_id, :p_docgoods_id, :pin_kilk;

      vkilk = :vkilk - :pin_kilk;

      update goods g
         set g.goods_rest = g.goods_rest + :vkilk
       where g.goods_id   = :p_goods_id;

      update docgoods dg
         set dg.kilk        = dg.kilk + :vkilk
       where dg.docgoods_id = :p_docgoods_id;

      execute procedure s_sliv_minusov(1, :vnomen_id);
    end
    --execute procedure ps_document_ins_or_upd_td16(:vdoc_id);
  end
  --suspend;
end^


ALTER PROCEDURE KAS_SYNC_CLOSE_DOCUMENT (
    IDOCUMENT_ID INTEGER)
AS
declare variable pdocrec_id integer;
declare variable pkilk double precision;
declare variable pnom_id integer;
declare variable pprice double precision;
declare variable ptype_doc integer;
begin
  for select dr.docrec_id, dr.nomen_id, dr.kilk, dr.price, d.typedoc_id
        from docrec dr
             inner join documents d on d.document_id = dr.document_id
       where d.document_id = :idocument_id
        into pdocrec_id, pnom_id, pkilk, pprice, ptype_doc
  do begin
    execute procedure kas_sync_close_docrec(:pdocrec_id, :pnom_id, :pkilk, :pprice, :ptype_doc);

    delete from docgoods
     where docrec_id = :pdocrec_id and
           kilk      = 0.0;
  end

  delete from docrec
    where document_id = :idocument_id and
          kilk = 0.0;
end^


ALTER PROCEDURE KAS_SYNC_EXP_CHECK_RECS (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODATE_CR DATE,
    OTIME_CR TIME,
    OUSER_CR VARCHAR(50),
    ODISC_PERSENT DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OIS_IN_DISCOUNT SMALLINT,
    OUSER_CONFIRM VARCHAR(155),
    OTS TIMESTAMP,
    OCOUPON_EAN_ID BIGINT,
    OSKU_QUANTITY DOUBLE PRECISION,
    ODISCOUNT_VALUE DOUBLE PRECISION)
AS
begin
  for select dr.docrec_id, dr.nomen_id, dr.kilk, dr.price,
             dr.date_cr, dr.time_cr, dr.user_cr, dr.disc_persent,
             dr.typepdv_id, dr.typepdv_pdv, dr.insum_pdv, dr.insum,
             dr.is_in_discount, dr.user_confirm, dr.ts,
             drp.coupon_ean_id, drp.sku_quantity, drp.discount_value
        from docrec dr
             left join t_dr_prop drp on dr.docrec_id = drp.docrec_id
       where dr.document_id = :idocument_id
        into odocrec_id, onomen_id, okilk, oprice,
             odate_cr, otime_cr, ouser_cr, odisc_persent,
             otypepdv_id, otypepdv_pdv, oinsum_pdv, oinsum,
             ois_in_discount, ouser_confirm, ots,
             ocoupon_ean_id, osku_quantity, odiscount_value
  do begin
    suspend;
  end
end^


ALTER PROCEDURE KAS_SYNC_EXP_CHECKS
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    ODOC_NUM VARCHAR(14),
    ODOC_MARK VARCHAR(14),
    OTYPEDOC_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE_CR DATE,
    ODOC_SUM DOUBLE PRECISION,
    ODOC_LOCK SMALLINT,
    OUSER_NAME VARCHAR(50),
    OBLOK INTEGER,
    OAUTH_ID INTEGER,
    ODISCONT_ID INTEGER,
    ODISC_PERSENT DOUBLE PRECISION,
    OLOCK_DATE DATE,
    OOPLATA_STATE SMALLINT,
    OOPLATA_TYPE SMALLINT,
    OTIME_CR TIME,
    ODELAY_PAY INTEGER,
    ONOTARIZATION VARCHAR(50),
    OKARDS_ID INTEGER,
    OTIME_FIX TIME,
    OKASSES_ID INTEGER,
    OMAKER_ID INTEGER,
    ORESERVING_TIME SMALLINT,
    OPREW_DOCUMENT_ID INTEGER,
    OTS TIMESTAMP,
    OLIGHT SMALLINT,
    OCOUPON_EAN_ID BIGINT)
AS
begin
  for select d.document_id, d.doc_date, d.doc_num, d.doc_mark, d.typedoc_id, d.objects_id,
             d.clients_id, d.staff_id, d.date_cr, d.doc_sum, d.doc_lock, d.user_name,
             d.blok, d.auth_id, d.discont_id, d.disc_persent, d.lock_date,
             d.oplata_state, d.oplata_type, d.time_cr, d.delay_pay, d.notarization,
             d.kards_id, d.time_fix, d.kasses_id, d.maker_id, d.reserving_time,
             d.prew_document_id, d.ts, dp.light, dpr.coupon_ean_id
        from documents d
             left join t_documents_prm dp on d.document_id = dp.document_id
             left join t_doc_prop dpr on d.document_id = dpr.document_id
       where d.doc_lock = 0 and
             d.typedoc_id = 11 and
             d.doc_date > cast('today' as date) - 10
        into odocument_id, odoc_date, odoc_num, odoc_mark, otypedoc_id, oobjects_id,
             oclients_id, ostaff_id, odate_cr, odoc_sum, odoc_lock, ouser_name,
             oblok, oauth_id, odiscont_id, odisc_persent, olock_date,
             ooplata_state, ooplata_type, otime_cr, odelay_pay, onotarization,
             okards_id, otime_fix, okasses_id, omaker_id, oreserving_time,
             oprew_document_id, ots, olight, ocoupon_ean_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOC_DEL (
    IDOCUMENT_ID INTEGER,
    IDOC_DATE DATE,
    IDOC_NUM VARCHAR(14),
    IDOC_MARK VARCHAR(14),
    ITYPEDOC_ID INTEGER,
    IOBJECTS_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IDOC_LOCK SMALLINT,
    IUSER_NAME VARCHAR(12),
    IDISCONT_ID INTEGER,
    IDISC_PERSENT DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP)
RETURNS (
    OREC_ID INTEGER)
AS
begin
  if (:idocument_id is null) then
  begin
    idocument_id = gen_id(gen_documents_id, 1);
  end
  orec_id = :idocument_id;
  insert into doc_del(document_id, doc_date, doc_num, doc_mark, typedoc_id, objects_id, clients_id,
            staff_id, doc_lock, user_name, discont_id, disc_persent, user_cr, date_cr)
     values(:idocument_id, :idoc_date, :idoc_num, :idoc_mark, :itypedoc_id, :iobjects_id, :iclients_id,
            :istaff_id, :idoc_lock, :iuser_name, :idiscont_id, :idisc_persent, :iuser_cr, :idate_cr);
  suspend;
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOC_REC (
    IDOCUMENT_ID INTEGER,
    IDOCREC_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDATE_CR DATE,
    ITIME_CR TIME,
    IUSER_CR VARCHAR(50),
    IDISC_PERSENT DOUBLE PRECISION,
    ITYPEPDV_ID INTEGER,
    ITYPEPDV_PDV DOUBLE PRECISION,
    IINSUM_PDV DOUBLE PRECISION,
    IINSUM DOUBLE PRECISION,
    IIS_IN_DISCOUNT SMALLINT,
    IUSER_CONFIRM VARCHAR(155),
    ITS TIMESTAMP,
    ICOUPON_EAN_ID BIGINT,
    ISKU_QUANTITY DOUBLE PRECISION,
    IDISCOUNT_VALUE DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable pdocrec_id integer;
begin
  pdocrec_id = gen_id(gen_docrec_id, 1);

  begin
    insert into docrec(docrec_id, document_id, nomen_id, kilk,
          price, date_cr, time_cr, user_cr, disc_persent, typepdv_id,
          typepdv_pdv, is_in_discount, user_confirm)
    values(:pdocrec_id, :idocument_id, :inomen_id, :ikilk,
          :iprice, :idate_cr, :itime_cr, :iuser_cr, :idisc_persent, :itypepdv_id,
          :itypepdv_pdv, :iis_in_discount, :iuser_confirm);
/*$$IBEC$$   when any do
    begin
      select first(1) n.nomen_id from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into inomen_id;

      insert into docrec(docrec_id, document_id, nomen_id, kilk,
             price, date_cr, time_cr, user_cr, disc_persent, typepdv_id,
             typepdv_pdv, is_in_discount, user_confirm)
          values(:pdocrec_id, :idocument_id, :inomen_id, :ikilk,
                 :iprice, :idate_cr, :itime_cr, :iuser_cr, :idisc_persent, :itypepdv_id,
                 :itypepdv_pdv, :iis_in_discount, :iuser_confirm);
  end $$IBEC$$*/
  end
  if (:icoupon_ean_id is not null) then
  insert into t_dr_prop(docrec_id, coupon_ean_id, sku_quantity, discount_value)
      values(:pdocrec_id, :icoupon_ean_id, :isku_quantity, :idiscount_value);

  odocrec_id = :pdocrec_id;
  suspend;
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOCREC_DEL (
    IDOCREC_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
begin
  if (:idocrec_id is null) then
  begin
    idocrec_id = gen_id(gen_docrec_id, 1);
  end

  orec_id = :idocrec_id;
  insert into docrec_del(docrec_id, document_id, nomen_id, kilk, price, user_cr, date_cr, user_confirm)
     values(:idocrec_id, :idocument_id, :inomen_id, :ikilk, :iprice, :iuser_cr, :idate_cr, :iuser_confirm);
  suspend;
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOCREC_LOG (
    IDOCUMENT_ID INTEGER,
    IDOC_NUM VARCHAR(14),
    IDOC_DATE DATE,
    ITYPEDOC_ID INTEGER,
    ICLIENTS_ID INTEGER,
    IDOCREC_ID INTEGER,
    INOMEN_ID INTEGER,
    IPRICE DOUBLE PRECISION,
    IKILK_OLD DOUBLE PRECISION,
    IKILK_NEW DOUBLE PRECISION,
    ITYPE_UPD SMALLINT,
    IUSER_CRT VARCHAR(12),
    IDATE_CRT TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
begin
  orec_id = gen_id(gen_docrec_log_id, 1);
  insert into docrec_log(docrec_log_id, document_id, doc_num, doc_date, typedoc_id,
        clients_id, docrec_id, nomen_id, price, kilk_old, kilk_new, type_upd, user_crt, date_crt, user_confirm)
     values(:orec_id, :idocument_id, :idoc_num, :idoc_date,  :itypedoc_id,
        :iclients_id, :idocrec_id, :inomen_id, :iprice, :ikilk_old, :ikilk_new, :itype_upd, :iuser_crt, :idate_crt, :iuser_confirm);
  suspend;
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOCREC_TMP (
    IDOCREC_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IUSER_CR VARCHAR(12),
    IDATE_CR TIMESTAMP,
    IUSER_CONFIRM VARCHAR(155))
RETURNS (
    OREC_ID INTEGER)
AS
begin
  if (:idocrec_id is null) then
  begin
    idocrec_id = gen_id(gen_docrec_id, 1);
  end
  insert into docrec_tmp(docrec_id, document_id, nomen_id, kilk, price, user_cr, date_cr, user_confirm)
     values(:idocrec_id, :idocument_id, :inomen_id, :ikilk, :iprice, :iuser_cr, :idate_cr, :iuser_confirm);
  suspend;
end^


ALTER PROCEDURE KAS_SYNC_IMP_DOCUMENT (
    IDOCUMENT_ID INTEGER,
    IDOC_DATE DATE,
    IDOC_NUM VARCHAR(14),
    IDOC_MARK VARCHAR(14),
    ITYPEDOC_ID INTEGER,
    IOBJECTS_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IDATE_CR DATE,
    IDOC_SUM DOUBLE PRECISION,
    IDOC_LOCK SMALLINT,
    IUSER_NAME VARCHAR(50),
    IBLOK INTEGER,
    IAUTH_ID INTEGER,
    IDISCONT_ID INTEGER,
    IDISC_PERSENT DOUBLE PRECISION,
    ILOCK_DATE DATE,
    IOPLATA_STATE SMALLINT,
    IOPLATA_TYPE SMALLINT,
    ITIME_CR TIME,
    IDELAY_PAY INTEGER,
    INOTARIZATION VARCHAR(50),
    IKARDS_ID INTEGER,
    ITIME_FIX TIME,
    IKASSES_ID INTEGER,
    IMAKER_ID INTEGER,
    IRESERVING_TIME SMALLINT,
    IPREW_DOCUMENT_ID INTEGER,
    ITS TIMESTAMP,
    ILIGHT SMALLINT,
    ICOUPON_EAN_ID BIGINT,
    ISTORE_DOC_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
declare variable PDOCUMENT_ID integer;
declare variable PDOCGOODS_ID integer;
declare variable PGOODS_ID integer;
declare variable PKILK double precision;
declare variable PDOCREC_ID integer;
begin
  if (:istore_doc_id is null) then
    pdocument_id = gen_id(gen_documents_id, 1);
  else
  begin
    pdocument_id = :istore_doc_id;
    odocument_id = :pdocument_id;
    for select dg.docgoods_id, dg.goods_id, dg.kilk
          from docrec dr
               left join docgoods dg on dr.docrec_id = dg.docrec_id
         where dr.document_id = :pdocument_id
          into pdocgoods_id, pgoods_id, pkilk
    do begin
      update goods g
         set g.goods_rest = g.goods_rest + :pkilk
       where g.goods_id = :pgoods_id;
      delete from docgoods dg where dg.docgoods_id = :pdocgoods_id;
    end

    for select dr.docrec_id from docrec dr
         where dr.document_id = :pdocument_id
          into pdocrec_id
    do begin
      delete from t_dr_prop dp where dp.docrec_id = :pdocrec_id;
      delete from docrec       where docrec_id = :pdocrec_id;
      delete from docrec_tmp   where docrec_id = :pdocrec_id;
      delete from t_del_docrecs where docrec_id = :pdocrec_id;
    end

    delete from t_doc_prop      where document_id = :istore_doc_id;
    delete from t_documents_prm where document_id = :istore_doc_id;
    delete from documents       where document_id = :istore_doc_id;
    delete from doc_del         where document_id = :istore_doc_id;
    delete from t_del_documents where document_id = :istore_doc_id;
  end
  if (not exists(select * from clients cl where cl.clients_id = :iclients_id)) then
    iclients_id = 99;
  insert into documents(document_id, doc_date, doc_num, doc_mark, typedoc_id, objects_id,
           clients_id, staff_id, date_cr, doc_sum, doc_lock, user_name, blok, auth_id,
           discont_id, disc_persent, lock_date, oplata_state, oplata_type, time_cr,
           delay_pay, notarization, kards_id, time_fix, kasses_id, maker_id, reserving_time, prew_document_id)
     values(:pdocument_id, :idoc_date, :idoc_num, :idoc_mark, :itypedoc_id, :iobjects_id,
           :iclients_id, :istaff_id, :idate_cr, :idoc_sum, :idoc_lock, :iuser_name, :iblok, :iauth_id,
           :idiscont_id, :idisc_persent, :ilock_date, :ioplata_state, :ioplata_type, :itime_cr,
           :idelay_pay, :inotarization, :ikards_id, :itime_fix, :ikasses_id, :imaker_id, :ireserving_time, :iprew_document_id);
  if (:ilight is not null) then
    insert into t_documents_prm(document_id, light)
     values(:pdocument_id, :ilight);
  if (:icoupon_ean_id is not null) then
    insert into t_doc_prop(document_id, coupon_ean_id)
     values(:pdocument_id, :icoupon_ean_id);

  odocument_id = :pdocument_id;
  suspend;
end^


ALTER PROCEDURE KAS_UPD_DOCREC (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RKILK DOUBLE PRECISION)
AS
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PREST DOUBLE PRECISION;
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PCAN_MINUS INTEGER;
begin
/*========== ?????? ?????? ===================================================*/
/*---------- ???????? ???????? -----------------------------------------------*/
  pobject_id = object();
  pcan_minus = can_minus();

  if (:pcan_minus = 0) then
  begin
    select sum(d.kilk) from docgoods d
      where d.docrec_id = :vdocrec_id
    into :pkilk;

    if (:pkilk is null) then
        pkilk = 0.0;

    if (:pkilk < :vkilk) then
    begin
      select sum(g.goods_rest) from goods g
        where     g.nomen_id = :vnomen_id
              and g.objects_id = :pobject_id
      into :prest;
      prest = max2(:prest, 0);

      if ((:vkilk-:pkilk) > :prest) then
          vkilk = :pkilk + min2(:prest, :vkilk - :pkilk);
    end
    execute procedure kas_close_docrec(:vdocrec_id, :vnomen_id, :vkilk, :vprice, 2);
  end

  update docrec
    set kilk = :vkilk
  where docrec_id = :vdocrec_id;
  rkilk = :vkilk;
  suspend;
end^


ALTER PROCEDURE KAS_UPD_DOCREC_V1 (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    VKILK DOUBLE PRECISION,
    VPRICE DOUBLE PRECISION)
RETURNS (
    RKILK DOUBLE PRECISION,
    RSUM DOUBLE PRECISION,
    RCOUPON_EAN_ID BIGINT,
    RIS_IN_DISCOUNT DOUBLE PRECISION)
AS
declare variable pkilk double precision;
declare variable prest double precision;
declare variable pobject_id integer;
declare variable pcan_minus integer;
declare variable psuspend_count integer;
declare variable pcount integer;
declare variable pdocument_id integer;
begin
  pobject_id = object();
  pcan_minus = can_minus();
  psuspend_count = 0;
  rsum = 0;

  if (:pcan_minus = 0) then
  begin
    select sum(d.kilk) from docgoods d
     where d.docrec_id = :vdocrec_id
      into pkilk;

    if (:pkilk is null) then
        pkilk = 0.0;

    if (:pkilk < :vkilk) then
    begin
      select sum(g.goods_rest) from goods g
       where g.nomen_id = :vnomen_id and
             g.objects_id = :pobject_id
        into prest;
      prest = max2(:prest, 0);

      if ((:vkilk - :pkilk) > :prest) then
        vkilk = :pkilk + min2(:prest, :vkilk - :pkilk);
    end
    execute procedure kas_close_docrec(:vdocrec_id, :vnomen_id, :vkilk, :vprice, 2);
  end

  update docrec
     set kilk = :vkilk
   where docrec_id = :vdocrec_id;
  /* У випадку наявності купона, участь в акції*/
  for select dp.coupon_ean_id, dr.document_id, dr.is_in_discount from t_doc_prop dp, docrec dr
       where dp.document_id = dr.document_id and
             dr.docrec_id = :vdocrec_id
        into rcoupon_ean_id, pdocument_id, ris_in_discount
  do begin
    select count(coupon_ean_id) from t_coupon_articles a
     where a.nomen_id = :vnomen_id and
           a.coupon_ean_id = :rcoupon_ean_id
      into pcount;
    if (:pcount > 0) then
    begin
      select osum from ps_coupon_recalc_quantity(:pdocument_id, :rcoupon_ean_id) rq
        into rsum;
      suspend;
      psuspend_count = :psuspend_count + 1;
    end
  end
  rkilk = :vkilk;
  if (:psuspend_count = 0) then suspend;
end^


ALTER PROCEDURE P_HAS_USER_ACCESS (
    I_USER_ID INTEGER,
    I_ACCESS_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
begin
  o_result = 0;
  /* старий варіант
  if (exists(select r.right_id from t_users u, t_rights_grp rg, t_rights r
             where u.user_id = :i_user_id and u.rights_grp_id = rg.right_grp_id and
                   rg.right_grp_id = r.rights_grp_id and
                   r.access_id = :i_access_id))
  а так простіше */
  if (exists(select r.right_id from t_users u, t_rights_grp rg, t_rights r
             where u.user_id = :i_user_id and
                   u.rights_grp_id = r.rights_grp_id and
                   r.access_id = :i_access_id))
  then
  begin
    o_result = 1;
  end
  suspend;
end^


ALTER PROCEDURE P_INVOICES_LIST (
    ILIST_ID VARCHAR(10000))
RETURNS (
    OINVOICE_ID INTEGER,
    OQ_HEADER VARCHAR(256),
    OQ_RECORDS VARCHAR(256),
    OQ_UPD_AFTER VARCHAR(256),
    OFRF_FILTER VARCHAR(64),
    OFRF_DESCRIPTOR VARCHAR(256),
    OACCESS_ID INTEGER,
    ORIGHTS_ID INTEGER)
AS
begin
  for select i.invoice_id, i.q_header, i.q_records, i.q_upd_after, i.frf_filter,
        i.frf_descriptor, i.access_id from t_invoices i
      where isinliststr(:ilist_id, i.invoice_id) = 1
    into :oinvoice_id, :oq_header, :oq_records, :oq_upd_after, :ofrf_filter,
        :ofrf_descriptor, :oaccess_id
  do begin

    if (:oaccess_id is null) then
      suspend;
    else
    begin
      select r.right_id from t_users u, t_rights_grp rg, t_rights r
          where u.user_login = user and
                u.rights_grp_id = rg.right_grp_id and
                r.rights_grp_id = rg.right_grp_id and
                r.access_id = :oaccess_id
      into :orights_id;

      if (:orights_id is not null) then
        suspend;
    end

    oq_header = null;
    oq_records = null;
    oq_upd_after = null;
    ofrf_filter = null;
    ofrf_descriptor = null;
    oaccess_id = null;
    orights_id = null;
  end
end^


ALTER PROCEDURE P_IS_ACCESS_GRANDED (
    I_ACCESS_ID INTEGER,
    I_RIGHTS_GRP_ID INTEGER)
RETURNS (
    O_RESULT INTEGER)
AS
begin
  o_result = 0;
  if (exists (select right_id from t_rights where
    access_id = :i_access_id and rights_grp_id = :i_rights_grp_id)) then
  begin
    o_result = 1;
  end
  suspend;
end^


ALTER PROCEDURE P_REEST_DEL (
    DAT1 DATE,
    DAT2 DATE)
RETURNS (
    RE_NUM INTEGER,
    RE_DAT DATE,
    RE_USE VARCHAR(12),
    D_DOK_NUM VARCHAR(14),
    D_DOK_SUM DOUBLE PRECISION,
    D_CLI VARCHAR(50))
AS
DECLARE VARIABLE CLIENT_IDS INTEGER;
begin
for select re.reestr_id, re.data, re.user_cr, d.doc_num, d.doc_sum, d.clients_id
     from reestr re, documents d
    where re.document_id = d.document_id AND RE.data between :dat1 and :dat2
    into :re_num, :re_dat, :re_use, :d_dok_num, :d_dok_sum, :CLIENT_IDS
   DO begin
    select cl.name from clients cl where cl.clients_id = :client_ids
    into :d_cli;
  suspend;
   end

end^


ALTER PROCEDURE P_REESTR_ADD (
    DOCUMENT_ID INTEGER)
RETURNS (
    REZULT CHAR(1))
AS
DECLARE VARIABLE COUTNS INTEGER;
begin
 select count(re.reestr_id) from reestr re where re.document_id=:document_id
  into :coutns;
  if (:coutns < 1 ) then
   insert into  reestr (DOCUMENT_ID) values (:document_id);
  else
   update reestr r set r.user_cr= user where r.document_id=:document_id;
  rezult= 'U';
  suspend;
end^


ALTER PROCEDURE P_REYESTR_POD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RDOCUMENT_NUM VARCHAR(14),
    RCLIENT VARCHAR(40),
    RSUM_OUT_PDV DOUBLE PRECISION,
    RKILK_NAKL INTEGER,
    RSUM_OUT DOUBLE PRECISION,
    DATE_S DATE,
    DATE_E DATE,
    S_SKLAD VARCHAR(50),
    DOC_DATE DATE,
    IPN VARCHAR(20),
    NUM INTEGER)
AS
DECLARE VARIABLE PDOCUMENT_ID INTEGER;
begin

/*  SELECT C.ROUND_SUM
   FROM CONFIGS C
   WHERE C.USERS=USER
   INTO :P_DIG_PRICE;         */

  for select dd.document_id, dd.doc_num, dd.doc_date, c.name, c.ipn
   from documents dd, clients c
    where dd.objects_id = :vsklad_id and
          dd.doc_date between :vdate1 and :vdate2 and
          dd.clients_id = c.clients_id order by dd.doc_date
  into :pdocument_id, :rdocument_num, :doc_date, :rclient, :ipn
  do begin
    select count(rr.document_id) from reestr rr
        where rr.document_id = :pdocument_id
      into :rkilk_nakl;
    if ((:rkilk_nakl <> 0) and (:rkilk_nakl is not null)) then
    begin
      select sum(sum_out_pdv), sum(sum_out) from s_docrec_view(:pdocument_id)
        into :rsum_out_pdv, :rsum_out;
            select c.name from clients c where c.clients_id = :VSKLAD_ID into :s_sklad;
            select max(re.reestr_id) from reestr re where re.document_id=:pdocument_id into :num;
    DATE_S = VDATE1;
    DATE_E = VDATE2;
    /*  rsum_out_pdv = aroundin(rsum_out_pdv,:P_DIG_PRICE);
      rsum_out = aroundin(rsum_out,:p_dig_price);  */
      suspend;
    end
  end
end^


ALTER PROCEDURE P_SELECT_ACCESS (
    I_RIGHTS_GRP_ID INTEGER)
RETURNS (
    O_ACCESS_ID INTEGER,
    O_NAME VARCHAR(120),
    O_PARENT INTEGER,
    O_IMAGE_INDEX INTEGER)
AS
begin
  for
    select access_id, name, parent from t_access
    into :o_access_id, :o_name, :o_parent
  do
  begin
    if (exists(select right_id from t_rights
       where rights_grp_id = :i_rights_grp_id and
       access_id = :o_access_id))
    then
      o_image_index = 1;
    else
      o_image_index = 0;

    suspend;
  end
end^


ALTER PROCEDURE P_STAFF_UPD (
    STAFF_ID INTEGER,
    STAFF_NUM VARCHAR(7),
    SURNAME VARCHAR(20),
    NAME VARCHAR(20),
    PATRONYMIC VARCHAR(20),
    DATE_BIRTH DATE,
    JOB_START DATE,
    JOB_END DATE,
    PASPORT VARCHAR(10),
    VIDANO VARCHAR(30),
    JOB INTEGER)
AS
begin
  update staff
   set  STAFF_NUM =:staff_num, SURNAME =:surname, NAME =:name, PATRONYMIC =:patronymic,
   DATE_BIRTH =:date_birth, JOBS_ID =:job, JOB_START =:job_start, JOB_END=:job_end, PASPORT =:pasport, VIDANO =:vidano
   where STAFF_ID = :staff_id;
  suspend;
end^


ALTER PROCEDURE PA_ADMIN_RIGHTS_SET
AS
declare variable TACCESS_ID integer;
begin

    for select a.access_id from t_access a
        into :taccess_id
    do begin
      INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (:taccess_id, 2);
    end

INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (100110, 1);

INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800001, 3);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800130, 3);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800120, 3);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800104, 3);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800102, 3);

INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800001, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800142, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800141, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800140, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800131, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800130, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800120, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800104, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800103, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800102, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800101, 4);
INSERT INTO T_RIGHTS (ACCESS_ID, RIGHTS_GRP_ID)
              VALUES (800100, 4);

end^


ALTER PROCEDURE PA_GET_USER_ID (
    I_USER_NAME VARCHAR(12))
RETURNS (
    O_USER_ID INTEGER)
AS
begin
  select u.user_id from t_users u where u.user_login = :i_user_name into :o_user_id;
  suspend;
end^


ALTER PROCEDURE PA_GROUP_DEL (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TCOUNT INTEGER;
begin
  if (iright_grp_id < 100) then
  begin
    ocaption = 'не можна видаляти службову групу';
    ocount = 1;
    tcount = :ocount;
    suspend;
  end

  ocaption = 'користувачів у даній групі';
  select count(u.user_id) from t_users u
  where u.rights_grp_id = :iright_grp_id into :ocount;
  tcount = tcount + :ocount;
  suspend;

  ocaption = 'наданих цій групі прав';
  select count(r.right_id) from t_rights r
  where r.rights_grp_id = :iright_grp_id into :ocount;
  tcount = tcount + :ocount;
  suspend;

  if (tcount = 0) then/* залежностей немає - отже видаляємо */
  begin
    delete from t_rights_grp rg where rg.right_grp_id = :iright_grp_id;
  end
end^


ALTER PROCEDURE PA_GROUP_INS (
    INAME VARCHAR(50))
RETURNS (
    OID INTEGER)
AS
begin
  oid = GEN_ID(gen_t_rights_grp_id, 1);

  insert into t_rights_grp(right_grp_id, name) values(:oid, :iname);
  suspend;
end^


ALTER PROCEDURE PA_GROUP_UPD (
    IID INTEGER,
    INAME VARCHAR(50))
RETURNS (
    OID INTEGER)
AS
begin
  oid = iid;
  update t_rights_grp rg set
    rg.name = :iname
  where rg.right_grp_id = :iid;
  suspend;
end^


ALTER PROCEDURE PA_GROUP_VIEW (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(50))
AS
begin
  select rg.right_grp_id, rg.name from t_rights_grp rg
  where rg.right_grp_id = :iright_grp_id
  into :oid, :oname;
  suspend;
end^


ALTER PROCEDURE PA_GROUPS_VIEW
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(50))
AS
begin
  for
  select rg.right_grp_id, rg.name from t_rights_grp rg
  into :oid, :oname
  do
  begin
    suspend;
  end
end^


ALTER PROCEDURE PA_HAS_USER_ACCESS (
    IUSER_ID INTEGER,
    IACCESS_ID INTEGER)
RETURNS (
    ORESULT INTEGER,
    OACCESS_NAME VARCHAR(120))
AS
begin
  oresult = 0;
  oaccess_name = null;

  if (exists(select * from t_users u, t_rights_grp rg, t_rights r
             where u.user_id = :iuser_id and
                   u.rights_grp_id = r.rights_grp_id and
                   r.access_id = :iaccess_id))
  then
  begin
    oresult = 1;
  end
  else
  begin
    select name
      from t_access a
      where a.access_id = :iaccess_id
      into oaccess_name;

    if (:oaccess_name is null) then
      oaccess_name = 'невідомий ідентифікатор права';
  end
  suspend;
end^


ALTER PROCEDURE PA_HAS_USER_ACCESS_V1 (
    I_USER_ID INTEGER,
    I_ACCESS_ID INTEGER)
RETURNS (
    O_RESULT INTEGER,
    O_ACCESS_NAME VARCHAR(120))
AS
begin
  o_result = 0;
  o_access_name = null;

  if (exists(select * from t_users u, t_rights_grp rg, t_rights r
             where u.user_id = :i_user_id and
                   u.rights_grp_id = r.rights_grp_id and
                   r.access_id = :i_access_id))
  then
  begin
    o_result = 1;
  end
  else
  begin
    select name
      from t_access a
      where a.access_id = :i_access_id
      into o_access_name;

    if (:o_access_name is null) then
      o_access_name = 'невідомий ідентифікатор права';
  end
  suspend;
end^


ALTER PROCEDURE PA_USER_DEL (
    IUSER_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
BEGIN
  ocaption = '';
  ocount = 0;

    delete from t_users u
      where u.user_id = :iuser_id;
END^


ALTER PROCEDURE PA_USER_INS (
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3))
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_users_id, 1);

  insert into t_users(user_id, user_login, user_keyword, rights_grp_id,
    user_surname, user_first_name, user_second_name, /*person_id,*/ nick)
  values(:oid, :ilogin, :ikeyword, :irights_grp_id, :isurname, :ifirst_name,
    :isecond_name, /*0,*/ :inick);
  suspend;
end^


ALTER PROCEDURE PA_USER_INS_V1 (
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3),
    ISIGNATURE VARCHAR(128))
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_users_id, 1);

  insert into t_users(user_id, user_login, user_keyword, rights_grp_id,
    user_surname, user_first_name, user_second_name, /*person_id,*/ nick, signature)
  values(:oid, :ilogin, :ikeyword, :irights_grp_id, :isurname, :ifirst_name,
    :isecond_name, /*0,*/ :inick, :isignature);
  suspend;
end^


ALTER PROCEDURE PA_USER_UPD (
    IID INTEGER,
    ILOGIN VARCHAR(12),
    IKEYWORD VARCHAR(20),
    IRIGHTS_GRP_ID INTEGER,
    ISURNAME VARCHAR(50),
    IFIRST_NAME VARCHAR(50),
    ISECOND_NAME VARCHAR(50),
    INICK VARCHAR(3))
RETURNS (
    OID INTEGER)
AS
begin
  update t_users u set
    u.user_login = :ilogin,
    u.user_keyword = :ikeyword,
    u.rights_grp_id = :irights_grp_id,
    u.user_surname = :isurname,
    u.user_first_name = :ifirst_name,
    u.user_second_name = :isecond_name,
    u.nick = :inick
  where u.user_id = :iid;
  oid = iid;
  suspend;
end^


ALTER PROCEDURE PA_USER_VIEW (
    IUSER_ID INTEGER)
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OSURNAME VARCHAR(50),
    OFIRST_NAME VARCHAR(50),
    OSECOND_NAME VARCHAR(50),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
begin
  select
    u.user_id,
    u.user_surname||' '||u.user_first_name||' '||u.user_second_name,
    u.user_surname,
    u.user_first_name,
    u.user_second_name,
    u.user_login,
    u.user_keyword,
    u.rights_grp_id,
    rg.name,
    u.nick
  from t_users u, t_rights_grp rg where u.rights_grp_id = rg.right_grp_id and
    u.user_id = :iuser_id
  into
    :oid,
    :ofull_name,
    :osurname,
    :ofirst_name,
    :osecond_name,
    :ologin,
    :okeyword,
    :orights_grp_id,
    :orights_grp_name,
    :onick;
  suspend;
end^


ALTER PROCEDURE PA_USERS_FROM_GROUP (
    IRIGHT_GRP_ID INTEGER)
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
begin
  for
  select
    u.user_id,
    u.user_surname||' '||u.user_first_name||' '||u.user_second_name,
    u.user_login,
    u.user_keyword,
    u.rights_grp_id,
    rg.name,
    u.nick
  from t_users u, t_rights_grp rg where u.rights_grp_id = rg.right_grp_id and
    rg.right_grp_id = :iright_grp_id
  into
    :oid,
    :ofull_name,
    :ologin,
    :okeyword,
    :orights_grp_id,
    :orights_grp_name,
    :onick
  do
  begin
    suspend;
  end
end^


ALTER PROCEDURE PA_USERS_VIEW
RETURNS (
    OID INTEGER,
    OFULL_NAME VARCHAR(152),
    OLOGIN VARCHAR(12),
    OKEYWORD VARCHAR(20),
    ORIGHTS_GRP_ID INTEGER,
    ORIGHTS_GRP_NAME VARCHAR(50),
    ONICK VARCHAR(3))
AS
begin
  for
  select
    u.user_id,
    u.user_surname||' '||u.user_first_name||' '||u.user_second_name,
    u.user_login,
    u.user_keyword,
    u.rights_grp_id,
    rg.name,
    u.nick
  from t_users u, t_rights_grp rg where u.rights_grp_id = rg.right_grp_id
  into
    :oid,
    :ofull_name,
    :ologin,
    :okeyword,
    :orights_grp_id,
    :orights_grp_name,
    :onick
  do
  begin
    suspend;
  end
end^


ALTER PROCEDURE PC_CITY_INS (
    INAME VARCHAR(40),
    IREGION_ID INTEGER,
    ICITY_TYPE SMALLINT)
RETURNS (
    OID INTEGER)
AS
begin
  oid = GEN_ID(gen_city_id, 1);

  insert into cities(city_id, city_name, city_type, region_id)
  values(:oid, :iname, :icity_type, :iregion_id);
  suspend;
end^


ALTER PROCEDURE PC_CITY_UPD (
    IID INTEGER,
    INAME VARCHAR(40),
    IREGION_ID INTEGER,
    ICITY_TYPE SMALLINT)
RETURNS (
    OID INTEGER)
AS
begin
  oid = iid;

  update cities c set
    c.city_name = :iname,
    c.region_id = :iregion_id,
    c.city_type = :icity_type
  where c.city_id = :iid;
  suspend;
end^


ALTER PROCEDURE PC_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENTS_CODE VARCHAR(7),
    OSHORTNAME VARCHAR(30),
    ONAME VARCHAR(50),
    OFULL_NAME VARCHAR(83),
    OTYPECLIENT_ID INTEGER,
    OTYPECLIENT VARCHAR(40),
    OADDRESS VARCHAR(50),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24))
AS
begin
  select
    c.clients_id,
    c.clients_code,
    c.shortname,
    c.name,
    c.shortname||' ('||c.name||')',
    c.typeclient_id,
    t.typeclient_name,
    c.adress,
    c.deliv_addr,
    c.phone
  from clients c, typeclient t
  where (c.typeclient_id = t.typeclient_id)and(c.clients_id = :iclient_id)
  into
    :oclient_id,
    :oclients_code,
    :oshortname,
    :oname,
    :ofull_name,
    :otypeclient_id,
    :otypeclient,
    :oaddress,
    :odeliv_addr,
    :ophone;

  suspend;
end^


ALTER PROCEDURE PC_CLIENTS_VIEW (
    IZKPO VARCHAR(20))
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENTS_CODE VARCHAR(7),
    OSHORTNAME VARCHAR(30),
    ONAME VARCHAR(50),
    OFULL_NAME VARCHAR(83),
    OTYPECLIENT_ID INTEGER,
    OTYPECLIENT VARCHAR(40),
    OADDRESS VARCHAR(50),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OZKPO VARCHAR(20))
AS
begin
  if(izkpo = '0')then/* вибираємо усіх клієнтів */
  begin
      for
      select
        c.clients_id,
        c.clients_code,
        c.shortname,
        c.name,
        c.shortname||' ('||c.name||')',
        c.typeclient_id,
        t.typeclient_name,
        c.adress,
        c.deliv_addr,
        c.phone,
        c.zkpo
      from clients c, typeclient t
      where (c.typeclient_id = t.typeclient_id)
      into
        :oclient_id,
        :oclients_code,
        :oshortname,
        :oname,
        :ofull_name,
        :otypeclient_id,
        :otypeclient,
        :oaddress,
        :odeliv_addr,
        :ophone,
        :ozkpo
      do
      begin
        suspend;
      end
  end
  else begin/* вибираємо клієнтів з конкретним ЗКПО */
      for
      select
        c.clients_id,
        c.clients_code,
        c.shortname,
        c.name,
        c.shortname||' ('||c.name||')',

        c.typeclient_id,
        t.typeclient_name,
        c.adress,
        c.deliv_addr,
        c.phone,
        c.zkpo
      from clients c, typeclient t
      where (c.typeclient_id = t.typeclient_id)and(c.zkpo = :izkpo)
      into
        :oclient_id,
        :oclients_code,
        :oshortname,
        :oname,
        :ofull_name,
        :otypeclient_id,
        :otypeclient,
        :oaddress,
        :odeliv_addr,
        :ophone,
        :ozkpo
      do
      begin
        suspend;
      end
  end
end^


ALTER PROCEDURE PC_POST_INS (
    INAME VARCHAR(40))
RETURNS (
    OPOST_ID INTEGER)
AS
begin
  opost_id = gen_id(gen_t_posts_id, 1);

  insert into t_posts(post_id, name) values(:opost_id, :iname);
  suspend;
end^


ALTER PROCEDURE PC_POST_UPD (
    IPOST_ID INTEGER,
    INAME VARCHAR(40))
RETURNS (
    OPOST_ID INTEGER)
AS
begin
  opost_id = ipost_id;

  update t_posts p set
    p.name = :iname
  where p.post_id = :ipost_id;
  suspend;
end^


ALTER PROCEDURE PC_POST_VIEW (
    IPOST_ID INTEGER)
RETURNS (
    OPOST_ID INTEGER,
    ONAME VARCHAR(40))
AS
begin
  select post_id, name from t_posts where post_id = :ipost_id
  into :opost_id, :oname;
  suspend;
end^


ALTER PROCEDURE PC_POSTS_VIEW
RETURNS (
    OPOST_ID INTEGER,
    ONAME VARCHAR(40))
AS
begin
  for
  select
    p.post_id,
    p.name
  from t_posts p
  into
    :opost_id,
    :oname
  do
  begin
    suspend;
  end
end^


ALTER PROCEDURE PC_REGION_DEL (
    IREGION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TCOUNT INTEGER;
begin
  ocaption = 'міст';
  select count(c.city_id) from cities c
  where c.region_id = :iregion_id into :ocount;
  tcount = ocount;
  suspend;

  if (tcount = 0) then/* залежностей немає - отже видаляємо */
  begin
    delete from regions where region_id = :iregion_id;
  end
end^


ALTER PROCEDURE PC_REGION_INS (
    INAME VARCHAR(40),
    ISTATE_ID INTEGER)
RETURNS (
    OID INTEGER)
AS
begin
  oid = GEN_ID(gen_region_id, 1);

  insert into regions(region_id, region_name, state_id)
  values(:oid, :iname, :istate_id);
  suspend;
end^


ALTER PROCEDURE PC_REGION_UPD (
    IID INTEGER,
    INAME VARCHAR(40),
    ISTATE_ID INTEGER)
RETURNS (
    OID INTEGER)
AS
begin
  oid = iid;

  update regions r set
    r.region_name = :iname,
    r.state_id = :istate_id
  where r.region_id = :iid;
  suspend;
end^


ALTER PROCEDURE PC_STATE_DEL (
    ISTATE_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TCOUNT INTEGER;
begin
  ocaption = 'районів';
  select count(r.region_id) from regions r
  where r.state_id = :istate_id into :ocount;
  tcount = ocount;
  suspend;

  if (tcount = 0) then/* залежностей немає - отже видаляємо */
  begin
    delete from states where state_id = :istate_id;
  end
end^


ALTER PROCEDURE PC_STATE_INS (
    INAME VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
begin
  oid = GEN_ID(gen_state_id, 1);

  insert into states(state_id, state_name) values(:oid, :iname);
  suspend;
end^


ALTER PROCEDURE PC_STATE_UPD (
    IID INTEGER,
    INAME VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
begin
  oid = iid;

  update states s set
    s.state_name = :iname
  where s.state_id = :iid;
  suspend;
end^


ALTER PROCEDURE PE_1C (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000))
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
declare variable tinsum_pdv double precision;
declare variable tsumwithvat double precision;
declare variable tinsum double precision;
declare variable tobject_id integer;
declare variable tclient_id integer;
declare variable tsrc_dst_id integer;
declare variable taccount_id integer;
declare variable treestr_id integer;
declare variable tkasses_id integer;
begin /*$$IBE$$ 
  idate1 = :idate1 - 1;

  select c.clients_code from clients c
      where c.clients_id = 1
    into :object_num;

  for select d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
             d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id,
             sum(calcpricepdv(dr.kilk * dr.price, d.disc_persent, 0.000, 6)),
             sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id
     where d.doc_date between :idate0 and :idate1 and
           ((d.doc_lock = 2) or ((d.doc_lock = 1) and (d.typedoc_id = 4))) and
           d.typedoc_id <> 11 and
           isinliststr(:itypes, d.typedoc_id) = 1
       group by d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
                d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id
       into :doc_lock, :document_id, :typedoc, :docdate, :docnum, :docmarck,
            :tclient_id, :tobject_id, :typevat, :typepay, :tkasses_id,
            :tsumwithvat, :tinsum_pdv, :tinsum
  do begin
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

 $$IBE$$*/ /*    if ((:doc_lock is null) or (:doc_lock <> 2)) then
        exception EX_NOT_LOCK; */ /*$$IBE$$ 

    if (:tclient_id <> 1) then
      tsrc_dst_id = :tclient_id;
    else if (:tobject_id <> 1) then
      tsrc_dst_id = :tobject_id;

    select c.name, c.zkpo, c.adress, c.ipn, c.numpdv, c.ipn, c.ispdv, c.phone
         from clients c
      where c.clients_id = :tsrc_dst_id
    into :partner, :partcode, :address, :ipn, :taxpayern, :singletaxn, :istaxpay, :phone;

    taccount_id = null;
    bankname = null;
    banknum = null;
    payaccount = null;

    select min(ca.account_id)
          from clientaccount ca
       where ca.clients_id = :tsrc_dst_id
    into :taccount_id;

    if (not (:taccount_id is null)) then
    begin
      select b.name, b.mfo, ca.account_num
        from clientaccount ca left join banks b on ca.banks_id = b.banks_id
              where ca.account_id = :taccount_id
      into :bankname, :banknum, :payaccount;
    end

    istax = 0;
    taxnum = null;
    taxdate = null;
    taxsumvat = 0.000;
    taxsum = 0.000;
    taxpayern = null;
    treestr_id = null;
    singletaxn = null;
    select max(r.reestr_id)
        from  reestr r
      where r.document_id = :document_id
    into :treestr_id;

    if (:treestr_id is null) then treestr_id = 0;
    if (:treestr_id > 0) then istax = 1;

    select r.td_number, r.td_date $$IBE$$*/ /*, r.td_sum, r.td_sum_vat, r.td_sum_with_vat*/ /*$$IBE$$ 
        from reestr r
      where r.reestr_id = :treestr_id
    into :taxnum, :taxdate $$IBE$$*/ /*, :taxsum,  :taxsumvat, :taxsumvat*/ /*$$IBE$$ ;

    if (:typedoc in (1, 4)) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);
 $$IBE$$*/ /*      sumdoc = :tinsum;  */
/*      sumin = :tinsum;  */ /*$$IBE$$ 
      sumin = sumdoc;
      sumwithvat = :tinsum_pdv;
      sumvat = :sumwithvat - :sumdoc;
    end

    if (:typedoc in (2, 17)) then
    begin
      sumdoc = calcsum(:tsumwithvat, :tsumwithvat - :tinsum, 0, :typevat, 6);
      sumin = :tinsum;
      sumwithvat = :tsumwithvat;
      sumvat = :sumwithvat - :sumdoc;

      if (typedoc = 17) then
        typedoc = 5;
    end

    if (:typedoc = 4) then
    begin
 $$IBE$$*/ /*      document_id = -:tkasses_id;  */ /*$$IBE$$ 
      docnum = :tkasses_id;
      ipn = '';
      select k.rn from kasses k
         where k.kasses_id = :tkasses_id
       into :ipn;
    end

    if (istax = 1) then
    begin
      taxsum = sumdoc;
      taxsumwvat = sumwithvat;
      taxsumvat = sumvat;
      if (:typedoc not in (1)) then
        taxdate = :docdate;
    end

  $$IBE$$*/ /*   select oisedit1, oisedit2 from pe_1c_log_edit(:docdate, :typevat, :SUMWITHVAT,
                :SUMVAT, :SUMDOC, :sumin, :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM,
                :TAXDATE, :TAXSUMWITHVAT, :TAXSUMVAT, :TAXSUM, :typepay)
      into isedit1, isedit2;  */ /*$$IBE$$ 

    if ((:typedoc = 4) and (:partcode is null)) then
      partner = 'Покупець';

    if (((:partcode <> '10001') or (:partcode is null)) and (sumwithvat <> 0.00)) then
      suspend;

    docmarck = null;
    sumdoc = null;
    sumin = null;
    sumwithvat = null;
    sumvat = null;
    taxsumwvat = null;
  end

  partner = 'Покупець';
  partcode = '';
  address = '';
  phone = '';
  bankname = null;
  banknum = null;
  payaccount = null;
  bankname = '';
  banknum = '';
  payaccount = '';
  taxnum = '';
  taxpayern = null;
  istax = null;
  taxdate = null;
  taxsumwithvat = 0.00;
  taxsumvat = 0.00;
  taxsum = 0.00;
  singletaxn = null;
  taxsumwvat = null;
  doc_lock = 2;
  for select d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id,
             sum(around(calcpricepdv(dr.kilk * dr.price, d.disc_persent, 0.000, 6))),
             sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id
     where d.doc_date between :idate0 and :idate1 and
           d.typedoc_id = 11 and
           d.doc_lock in (1, 2) and
           isinliststr(:itypes, d.typedoc_id) = 1
       group by d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id
       into :docdate, :typevat, :typepay, :tkasses_id,
            :tsumwithvat, :tinsum_pdv, :tinsum
  do begin
    if (:tkasses_id is null) then tkasses_id = 0;
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    sumin = :tinsum;
    sumwithvat = :tsumwithvat;
    sumdoc = calcsum(:sumwithvat, (:sumwithvat - :sumin), 0, :typevat, 6);
    sumvat = :sumwithvat - :sumdoc;

    document_id = -:tkasses_id;
    docnum = :tkasses_id;
    ipn = '';
    select k.rn from kasses k
       where k.kasses_id = :tkasses_id
     into :ipn;

    typedoc = 3;

 $$IBE$$*/ /*    select oisedit1, oisedit2 from pe_1c_log_edit(:docdate, :typevat, :SUMWITHVAT,
                :SUMVAT, :SUMDOC, :sumin, :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM,
                :TAXDATE, :TAXSUMWITHVAT, :TAXSUMVAT, :TAXSUM, :typepay)
      into isedit1, isedit2; */ /*$$IBE$$ 
    suspend;
  end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PE_1C_LOG_EDIT (
    IDOCDATE DATE,
    ITYPEVAT SMALLINT,
    ISUMWITHVAT NUMERIC(9,2),
    ISUMVAT NUMERIC(9,2),
    ISUMDOC NUMERIC(9,2),
    ISUMIN NUMERIC(9,2),
    IDOCMARCK VARCHAR(14),
    IDOCUMENT_ID INTEGER,
    IISTAX SMALLINT,
    ITAXNUM VARCHAR(20),
    ITAXDATE DATE,
    ITAXSUMWITHVAT NUMERIC(9,2),
    ITAXSUMVAT NUMERIC(9,2),
    ITAXSUM NUMERIC(9,2),
    ITYPEPAY INTEGER)
RETURNS (
    OISEDIT1 INTEGER,
    OISEDIT2 INTEGER)
AS
DECLARE VARIABLE TLOG_DOCDATE DATE;
DECLARE VARIABLE TLOG_SUMWITHVAT NUMERIC(9,2);
DECLARE VARIABLE TLOG_SUMVAT NUMERIC(9,2);
DECLARE VARIABLE TLOG_SUMDOC NUMERIC(9,2);
DECLARE VARIABLE TLOG_SUMIN NUMERIC(9,2);
DECLARE VARIABLE TLOG_DOCNUM VARCHAR(14);
DECLARE VARIABLE TLOG_DOCMARCK VARCHAR(14);
DECLARE VARIABLE TLOG_ISTAX SMALLINT;
DECLARE VARIABLE TLOG_TAXNUM VARCHAR(20);
DECLARE VARIABLE TLOG_TAXDATE DATE;
DECLARE VARIABLE TLOG_TAXSUMWITHVAT NUMERIC(9,2);
DECLARE VARIABLE TLOG_TAXSUMVAT NUMERIC(9,2);
DECLARE VARIABLE TLOG_TAXSUM NUMERIC(9,2);
begin
  tlog_docdate = null;
  select l.docdate, l.sumwithvat, l.sumvat, l.sumin,
         l.sumdoc, l.docnum, l.docmarck, l.istax, l.taxdate,
         l.taxnum, l.taxsum, l.taxsumvat, l.taxsumwithvat
   from t_1c_log l
     where l.document_id = :idocument_id and
           l.typevat = :itypevat and
           l.docdate = :idocdate and
           l.typepay = :itypepay
     into :tlog_docdate, :tlog_sumwithvat, :tlog_sumvat, :tlog_sumin,
          :tlog_sumdoc, :tlog_docnum, :tlog_docmarck, :tlog_istax, :tlog_taxdate,
          :tlog_taxnum, :tlog_taxsum, :tlog_taxsumvat, :tlog_taxsumwithvat;

  oisedit1 = 0;
  oisedit2 = 0;
  if (not (:tlog_docdate is null)) then
  begin
    oisedit1 = 1;
    oisedit2 = 1;
    if (:tlog_docdate <> :idocdate) then oisedit1 = 2;
    if (around(:tlog_sumwithvat) <> around(:isumwithvat)) then oisedit1 = 2;
    if (around(:tlog_sumvat) <> around(:isumvat)) then oisedit1 = 2;
    if (around(:tlog_sumdoc) <> around(:isumdoc)) then oisedit1 = 2;
    if (:tlog_docmarck <> :idocmarck) then oisedit1 = 2;
    if (:tlog_istax <> :iistax) then oisedit2 = 2;
    if (:tlog_taxdate <> :itaxdate) then oisedit2 = 2;
    if (:tlog_taxnum <> :itaxnum) then oisedit2 = 2;
    if (around(:tlog_taxsum) <> around(:itaxsum)) then oisedit2 = 2;
    if (around(:tlog_taxsumvat) <> around(:itaxsumvat)) then oisedit2 = 2;
    if (around(:tlog_taxsumwithvat) <> around(:itaxsumwithvat)) then oisedit2 = 2;
  end

  suspend;
end^


ALTER PROCEDURE PE_1C_PERIODIC_ADD (
    IPERIODIC_ID DATE,
    IFINAL_DATE DATE)
AS
DECLARE VARIABLE TPERIODIC_ID DATE;
begin
  select p.periodic_id from t_1c_periodics p
      where p.periodic_id = :iperiodic_id
    into :tperiodic_id;

  if (:tperiodic_id is null) then
    insert into t_1c_periodics (periodic_id, sum_x, final_date)
       values (:iperiodic_id, 0, :ifinal_date);
  else
    update t_1c_periodics p
        set p.final_date = :ifinal_date
      where p.periodic_id = :iperiodic_id;
end^


ALTER PROCEDURE PE_1C_PERIODICS_VIEW
RETURNS (
    OPERIODIC_ID DATE,
    OSUM_X DOUBLE PRECISION,
    OFINAL_DATE DATE)
AS
begin
  for select p.periodic_id, p.sum_x, p.final_date from t_1c_periodics p
      order by p.periodic_id desc
    into :operiodic_id, :osum_x, :ofinal_date
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PE_1C_SUMS_1 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
declare variable tinsum_pdv double precision;
declare variable tsumwithvat double precision;
declare variable tinsum double precision;
declare variable tobject_id integer;
declare variable tclient_id integer;
declare variable tsrc_dst_id integer;
declare variable taccount_id integer;
declare variable treestr_id integer;
declare variable tkasses_id integer;
declare variable pint_partcode integer;
begin
  idate1 = :idate1 - 1;

  select c.clients_code from clients c
   where c.clients_id = 1
    into object_num;

 for select d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
            d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id,
            sum(gs.osum_pdv), sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id,
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :idate0 and :idate1 and
            (((d.doc_lock = 2) or ((d.doc_lock = 1) and (d.typedoc_id = 4))) or (:iis_final <> 0)) and
            d.typedoc_id <> 11 and isinliststr(:itypes, d.typedoc_id) = 1
   group by d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
            d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id
       into doc_lock, document_id, typedoc, docdate, docnum, docmarck,
            tclient_id, tobject_id, typevat, typepay, tkasses_id,
            tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    if (:tclient_id <> 1) then
      tsrc_dst_id = :tclient_id;
    else if (:tobject_id <> 1) then
      tsrc_dst_id = :tobject_id;

    select c.name, c.zkpo, c.adress, c.ipn, c.numpdv, c.ispdv, c.ispdv, c.phone
      from clients c
     where c.clients_id = :tsrc_dst_id
      into partner, partcode, address, ipn, taxpayern, singletaxn, istaxpay, phone;

    taccount_id = null;
    bankname    = null;
    banknum     = null;
    payaccount  = null;

    select min(ca.account_id)
      from clientaccount ca
     where ca.clients_id = :tsrc_dst_id
      into taccount_id;

    if (not (:taccount_id is null)) then
    begin
      select b.name, b.mfo, ca.account_num
        from clientaccount ca left join banks b on ca.banks_id = b.banks_id
              where ca.account_id = :taccount_id
        into bankname, banknum, payaccount;
    end

    istax = 0;
    taxnum = null;
    taxdate = null;
    taxsumvat = 0.000;
    taxsum = 0.000;
    treestr_id = null;
    singletaxn = null;
    select max(r.reestr_id)
        from  reestr r
      where r.document_id = :document_id
    into :treestr_id;

    if (:treestr_id is null) then treestr_id = 0;
    if (:treestr_id > 0) then istax = 1;

    select r.td_number, r.td_date, r.td_sum, r.td_sum_vat, r.td_sum_with_vat
      from reestr r
     where r.reestr_id = :treestr_id
      into taxnum, taxdate, taxsum,  taxsumvat, taxsumwvat;

    if (:typedoc = 1) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);

      sumin = sumdoc;
      sumwithvat = :tinsum_pdv;
      sumvat = :sumwithvat - :sumdoc;
    end

    if (:typedoc in (2, 17)) then
    begin
      sumdoc = calcsum(:tsumwithvat, :tsumwithvat - :tinsum, 0, :typevat, 6);
      sumin = :tinsum;
      sumwithvat = :tsumwithvat;
      sumvat = :sumwithvat - :sumdoc;

      if (:typedoc = 17) then
        typedoc = 5;
    end

    if (:typedoc = 4) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);
      sumwithvat = :tsumwithvat;
      sumin = :tinsum;
      sumvat = :sumwithvat - :sumdoc;

      docnum = :tkasses_id;
      ipn = '';
      select k.rn from kasses k
         where k.kasses_id = :tkasses_id
       into :ipn;
    end

    if ((istax = 1)and(:typedoc = 2)) then
    begin
      taxsum = sumdoc;
      taxsumwvat = sumwithvat;
      taxsumvat = sumvat;
      --if (:typedoc not in (1)) then
      taxdate = :docdate;
    end

    if (istax = 0) then
    begin
      taxsum = null;--sumdoc;
      taxsumwvat = null;-- sumwithvat;
      taxsumvat = null;--sumvat;
      taxdate = null;
      --if (:typedoc not in (1)) then
        --taxdate = :docdate;
    end

    if ((:typedoc = 4) and (:partcode is null)) then
      partner = 'Покупець';

    begin
      pint_partcode = cast(:partcode as integer);
      if (:pint_partcode between 10000 and 11111) then
        partcode = '10001';
      when any do
      begin
      end
    end

    if (((:partcode <> '10001') or (:partcode is null)) and (sumwithvat <> 0.00)) then
      suspend;

    docmarck = null;
    sumdoc = null;
    sumin = null;
    sumwithvat = null;
    sumvat = null;
    taxsumwvat = null;
    taxpayern = null;
  end

  partner = 'Покупець';
  partcode = '';
  address = '';
  phone = '';
  bankname = null;
  banknum = null;
  payaccount = null;
  bankname = '';
  banknum = '';
  payaccount = '';
  taxnum = '';
  taxpayern = null;
  istax = null;
  taxdate = null;
  taxsumwithvat = 0.00;
  taxsumvat = 0.00;
  taxsum = 0.00;
  singletaxn = null;
  taxsumwvat = null;
  doc_lock = 2;
  for select d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id,
             sum(around(gs.osum_pdv)),
             sum(dr.insum_pdv), sum(dr.insum)
        from documents d
             left join docrec dr on d.document_id = dr.document_id,
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11 and
             d.doc_lock in (1, 2) and
             isinliststr(:itypes, d.typedoc_id) = 1
    group by d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id
        into docdate, typevat, typepay, tkasses_id,
             tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:tkasses_id is null)  then tkasses_id = 0;
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    sumin = :tinsum;
    sumwithvat = :tsumwithvat;
    sumdoc = calcsum(:sumwithvat, (:sumwithvat - :sumin), 0, :typevat, 6);
    sumvat = :sumwithvat - :sumdoc;

    document_id = -:tkasses_id;
    docnum = :tkasses_id;
    ipn = '';
    select k.rn from kasses k
       where k.kasses_id = :tkasses_id
     into :ipn;

    typedoc = 3;
    suspend;
  end
end^


ALTER PROCEDURE PE_1C_SUMS_1_WITHOUT_PDV (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER)
AS
declare variable tinsum_pdv double precision;
declare variable tsumwithvat double precision;
declare variable tinsum double precision;
declare variable tobject_id integer;
declare variable tclient_id integer;
declare variable tsrc_dst_id integer;
declare variable taccount_id integer;
declare variable treestr_id integer;
declare variable tkasses_id integer;
declare variable pint_partcode integer;
begin
  idate1 = :idate1 - 1;

  select c.clients_code from clients c
   where c.clients_id = 1
    into object_num;

 for select d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
            d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id,
            sum(gs.osum_pdv), sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id,
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :idate0 and :idate1 and
            (((d.doc_lock = 2) or ((d.doc_lock = 1) and (d.typedoc_id = 4))) or (:iis_final <> 0)) and
            d.typedoc_id <> 11 and isinliststr(:itypes, d.typedoc_id) = 1 and
            dr.typepdv_id > 1
   group by d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
            d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id
       into doc_lock, document_id, typedoc, docdate, docnum, docmarck,
            tclient_id, tobject_id, typevat, typepay, tkasses_id,
            tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    if (:tclient_id <> 1) then
      tsrc_dst_id = :tclient_id;
    else if (:tobject_id <> 1) then
      tsrc_dst_id = :tobject_id;

    select c.name, c.zkpo, c.adress, c.ipn, c.numpdv, c.ispdv, c.ispdv, c.phone
      from clients c
     where c.clients_id = :tsrc_dst_id
      into partner, partcode, address, ipn, taxpayern, singletaxn, istaxpay, phone;

    taccount_id = null;
    bankname    = null;
    banknum     = null;
    payaccount  = null;

    select min(ca.account_id)
      from clientaccount ca
     where ca.clients_id = :tsrc_dst_id
      into taccount_id;

    if (not (:taccount_id is null)) then
    begin
      select b.name, b.mfo, ca.account_num
        from clientaccount ca left join banks b on ca.banks_id = b.banks_id
              where ca.account_id = :taccount_id
        into bankname, banknum, payaccount;
    end

    istax = 0;
    taxnum = null;
    taxdate = null;
    taxsumvat = 0.000;
    taxsum = 0.000;
    treestr_id = null;
    singletaxn = null;
    select max(r.reestr_id)
        from  reestr r
      where r.document_id = :document_id
    into :treestr_id;

    if (:treestr_id is null) then treestr_id = 0;
    if (:treestr_id > 0) then istax = 1;

    select r.td_number, r.td_date, r.td_sum, r.td_sum_vat, r.td_sum_with_vat
      from reestr r
     where r.reestr_id = :treestr_id
      into taxnum, taxdate, taxsum,  taxsumvat, taxsumwvat;

    if (:typedoc = 1) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);

      sumin = sumdoc;
      sumwithvat = :tinsum_pdv;
      sumvat = :sumwithvat - :sumdoc;
    end

    if (:typedoc in (2, 17)) then
    begin
      sumdoc = calcsum(:tsumwithvat, :tsumwithvat - :tinsum, 0, :typevat, 6);
      sumin = :tinsum;
      sumwithvat = :tsumwithvat;
      sumvat = :sumwithvat - :sumdoc;

      if (:typedoc = 17) then
        typedoc = 5;
    end

    if (:typedoc = 4) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);
      sumwithvat = :tsumwithvat;
      sumin = :tinsum;
      sumvat = :sumwithvat - :sumdoc;

      docnum = :tkasses_id;
      ipn = '';
      select k.rn from kasses k
         where k.kasses_id = :tkasses_id
       into :ipn;
    end

    if ((istax = 1)and(:typedoc = 2)) then
    begin
      taxsum = sumdoc;
      taxsumwvat = sumwithvat;
      taxsumvat = sumvat;
      --if (:typedoc not in (1)) then
      taxdate = :docdate;
    end

    if (istax = 0) then
    begin
      taxsum = null;--sumdoc;
      taxsumwvat = null;-- sumwithvat;
      taxsumvat = null;--sumvat;
      taxdate = null;
      --if (:typedoc not in (1)) then
        --taxdate = :docdate;
    end

    if ((:typedoc = 4) and (:partcode is null)) then
      partner = 'Покупець';

    begin
      pint_partcode = cast(:partcode as integer);
      if (:pint_partcode between 10000 and 11111) then
        partcode = '10001';
      when any do
      begin
      end
    end

    if (((:partcode <> '10001') or (:partcode is null)) and (sumwithvat <> 0.00)) then
      suspend;

    docmarck = null;
    sumdoc = null;
    sumin = null;
    sumwithvat = null;
    sumvat = null;
    taxsumwvat = null;
    taxpayern = null;
  end

  partner = 'Покупець';
  partcode = '';
  address = '';
  phone = '';
  bankname = null;
  banknum = null;
  payaccount = null;
  bankname = '';
  banknum = '';
  payaccount = '';
  taxnum = '';
  taxpayern = null;
  istax = null;
  taxdate = null;
  taxsumwithvat = 0.00;
  taxsumvat = 0.00;
  taxsum = 0.00;
  singletaxn = null;
  taxsumwvat = null;
  doc_lock = 2;
  for select d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id,
             sum(around(gs.osum_pdv)),
             sum(dr.insum_pdv), sum(dr.insum)
        from documents d
             left join docrec dr on d.document_id = dr.document_id,
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11 and
             d.doc_lock in (1, 2) and
             isinliststr(:itypes, d.typedoc_id) = 1 and
             dr.typepdv_id > 1
    group by d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id
        into docdate, typevat, typepay, tkasses_id,
             tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:tkasses_id is null)  then tkasses_id = 0;
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    sumin = :tinsum;
    sumwithvat = :tsumwithvat;
    sumdoc = calcsum(:sumwithvat, (:sumwithvat - :sumin), 0, :typevat, 6);
    sumvat = :sumwithvat - :sumdoc;

    document_id = -:tkasses_id;
    docnum = :tkasses_id;
    ipn = '';
    select k.rn from kasses k
       where k.kasses_id = :tkasses_id
     into :ipn;

    typedoc = 3;
    suspend;
  end
end^


ALTER PROCEDURE PE_1C_SUMS_2 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER,
    SUMREAL NUMERIC(9,2))
AS
declare variable tinsum_pdv double precision;
declare variable tsumwithvat double precision;
declare variable tinsum double precision;
declare variable tobject_id integer;
declare variable tclient_id integer;
declare variable tsrc_dst_id integer;
declare variable taccount_id integer;
declare variable treestr_id integer;
declare variable tkasses_id integer;
declare variable pint_partcode integer;
begin
  idate1 = :idate1 - 1;

  select c.clients_code from clients c
      where c.clients_id = 1
    into :object_num;

  for select d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
             d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id, n.sg_id,
             sum(gs.osum_pdv),
             sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id
            join nomen n on n.nomen_id = dr.nomen_id,
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :idate0 and :idate1 and
            (((d.doc_lock = 2) or ((d.doc_lock = 1) and (d.typedoc_id = 4))) or (:iis_final <> 0)) and
            d.typedoc_id <> 11 and
            isinliststr(:itypes, d.typedoc_id) = 1
   group by d.doc_lock, d.document_id, d.typedoc_id, d.doc_date, d.doc_num, d.doc_mark,
            d.clients_id, d.objects_id, dr.typepdv_id, d.oplata_type, d.kasses_id, n.sg_id
       into doc_lock, document_id, typedoc, docdate, docnum, docmarck,
            tclient_id, tobject_id, typevat, typepay, tkasses_id, isedit1,
            tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:isedit1 is null) then isedit1 = 0;
    if ((:isedit1 <> 1) and (:isedit1 <> 4)) then isedit1 = 0;

    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

/*    if ((:doc_lock is null) or (:doc_lock <> 2)) then
        exception EX_NOT_LOCK; */

    if (:tclient_id <> 1) then
      tsrc_dst_id = :tclient_id;
    else if (:tobject_id <> 1) then
      tsrc_dst_id = :tobject_id;

    select c.name, c.zkpo, c.adress, c.ipn, c.numpdv, c.ipn, c.ispdv, c.phone
         from clients c
      where c.clients_id = :tsrc_dst_id
    into :partner, :partcode, :address, :ipn, :taxpayern, :singletaxn, :istaxpay, :phone;

    taccount_id = null;
    bankname = null;
    banknum = null;
    payaccount = null;

    select min(ca.account_id)
          from clientaccount ca
       where ca.clients_id = :tsrc_dst_id
    into :taccount_id;

    if (not (:taccount_id is null)) then
    begin
      select b.name, b.mfo, ca.account_num
        from clientaccount ca left join banks b on ca.banks_id = b.banks_id
              where ca.account_id = :taccount_id
      into :bankname, :banknum, :payaccount;
    end

    istax = 0;
    taxnum = null;
    taxdate = null;
    taxsumvat = 0.000;
    taxsum = 0.000;
    treestr_id = null;
    singletaxn = null;
    select max(r.reestr_id)
        from  reestr r
      where r.document_id = :document_id
    into :treestr_id;

    if (:treestr_id is null) then treestr_id = 0;
    if (:treestr_id > 0) then istax = 1;

    select r.td_number, r.td_date/*, r.td_sum, r.td_sum_vat, r.td_sum_with_vat*/
        from reestr r
      where r.reestr_id = :treestr_id
    into :taxnum, :taxdate/*, :taxsum,  :taxsumvat, :taxsumvat*/;

    sumreal = 0;

    if (:typedoc = 1) then
    begin
      select osum
        from ps_realis_by_document_sg(:document_id, :typevat, :isedit1)
      into :sumreal ;
    end

    if (:typedoc in (1, 4)) then
    begin
      sumdoc = calcsum(:tsumwithvat, 0, 0, :typevat, 6);
/*      sumdoc = :tinsum;  */
/*      sumin = :tinsum;  */
      sumin = sumdoc;
      sumwithvat = :tinsum_pdv;
      sumvat = :sumwithvat - :sumdoc;
    end

    if (:typedoc in (2, 17)) then
    begin
      sumdoc = calcsum(:tsumwithvat, :tsumwithvat - :tinsum, 0, :typevat, 6);
      sumin = :tinsum;
      sumwithvat = :tsumwithvat;
      sumvat = :sumwithvat - :sumdoc;

      if (typedoc = 17) then
        typedoc = 5;
    end

    if (:typedoc = 4) then
    begin
/*      document_id = -:tkasses_id;  */
      docnum = :tkasses_id;
      ipn = '';
      select k.rn from kasses k
         where k.kasses_id = :tkasses_id
       into :ipn;
    end

    if (istax = 1) then
    begin
      taxsum = sumdoc;
      taxsumwvat = sumwithvat;
      taxsumvat = sumvat;
      if (:typedoc not in (1)) then
        taxdate = :docdate;
    end

 /*   select oisedit1, oisedit2 from pe_1c_log_edit(:docdate, :typevat, :SUMWITHVAT,
                :SUMVAT, :SUMDOC, :sumin, :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM,
                :TAXDATE, :TAXSUMWITHVAT, :TAXSUMVAT, :TAXSUM, :typepay)
      into isedit1, isedit2;  */

    if ((:typedoc = 4) and (:partcode is null)) then
      partner = 'Покупець';

    begin
      pint_partcode = cast(:partcode as integer);
      if (:pint_partcode between 10000 and 11111) then
        partcode = '10001';
      when any do
      begin
      end
    end

    if (((:partcode <> '10001') or (:partcode is null)) and (sumwithvat <> 0.00)) then
      suspend;

    docmarck = null;
    sumdoc = null;
    sumin = null;
    sumwithvat = null;
    sumvat = null;
    taxsumwvat = null;
    taxpayern = null;
    isedit1 = null;
  end

  partner = 'Покупець';
  partcode = '';
  address = '';
  phone = '';
  bankname = null;
  banknum = null;
  payaccount = null;
  bankname = '';
  banknum = '';
  payaccount = '';
  taxnum = '';
  taxpayern = null;
  istax = null;
  taxdate = null;
  taxsumwithvat = 0.00;
  taxsumvat = 0.00;
  taxsum = 0.00;
  singletaxn = null;
  taxsumwvat = null;
  doc_lock = 2;
  for select d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id, n.sg_id,
             sum(around(gs.osum_pdv)), sum(dr.insum_pdv), sum(dr.insum)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join nomen n on(n.nomen_id = dr.nomen_id),
             ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11 and
             d.doc_lock in (1, 2) and
             isinliststr(:itypes, d.typedoc_id) = 1
    group by d.doc_date, dr.typepdv_id, d.oplata_type, d.kasses_id, n.sg_id
        into docdate, typevat, typepay, tkasses_id, isedit1,
             tsumwithvat, tinsum_pdv, tinsum
  do begin
    if (:isedit1 is null) then isedit1 = 0;
    if ((:isedit1 <> 1) and (:isedit1 <> 4)) then isedit1 = 0;

    if (:tkasses_id is null)  then tkasses_id = 0;
    if (:tsumwithvat is null) then tsumwithvat = 0.000;
    if (:tinsum is null)      then tinsum = 0.000;
    if (:tinsum_pdv is null)  then tinsum_pdv = 0.000;

    sumin = :tinsum;
    sumwithvat = :tsumwithvat;
    sumdoc = calcsum(:sumwithvat, (:sumwithvat - :sumin), 0, :typevat, 6);
    sumvat = :sumwithvat - :sumdoc;
    sumreal = 0;

    document_id = -:tkasses_id;
    docnum = :tkasses_id;
    ipn = '';
    select k.rn from kasses k
       where k.kasses_id = :tkasses_id
     into :ipn;

    typedoc = 3;

/*    select oisedit1, oisedit2 from pe_1c_log_edit(:docdate, :typevat, :SUMWITHVAT,
                :SUMVAT, :SUMDOC, :sumin, :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM,
                :TAXDATE, :TAXSUMWITHVAT, :TAXSUMVAT, :TAXSUM, :typepay)
      into isedit1, isedit2; */
    suspend;

    isedit1 = null;
  end
end^


ALTER PROCEDURE PE_1C_V1 (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000),
    IIS_FINAL SMALLINT)
RETURNS (
    DOCDATE DATE,
    TYPEDOC SMALLINT,
    PARTNER VARCHAR(100),
    PARTCODE VARCHAR(20),
    ADDRESS VARCHAR(100),
    PHONE VARCHAR(24),
    TAXPAYERN VARCHAR(20),
    SINGLETAXN VARCHAR(20),
    IPN VARCHAR(24),
    BANKNAME VARCHAR(100),
    BANKNUM VARCHAR(20),
    PAYACCOUNT VARCHAR(20),
    ISTAXPAY SMALLINT,
    TYPEVAT SMALLINT,
    TYPEPAY SMALLINT,
    SUMWITHVAT NUMERIC(9,2),
    SUMVAT NUMERIC(9,2),
    SUMDOC NUMERIC(9,2),
    SUMIN NUMERIC(9,2),
    DOCNUM VARCHAR(14),
    DOCMARCK VARCHAR(14),
    DOCUMENT_ID INTEGER,
    ISTAX SMALLINT,
    TAXNUM VARCHAR(20),
    TAXDATE DATE,
    TAXSUMWITHVAT NUMERIC(9,2),
    TAXSUMVAT NUMERIC(9,2),
    TAXSUM NUMERIC(9,2),
    ISEDIT1 INTEGER,
    ISEDIT2 INTEGER,
    TAXSUMWVAT NUMERIC(9,2),
    OBJECT_NUM INTEGER,
    DOC_LOCK INTEGER,
    OIS_FINAL SMALLINT,
    SUMREAL NUMERIC(9,2))
AS
declare variable tinsum_pdv double precision;
declare variable tsumwithvat double precision;
declare variable tinsum double precision;
declare variable tobject_id integer;
declare variable tclient_id integer;
declare variable tsrc_dst_id integer;
declare variable taccount_id integer;
declare variable treestr_id integer;
declare variable tkasses_id integer;
declare variable tmarker varchar(64);
begin
  select c.marker from t_configs c
      where c.config_id = 2 and
            c.module = 'export_1c'
    into :tmarker;

  if (:tmarker is null) then tmarker = 'no';

  if (:tmarker = 'yes') then
  begin

    for select DOCDATE, TYPEDOC, PARTNER, PARTCODE, ADDRESS, PHONE, TAXPAYERN, SINGLETAXN,
               IPN, BANKNAME, BANKNUM,  PAYACCOUNT, ISTAXPAY, TYPEVAT, TYPEPAY,
               sum(SUMWITHVAT), sum(SUMVAT), sum(SUMDOC), sum(SUMIN), DOCNUM, DOCMARCK,
               DOCUMENT_ID, ISTAX, TAXNUM, TAXDATE, sum(TAXSUMWVAT), sum(TAXSUMVAT),
               sum(TAXSUM), ISEDIT1, ISEDIT2, object_num, doc_lock, sum(SUMREAL)
        from  pe_1c_sums_2 (:IDATE0, :IDATE1, :ITYPES, :IIS_FINAL)
      group by DOCDATE, TYPEDOC, PARTNER, PARTCODE, ADDRESS, PHONE, TAXPAYERN, SINGLETAXN,
            IPN, BANKNAME, BANKNUM,  PAYACCOUNT, ISTAXPAY,
            TYPEVAT, TYPEPAY, DOCNUM, DOCMARCK, DOCUMENT_ID, ISTAX, TAXNUM, TAXDATE,
            ISEDIT1, ISEDIT2, object_num, doc_lock
        into :DOCDATE, :TYPEDOC, :PARTNER, :PARTCODE, :ADDRESS, :PHONE, :TAXPAYERN,
             :SINGLETAXN, :IPN, :BANKNAME, :BANKNUM,  :PAYACCOUNT, :ISTAXPAY,
             :TYPEVAT, :TYPEPAY, :SUMWITHVAT, :SUMVAT, :SUMDOC, :SUMIN, :DOCNUM,
             :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM, :TAXDATE, :TAXSUMWVAT,
             :TAXSUMVAT, :TAXSUM, :ISEDIT1, :ISEDIT2, :object_num, :doc_lock, :sumreal
    do begin
      isedit2 = :iis_final;
      suspend;
    end

  end
  else
  begin

    for select DOCDATE, TYPEDOC, PARTNER, PARTCODE, ADDRESS, PHONE, TAXPAYERN,
               SINGLETAXN, IPN, BANKNAME, BANKNUM,  PAYACCOUNT, ISTAXPAY,
               TYPEVAT, TYPEPAY, SUMWITHVAT, SUMVAT, SUMDOC, SUMIN, DOCNUM, DOCMARCK,
               DOCUMENT_ID, ISTAX, TAXNUM, TAXDATE, TAXSUMWVAT, TAXSUMVAT, TAXSUM,
               ISEDIT1, ISEDIT2, object_num, doc_lock
        from  pe_1c_sums_1 (:IDATE0, :IDATE1, :ITYPES, :IIS_FINAL)
      into :DOCDATE, :TYPEDOC, :PARTNER, :PARTCODE, :ADDRESS, :PHONE, :TAXPAYERN,
           :SINGLETAXN, :IPN, :BANKNAME, :BANKNUM,  :PAYACCOUNT, :ISTAXPAY,
           :TYPEVAT, :TYPEPAY, :SUMWITHVAT, :SUMVAT, :SUMDOC, :SUMIN, :DOCNUM,
           :DOCMARCK, :DOCUMENT_ID, :ISTAX, :TAXNUM, :TAXDATE,
           :TAXSUMWVAT, :TAXSUMVAT, :TAXSUM, :ISEDIT1, :ISEDIT2, :object_num, :doc_lock
    do begin
      isedit2 = :iis_final;
      SUMREAL = 0;
      suspend;
    end 

  end
end^


ALTER PROCEDURE PR_CALCULATION
RETURNS (
    OCALCULATION_ID INTEGER,
    OCALC_NOMEN_ID INTEGER,
    OCALC_NOMEN_CODE VARCHAR(7),
    OCALC_NOMEN_NAME VARCHAR(40),
    OREC_NOMEN_ID INTEGER,
    OREC_NOMEN_CODE VARCHAR(7),
    OREC_NOMEN_NAME VARCHAR(40))
AS
begin
  for select c.calculation_id, c.nomen_id, n1.nomen_code, n1.nomen_name,
             cr.nomen_id, n2.nomen_code, n2.nomen_name
    from t_calculations c
         inner join nomen n1 on (c.nomen_id = n1.nomen_id)
         left join t_calc_records cr on (c.calculation_id = cr.calculation_id)
         inner join nomen n2 on (cr.nomen_id = n2.nomen_id)
    into ocalculation_id, ocalc_nomen_id, ocalc_nomen_code, ocalc_nomen_name,
         orec_nomen_id, orec_nomen_code, orec_nomen_name
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PR_CLIENT_HEADER (
    ICLIENT_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OOBJECT_NAME VARCHAR(50),
    OOBJECT_SHOT_NAME VARCHAR(30),
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHOT_NAME VARCHAR(30),
    ODATE0 DATE,
    ODATE1 DATE,
    OOBJECT_ADRESS VARCHAR(50),
    OCLIENT_ADRESS VARCHAR(50))
AS
begin
  odate0 = :idate0;
  odate1 = :idate1;
  select cl.name, cl.shortname, cl.adress
    from clients cl where cl.clients_id = 1
    into oobject_name, oobject_shot_name, oobject_adress;

  select cl.name, cl.shortname, cl.adress
    from clients cl where cl.clients_id = :iclient_id
    into oclient_name, oclient_shot_name, oclient_adress;

  suspend;
end^


ALTER PROCEDURE PR_DEBITORKA (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2))
AS
declare variable pobject_name varchar(50);
declare variable ptype_doc integer;
begin
  opay_sum_pdv = 0.00;

 for select c.name, d.oplata_type, sum(gs.osum_pdv), o.name, d.typedoc_id
       from documents d
            left join docrec dr on (d.document_id = dr.document_id)
            left join clients c on (d.clients_id  = c.clients_id)
            left join clients o on (d.objects_id  = o.clients_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :idate_0 and :idate_1 and
            d.typedoc_id  in (2, 4)
   group by c.name, d.oplata_type, o.name, d.typedoc_id
        into oclient_name, otypepay_id, odoc_sum_pdv, pobject_name, ptype_doc
  do begin
    if (:ptype_doc = 4) then
    begin
      oclient_name = :pobject_name;
      odoc_sum_pdv = -:odoc_sum_pdv;
    end
    suspend;
  end

  odoc_sum_pdv = 0.00;
 for select c.name, p.pay_type_id, sum(p.pay_sum)
       from documents d, clients c, t_pays p
      where p.pay_date between :idate_0 and :idate_1 and
            d.clients_id  = c.clients_id  and
            d.document_id = p.document_id and
            d.typedoc_id  = 2
   group by c.name, p.pay_type_id
       into oclient_name, otypepay_id, opay_sum_pdv
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PR_DEBITORKA_CLNT_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    ONOMEN_NAME VARCHAR(40),
    OPAY_ID VARCHAR(14),
    OTYPE_PAY_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OIN_DEBT DOUBLE PRECISION)
AS
declare variable tdocument_id integer;
declare variable tpays_count integer;
declare variable ttypedoc_id integer;
declare variable tobject_name varchar(50);
declare variable pall_sum double precision;
declare variable pdisc_percent double precision;
declare variable pall_kilk double precision;
declare variable pmin_date date;
begin
  opay_sum_pdv = 0.00;
  select min(d.doc_date) from documents d
   where d.clients_id = :iclient_id or
         d.objects_id = :iclient_id
    into pmin_date;

 select sum(df.odoc_sum_pdv - df.opay_sum_pdv)
   from pr_debitorka_full(:pmin_date, (:idate_0 - 1)) df
  where df.oclient_id = :iclient_id
   into oin_debt;
  if (:oin_debt is null) then oin_debt = 0;

  for select d.doc_date, d.document_id, d.doc_num, d.doc_mark, c.name ,
             d.oplata_type, sum(gs.osum_pdv), d.typedoc_id, o.name, d.disc_persent,
             sum(dr.kilk)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.clients_id  = c.clients_id)
             join clients o on (d.objects_id  = o.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate_0 and :idate_1 and
             ((d.typedoc_id = 2 and d.clients_id = :iclient_id) or
             (d.typedoc_id = 4 and d.objects_id = :iclient_id))
    group by d.doc_date, d.document_id, d.doc_num, d.doc_mark, c.name ,
             d.oplata_type, d.typedoc_id, o.name, d.disc_persent
  union
      select p.pay_date, cast(0 as integer), cast(p.pay_id as varchar(14)), cast('' as varchar(14)), cast(tp.typepay_name as varchar(50)),
             cast(0 as smallint), p.pay_sum, cast(0 as integer), cast('' as varchar(50)), cast(0 as double precision),
             cast(0 as double precision)
        from t_pays p
             join documents d on (p.document_id = d.document_id)
             join typepay tp  on (tp.typepay_id = p.pay_type_id)
       where d.clients_id = :iclient_id and
             p.pay_date between :idate_0 and :idate_1
    order by 1

        into odoc_date, tdocument_id, odoc_num, odoc_mark, oclient_name,
             otypepay_id, pall_sum, ttypedoc_id, tobject_name, pdisc_percent,
             pall_kilk
  do begin
    if (:tdocument_id > 0) then
    begin
       opay_id = null;
       opay_date = null;
       opay_sum_pdv = null;
       otype_pay_name = null;
      for select n.nomen_name, gs.osum_pdv, dr.kilk
            from docrec dr
                 join nomen n on (dr.nomen_id = n.nomen_id)
                 left join ps_get_sum(dr.docrec_id,  :pdisc_percent, dr.disc_persent) gs on 1=1
           where dr.document_id = :tdocument_id
        order by dr.docrec_id
            into onomen_name, odoc_sum_pdv, odoc_kilk
      do begin
        if (:ttypedoc_id = 4) then
        begin
          odoc_sum_pdv = -:odoc_sum_pdv;
          odoc_kilk    = -:odoc_kilk;
          oclient_name = :tobject_name;
        end
        suspend;
      end

      odoc_sum_pdv = :pall_sum;
      odoc_kilk    = :pall_kilk;
      if (:ttypedoc_id = 4) then
      begin
        odoc_sum_pdv = -:pall_sum;
        odoc_kilk    = -:pall_kilk;
        oclient_name = :tobject_name;
      end
      odoc_num = null;
      odoc_mark = null;
      odoc_date = null;
      oclient_name = null;
      otypepay_id = null;
      odoc_kilk   = null;
      onomen_name = '========== ВСЬОГО:';
      suspend;

    
      odoc_sum_pdv = null;
      onomen_name = null;
      select count(p.pay_id) from t_pays p
       where p.document_id = :tdocument_id
        into tpays_count;
    end
    else
    begin
      opay_id = :odoc_num;
      opay_date = :odoc_date;
      opay_sum_pdv = :pall_sum;
      otype_pay_name = :oclient_name;
      oclient_name = null;
      odoc_sum_pdv = null;
      odoc_num = null;
      odoc_date = null;
      odoc_mark = null;
      onomen_name = null;
      odoc_kilk = null;
      suspend;
    end
  end
end^


ALTER PROCEDURE PR_DEBITORKA_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER)
AS
declare variable tdocument_id integer;
declare variable tpays_count integer;
declare variable ttypedoc_id integer;
declare variable tobject_name varchar(50);
declare variable pobject_id integer;
begin
  opay_sum_pdv = 0.00;

  for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, sum(gs.osum_pdv), d.typedoc_id, o.name,
             c.clients_id, o.clients_id
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.clients_id  = c.clients_id)
             join clients o on (d.objects_id  = o.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate_0 and :idate_1 and
             d.typedoc_id  in (2, 4)
    group by d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, d.typedoc_id, o.name,
             c.clients_id, o.clients_id
        into tdocument_id, odoc_num, odoc_mark, odoc_date, oclient_name,
             otypepay_id, odoc_sum_pdv, ttypedoc_id, tobject_name,
             oclient_id, pobject_id
  do begin
    opay_sum_pdv = 0.00;

    select count(p.pay_id)
      from t_pays p
     where p.document_id = :tdocument_id
      into tpays_count;

   if (:ttypedoc_id = 4) then
   begin
     odoc_sum_pdv = -:odoc_sum_pdv;
     oclient_name = :tobject_name;
     oclient_id = :pobject_id;
   end

   if (:tpays_count = 0) then
   begin
     suspend;
   end
   if (:tpays_count > 0) then
   begin
    for select p.pay_type_id, p.pay_date, sum(p.pay_sum)
          from t_pays p
         where p.document_id = :tdocument_id
      group by p.pay_type_id, p.pay_date
          into otypepay_id, opay_date, opay_sum_pdv
    do begin
      suspend;
    end
   end
  end
end^


ALTER PROCEDURE PR_DISCOUNT_RALASE (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OKARDCODE VARCHAR(13),
    ONAME VARCHAR(50),
    OPERCENT DOUBLE PRECISION,
    ODOC_DATE DATE,
    ODOC_TIME TIME,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
declare variable pkards_id integer;
begin
  for select d.document_id, d.kards_id, d.doc_date, d.time_cr,
             sum(dr.price * dr.kilk), d.disc_persent
        from documents d, docrec dr
       where d.doc_date between :idate0 and :idate1 and
             d.kards_id is not null                 and
             d.document_id = dr.document_id
    group by d.document_id, d.kards_id, d.doc_date, d.time_cr, d.disc_persent
        into odocument_id, pkards_id, odoc_date, odoc_time,
             osum_out_pdv, opercent
  do begin
    select k.kardcode, k.name
      from kards k
     where k.kards_id = :pkards_id
      into okardcode, oname;
  suspend;
  end
end^


ALTER PROCEDURE PR_DOC_DEL (
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    ONOMEN_CODE VARCHAR(7),
    OCLIENT_NAME VARCHAR(50),
    OOBJECT_NAME VARCHAR(50),
    ONOMEN_NAME VARCHAR(40),
    OTYPEPDV_NAME VARCHAR(40),
    OTYPEDOC_NAME VARCHAR(30),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OUSER_NAME VARCHAR(12),
    OUSER_FULL_NAME VARCHAR(155),
    OUSER_DOCREC_NAME VARCHAR(12),
    ODOCUMENT_ID INTEGER,
    OWHATDO VARCHAR(30),
    ODOC_DATE DATE,
    ODOC_NUM VARCHAR(14),
    ODOC_MARK VARCHAR(14),
    OUSER_CONFIRM VARCHAR(155))
AS
declare variable tobjects_id integer;
declare variable tclients_id integer;
declare variable ttypedoc_id integer;
declare variable ttypepdv_id integer;
declare variable trights_grp_id integer;
begin
  select u.rights_grp_id from t_users u
   where u.user_login = user
    into trights_grp_id;

  if (:trights_grp_id <> 2) then
  begin
    exception user_isnotadmin;
  end
  else
  begin

  for select dd.document_id,  n.nomen_code, n.nomen_name, drd.price, drd.kilk,
             dd.typedoc_id, dd.disc_persent, dd.typedoc_id, dd.objects_id, dd.clients_id,
             dd.user_cr, drd.user_cr, drd.user_confirm, dd.doc_date, dd.doc_num, dd.doc_mark
        from doc_del dd
             left join docrec_del drd on (dd.document_id = drd.document_id)
             inner join nomen n on drd.nomen_id=n.nomen_id
       where (cast(dd.date_cr as date) >= :idate_begin) and
             (cast(dd.date_cr as date) <= :idate_end)
       order by drd.docrec_id
        into odocument_id, onomen_code, onomen_name, oprice, okilk,
             ttypepdv_id, odisc_persent, ttypedoc_id, tobjects_id, tclients_id,
             ouser_name, ouser_docrec_name, ouser_confirm, odoc_date, odoc_num, odoc_mark
  do begin
      select c.name  from clients c
       where c.clients_id = :tclients_id
        into oclient_name;

      select u.user_surname || ' ' || u.user_first_name || ' ' || u.user_second_name
        from t_users u where u.user_login = :ouser_name
        into ouser_full_name;

      select c.name from clients c
       where c.clients_id = :tobjects_id
        into oobject_name;

      select t.typepdv_name
        from typepdv t
       where t.typepdv_id = :ttypepdv_id
        into otypepdv_name;

      select td.typedoc_name
        from typedoc  td
       where td.typedoc_id = :ttypedoc_id
        into otypedoc_name;

      owhatdo = 'документ';
    suspend;
  end



 for select dd.document_id,  n.nomen_code, n.nomen_name, drt.price, drt.kilk,
            dd.typedoc_id, dd.disc_persent, dd.typedoc_id, dd.objects_id, dd.clients_id,
            dd.user_name, drt.user_cr, dd.doc_date, dd.doc_num, dd.doc_mark, drt.user_confirm
       from docrec_tmp drt
            inner join documents dd on dd.document_id = drt.document_id
            inner join nomen n on drt.nomen_id = n.nomen_id
      where (cast(drt.date_cr as date) between :idate_begin and :idate_end)
       into odocument_id, onomen_code, onomen_name, oprice, okilk,
            ttypepdv_id, odisc_persent, ttypedoc_id, tobjects_id, tclients_id,
            ouser_name, ouser_docrec_name, odoc_date, odoc_num, odoc_mark, ouser_confirm
 do begin
      select c.name from clients c
       where c.clients_id = :tclients_id
        into oclient_name;

      select u.user_surname || ' ' || u.user_first_name || ' ' || u.user_second_name
        from t_users u where u.user_login = :ouser_name
        into ouser_full_name;

      select c.name from clients c
       where c.clients_id = :tobjects_id
        into oobject_name;

      select t.typepdv_name from typepdv t
       where t.typepdv_id = :ttypepdv_id
        into otypepdv_name;

      select td.typedoc_name from typedoc  td
       where td.typedoc_id = :ttypedoc_id
        into otypedoc_name;
    owhatdo = 'позиції';
    suspend;
  end

for select dd.document_id,  n.nomen_code, n.nomen_name, drl.price, (drl.kilk_new - drl.kilk_old),
           dd.typedoc_id, dd.disc_persent, dd.typedoc_id, dd.objects_id, dd.clients_id,
           dd.user_name, drl.user_crt, dd.doc_date, dd.doc_num, dd.doc_mark, drl.user_confirm
      from docrec_log drl
           inner join documents dd on dd.document_id = drl.document_id
           inner join nomen n on drl.nomen_id = n.nomen_id
     where (cast(drl.date_crt as date) between :idate_begin and :idate_end)
      into odocument_id, onomen_code, onomen_name, oprice, okilk,
           ttypepdv_id, odisc_persent, ttypedoc_id, tobjects_id, tclients_id,
           ouser_name, ouser_docrec_name, odoc_date, odoc_num, odoc_mark, ouser_confirm
 do begin
      select c.name from clients c
       where c.clients_id = :tclients_id
        into oclient_name;

      select u.user_surname || ' ' || u.user_first_name || ' ' || u.user_second_name
        from t_users u where u.user_login = :ouser_name
        into ouser_full_name;

      select c.name from clients c
       where c.clients_id = :tobjects_id
        into oobject_name;

      select t.typepdv_name from typepdv t
       where t.typepdv_id = :ttypepdv_id
        into otypepdv_name;

      select td.typedoc_name from typedoc  td
       where td.typedoc_id = :ttypedoc_id
        into otypedoc_name;

      owhatdo = 'зменьшення к-ті';
  suspend;
 end

  end

when exception user_isnotadmin do
begin
end

end^


ALTER PROCEDURE PR_DOCREC_SUM_TYPY_PDV (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION,
    TYPE_PDV INTEGER)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_docrec_id integer;
declare variable p_kilk double precision;
declare variable p_main_price double precision;
declare variable p_price_out_pdv double precision;
declare variable p_sum_out_pdv double precision;
declare variable p_sum_in_pdv double precision;
declare variable p_sum_in double precision;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_disc_persent double precision;
declare variable p_sum_disc_persent double precision;
declare variable p_count_rec integer;
begin
  /* procedure text */
 sum_out_pdv = 0.000;
 sum_out     = 0.000;
 sum_in_pdv  = 0.000;
 sum_in      = 0.000;
 if (:disc_persent is null) then disc_persent = 0.000;
 p_sum_disc_persent = 0.000;
 p_count_rec        = 0;
 for select dr.docrec_id, dr.kilk, dr.price, dr.typepdv_id, dr.typepdv_pdv,
            dr.disc_persent, dr.insum_pdv, dr.insum
       from docrec dr
      where dr.document_id = :documents_id and
            dr.typepdv_id  = :type_pdv
       into p_docrec_id, p_kilk, p_main_price, p_typepdv_id, p_typepdv_pdv,
            p_disc_persent, p_sum_in_pdv, p_sum_in
 do begin
  if ((:p_disc_persent is null) or (:p_disc_persent=0.000)) then begin
    p_sum_disc_persent = :p_sum_disc_persent + :disc_persent;
   end
  else begin
    p_sum_disc_persent = :p_sum_disc_persent + :p_disc_persent;
   end

  p_count_rec = :p_count_rec + 1;
  select oprice_pdv, osum_pdv from ps_get_sum(:p_docrec_id, :disc_persent, :p_disc_persent)
    into p_price_out_pdv, p_sum_out_pdv;

  sum_in_pdv  = :sum_in_pdv  + :p_sum_in_pdv;
  sum_out_pdv = :sum_out_pdv + :p_sum_out_pdv;

  sum_in  = :sum_in + :p_sum_in;
  sum_out = :sum_out + calcsum(:p_sum_out_pdv, :p_sum_out_pdv-:p_sum_in_pdv, :p_typepdv_pdv, :p_typepdv_id, 0);

 end
 if (:p_count_rec <> 0) then begin
   avg_disc_persent = (:p_sum_disc_persent/:p_count_rec);
  end
 else begin
  avg_disc_persent = :disc_persent;
 end
 suspend;
end^


ALTER PROCEDURE PR_DOCUMENTS_PERIOD (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER,
    ITYPE_PDV INTEGER)
RETURNS (
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OCLIENT_NAME VARCHAR(50),
    OINSUM DOUBLE PRECISION,
    OOUTSUM DOUBLE PRECISION,
    OMARKUP DOUBLE PRECISION,
    ODISCOUNT_SUM DOUBLE PRECISION,
    OPDV_SUM DOUBLE PRECISION,
    OOUTSUM_PDV DOUBLE PRECISION,
    OSTORE_SUM DOUBLE PRECISION)
AS
declare variable pdisc_persent double precision;
declare variable ptype_pdv integer;
begin
  ptype_pdv = :itype_pdv;

  document_id   = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  odoc_num      = null;
  odoc_date     = null;
  oclient_name  = 'ПРИХОДИ';
  oinsum        = null;
  ooutsum       = null;
  omarkup       = null;
  odiscount_sum = null;
  opdv_sum      = null;
  ooutsum_pdv   = null;
  ostore_sum    = null;
  suspend;

  for select d.doc_date, d.doc_num, c.name, dv.sum_in, dv.sum_out,
             d.disc_persent, dv.sum_out_pdv
        from documents d
             left join clients c on d.objects_id = c.clients_id
             left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :ptype_pdv) dv on 1 = 1
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id in (1, 4, 7, 14) and
             d.doc_lock > 0 and
             d.clients_id = 1
    order by d.doc_date
        into odoc_date, odoc_num, oclient_name, oinsum, ooutsum,
             pdisc_persent, ooutsum_pdv
  do begin
    omarkup = :ooutsum - :oinsum;
    opdv_sum = :ooutsum_pdv - :ooutsum;
    ostore_sum = :ooutsum_pdv;
    odiscount_sum = (:ooutsum_pdv * 100) / (100 - :pdisc_persent);
    if (odiscount_sum is null) then odiscount_sum = 0;
    if (:ostore_sum != 0) then  suspend;
  end
  odoc_num      = null;
  odoc_date     = null;
  oclient_name  = 'ВИДАТКИ';
  oinsum        = null;
  ooutsum       = null;
  omarkup       = null;
  odiscount_sum = null;
  opdv_sum      = null;
  ooutsum_pdv   = null;
  ostore_sum    = null;
  suspend;

  for select d.doc_date, d.doc_num, c.name, dv.sum_in, dv.sum_out,
             d.disc_persent, dv.sum_out_pdv
        from documents d
             left join clients c on d.clients_id = c.clients_id
             left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :ptype_pdv) dv on 1 = 1
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id in (2, 6, 14, 15, 17) and
             d.doc_lock > 0 and
             d.objects_id = 1
    order by d.doc_date
        into odoc_date, odoc_num, oclient_name, oinsum, ooutsum,
             pdisc_persent, ooutsum_pdv
  do begin
    omarkup = :ooutsum - :oinsum;
    opdv_sum = :ooutsum_pdv - :ooutsum;
    ostore_sum = :ooutsum_pdv;
    odiscount_sum = (:ooutsum_pdv * 100) / (100 - :pdisc_persent);
    if (odiscount_sum is null) then odiscount_sum = 0;
    if (:ostore_sum != 0) then  suspend;
  end
  odoc_num      = null;
  odoc_date     = null;
  oclient_name  = 'ГОТІВКА';
  oinsum        = null;
  ooutsum       = null;
  omarkup       = null;
  odiscount_sum = null;
  opdv_sum      = null;
  ooutsum_pdv   = null;
  ostore_sum    = null;
  suspend;
  oclient_name  = 'Чеки за період';
  for select --d.odate, d.doc_num, c.name,
             sum(dv.sum_in), sum(dv.sum_out), avg(d.disc_persent), sum(dv.sum_out_pdv)
        from documents d
             left join clients c on d.objects_id = c.clients_id
             left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :ptype_pdv) dv on 1 = 1
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id = 11 and
             d.doc_lock > 0
    --order by d.doc_date
        into --odoc_date, odoc_num, oclient_name,
             oinsum, ooutsum, pdisc_persent, ooutsum_pdv
  do begin
    omarkup = :ooutsum - :oinsum;
    opdv_sum = :ooutsum_pdv - :ooutsum;
    ostore_sum = :ooutsum_pdv;
    odiscount_sum = (:ooutsum_pdv * 100) / (100 - :pdisc_persent);
    if (odiscount_sum is null) then odiscount_sum = 0;
    if (:ostore_sum != 0) then  suspend;
  end
end^


ALTER PROCEDURE PR_DOCUMENTS_PERIOD_HEADER (
    DOCUMENT_ID INTEGER,
    DATE0 DATE,
    DATE1 DATE,
    ITYPE_PDV INTEGER)
RETURNS (
    ODATE0 DATE,
    ODATE1 DATE,
    OEND_INSUM DOUBLE PRECISION,
    OEND_OUTSUM DOUBLE PRECISION,
    OROZH_INSUM DOUBLE PRECISION,
    OROZH_OUTSUM DOUBLE PRECISION,
    OPRIH_INSUM DOUBLE PRECISION,
    OPRIH_OUTSUM DOUBLE PRECISION,
    OBEGIN_INSUM DOUBLE PRECISION,
    OBEGIN_OUTSUM DOUBLE PRECISION)
AS
declare variable PMIN_DATE date;
declare variable PBEGIN_ROZH_INSUM double precision;
declare variable PBEGIN_ROZH_OUTSUM double precision;
declare variable PBEGIN_PRIH_INSUM double precision;
declare variable PBEGIN_PRIH_OUTSUM double precision;
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  odate0 = :date0;
  odate1 = :date1;

  select min(doc_date) from documents
    into pmin_date;

  select sum(dv.sum_in), sum(dv.sum_out_pdv)
    from documents d
         left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :itype_pdv) dv on 1 = 1
   where d.doc_date between :pmin_date and (:date0 - 1) and
         d.typedoc_id in (1, 4, 7, 14) and
         d.doc_lock > 0 and
         d.clients_id = 1
    into pbegin_prih_insum, pbegin_prih_outsum;

  select sum(dv.sum_in), sum(dv.sum_out_pdv)
        from documents d
           --  left join clients c on d.clients_id = c.clients_id
             left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :itype_pdv) dv on 1 = 1
       where d.doc_date between :pmin_date and (:date0 - 1) and
             d.typedoc_id in (2, 6, 14, 15, 11, 17) and
             d.doc_lock > 0 and
             d.objects_id = 1
    into pbegin_rozh_insum, pbegin_rozh_outsum;

  select sum(dv.sum_in), sum(dv.sum_out_pdv)
    from documents d
         left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :itype_pdv) dv on 1 = 1
   where d.doc_date between :date0 and :date1 and
         d.typedoc_id in (1, 4, 7, 14) and
         d.doc_lock > 0 and
         d.clients_id = 1
    into oprih_insum, oprih_outsum;

  select sum(dv.sum_in), sum(dv.sum_out_pdv)
        from documents d
           --  left join clients c on d.clients_id = c.clients_id
             left join pr_docrec_sum_typy_pdv(d.document_id, d.disc_persent, :itype_pdv) dv on 1 = 1
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id in (2, 6, 14, 15, 11, 17) and
             d.doc_lock > 0 and
             d.objects_id = 1
    into orozh_insum, orozh_outsum;


    if (oprih_insum is null)  then oprih_insum  = 0;
    if (oprih_outsum is null) then oprih_outsum = 0;
    if (orozh_insum is null)  then orozh_insum  = 0;
    if (orozh_outsum is null) then orozh_outsum = 0;

    if (pbegin_prih_insum is null)  then pbegin_prih_insum  = 0;
    if (pbegin_prih_outsum is null) then pbegin_prih_outsum = 0;
    if (pbegin_rozh_insum is null)  then pbegin_rozh_insum  = 0;
    if (pbegin_rozh_outsum is null) then pbegin_rozh_outsum = 0;

  obegin_insum  = :pbegin_prih_insum - :pbegin_rozh_insum;
  obegin_outsum = :pbegin_prih_outsum - :pbegin_rozh_outsum;
  oend_insum = :obegin_insum + :oprih_insum - :orozh_insum;
  oend_outsum = :obegin_outsum + :oprih_outsum - :orozh_outsum;

  suspend;
end^


ALTER PROCEDURE PR_INVOICE_PAYS_DEBT (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER,
    OPAY_ID INTEGER,
    OAMOUNT_DAYS SMALLINT,
    OREAL_DEBT_SUM DOUBLE PRECISION,
    OFORMAL_DEBT_SUM DOUBLE PRECISION)
AS
declare variable tdocument_id integer;
declare variable ppays_count integer;
declare variable ttypedoc_id integer;
declare variable tobject_name varchar(50);
declare variable pobject_id integer;
declare variable pall_pay_sum double precision;
declare variable pobjects_amount_days integer;
declare variable ppay_num integer;
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  opay_sum_pdv = 0.00;

  for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, sum(gs.osum_pdv), d.typedoc_id, o.name,
             c.clients_id, o.clients_id, c.amount_days, o.amount_days
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.clients_id  = c.clients_id)
             join clients o on (d.objects_id  = o.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id  in (2, 4)
    group by d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, d.typedoc_id, o.name,
             c.clients_id, o.clients_id, c.amount_days, o.amount_days
        into tdocument_id, odoc_num, odoc_mark, odoc_date, oclient_name,
             otypepay_id, odoc_sum_pdv, ttypedoc_id, tobject_name,
             oclient_id, pobject_id, oamount_days, pobjects_amount_days
  do begin
    opay_sum_pdv = 0.00;

   if (:ttypedoc_id = 4) then
   begin
     odoc_sum_pdv = -:odoc_sum_pdv;
     oclient_name = :tobject_name;
     oclient_id = :pobject_id;
     oamount_days = :pobjects_amount_days;
   end

   select sum(p.pay_sum), count(p.pay_id) from t_pays p
    where p.document_id = :tdocument_id
     into pall_pay_sum, ppays_count;
/*$$IBEC$$    select count(p.pay_id) from t_pays p
    where p.document_id = :tdocument_id
     into ppays_count; $$IBEC$$*/
   ppay_num = 0;

   if (:ppays_count = 0) then
   begin
     oreal_debt_sum   = :odoc_sum_pdv;
     if ((:date1 - :odoc_date) > :oamount_days ) then
       oformal_debt_sum = :oreal_debt_sum;
     else
       oformal_debt_sum = null;
     suspend;

     oclient_name = null;
     otypepay_id  = null;
     odoc_sum_pdv = null;
     opay_sum_pdv = null;
     odoc_num  = null;
     odoc_date = null;
     opay_date = null;
     odoc_mark  = null;
     oclient_id = null;
     opay_id    = null;
   --  oamount_days = null;
     oformal_debt_sum = null;
   end else /*if (:ppays_count = 0) then*/
   begin
     for select p.pay_id, p.pay_type_id, p.pay_date, p.pay_sum
           from t_pays p
          where p.document_id = :tdocument_id
           into opay_id, otypepay_id, opay_date, opay_sum_pdv
     do begin
       ppay_num = :ppay_num + 1;
       oreal_debt_sum = null;
       oformal_debt_sum = null;

       if (:ppay_num != :ppays_count) then
       begin
         suspend;
         if (:ppay_num = 1) then
         begin
           oclient_name = null;
           otypepay_id  = null;
      --     odoc_sum_pdv = null;
           odoc_num   = null;
      --     odoc_date  = null;
           odoc_mark  = null;
           oclient_id = null;
           opay_id    = null;
         end
       end else /*if (:ppay_num != :ppays_count) then*/
       begin
        oreal_debt_sum   = :odoc_sum_pdv - :pall_pay_sum;
        if ((:date1 - :odoc_date) > :oamount_days ) then
          oformal_debt_sum = :oreal_debt_sum;
        else
          oformal_debt_sum = null;
        suspend;

        oclient_name = null;
        otypepay_id  = null;
        odoc_sum_pdv = null;
        opay_sum_pdv = null;
        odoc_num  = null;
        odoc_date = null;
        opay_date = null;
        odoc_mark  = null;
        oclient_id = null;
        opay_id    = null;
 --    oamount_days = null;
        oformal_debt_sum = null;
       end

    end
   end
  end
end^


ALTER PROCEDURE PR_INVOICE_PAYS_KRED (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER,
    OPAY_ID INTEGER,
    OAMOUNT_DAYS SMALLINT,
    OREAL_DEBT_SUM DOUBLE PRECISION,
    OFORMAL_DEBT_SUM DOUBLE PRECISION)
AS
declare variable tdocument_id integer;
declare variable ppays_count integer;
declare variable ttypedoc_id integer;
declare variable pall_pay_sum double precision;
declare variable ppay_num integer;
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  opay_sum_pdv = 0.00;

  for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, sum(gs.osum_pdv), d.typedoc_id,
             c.clients_id, c.amount_days
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.objects_id  = c.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :date0 and :date1 and
             d.typedoc_id  in (1, 4)
    group by d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name,
             d.oplata_type, d.typedoc_id,
             c.clients_id, c.amount_days
        into tdocument_id, odoc_num, odoc_mark, odoc_date, oclient_name,
             otypepay_id, odoc_sum_pdv, ttypedoc_id,
             oclient_id, oamount_days
  do begin
    opay_sum_pdv = 0.00;

   select sum(p.pay_sum), count(p.pay_id) from t_pays p
    where p.document_id = :tdocument_id
     into pall_pay_sum, ppays_count;
/*$$IBEC$$    select count(p.pay_id) from t_pays p
    where p.document_id = :tdocument_id
     into ppays_count; $$IBEC$$*/
   ppay_num = 0;

   if (:ppays_count = 0) then
   begin
     oreal_debt_sum   = :odoc_sum_pdv;
     if ((:date1 - :odoc_date) > :oamount_days ) then
       oformal_debt_sum = :oreal_debt_sum;
     else
       oformal_debt_sum = null;
     suspend;

     oclient_name = null;
     otypepay_id  = null;
     odoc_sum_pdv = null;
     opay_sum_pdv = null;
     odoc_num  = null;
     odoc_date = null;
     opay_date = null;
     odoc_mark  = null;
     oclient_id = null;
     opay_id    = null;
   --  oamount_days = null;
     oformal_debt_sum = null;
   end else /*if (:ppays_count = 0) then*/
   begin
     for select p.pay_id, p.pay_type_id, p.pay_date, p.pay_sum
           from t_pays p
          where p.document_id = :tdocument_id
           into opay_id, otypepay_id, opay_date, opay_sum_pdv
     do begin
       ppay_num = :ppay_num + 1;
       oreal_debt_sum = null;
       oformal_debt_sum = null;

       if (:ppay_num != :ppays_count) then
       begin
         suspend;
         if (:ppay_num = 1) then
         begin
           oclient_name = null;
           otypepay_id  = null;
      --     odoc_sum_pdv = null;
           odoc_num   = null;
      --     odoc_date  = null;
           odoc_mark  = null;
           oclient_id = null;
           opay_id    = null;
         end
       end else /*if (:ppay_num != :ppays_count) then*/
       begin
        oreal_debt_sum   = :odoc_sum_pdv - :pall_pay_sum;
        if ((:date1 - :odoc_date) > :oamount_days ) then
          oformal_debt_sum = :oreal_debt_sum;
        else
          oformal_debt_sum = null;
        suspend;

        oclient_name = null;
        otypepay_id  = null;
        odoc_sum_pdv = null;
        opay_sum_pdv = null;
        odoc_num  = null;
        odoc_date = null;
        opay_date = null;
        odoc_mark  = null;
        oclient_id = null;
        opay_id    = null;
 --    oamount_days = null;
        oformal_debt_sum = null;
       end

    end
   end
  end
end^


ALTER PROCEDURE PR_KARDS_RALASE (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OKARDCODE VARCHAR(13),
    ONAME VARCHAR(50),
    OPROCENT DOUBLE PRECISION,
    OSUMA DOUBLE PRECISION)
AS
begin
  for select k.kardcode, k.name, dc.procent, sum(gs.osum_pdv)
        from kards k
             join documents d on (d.kards_id = k.kards_id)
             left join docrec dr on (d.document_id = dr.document_id)
             join discont dc on (k.discont_id = dc.discont_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate0 and :idate1 and
             d.kards_id is not null and
             not(d.typedoc_id in (10))
    group by k.kardcode, k.name, dc.procent
        into okardcode, oname, oprocent, osuma
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PR_KREDITORKA (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2))
AS
begin
  opay_sum_pdv = 0.00;

  for select c.name, d.oplata_type, sum(gs.osum_pdv)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.objects_id = c.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate_0 and :idate_1 and
             d.typedoc_id in (1, 4)
    group by c.name, d.oplata_type
        into oclient_name, otypepay_id, odoc_sum_pdv
  do begin
    suspend;
  end

  odoc_sum_pdv = 0.00;
  for select c.name, p.pay_type_id, sum(p.pay_sum)
        from documents d, clients c, t_pays p
       where p.pay_date between :idate_0 and :idate_1 and
             d.objects_id = c.clients_id and
             d.document_id = p.document_id and
             d.typedoc_id = 1
    group by c.name, p.pay_type_id
        into oclient_name, otypepay_id, opay_sum_pdv
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PR_KREDITORKA_CLNT_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    ONOMEN_NAME VARCHAR(40),
    OPAY_ID VARCHAR(14),
    OTYPE_PAY_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OIN_DEBT DOUBLE PRECISION)
AS
declare variable tdocument_id integer;
declare variable tpays_count integer;
declare variable ttypedoc_id integer;
declare variable pall_sum double precision;
declare variable pdisc_percent double precision;
declare variable pall_kilk double precision;
declare variable pmin_date date;
begin
  opay_sum_pdv = 0.00;
  select min(d.doc_date) from documents d
   where d.clients_id = :iclient_id or
         d.objects_id = :iclient_id
    into pmin_date;

 select sum(df.odoc_sum_pdv - df.opay_sum_pdv)
   from pr_kreditorka_full(:pmin_date, (:idate_0 - 1)) df
  where df.oclient_id = :iclient_id
   into oin_debt;
  if (:oin_debt is null) then oin_debt = 0;

  for select d.doc_date, d.document_id, d.doc_num, d.doc_mark, c.name ,
             d.oplata_type, sum(gs.osum_pdv), d.typedoc_id, d.disc_persent,
             sum(dr.kilk)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join clients c on (d.objects_id  = c.clients_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :idate_0 and :idate_1 and
             (d.typedoc_id in (1, 4)) and
             d.objects_id = :iclient_id
    group by d.doc_date, d.document_id, d.doc_num, d.doc_mark, c.name ,
             d.oplata_type, d.typedoc_id, d.disc_persent
  union
      select p.pay_date, cast(0 as integer), cast(p.pay_id as varchar(14)), cast('' as varchar(14)), cast(tp.typepay_name as varchar(50)),
             cast(0 as smallint), p.pay_sum, cast(0 as integer), cast(0 as double precision),
             cast(0 as double precision)
        from t_pays p
             join documents d on (p.document_id = d.document_id)
             join typepay tp  on (tp.typepay_id = p.pay_type_id)
       where d.objects_id = :iclient_id and
             p.pay_date between :idate_0 and :idate_1
    order by 1

        into odoc_date, tdocument_id, odoc_num, odoc_mark, oclient_name,
             otypepay_id, pall_sum, ttypedoc_id, pdisc_percent,
             pall_kilk
  do begin
    if (:tdocument_id > 0) then
    begin
       opay_id = null;
       opay_date = null;
       opay_sum_pdv = null;
       otype_pay_name = null;
      for select n.nomen_name, gs.osum_pdv, dr.kilk
            from docrec dr
                 join nomen n on (dr.nomen_id = n.nomen_id)
                 left join ps_get_sum(dr.docrec_id,  :pdisc_percent, dr.disc_persent) gs on 1=1
           where dr.document_id = :tdocument_id
        order by dr.docrec_id
            into onomen_name, odoc_sum_pdv, odoc_kilk
      do begin
        suspend;
      end

      odoc_sum_pdv = :pall_sum;
      odoc_kilk    = :pall_kilk;
      odoc_num = null;
      odoc_mark = null;
      odoc_date = null;
      oclient_name = null;
      otypepay_id = null;
      odoc_kilk   = null;
      onomen_name = '========== ВСЬОГО:';
      suspend;

    
      odoc_sum_pdv = null;
      onomen_name = null;
      select count(p.pay_id) from t_pays p
       where p.document_id = :tdocument_id
        into tpays_count;
    end
    else
    begin
      opay_id = :odoc_num;
      opay_date = :odoc_date;
      opay_sum_pdv = :pall_sum;
      otype_pay_name = :oclient_name;
      oclient_name = null;
      odoc_sum_pdv = null;
      odoc_num = null;
      odoc_date = null;
      odoc_mark = null;
      onomen_name = null;
      odoc_kilk = null;
      suspend;
    end
  end
end^


ALTER PROCEDURE PR_KREDITORKA_FULL (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    OCLIENT_NAME VARCHAR(50),
    OTYPEPAY_ID INTEGER,
    ODOC_SUM_PDV NUMERIC(15,2),
    OPAY_SUM_PDV NUMERIC(15,2),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OPAY_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OCLIENT_ID INTEGER)
AS
declare variable tdocument_id integer;
declare variable tcount_pays integer;
begin
  opay_sum_pdv = 0.00;

 for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name, d.oplata_type,
            sum(gs.osum_pdv), d.clients_id
       from documents d
            left join docrec dr on (d.document_id = dr.document_id)
            join clients c on (d.objects_id  = c.clients_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :idate_0 and :idate_1 and
            d.typedoc_id  in (1, 4)
      group by d.document_id, d.doc_num, d.doc_mark, d.doc_date, c.name, d.oplata_type,
            d.clients_id
       into tdocument_id, odoc_num, odoc_mark, odoc_date, oclient_name, otypepay_id,
            odoc_sum_pdv, oclient_id
  do begin
    opay_sum_pdv = 0.00;

    select count(p.pay_id)
      from t_pays p
     where p.document_id = :tdocument_id
      into tcount_pays;

    if (:tcount_pays = 0) then
    begin
      suspend;
    end

    if (:tcount_pays > 0) then
    begin
      for select p.pay_type_id, p.pay_date, sum(p.pay_sum)
            from t_pays p
           where p.document_id = :tdocument_id
           group by p.pay_type_id, p.pay_date
            into otypepay_id, opay_date, opay_sum_pdv
      do begin
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE PR_LIGHTS (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OLOGIN VARCHAR(12),
    ONAME VARCHAR(170),
    ONOT_GOOD_COUNT INTEGER,
    OINDIFFERENTLY_COUNT INTEGER,
    OGOOD_COUNT INTEGER)
AS
declare variable pall_light integer;
begin
  for select d.user_name, u.user_surname || ' ' || u.user_first_name || ' ' || u.user_second_name,
             count(d.document_id)
        from documents d
             left join t_users u on u.user_login = d.user_name
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11
    group by d.user_name, u.user_surname, u.user_first_name, u.user_second_name
    order by d.user_name
        into ologin, oname, pall_light
  do begin
      select count(dp.light)
        from documents d
             join t_documents_prm dp on d.document_id = dp.document_id
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11 and
             d.user_name = :ologin and
             dp.light = 1
        into ogood_count;
      select count(dp.light)
        from documents d
             join t_documents_prm dp on d.document_id = dp.document_id
       where d.doc_date between :idate0 and :idate1 and
             d.typedoc_id = 11 and
             d.user_name = :ologin and
             dp.light = -1
        into onot_good_count;
      oindifferently_count = :pall_light - :ogood_count - :onot_good_count;
    suspend;
  end
end^


ALTER PROCEDURE PR_LIST_CHARGES (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODATEX_NAME VARCHAR(26),
    ONOMEN_NAME VARCHAR(50),
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    OSI_NAME VARCHAR(12),
    ODR_KILK DOUBLE PRECISION,
    ODR_IN_SUM DOUBLE PRECISION,
    ODR_SUM_OUT DOUBLE PRECISION,
    ODR_NATSINKA DOUBLE PRECISION,
    ODR_PDV DOUBLE PRECISION,
    ODR_SUM_OUT_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50))
AS
declare variable pgrp_id integer;
declare variable pgrp_name varchar(40);
declare variable pall_kilk double precision;
declare variable pall_sum_in double precision;
declare variable pall_sum_out double precision;
declare variable pall_natsinka double precision;
declare variable pall_pdv double precision;
declare variable pall_sum_out_pdv double precision;
declare variable ptd_id integer;
declare variable pobject_name varchar(40);
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  for select g.grp_id, g.grp_name
        from grp g
       where exists(select * from docrec dr
                      join nomen n on n.nomen_id = dr.nomen_id
                      join documents d on dr.document_id = d.document_id
                     where d.doc_date between :date0 and :date1 and
                           d.typedoc_id in (2, 4) and
                           n.grp_id = g.grp_id)
       order by g.grp_name
        into pgrp_id, pgrp_name
  do begin
    /*Вивід назви групи*/
    odatex_name = null;
    odoc_num = null;
    odoc_date = null;
    osi_name = null;
    odr_kilk = null;
    odr_in_sum = null;
    odr_sum_out = null;
    odr_natsinka = null;
    odr_pdv = null;
    odr_sum_out_pdv = null;
    oclient_name = null;
    onomen_name = :pgrp_name;
    suspend;
    /*Вивід елементів групи*/
    pall_kilk = 0;
    pall_sum_in = 0;
    pall_sum_out = 0;
    pall_natsinka = 0;
    pall_pdv = 0;
    pall_sum_out_pdv = 0;
    for select distinct n.datex_name, n.nomen_name, d.doc_num, d.doc_date, s.si_name,
               dr.kilk, dr.insum, calcsum(gs.osum_pdv, gs.osum_pdv - dr.insum_pdv, tp.pdv, tp.typepdv_id, 0),
               gs.osum_pdv, d.typedoc_id, c.shortname, o.shortname
          from documents d
               join (docrec dr
                          left join (nomen n
                               left join si s on s.si_id = n.si_id) on (n.nomen_id = dr.nomen_id)
                          left join typepdv tp on (dr.typepdv_id = tp.typepdv_id))
                 on dr.document_id = d.document_id
               left join clients c on c.clients_id = d.objects_id
               left join clients o on o.clients_id = d.clients_id
               left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs on 1=1
         where d.doc_date between :date0 and :date1 and
               d.typedoc_id in (2, 4) and
               n.grp_id = :pgrp_id
          into odatex_name, onomen_name, odoc_num, odoc_date, osi_name,
               odr_kilk, odr_in_sum, odr_sum_out,
               odr_sum_out_pdv, ptd_id, pobject_name, oclient_name
    do begin
      odr_natsinka = :odr_sum_out - :odr_in_sum;
      odr_pdv = :odr_sum_out_pdv - :odr_sum_out;
      if (:ptd_id = 4) then
      begin
        oclient_name = :pobject_name;
        odr_kilk = -:odr_kilk;
        odr_in_sum = -:odr_in_sum;
        odr_sum_out = -:odr_sum_out;
        odr_sum_out_pdv = -:odr_sum_out_pdv;
        odr_natsinka = -:odr_natsinka;
        odr_pdv = -:odr_pdv;
      end
      suspend;
      pall_kilk      = :pall_kilk     + :odr_kilk;
      pall_sum_in    = :pall_sum_in   + :odr_in_sum;
      pall_sum_out   = :pall_sum_out  + :odr_sum_out;
      pall_natsinka  = :pall_natsinka + :odr_natsinka;
      pall_pdv       = :pall_pdv      + :odr_pdv;
      pall_sum_out_pdv = :pall_sum_out_pdv + :odr_sum_out_pdv;
    end
    /*Вивід підсумку*/
    odatex_name = null;
    odoc_num = null;
    odoc_date = null;
    osi_name = null;
    odr_kilk = :pall_kilk;
    odr_in_sum = :pall_sum_in;
    odr_sum_out = :pall_sum_out;
    odr_natsinka = :pall_natsinka;
    odr_pdv = :pall_pdv;
    odr_sum_out_pdv = :pall_sum_out_pdv;
    oclient_name = null;
    onomen_name = '==Всього: '||:pgrp_name;
    suspend;
  end
end^


ALTER PROCEDURE PR_MAKER (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OMAKER_NAME VARCHAR(40),
    OSUM_TD2 DOUBLE PRECISION,
    OSUM_TD2_PDV DOUBLE PRECISION,
    OKILK_TD2 DOUBLE PRECISION,
    OSUM_TD17 DOUBLE PRECISION,
    OSUM_TD17_PDV DOUBLE PRECISION,
    OKILK_TD17 DOUBLE PRECISION,
    ODELTA_SUM DOUBLE PRECISION,
    ODELTA_SUM_PDV DOUBLE PRECISION,
    ODELTA_KILK DOUBLE PRECISION,
    OMAKER_ID INTEGER)
AS
begin
  for select m.maker_id, m.maker_name
        from maker m
    order by m.maker_name
        into omaker_id, omaker_name
  do begin
    select around(sum(ps.osum_pdv)), around(sum(calcsum(ps.osum_pdv, (ps.osum_pdv-dr.insum_pdv), dr.typepdv_pdv, dr.typepdv_id, 0))),
           around(sum(dr.kilk))
      from documents d
           left join docrec dr on dr.document_id = d.document_id
             left join nomen n on n.nomen_id = dr.nomen_id
           left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) ps on 1=1
     where d.doc_date between :idate0 and :idate1 and
           d.typedoc_id = 1 and
           d.doc_lock > 0 and
           n.maker_id = :omaker_id
      into osum_td2_pdv, osum_td2, okilk_td2;

    if (:osum_td2_pdv is null) then osum_td2_pdv = 0;
    if (:osum_td2  is null) then osum_td2 = 0;
    if (:okilk_td2 is null) then okilk_td2 = 0;

    select around(sum(ps.osum_pdv)), around(sum(calcsum(ps.osum_pdv, (ps.osum_pdv-dr.insum_pdv), dr.typepdv_pdv, dr.typepdv_id, 0))),
           around(sum(dr.kilk))
      from documents d
           left join docrec dr on dr.document_id = d.document_id
             left join nomen n on n.nomen_id = dr.nomen_id
           left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) ps on 1=1
     where d.doc_date between :idate0 and :idate1 and
           d.typedoc_id = 17 and
           d.doc_lock > 0 and
           n.maker_id = :omaker_id
      into osum_td17_pdv, osum_td17, okilk_td17;

    if (:osum_td17_pdv is null) then osum_td17_pdv = 0;
    if (:osum_td17  is null) then osum_td17 = 0;
    if (:okilk_td17 is null) then okilk_td17 = 0;

    odelta_kilk = around(:okilk_td2 - :okilk_td17);
    odelta_sum  = around(:osum_td2  - :osum_td17);
    odelta_sum_pdv = around(:osum_td2_pdv - :osum_td17_pdv);

    if ((:okilk_td17 != 0)or(:okilk_td2 != 0)) then
      suspend;
  end
end^


ALTER PROCEDURE PR_NILSEN (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    BARCODE VARCHAR(27),
    BARNAME VARCHAR(50),
    STOCK NUMERIC(10,2),
    SALESITEM NUMERIC(10,2),
    PRICE NUMERIC(10,2))
AS
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TNOMEN_CODE VARCHAR(7);
DECLARE VARIABLE TBARCODE_ID INTEGER;
DECLARE VARIABLE TBARCODES_CNT INTEGER;
begin
  for select rs.onomen_id, sum(rs.e_k) as e_k, sum(rs.r_k) as r_k
        from pr_ralase_nilsen(:idate0, :idate1) rs
      group by rs.onomen_id
   into :tnomen_id, :stock, :salesitem
  do begin
    if (:salesitem <> 0) then
    begin
      select n.out_price, n.nomen_code, n.nomen_name from nomen n
          where n.nomen_id = :tnomen_id
        into :price, :tnomen_code, :barname;

      select first(1) b.barcode_id, b.code from nom_bar nb, barcode b
          where nb.nomen_id = :tnomen_id and
                nb.barcode_id = b.barcode_id
         order by nb.nom_bar_id desc
        into :tbarcode_id, :barcode;

      tbarcodes_cnt = 1;
      if (:tbarcode_id is not null) then
        select count(nb.nom_bar_id) from nom_bar nb
            where nb.barcode_id = :tbarcode_id
          into :tbarcodes_cnt;

      if ((:barcode is null) or (:tbarcodes_cnt > 1)) then
        barcode = :tnomen_code;

      suspend;
    end
    barcode = null;
    tbarcode_id = null;
  end
end^


ALTER PROCEDURE PR_NILSEN_V1 (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    BARCODE VARCHAR(27),
    BARNAME VARCHAR(50),
    STOCK NUMERIC(10,2),
    SALESITEM NUMERIC(10,2),
    PRICE NUMERIC(10,2),
    GRP_ID INTEGER,
    GRP_FULLNAME VARCHAR(200))
AS
declare variable tnomen_id integer;
declare variable tnomen_code varchar(7);
declare variable tbarcode_id integer;
declare variable tbarcodes_cnt integer;
begin
  for select rs.onomen_id, sum(rs.e_k) as e_k, sum(rs.r_k) as r_k
        from pr_ralase_nilsen(:idate0, :idate1) rs
      group by rs.onomen_id
   into tnomen_id, stock, salesitem
  do begin
    if (:salesitem <> 0) then
    begin
      select n.out_price, n.nomen_code, n.nomen_name, n.grp_id
        from nomen n
       where n.nomen_id = :tnomen_id
        into price, tnomen_code, barname, grp_id;

      select g.grp_fullname
        from grp g
       where g.grp_id = :grp_id
        into grp_fullname;

      select first(1) b.barcode_id, b.code from nom_bar nb, barcode b
          where nb.nomen_id = :tnomen_id and
                nb.barcode_id = b.barcode_id
       order by nb.nom_bar_id desc
           into tbarcode_id, barcode;

      tbarcodes_cnt = 1;
      if (:tbarcode_id is not null) then
        select count(nb.nom_bar_id)
          from nom_bar nb
         where nb.barcode_id = :tbarcode_id
          into tbarcodes_cnt;

      if ((:barcode is null) or (:tbarcodes_cnt > 1)) then
        barcode = :tnomen_code;

      suspend;
    end
    barcode = null;
    tbarcode_id = null;
  end
end^


ALTER PROCEDURE PR_NOMEN_REV (
    IDATE0 DATE,
    IDATE1 DATE,
    IGRP_ID INTEGER)
RETURNS (
    OW3_NOMEN_ID INTEGER,
    ONOMEN_MANE VARCHAR(50),
    ONOMEN_CODE VARCHAR(7),
    OIS_VISIBLE INTEGER,
    ORGP_NAME VARCHAR(255),
    OGRP_ID INTEGER,
    OREST DOUBLE PRECISION)
AS
declare variable vnom_id integer;
begin
  for select n.nomen_id, n.nomen_code, n.nomen_name, n.grp_id, g.rgrp_full_name,
             n.is_visible, n.w3_nomen_id, r.rest
        from nomen n
             inner join t_grp_childs (:igrp_id) g on n.grp_id = g.rgrp_id
             inner join rst r on ((r.nomen_id = n.nomen_id)and(r.objects_id = 1))
       where ((r.rest not between -0.00001 and 0.00001)or(n.is_visible = 1)) and
             n.grp_id = g.rgrp_id and
             n.nomen_id not in (select rr.nomen_id from rev_records rr,revision r
                                 where r.revision_id = rr.revision_id and
                                       r.revision_date between :idate0 and :idate1)
        into vnom_id, onomen_code, onomen_mane, ogrp_id, orgp_name,
             ois_visible, ow3_nomen_id, orest
  do begin

    suspend;
  end
end^


ALTER PROCEDURE PR_NOMEN_WITH_BARCODE (
    ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OBARCODE VARCHAR(27))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pmax_barcode integer;
declare variable pgrp_id integer;
begin
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

  for select gr.rgrp_id, gr.rgrp_name from t_grp_childs(:id) gr
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id
        from nomen n, rst rt
            where n.nomen_id = rt.nomen_id and
                  n.grp_id = :ogrp_id and
                  rt.objects_id = 1 and
                  ((n.is_exist = 1)or(n.is_exist is null))
       into :onomen_id, :ocode, :ofull_name, :oshort_name, :oprice_out,
                 :oprice_in, :orest, :tmaker_id
      do begin
        select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

        if (:obarcodes_cnt>0) then
         begin
          select max(b.barcode_id) from barcode b, nom_bar nb
           where nb.nomen_id = :onomen_id and
                nb.barcode_id = b.barcode_id
           into :pmax_barcode;
          select b.code from barcode b
           where b.barcode_id = :pmax_barcode
          into :obarcode;
         end



       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;
       suspend;
       omaker_name = null;
       tmaker_id = null;
      end
    end
  end
end^


ALTER PROCEDURE PR_NOMENREPORT (
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    ODOC_MARK VARCHAR(14),
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    ODATE_CR DATE,
    OZKPO VARCHAR(20),
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OIN_SUMALL DOUBLE PRECISION,
    OIN_SUMALLPDV DOUBLE PRECISION,
    OINCOMINGDOC_SUM_TARE DOUBLE PRECISION,
    OINCOMINGDOC_SUM_NOTPDV DOUBLE PRECISION,
    OINCOMINGDOC_SUM_PDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV_TARE DOUBLE PRECISION,
    OOUTGOINGDOC_SUM_NOTPDV DOUBLE PRECISION,
    OOUT_SUM_TAX_OUTPDV DOUBLE PRECISION,
    OOUTGOINGDOC_SUMPDV_PDV DOUBLE PRECISION)
AS
declare variable tclient_id integer;
declare variable tspecialgroup_id integer;
declare variable ttypepdv integer;
declare variable ttype_pdv_pdv integer;
declare variable ttype_pdv_id integer;
declare variable tnomen_id integer;
declare variable tdate_markup_end timestamp;
declare variable tlock_date date;
declare variable ttime_fix time;
declare variable tdate_markup_begin timestamp;
declare variable tprice double precision;
declare variable tdoc_time_cr time;
declare variable tdocument_id integer;
declare variable tdocrec_id integer;
declare variable trest_begin double precision;
declare variable tkilk double precision;
begin
  /* Procedure Text */
for select d.document_id, d.objects_id, d.doc_mark, d.date_cr, d.doc_date,
           d.time_cr, d.lock_date, D.time_fix
      from DOCUMENTS d
     where (d.typedoc_id = 1) and
           (d.date_cr between :idate_begin and :idate_end)
     order by d.document_id
      into odocument_id, tclient_id, odoc_mark, odate_cr,  odoc_date,
           tdoc_time_cr, tlock_date, ttime_fix
  do
  begin
      select c.zkpo, c.name
        from clients c
       where c.clients_id = :tclient_id
        into ozkpo, onameclient;

      /* сума по всьому товару */
      select around(sum(dr.insum)), around(sum(dr.insum_pdv))
        from docrec dr
       where :odocument_id = dr.document_id
        into oin_sumall, oin_sumallpdv;

      /*сума по товару що оподатковується */
      select around(sum(dr.insum)), around(sum(dr.insum_pdv))
        from docrec dr, nomen n, documents d
       where (:odocument_id  = dr.document_id) AND
             (dr.document_id = d.document_id ) and
             (d.typedoc_id  != 10            ) and
             (n.nomen_id     =  dr.nomen_id  ) and
             (n.typepdv_id   in (2,3)        ) and
             ((n.sg_id <> 4) or (n.sg_id is null))
        into oincomingdoc_sum, oincomingdoc_sum_pdv;
      /*сума по товару що не оподатковується */
      select around(sum(dr.insum))
       from docrec dr,nomen n, documents d
      where (:odocument_id = dr.document_id) AND
            (d.document_id = dr.docrec_id  ) and
            (d.typedoc_id != 10            ) and
            (n.nomen_id    = dr.nomen_id   ) and
            (n.typepdv_id  = 1             ) and
            ((n.sg_id <> 4) or (n.sg_id is null))
       into oincomingdoc_sum_notpdv;

       /*сума по тарі */
      select around(sum(dr.insum))
        from docrec dr,nomen n, documents d
       where (:odocument_id = dr.document_id) AND
             (d.document_id = dr.document_id) and
             (d.typedoc_id != 10            ) and
             (n.nomen_id    = dr.nomen_id   ) and
             (n.sg_id       = 4             )
        into OINCOMINGDOC_SUM_TARE;


     ooutgoingdoc_sumpdv      = 0.000;
     OOUTGOINGDOC_SUMPDV_TARE = 0.000;
     OOUTGOINGDOC_SUM_NOTPDV  = 0.000;
     OOUTGOINGDOC_SUMPDV_PDV  = 0.000;

 /*------------------------------------------------------------------*/
      for select dr.docrec_id,  dr.nomen_id, DR.kilk, DR.typepdv_pdv, dr.typepdv_id
            from docrec dr, documents d
           where (dr.document_id = :odocument_id ) and
                 (dr.document_id = d.document_id ) and
                 (d.typedoc_id  != 10            )
            into tdocrec_id,  tnomen_id, tkilk, ttype_pdv_pdv, ttype_pdv_id
      DO
      begin
        select n.sg_id, n.typepdv_id
          from nomen n
         where n.nomen_id = :tnomen_id
          into TSPECIALGROUP_ID, TTYPEPDV;

        if (:TSPECIALGROUP_ID is null) then TSPECIALGROUP_ID = 0.00;

        select first 1 mr.out_price
          from t_markup_records mr, t_markups m
         where (mr.nomen_id = :tnomen_id)  and
               (m.markup_id = mr.markup_id)and
               (m.is_fixed = 1)            and
               ((cast(m.time_fix as date) < :tlock_date)or
                (cast(m.time_fix as date) = :tlock_date)and
                 cast(m.time_fix as TIME) < :ttime_fix)
          order by mr.markup_record_id desc
           into tprice;

      if ((TSPECIALGROUP_ID  <> 1) or (TSPECIALGROUP_ID  is null)) then
      begin
        if (TSPECIALGROUP_ID  = 4)  then
            OOUTGOINGDOC_SUMPDV_TARE = OOUTGOINGDOC_SUMPDV_TARE  + :tkilk * tprice;
        if ((:TTYPEPDV  = 1) and  (:TSPECIALGROUP_ID <> 4)) then
            OOUTGOINGDOC_SUM_NOTPDV = OOUTGOINGDOC_SUM_NOTPDV  + :tkilk * tprice;
        if (((:TTYPEPDV  = 2) or (:TTYPEPDV  = 3)) and  (:TSPECIALGROUP_ID <> 4)) then
            OOUTGOINGDOC_SUMPDV_PDV = OOUTGOINGDOC_SUMPDV_PDV + :tkilk * tprice;
      end
      ooutgoingdoc_sumpdv = ooutgoingdoc_sumpdv + :tkilk * tprice;
    end
  OOUTGOINGDOC_SUMPDV_TARE = around(OOUTGOINGDOC_SUMPDV_TARE);
  OOUTGOINGDOC_SUMPDV_PDV  = around(OOUTGOINGDOC_SUMPDV_PDV);
  OOUTGOINGDOC_SUM_NOTPDV  = around(OOUTGOINGDOC_SUM_NOTPDV);
  OOUT_SUM_TAX_OUTPDV = around(calcsum(OOUTGOINGDOC_SUMPDV_PDV, OOUTGOINGDOC_SUMPDV_PDV - oincomingdoc_sum_pdv, :ttype_pdv_pdv, :ttype_pdv_id,0));
  suspend;
  tprice = NULL;
--  TDATE_MARKUP_begin; TDATE_MARKUP_END;
--  tprice_end = null;
  tkilk = NULL;
  end

END^


ALTER PROCEDURE PR_NOMENREPORT_MARKUPS (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
begin
  rprihod_k = 0.0;
  rprihod_s = 0.0;

 for select dg.goods_id, dr.nomen_id, n.typepdv_id, t.pdv, n.grp_id,
            d.clients_id, sum(dg.kilk), sum(gs.osum_pdv), sum(dg.kilk * g.goods_inprice)
       from documents d
            left join docrec dr on (d.document_id = dr.document_id)
            join docgoods dg on (dr.docrec_id = dg.docrec_id)
            join goods g on (g.goods_id = dg.goods_id)
            join nomen n on (n.nomen_id = g.nomen_id)
            join typepdv t on (n.typepdv_id = t.typepdv_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.objects_id    = :vsklad_id            and
            d.doc_date between :vdate1 and :vdate2  and
            d.document_id   = dr.document_id        and
            d.typedoc_id   != 10
   group by dg.goods_id, dr.nomen_id, n.typepdv_id, t.pdv, n.grp_id, d.clients_id
       into rgoods_id, rnomen_id, ptypepdv, ppdv, rgrp_id,
            rclients_id, rrashod_k, rrashod_s_pdv, rin_sum
  do begin
    rnacinka = :rrashod_s_pdv - :rin_sum;
    rrashod_s = calcsum(:rrashod_s_pdv, :rnacinka, :ppdv, :ptypepdv, 6);
    rpdv = :rrashod_s_pdv - :rrashod_s;
    suspend;
  end

  rrashod_k = 0.0;
  rrashod_s_pdv = 0.0;
  rrashod_s = 0.0;
  rpdv = 0.0;
  rnacinka = 0.0;
  for select dg.goods_id, dr.nomen_id, n.grp_id, d.objects_id, sum(dg.kilk), sum(aroundin(dr.price, 3)*dg.kilk)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join docgoods dg on (dr.docrec_id = dg.docrec_id)
             join nomen n on (dr.nomen_id = n.nomen_id)
       where d.clients_id    = :vsklad_id            and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10
    group by dg.goods_id, dr.nomen_id, n.grp_id, d.objects_id
        into rgoods_id, rnomen_id, rgrp_id, rclients_id, rprihod_k, rprihod_s
  do begin
    rin_sum = :rprihod_s;
    suspend;
  end
end^


ALTER PROCEDURE PR_NOMENSRESTS (
    IDATE DATE)
RETURNS (
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OSUM DOUBLE PRECISION)
AS
declare variable pnomen_id integer;
BEGIN
 for select rr.nomen_id, rr.nomen_code, rr.nomen_name, around3(sum(rr.e_k))
     from rs_ralase(1,:idate,:idate, null) rr
     group by rr.nomen_id, rr.nomen_code, rr.nomen_name
     into :pnomen_id, :onomen_code, :onomen_name, :okilk
  do begin
    select around(pd.oprice) from ps_price_by_date(:pnomen_id, :idate) pd
    into :oprice;
    osum = around(:okilk * :oprice);
  SUSPEND;
  end
END^


ALTER PROCEDURE PR_NOMENZVIT (
    IDATE DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    OSUM DOUBLE PRECISION,
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OMARKUPDOC DOUBLE PRECISION)
AS
declare variable pclient_id integer;
declare variable pdocument_id integer;
declare variable pignore_clients_id integer;
begin
    select cl.clients_id from clients cl
    where cl.clients_code = '1016677'
    into :pignore_clients_id;

for select d.document_id, d.objects_id
    from DOCUMENTS d
    where (d.typedoc_id = 1) and (d.doc_date = :idate) and
          d.objects_id != :pignore_clients_id
    order by d.document_id
    into :pdocument_id, :pclient_id

  do
  begin
      select  c.name
         from clients c
         where c.clients_id = :pclient_id
         into  :onameclient;

      /*сума приходу без ПДВ*/
      select around(sum(dr.insum))
         from docrec dr, nomen n, documents d
         where (:pdocument_id = dr.document_id  ) AND
               (d.document_id = dr.document_id  ) and
               (d.typedoc_id != 10              ) and
               (n.nomen_id    = dr.nomen_id     ) and
               ((n.sg_id <> 4) or (n.sg_id is null))
         into  :oincomingdoc_sum;
       osum = 0;
       /* перемiщення */
      select rbd.osum
         from ps_realis_by_document(:pdocument_id) rbd
      into :osum;
      osum = around(:osum);
      /* торгова націнка */
      omarkupdoc = around(:osum - :oincomingdoc_sum);

 suspend;
  end

END^


ALTER PROCEDURE PR_RALASE (
    IDATE0 DATE,
    IDATE1 DATE,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf
       from t_grp_childs_shelfs(:igrp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
      where r.objects_id=1
       into onomen_id, onomen_code, onomen_name, e_k, s_in_vat,
            p_tvat_id, ogrp_name, shelf
 do begin
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value = 0.2; end
   else begin p_tvat_value = 0.0; end
  e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k     = :e_k;
  b_s_in  = :e_s_in;
  p_k     = 0.000;
  p_s_in  = 0.000;
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_vat = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 select max(d.doc_date)
  from documents d
  into :p_date_out;
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv
       from (t_grp_childs_shelfs(:igrp_id) gch
                  left join nomen n on gch.rgrp_id=n.grp_id)
            join (documents d
                  left join docrec dr on d.document_id=dr.document_id
                  left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
            on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date   between :idate0 and :p_date_out    and
            d.typedoc_id        != 10                       and
            (not ((d.typedoc_id in (4, 11)) and 
                  (d.doc_lock   = 0      )))                and
            ((d.objects_id = 1) or (d.clients_id = 1))
       into p_doc_date, onomen_id, onomen_code, onomen_name, ogrp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price
 do begin
  if (:s_in is null) then s_in = 0.000;

  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date>:idate1) then begin
    if (:p_dst_id=1) then begin
     e_k   =-:p_kilk;
     e_s_in=-:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=1) then begin
     e_k   =:p_kilk;
     e_s_in=:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
   end
  else begin
    if (:p_dst_id=1) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =:p_kilk;
     p_s_in=:s_in;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=1) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =:p_kilk;
     r_s_in=:s_in;
     r_s_out=calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat=(:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k=:e_k+:r_k-:p_k;
  b_s_in=:e_s_in+:r_s_in-:p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE PR_RALASE_MAKER (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPRIHOD_K NUMERIC(15,2),
    ORASHOD_K NUMERIC(15,2),
    OPRIHOD_S NUMERIC(15,2),
    ORASHOD_S_PDV NUMERIC(15,2),
    OIN_SUM NUMERIC(15,2),
    ONACINKA NUMERIC(15,2),
    OPDV NUMERIC(15,2),
    ORASHOD_S NUMERIC(15,2),
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    OPRIHOD_S_PDV NUMERIC(15,2))
AS
begin
  for select rmaker_id, sum(rprihod_k), sum(rprihod_s), sum(rprihod_s_pdv), sum(rin_sum),
             sum(rrashod_k), sum(rrashod_s), sum(rrashod_s_pdv), sum(rpdv), sum(rnacinka) from rc_ralase_dr(:idate0, :idate1, 1, null)
    group by rmaker_id
  into :omaker_id, :oprihod_k, :oprihod_s, :oprihod_s_pdv, :oin_sum, :orashod_k, :orashod_s, :orashod_s_pdv, :opdv, :onacinka
  do begin
/*    select s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
      from staff s
        where s.staff_id=:rstaff_id
    into :rstaff_name;  */

/*    if (:rstaff_id is null) then rstaff_name = null;*/

    if (:omaker_id is not null) then
      select m.maker_name from maker m
          where m.maker_id = :omaker_id
       into :omaker_name;

    suspend;
    omaker_id = null;
    omaker_name = null;
  end
end^


ALTER PROCEDURE PR_RALASE_NILSEN (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    P_K DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    E_K DOUBLE PRECISION)
AS
DECLARE VARIABLE P_DOC_DATE DATE;
DECLARE VARIABLE P_KILK DOUBLE PRECISION;
DECLARE VARIABLE P_DST_ID INTEGER;
DECLARE VARIABLE P_SRC_ID INTEGER;
DECLARE VARIABLE S_IN DOUBLE PRECISION;
DECLARE VARIABLE S_IN_VAT DOUBLE PRECISION;
DECLARE VARIABLE P_TVAT_ID INTEGER;
DECLARE VARIABLE P_TVAT_VALUE DOUBLE PRECISION;
DECLARE VARIABLE P_PRICE DOUBLE PRECISION;
DECLARE VARIABLE P_DATE_OUT DATE;
DECLARE VARIABLE TTYPEDOC_ID INTEGER;
BEGIN
 for select r.nomen_id, r.rest
      from rst r
   into :onomen_id, :e_k
 do begin
  P_K = 0.000;
  R_K = 0.000;
  suspend;
 end

 select max(d.doc_date)
     from documents d
   into :p_date_out;

 for select D.DOC_DATE, dr.nomen_id, DR.KILK, D.OBJECTS_ID, D.CLIENTS_ID, d.typedoc_id
      from documents d left join docrec dr on d.document_id=dr.document_id
      WHERE D.DOC_DATE   BETWEEN :idate0 AND :P_DATE_OUT AND
            d.typedoc_id != 10                           and
            (NOT ((D.TYPEDOC_ID IN (4, 11)) AND (D.DOC_LOCK = 0))) AND
            ((D.OBJECTS_ID=1) OR (D.CLIENTS_ID=1))
      INTO :P_DOC_DATE, :onomen_id, :P_KILK, :P_SRC_ID, :P_DST_ID, :ttypedoc_id
 do begin
  IF (:P_KILK IS NULL) THEN P_KILK=0.000;

  IF (:P_DOC_DATE>:idate1) THEN BEGIN
    IF (:P_DST_ID=1) THEN BEGIN
     E_K   =-:P_KILK;
     P_K   =0.000;
     R_K   =0.000;
    END
    IF (:P_SRC_ID=1) THEN BEGIN
     E_K   =:P_KILK;
     P_K   =0.000;
     R_K   =0.000;
    END
    SUSPEND;
   END
  ELSE BEGIN
/*    IF (:P_DST_ID=1) THEN BEGIN
     E_K   =0.000;
     P_K   =:P_KILK;
     R_K   =0.000;
    END  */
    IF ((:P_SRC_ID=1) and (:ttypedoc_id in (2, 11))) THEN BEGIN
     E_K   =0.000;
     P_K   =0.000;
     R_K   =:P_KILK;
     SUSPEND;
    END
   END
/*  B_K=:E_K+:R_K-:P_K;*/
/*  B_S_IN=:E_S_IN+:R_S_IN-:P_S_IN;*/
 END
END^


ALTER PROCEDURE PR_RALASE_NOMEN (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    B_S_OUT DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    E_S_OUT DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
declare variable pcoeficient integer;
declare variable pin_sum_pdv double precision;
declare variable pout_sum_pdv double precision;
declare variable objects_id integer;
declare variable posum_pdv double precision;
begin
/* flag0 = 1 - лише видимі товари */
 objects_id = 1;
 if (:flag0 is null) then flag0 = 0;
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            pd.oprice * r.rest, pid.oprice * r.rest
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id,
            ps_price_by_date(n.nomen_id, :date_out) pd,
            ps_inprice_by_date(n.nomen_id, :date_out) pid
      where gch.rgrp_id = n.grp_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            e_s_out, e_s_in
 do begin
   if (((:flag0 = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then p_tvat_value = 0.2;
       else begin p_tvat_value = 0.0; end
   /*  e_s_in  = :s_in_vat;/*calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0); */
     b_k     = :e_k;
     b_s_in  = :e_s_in;
     b_s_out = :e_s_out;
     p_k     = 0.000;
     p_s_in  = 0.000;
     p_s_out = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            gs.oin_sum_pdv, gs.oout_sum_pdv, gs.osum_pdv
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on (gch.rgrp_id = n.grp_id)
            join docrec dr on (n.nomen_id = dr.nomen_id)
            left join documents d on (d.document_id = dr.document_id)
            inner join grp g  on g.grp_id = gch.rgrp_id,
            ps_get_all_sums(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where d.doc_date between :date_in and :p_date_out             and
            d.typedoc_id   != 10                                    and
            (not((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            pin_sum_pdv, pout_sum_pdv, posum_pdv
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:pin_sum_pdv  is null) then pin_sum_pdv  = 0.000;
  if (:pout_sum_pdv is null) then pout_sum_pdv = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = 1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = -1;
    e_k     = :pcoeficient * -:p_kilk;
    e_s_in  = :pcoeficient * -:s_in_vat;/*:s_in;*/
    e_s_out = :pcoeficient * -:pout_sum_pdv;
    p_k     = 0.0;
    p_s_in  = 0.0;
    p_s_out = 0.0;
    r_k     = 0.0;
    r_s_in  = 0.0;
    r_s_vat = 0.0;
    r_s_out = 0.0;
  end
  else begin
    if (:p_dst_id = :objects_id) then begin
      p_k     = :p_kilk;
      p_s_in  = :pin_sum_pdv;/*:s_in;*/
      p_s_out = :pout_sum_pdv;
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      p_k     = 0.0;
      p_s_in  = 0.0;
      p_s_out = 0.0;
      r_k     = :p_kilk;
      r_s_in  = :pin_sum_pdv;/*:s_in;*/
      r_s_out = :posum_pdv; /*(calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0); */
      r_s_vat = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k     = 0.0;
    e_s_in  = 0.0;
    e_s_out = 0.0;
   end
  b_k     = :e_k + :r_k - :p_k;
  b_s_in  = :e_s_in + :r_s_in - :p_s_in;
  b_s_out = :e_s_out + :r_s_out - :p_s_out;
  suspend;
  end
 end
end^


ALTER PROCEDURE PR_RALASE_NOMEN_ACTION (
    DATE_IN DATE,
    DATE_OUT DATE,
    DATE_IN1 DATE,
    DATE_OUT1 DATE,
    ACTION_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    B_K1 DOUBLE PRECISION,
    P_K1 DOUBLE PRECISION,
    P_S_IN1 DOUBLE PRECISION,
    P_S_OUT1 DOUBLE PRECISION,
    R_K1 DOUBLE PRECISION,
    R_S_IN1 DOUBLE PRECISION,
    R_S_VAT1 DOUBLE PRECISION,
    R_S_OUT1 DOUBLE PRECISION,
    E_K1 DOUBLE PRECISION,
    E_S_IN1 DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
declare variable pcoeficient integer;
declare variable objects_id integer;
declare variable posum_pdv double precision;
declare variable pout_price double precision;
declare variable ptype_doc integer;
begin
/* flag0 = 1 - лише видимий товар */
 objects_id = 1;
 if (:flag0 is null) then flag0 = 0;
 for select n.nomen_id, /*$$IBEC$$ n.nomen_code, n.nomen_name, $$IBEC$$*/ r.rest, r.rest_sum,
            n.typepdv_id, n.is_visible
       from nomen n
            left join rst r   on n.nomen_id  = r.nomen_id
      where n.action_id = :action_id
       into nomen_id, /*$$IBEC$$ nomen_code, nomen_name, $$IBEC$$*/ e_k, s_in_vat,
            p_tvat_id, pis_visible
 do begin
   if (((:flag0 = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then p_tvat_value = 0.2;
       else begin p_tvat_value = 0.0; end
     e_s_in  = :s_in_vat;
     b_k     = :e_k;
     p_k     = 0.000;
     p_s_in  = 0.000;
     p_s_out = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;

    b_k1     = b_k;
    p_k1     = p_k;
    p_s_in1  = p_s_in;
    p_s_out1 = p_s_out;
    r_k1     = r_k;
    r_s_in1  = r_s_in;
    r_s_vat1 = r_s_vat;
    r_s_out1 = r_s_out;
    e_k1     = e_k;
    e_s_in1  = e_s_in;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, /*$$IBEC$$ n.nomen_code, n.nomen_name, $$IBEC$$*/ dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible,
            gs.osum_pdv, d.typedoc_id
       from nomen n
            join (documents d
                  left join docrec dr on d.document_id=dr.document_id
                  left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
            on n.nomen_id=dr.nomen_id
      where n.action_id = :action_id and
            d.doc_date between :date_in and :p_date_out and
            d.typedoc_id   != 10                        and
            (not((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))
       into p_doc_date, nomen_id, /*$$IBEC$$ nomen_code, nomen_name, $$IBEC$$*/ p_kilk,
            p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible,
            posum_pdv, ptype_doc
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
/*$$IBEC$$   if (:pin_sum_pdv  is null) then pin_sum_pdv  = 0.000;
  if (:pout_sum_pdv is null) then pout_sum_pdv = 0.000; $$IBEC$$*/
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end

/*Обчислення першого періоду*/
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = -1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = 1;
    e_k     = :pcoeficient * :p_kilk;
    e_s_in  = :pcoeficient * :s_in_vat;
    p_k     = 0.0;
    p_s_in  = 0.0;
    p_s_out = 0.0;
    r_k     = 0.0;
    r_s_in  = 0.0;
    r_s_vat = 0.0;
    r_s_out = 0.0;
  end
  else begin
    if (:ptype_doc = 17) then
    begin
      e_s_in  = 0.0;
      p_k     = -:p_kilk;
      p_s_in  = -:s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = -:p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_dst_id = :objects_id) then begin
      e_s_in  = 0.0;
      p_k     = :p_kilk;
      p_s_in  = :s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = :p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      e_s_in  = 0.0;
      p_k     = 0.0;
      p_s_in  = 0.0;
      p_s_out = 0.0;
      r_k     = :p_kilk;
      r_s_in  = :s_in_vat;
      r_s_out = :posum_pdv;
      r_s_vat = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k = 0.0;
   end

/*Обчислення другого періоду*/
if (:p_doc_date >= :date_in1) then begin
   if (:p_doc_date > :date_out1) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = -1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = 1;
    e_k1     = :pcoeficient * :p_kilk;
    e_s_in1  = :pcoeficient * :s_in_vat;
    p_k1     = 0.0;
    p_s_in1  = 0.0;
    p_s_out1 = 0.0;
    r_k1     = 0.0;
    r_s_in1  = 0.0;
    r_s_vat1 = 0.0;
    r_s_out1 = 0.0;
  end
  else begin
    if (:ptype_doc = 17) then
    begin
      e_s_in1  = 0.0;
      p_k1     = -:p_kilk;
      p_s_in1  = -:s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out1 = -:p_kilk * :pout_price; /*:posum_pdv;*/
      r_k1     = 0.0;
      r_s_in1  = 0.0;
      r_s_vat1 = 0.0;
      r_s_out1 = 0.0;
    end else
    if (:p_dst_id = :objects_id) then begin
      e_s_in1  = 0.0;
      p_k1     = :p_kilk;
      p_s_in1  = :s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out1 = :p_kilk * :pout_price; /*:posum_pdv;*/
      r_k1     = 0.0;
      r_s_in1  = 0.0;
      r_s_vat1 = 0.0;
      r_s_out1 = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      e_s_in1  = 0.0;
      p_k1     = 0.0;
      p_s_in1  = 0.0;
      p_s_out1 = 0.0;
      r_k1     = :p_kilk;
      r_s_in1  = :s_in_vat;
      r_s_out1 = :posum_pdv;
      r_s_vat1 = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k1 = 0.0;
   end
  end else
  begin
    b_k1     = 0.0;
    p_k1     = 0.0;
    p_s_in1  = 0.0;
    p_s_out1 = 0.0;
    r_k1     = 0.0;
    r_s_in1  = 0.0;
    r_s_vat1 = 0.0;
    r_s_out1 = 0.0;
    e_k1     = 0.0;
    e_s_in1  = 0.0;
  end
  b_k   = :e_k + :r_k - :p_k;
  b_k1  = :e_k1 + :r_k1 - :p_k1;
  suspend;
  end
 end
end^


ALTER PROCEDURE PR_RALASE_NOMEN_HEADER (
    DOCUMENT_ID INTEGER,
    DATE0 DATE,
    DATE1 DATE)
RETURNS (
    ODEB_SUM0 DOUBLE PRECISION,
    OREALIZ_SUM DOUBLE PRECISION,
    OPAY_SUM DOUBLE PRECISION,
    OPOVERN_SUM DOUBLE PRECISION,
    ODATE0 DATE,
    ODATE1 DATE)
AS
declare variable pmin_date date;
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  select min(d.doc_date)
    from documents d
    into pmin_date;

  odate0 = :date0;
  odate1 = :date1;

  select sum(deb.odoc_sum_pdv - deb.opay_sum_pdv)
    from pr_debitorka(:pmin_date, :date0) deb
    into odeb_sum0;

  select sum(s.sum_out_pdv)
   from documents d
        left join s_docrec_sum(d.document_id, d.disc_persent) s on 1=1
  where d.typedoc_id in (2, 11) and
        d.doc_date between :date0 and :date1
   into orealiz_sum;

  select sum(s.sum_out_pdv)
   from documents d
        left join s_docrec_sum(d.document_id, d.disc_persent) s on 1=1
  where d.typedoc_id in (4) and
        d.doc_date between :date0 and :date1
   into opovern_sum;

  select sum(p.pay_sum)
    from t_pays p
         join typepay tp on tp.typepay_id = p.pay_type_id
         join documents d on p.document_id = d.document_id
   where p.pay_date between :date0 and :date1 and
         d.objects_id = 1
    into opay_sum;

  if (:odeb_sum0 is null) then odeb_sum0 = 0;
  if (:opay_sum is null) then opay_sum = 0;
  if (:opovern_sum is null) then opovern_sum = 0;
  if (:orealiz_sum is null) then orealiz_sum = 0;
  suspend;
end^


ALTER PROCEDURE PR_RALASE_NOMEN_PERIOD (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_NUM VARCHAR(14),
    ODOC_DATE DATE,
    ODOC_MARK VARCHAR(14),
    OTYPE_DOC_NAME VARCHAR(30),
    OTYPE_PAY_NAME VARCHAR(30),
    ODOC_SUM DOUBLE PRECISION)
AS
declare variable poplata_type smallint;
declare variable pall_sum double precision;
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  odocument_id = null;
  odoc_num = null;
  odoc_date = null;
  odoc_mark = 'РЕАЛІЗАЦІЯ:';
  otype_pay_name = null;
  odoc_sum = null;
  otype_doc_name = null;
  pall_sum = 0.0;
  suspend;

  for select d.document_id, d.doc_num, d.doc_date, d.doc_mark, d.oplata_type,
             s.sum_out_pdv, td.typedoc_name
        from documents d
             join typedoc td on td.typedoc_id = d.typedoc_id
             left join s_docrec_sum(d.document_id, d.disc_persent) s on 1=1
       where d.typedoc_id in (2, 11) and
             d.doc_date between :date0 and :date1
    order by d.doc_date
        into odocument_id, odoc_num, odoc_date, odoc_mark, poplata_type,
             odoc_sum, otype_doc_name
  do begin
    if (:poplata_type = 1) then otype_pay_name = 'Готівка'; else
    if (:poplata_type = 2) then otype_pay_name = 'Перерахунок'; else
    if (:poplata_type = 3) then otype_pay_name = 'Мішана проплата'; else
      otype_pay_name = 'Не оплачувався';
    pall_sum = :pall_sum + :odoc_sum;
    suspend;
  end
  odocument_id = null;
  odoc_num = null;
  odoc_date = null;
  odoc_mark = '======Всього:';
  otype_pay_name = null;
  otype_doc_name = null;
  odoc_sum = :pall_sum;
  pall_sum = 0.0;
  suspend;

  odoc_mark = 'ПРОПЛАТИ:';
  odoc_sum = null;
  suspend;
  for select p.pay_id, cast(p.pay_id as varchar(14)), p.pay_date, '', tp.typepay_name,
             p.pay_sum, 'Проплата'
        from t_pays p
             join typepay tp on tp.typepay_id = p.pay_type_id
             join documents d on p.document_id = d.document_id
       where p.pay_date between :date0 and :date1 and
             d.objects_id = 1
    order by p.pay_date
        into odocument_id, odoc_num, odoc_date, odoc_mark, otype_pay_name,
             odoc_sum, otype_doc_name
  do begin
    pall_sum = :pall_sum + :odoc_sum;
    suspend;
  end
  odocument_id = null;
  odoc_num = null;
  odoc_date = null;
  odoc_mark = '======Всього:';
  otype_pay_name = null;
  otype_doc_name = null;
  odoc_sum = :pall_sum;
  pall_sum = 0.0;
  suspend;

  odoc_mark = 'ПОВЕРНЕННЯ:';
  odoc_sum = null;
  suspend;
  for select d.document_id, d.doc_num, d.doc_date, d.doc_mark, d.oplata_type,
             s.sum_out_pdv, td.typedoc_name
        from documents d
             join typedoc td on td.typedoc_id = d.typedoc_id
             left join s_docrec_sum(d.document_id, d.disc_persent) s on 1=1
       where d.typedoc_id in (4) and
             d.doc_date between :date0 and :date1
    order by d.doc_date
        into odocument_id, odoc_num, odoc_date, odoc_mark, poplata_type,
             odoc_sum, otype_doc_name
  do begin
    if (:poplata_type = 1) then otype_pay_name = 'Готівка'; else
    if (:poplata_type = 2) then otype_pay_name = 'Перерахунок'; else
    if (:poplata_type = 3) then otype_pay_name = 'Мішана проплата'; else
      otype_pay_name = 'Не оплачувався';
    pall_sum = :pall_sum + :odoc_sum;
    suspend;
  end
  odocument_id = null;
  odoc_num = null;
  odoc_date = null;
  odoc_mark = '======Всього:';
  otype_pay_name = null;
  otype_doc_name = null;
  odoc_sum = :pall_sum;
  pall_sum = 0.0;
  suspend;
end^


ALTER PROCEDURE PR_RALASE_NOMEN_V1 (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
declare variable pcoeficient integer;
declare variable objects_id integer;
declare variable posum_pdv double precision;
declare variable pout_price double precision;
declare variable ptype_doc integer;
begin
/* flag0 = 1 - лише видимий товар */
 objects_id = 1;
 if (:flag0 is null) then flag0 = 0;
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id
      where gch.rgrp_id = n.grp_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name
 do begin
   if (((:flag0 = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then p_tvat_value = 0.2;
       else begin p_tvat_value = 0.0; end
     b_k     = :e_k;
     p_k     = 0.000;
     p_s_in  = 0.000;
     p_s_out = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            gs.osum_pdv, d.typedoc_id
       from (t_grp_childs_shelfs(:grp_id) gch
                  left join nomen n on gch.rgrp_id=n.grp_id)
            join (documents d
                  left join docrec dr on d.document_id=dr.document_id
                  left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
            on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out and
            d.typedoc_id   != 10                        and
            (not((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            posum_pdv, ptype_doc
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
/*$$IBEC$$   if (:pin_sum_pdv  is null) then pin_sum_pdv  = 0.000;
  if (:pout_sum_pdv is null) then pout_sum_pdv = 0.000; $$IBEC$$*/
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = -1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = 1;
    e_k     = :pcoeficient * :p_kilk;
    p_k     = 0.0;
    p_s_in  = 0.0;
    p_s_out = 0.0;
    r_k     = 0.0;
    r_s_in  = 0.0;
    r_s_vat = 0.0;
    r_s_out = 0.0;
  end
  else begin
    if (:ptype_doc = 17) then
    begin
      p_k     = -:p_kilk;
      p_s_in  = -:s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = -:p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_dst_id = :objects_id) then begin
      p_k     = :p_kilk;
      p_s_in  = :s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = :p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      p_k     = 0.0;
      p_s_in  = 0.0;
      p_s_out = 0.0;
      r_k     = :p_kilk;
      r_s_in  = :s_in_vat;
      r_s_out = :posum_pdv;
      r_s_vat = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k = 0.0;
   end
  b_k   = :e_k + :r_k - :p_k;
  suspend;
  end
 end
end^


ALTER PROCEDURE PR_RALASE_NOMEN_V2 (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    E_S_IN DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
declare variable pcoeficient integer;
declare variable objects_id integer;
declare variable posum_pdv double precision;
declare variable pout_price double precision;
declare variable ptype_doc integer;
begin
/* flag0 = 1 - лише видимий товар */
 objects_id = 1;
 if (:flag0 is null) then flag0 = 0;
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            g.grp_id
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id
      where gch.rgrp_id = n.grp_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0 = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then p_tvat_value = 0.2;
       else begin p_tvat_value = 0.0; end
     e_s_in  = :s_in_vat;
     b_k     = :e_k;
     p_k     = 0.000;
     p_s_in  = 0.000;
     p_s_out = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            gs.osum_pdv, d.typedoc_id
       from (t_grp_childs_shelfs(:grp_id) gch
                  left join nomen n on gch.rgrp_id=n.grp_id)
            join (documents d
                  left join docrec dr on d.document_id=dr.document_id
                  left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
            on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out and
            d.typedoc_id   != 10                        and
            (not((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            posum_pdv, ptype_doc
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
/*$$IBEC$$   if (:pin_sum_pdv  is null) then pin_sum_pdv  = 0.000;
  if (:pout_sum_pdv is null) then pout_sum_pdv = 0.000; $$IBEC$$*/
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = -1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = 1;
    e_k     = :pcoeficient * :p_kilk;
    e_s_in  = :pcoeficient * :s_in_vat;
    p_k     = 0.0;
    p_s_in  = 0.0;
    p_s_out = 0.0;
    r_k     = 0.0;
    r_s_in  = 0.0;
    r_s_vat = 0.0;
    r_s_out = 0.0;
  end
  else begin
    if (:ptype_doc = 17) then
    begin
      e_s_in  = 0.0;
      p_k     = -:p_kilk;
      p_s_in  = -:s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = -:p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_dst_id = :objects_id) then begin
      e_s_in  = 0.0;
      p_k     = :p_kilk;
      p_s_in  = :s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = :p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      e_s_in  = 0.0;
      p_k     = 0.0;
      p_s_in  = 0.0;
      p_s_out = 0.0;
      r_k     = :p_kilk;
      r_s_in  = :s_in_vat;
      r_s_out = :posum_pdv;
      r_s_vat = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k = 0.0;
   end
  b_k   = :e_k + :r_k - :p_k;
  suspend;
  end
 end
end^


ALTER PROCEDURE PR_RALASE_SALES (
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    P_S_OUT DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
declare variable pcoeficient integer;
declare variable objects_id integer;
declare variable posum_pdv double precision;
declare variable pout_price double precision;
declare variable ptype_doc_id integer;
begin
/* flag0 = 1 - лише видимі товари */
 objects_id = 1;
 if (:flag0 is null) then flag0 = 0;
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            g.grp_id
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id
      where gch.rgrp_id = n.grp_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0 = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then p_tvat_value = 0.2;
       else begin p_tvat_value = 0.0; end
     p_k     = 0.000;
     p_s_in  = 0.000;
     p_s_out = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            gs.osum_pdv, d.typedoc_id, g.grp_id
       from (t_grp_childs_shelfs(:grp_id) gch
                  left join nomen n on gch.rgrp_id=n.grp_id)
            join (documents d
                  left join docrec dr on d.document_id=dr.document_id
                  left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
            on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out and
            d.typedoc_id   != 10                        and
            (not((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            posum_pdv, ptype_doc_id, ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       (:flag0 != 1)) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
/*$$IBEC$$   if (:pin_sum_pdv  is null) then pin_sum_pdv  = 0.000;
  if (:pout_sum_pdv is null) then pout_sum_pdv = 0.000; $$IBEC$$*/
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
      pcoeficient = -1;
    else
    if (:p_src_id = :objects_id) then
      pcoeficient = 1;
    e_k     = :pcoeficient * :p_kilk;
    p_k     = 0.0;
    p_s_in  = 0.0;
    p_s_out = 0.0;
    r_k     = 0.0;
    r_s_in  = 0.0;
    r_s_vat = 0.0;
    r_s_out = 0.0;
  end
  else begin
  if (:ptype_doc_id in (2, 11)) then
  begin
    if (:p_dst_id = :objects_id) then begin
      p_k     = :p_kilk;
      p_s_in  = :s_in_vat;
        select pd.oprice from ps_price_by_date(:nomen_id, :p_doc_date) pd
          into pout_price;
      p_s_out = :p_kilk * :pout_price; /*:posum_pdv;*/
      r_k     = 0.0;
      r_s_in  = 0.0;
      r_s_vat = 0.0;
      r_s_out = 0.0;
    end else
    if (:p_src_id = :objects_id) then begin
      p_k     = 0.0;
      p_s_in  = 0.0;
      p_s_out = 0.0;
      r_k     = :p_kilk;
      r_s_in  = :s_in_vat;
      r_s_out = :posum_pdv;
      r_s_vat = (:p_kilk * :p_price) - calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
    e_k = 0.0;
  end
  end
  suspend;
  end
 end
end^


ALTER PROCEDURE PR_RALASETYPEPDV_BYGROUP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER,
    RPER_NAC_OFIC DOUBLE PRECISION)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
declare variable pclients_id integer;
declare variable pobjects_id integer;
declare variable psum_s_pdv double precision;
declare variable pkilk double precision;
declare variable pdocrec_id integer;
declare variable pnacinka double precision;
declare variable perm_nacinka integer;
declare variable pinsum double precision;
declare variable pinsum_pdv double precision;
begin
   perm_nacinka =1;

    for select d.document_id, d.clients_id, d.objects_id, d.staff_id, dr.nomen_id,
               dr.typepdv_id, dr.typepdv_pdv, gs.osum_pdv, dr.docrec_id, dr.kilk,
               dr.insum, dr.insum_pdv, gr.rgrp_id, gr.rgrp_name, dr.typepdv_id
          from (t_grp_childs(:vgrp_id) gr left join nomen n on gr.rgrp_id=n.grp_id)
                   join
               (documents d left join docrec dr on (d.document_id=dr.document_id)
                left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                   on dr.nomen_id=n.nomen_id
         where d.doc_date between :vdate1 and :vdate2 and
               d.typedoc_id != 10                     and
               ((d.clients_id = :vsklad_id) or (d.objects_id = :vsklad_id))
          into rdocument_id, pclients_id, pobjects_id, rstaff_id, rnomen_id,
               ptypepdv, ppdv, psum_s_pdv, pdocrec_id, pkilk,
               pinsum, pinsum_pdv, rgrp_id, rgrp_name, rtype_pdv
      do begin
    /* ?????? */
        if (:pobjects_id = :vsklad_id) then
        begin
          rprihod_k = 0.0;    rprihod_s = 0.0;
          rprihod_s_pdv = 0.0;
          rrashod_s_pdv = :psum_s_pdv;
          pnacinka = :psum_s_pdv - :pinsum_pdv;
          rrashod_s = calcsum(:rrashod_s_pdv, :pnacinka, :ppdv, :ptypepdv, 6);
          rin_sum   = :pinsum;
          if (:perm_nacinka = 1) then
            rnacinka = :rrashod_s - :rin_sum;
          else
            rnacinka = 0.0;
          rpdv = :rrashod_s_pdv - :rrashod_s;
          rrashod_k = :pkilk;
          rclients_id = :pclients_id;
          if (:rin_sum = 0.0) then
            rper_nac = 0.0;
          else
            rper_nac = (:rnacinka/:rin_sum) * 100.0;

            RPDV = (RRASHOD_S_PDV - RRASHOD_S);
            RNACINKA = (RRASHOD_S - RIN_SUM);
            if (RRASHOD_S = 0.00) then
                RPER_NAC = 0.00;
            else
                RPER_NAC = (RNACINKA / RRASHOD_S) * 100;

            if (RIN_SUM = 0.00)then
                RPER_NAC_OFIC = 0.00;
            else
                RPER_NAC_OFIC = (RNACINKA / RIN_SUM) * 100;
          suspend;
        end

    /* ?????? */
        if (:pclients_id = :vsklad_id) then
        begin
          rin_sum = 0.0;
          rnacinka = 0.0;
          rrashod_s = 0.0;
          rpdv = 0.0;
          rrashod_k = 0.0;
          rrashod_s_pdv = 0.0;

          rprihod_k = :pkilk;
          rprihod_s_pdv = :psum_s_pdv;
          rprihod_s   = :pinsum;
          rclients_id = :pobjects_id;
          RPDV = (RRASHOD_S_PDV - RRASHOD_S);
            RNACINKA = (RRASHOD_S - RIN_SUM);
            if (RRASHOD_S = 0.00) then
                RPER_NAC = 0.00;
            else
                RPER_NAC = (RNACINKA / RRASHOD_S) * 100;

            if (RIN_SUM = 0.00)then
                RPER_NAC_OFIC = 0.00;
            else
                RPER_NAC_OFIC = (RNACINKA / RIN_SUM) * 100;
          suspend;
        end
      end
end^


ALTER PROCEDURE PR_REGISTER_INVOICES_OUT (
    DATE0 DATE,
    DATE1 DATE,
    DOCUMENT_ID INTEGER)
RETURNS (
    ODATE DATE,
    ONUMBER VARCHAR(14),
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    ONATSINKA DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(30))
AS
declare variable ptypedoc_id integer;
declare variable pobject_name varchar(30);
begin
  document_id = null;/*Параметер ні на що не впливає, і введено лише для сумісності з бінарниками */
  for select dw.otypedoc_id, dw.odate, dw.onumber, dw.osum_in, dw.osum_out,
             (dw.osum_out-dw.osum_in), (dw.osum_out_pdv-dw.osum_out),
             dw.osum_out_pdv, dw.osrc_name, dw.odst_name
        from ps_documents_view(:date0, :date1, ' 2 4 ', ' 0 1 2 3 4 ', ' 0 1 2 3 4 ') dw
    order by odate
        into ptypedoc_id, odate, onumber, osum_in, osum_out,
             onatsinka, osum_pdv,
             osum_out_pdv, pobject_name, oclient_name
  do begin
    if (:ptypedoc_id = 4) then
    begin
      osum_in = -:osum_in;
      osum_out = -:osum_out;
      onatsinka = -:onatsinka;
      osum_pdv = -:osum_pdv;
      osum_out_pdv = -:osum_out_pdv;
      oclient_name = :pobject_name;
    end

    suspend;
  end
end^


ALTER PROCEDURE PR_REPORT_DETAIL (
    IREPORT_ID INTEGER)
RETURNS (
    OLABEL VARCHAR(100),
    ODESCRIPT VARCHAR(50),
    OTYPE SMALLINT,
    OPOSITION INTEGER)
AS
begin
  otype = 0;
  for select rf.label, rf.description, rf.fieldposition from t_reportfields rf
         where rf.report_id = :ireport_id
       order by rf.fieldposition
     into :olabel, :odescript, :oposition
  do begin
    suspend;
  end

  otype = 1;
  for select rc.caption, rc.description, rc.captionposition from t_reportcaptions rc
         where rc.report_id = :ireport_id
       order by rc.captionposition
     into :olabel, :odescript, :oposition
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PR_REPORTS_VIEW
RETURNS (
    OREPORT_ID INTEGER,
    ONAME VARCHAR(50),
    ODESCRIPT VARCHAR(1024),
    OFIELDS_CNT INTEGER,
    OPARAMS_CNT INTEGER,
    OIS_ENABLED SMALLINT)
AS
declare variable taccess_id integer;
begin
  for select r.report_id, r.name, r.descript, r.access_id
        from t_reports r
        order by r.report_id
    into :oreport_id, :oname, :odescript, :taccess_id
  do begin

      if (:taccess_id is null) then
      begin
        ois_enabled = 1;
      end
      else if (:taccess_id = -1) then
      begin
        ois_enabled = 2;
      end
      else
      begin
        select count(r.right_id) from t_users u, t_rights r
            where u.user_login = user and
                  u.rights_grp_id = r.rights_grp_id and
                  r.access_id = :taccess_id
          into :taccess_id;

        if (:taccess_id = 0) then
          ois_enabled = 0;
        else
          ois_enabled = 1;
      end

      select count(rf.t_reportfield_id) from t_reportfields rf
         where rf.report_id = :oreport_id
        into :oparams_cnt;
      select count(rc.reportcaption_id) from t_reportcaptions rc
         where rc.report_id = :oreport_id
        into :ofields_cnt;

      suspend;

      taccess_id = null;
  end
end^


ALTER PROCEDURE PR_REVISION_LIST (
    IDATE DATE)
RETURNS (
    OGRP_CODE INTEGER,
    OGRP_NAME VARCHAR(40),
    ONOMEN_CODE VARCHAR(7),
    OBARCODE VARCHAR(27),
    ONOMEN_NAME VARCHAR(40),
    OSI_NAME VARCHAR(12),
    OKILK_OLD DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OSUM_PROGRAM DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OSUM_REAL DOUBLE PRECISION,
    OKILK_RIZN DOUBLE PRECISION,
    OSUM_RIZN DOUBLE PRECISION)
AS
declare variable pnomen_id integer;
declare variable pmax_barcode_id integer;
declare variable prevision_id integer;
begin
for select r.revision_id from revision r
     where r.revision_date = :idate
      into :prevision_id
 do begin
 for select g.grp_code, g.grp_name, n.nomen_code, n.nomen_name, si.si_name, rr.kilk_old,
            rr.price_out_pdv, rr.kilk_new, n.nomen_id
       from rev_records rr, nomen n, grp g, si
  where rr.revision_id = :prevision_id and
        n.nomen_id     = rr.nomen_id   and
        n.grp_id       = g.grp_id      and
        n.si_id        = si.si_id
  into :ogrp_code, :ogrp_name, :onomen_code, :onomen_name, :osi_name, :okilk_old,
       :oprice_out_pdv, :okilk_new, :pnomen_id
 do begin
  osum_program = :okilk_old  * :oprice_out_pdv;
  osum_real    = :okilk_new  * :oprice_out_pdv;
  okilk_rizn   = :okilk_old  - :okilk_new;
  osum_rizn    = :okilk_rizn * :oprice_out_pdv;

  okilk_old      = around3(:okilk_old);
  okilk_new      = around3(:okilk_new);
  okilk_rizn     = around3(:okilk_rizn);
  oprice_out_pdv = around(:oprice_out_pdv);
  osum_program   = around(:osum_program);
  osum_real      = around(:osum_real);
  osum_rizn      = around(:osum_rizn);

  select max(nb.nom_bar_id) from nom_bar nb
   where nb.nomen_id = :pnomen_id
    into :pmax_barcode_id;

  if (:pmax_barcode_id is not null) then
  begin
   select b.code from barcode b, nom_bar nb
    where nb.nom_bar_id = :pmax_barcode_id and
          b.barcode_id  = nb.barcode_id
     into :obarcode;
  end
  suspend;
 end
end
end^


ALTER PROCEDURE PRV_BARCODES_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OCODE VARCHAR(27))
AS
begin
  /* Вигрібання штрихкодів по revision_id */
for select b.barcode_id, b.code
      from rev_records rr, nom_bar nb, barcode b
    where rr.revision_id = :irevision_id and
          rr.nomen_id    = nb.nomen_id and
          nb.barcode_id  = b.barcode_id
     into :obarcode_id, :ocode
  do suspend;
end^


ALTER PROCEDURE PRV_ISBLOCK (
    IREVISION_ID INTEGER)
RETURNS (
    OIS_BLOCK INTEGER)
AS
declare variable pmarker varchar(64);
begin
  select r.is_block from revision r
     where r.revision_id = :irevision_id
  into :ois_block;

  select c.marker
    from t_configs c
   where c.config_id = 1 and
         c.module = 'revision_revision_r'
    into :pmarker;

  if (((:pmarker != 'plus') or (:pmarker is null)) and
     ((:ois_block = 0)    or (:ois_block is null))) then
   update revision r
    set r.is_block = 1
   where r.revision_id = :irevision_id;

  suspend;
end^


ALTER PROCEDURE PRV_NOM_BARS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OBARCODE_ID INTEGER)
AS
begin
  /* Вигрібання номбарів по revision_id */
  for select nb.nomen_id, nb.barcode_id
        from rev_records rr, nom_bar nb
       where rr.revision_id = :irevision_id and
             rr.nomen_id = nb.nomen_id
        into :onomen_id, :obarcode_id
  do suspend;
end^


ALTER PROCEDURE PRV_NOMENS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    ONAME VARCHAR(40),
    OIS_DIVIDEND SMALLINT,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OIN_PRICE_PDV DOUBLE PRECISION)
AS
declare variable psum_insum double precision;
declare variable psum_rest double precision;
begin
  /* вигрібання товару по revision_id */
 for select n.nomen_id, n.nomen_code, n.nomen_name, n.is_weight, n.out_price
       from nomen n, rev_records rr
      where rr.revision_id = :irevision_id and
            rr.nomen_id    = n.nomen_id
       into onomen_id, ocode, oname, ois_dividend, oout_price_pdv
  do begin
    select sum(g.goods_inprice * g.goods_rest), sum(g.goods_rest)
      from goods g
     where g.nomen_id   = :onomen_id and
           g.goods_rest > 0.002
      into psum_insum, psum_rest;

    oin_price_pdv = :psum_insum / :psum_rest;
    if ((:oin_price_pdv = 0)or(:oin_price_pdv is null)) then oin_price_pdv = 1;
    suspend;
  end
end^


ALTER PROCEDURE PRV_REV_RECORD_UPD (
    IREV_RECORD_ID INTEGER,
    IKILK_NEW DOUBLE PRECISION,
    IFLAG SMALLINT)
AS
declare variable pmarker varchar(64);
declare variable pkilk_old double precision;
declare variable pnomen_id integer;
begin
  select c.marker
    from t_configs c
   where c.config_id = 1 and
         c.module = 'revision_revision_r'
    into :pmarker;

   /* Зміна фактичних кількостей */
  if (:pmarker = 'plus') then
  begin
    update rev_records
       set kilk_new       = kilk_new + :ikilk_new
     where rev_records_id = :irev_record_id;
  end
  else
  begin
    update rev_records
       set kilk_new       = :ikilk_new
     where rev_records_id = :irev_record_id;
  end
  /* Зміна наявної кількості */
  if (:iflag = 1) then
  begin
    select rr.nomen_id from rev_records rr
     where rr.rev_records_id = :irev_record_id
      into pnomen_id;

    SELECT SUM(G.GOODS_REST)
      FROM GOODS G
     WHERE G.OBJECTS_ID = 1 AND
           G.NOMEN_ID   = :pnomen_id
      INTO pkilk_old;

    update rev_records
       set kilk_old       = :pkilk_old
     where rev_records_id = :irev_record_id;
  end

end^


ALTER PROCEDURE PRV_REV_RECORDS_VIEW_IMP (
    IREVISION_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER,
    OREVISION_ID INTEGER,
    ONOMEN_ID INTEGER,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION)
AS
begin
  /* Вигрібання записів ревізії по revision_id */
  for select rr.rev_records_id, rr.revision_id, rr.nomen_id, rr.kilk_old, rr.kilk_new
        from rev_records rr
       where rr.revision_id = :irevision_id
        into :orev_record_id, :orevision_id, :onomen_id, :okilk_old, :okilk_new
  do
  begin
    if (:okilk_new is null) then
       okilk_new = 0;

    /* При flag=1 - занулюємо фактичні кількості */
    if (:iflag = 1) then
       okilk_new = 0;

    if (:okilk_old is null) then
       okilk_old = 0;
    suspend;
  end
end^


ALTER PROCEDURE PRV_REVISION_DETAIL (
    IREVISION_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OKILK_RIZN DOUBLE PRECISION)
AS
begin
  for select n.nomen_id, n.nomen_code, n.nomen_name,
             rr.kilk_old, rr.kilk_new, (rr.kilk_new - rr.kilk_old)
         from nomen n, rev_records rr
      where rr.revision_id = :irevision_id and
            rr.nomen_id    = n.nomen_id
      into :onomen_id, :onomen_code, :onomen_name,
           :okilk_old, :okilk_new, :okilk_rizn
  do suspend;
end^


ALTER PROCEDURE PRV_REVISION_UPD (
    IREVISION_ID INTEGER)
AS
begin
  update revision
     set is_block = 0
   where revision_id = :irevision_id;
end^


ALTER PROCEDURE PRV_REVISION_VIEW (
    IREVISION_ID INTEGER,
    ILIST VARCHAR(10000))
RETURNS (
    OREVISION_ID INTEGER,
    OIS_BLOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OIS_INLBD SMALLINT)
AS
begin
  select r.revision_id, r.is_block, r.revision_date, r.revision_mark
       from revision r
        where r.revision_id = :irevision_id
      into :orevision_id, :ois_block, :orevision_date, :orevision_mark;

     if (:ois_block is null) then
         ois_block = 0;

     ois_inLBD = isinliststr(:ilist, :orevision_id);

     suspend;
end^


ALTER PROCEDURE PRV_REVISIONS_VIEW (
    ILIST VARCHAR(10000))
RETURNS (
    OREVISION_ID INTEGER,
    OIS_BLOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OIS_INLBD SMALLINT)
AS
begin
  for select r.revision_id, r.is_block, r.revision_date, r.revision_mark
       from revision r
        where r.revision_lock = 0
      into :orevision_id, :ois_block, :orevision_date, :orevision_mark
   do begin
     if (:ois_block is null) then
         ois_block = 0;
     ois_inLBD = isinliststr(:ilist, :orevision_id);
     suspend;
   end
end^


ALTER PROCEDURE PRV_REVISIONS_VIEW_IMP (
    IREVISION_ID INTEGER)
RETURNS (
    OREVISION_ID INTEGER,
    OREVISION_DATE DATE,
    OTOKEN VARCHAR(40))
AS
begin
  select r.revision_id, r.revision_date, r.revision_mark
    from revision r
   where r.revision_id = :irevision_id
    into :orevision_id, :orevision_date, :otoken;
  suspend;
end^


ALTER PROCEDURE PS_ACCOUNT_INS (
    ICLIENT_ID INTEGER,
    IACCOUNT_NUM VARCHAR(20),
    IBANK_ID INTEGER)
RETURNS (
    OACCOUNT_ID INTEGER)
AS
begin
  oaccount_id = GEN_ID(GEN_CLIENTACCOUNT_ID,1);
  insert into clientaccount(account_id, account_num, clients_id, banks_id)
               values(:oaccount_id, :iaccount_num, :iclient_id, :ibank_id);
  suspend;
end^


ALTER PROCEDURE PS_ACCOUNT_UPD (
    IACCOUNT_ID INTEGER,
    IACCOUNT_NUM VARCHAR(20),
    IBANK_ID INTEGER)
AS
begin
  update clientaccount ca
    set ca.account_num = :iaccount_num,
        ca.banks_id = :ibank_id
   where ca.account_id = :iaccount_id;
end^


ALTER PROCEDURE PS_ACCOUNTS_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OACCOUNT_NUM VARCHAR(20),
    OBANK_NAME VARCHAR(40),
    OMFO VARCHAR(20),
    OACCOUNT_ID INTEGER,
    OBANK_ID INTEGER)
AS
begin
  for select ca.account_id, ca.account_num, b.name, b.mfo, b.banks_id from clientaccount ca, banks b
      where ca.clients_id = :iclient_id and
            ca.banks_id = b.banks_id
    into :oaccount_id, :oaccount_num, :obank_name, :omfo, :obank_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_AO_CREATE_TD1 (
    ILIST_OF_ID VARCHAR(1000))
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
declare variable TCLIENT_ID integer;
declare variable TLAST_DOC_NUM varchar(14);
declare variable TSTAFF_ID integer;
declare variable TNOTE varchar(30);
declare variable TNOMEN_ID integer;
declare variable TDOCREC_ID integer;
declare variable TKILK double precision;
declare variable TPRICE double precision;
declare variable TAO_ID integer;
begin
  select first(1) ao.ao_note, ao.ao_client_id, ao.ao_staff_id
    from autoorders ao
   where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1
    into tnote, tclient_id, tstaff_id;
  tnote = substring(:tnote from 1 for 14);

  odocument_id = gen_id(gen_documents_id, 1);

  select odoc_num from ps_document_number
    into tlast_doc_num;

    insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
        doc_lock, user_name, blok, clients_id, disc_persent, oplata_type, oplata_state, staff_id, note)
      values (:odocument_id, :tlast_doc_num, :tnote, 'today', 1, :tclient_id,
        0, user, 0, 1, 0, 2, 0, :tstaff_id, :ilist_of_id);

  for select ao.autoorder_id
        from autoorders ao
       where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1
        into tao_id
  do begin
    insert into t_document_autoorder (documents_id, autoorder_id)
       values(:odocument_id, :tao_id);
  end

/*$$IBEC$$   for select aor.aor_nomen_id, aor.aor_ordered
        from autoorders ao
             inner join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
       where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1
       order by aor.ao_record_id
        into tnomen_id, tkilk
  do begin
    select n.out_price from nomen n
     where n.nomen_id = :tnomen_id
      into tprice;

    select dr.docrec_id from docrec dr
     where dr.nomen_id    = :tnomen_id and
           dr.document_id = :odocument_id
      into tdocrec_id;

    if (:tdocrec_id is null) then
    begin
      select di.odocrec_id from ps_docrec_td1_ins(:odocument_id,  :tnomen_id, :tkilk, :tprice, 0) di
        into tdocrec_id;
    end else
    begin
      select du.okilk from ps_docrec_td1_upd(:tdocrec_id, :tkilk, :tprice, 0) du
        into tkilk;
    end
    tdocrec_id = null;
  end $$IBEC$$*/
  update autoorders ao
     set ao.document_id = :odocument_id
   where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1;

end^


ALTER PROCEDURE PS_AO_CREATE_TD1_INFO (
    ILIST_OF_ID VARCHAR(1000))
RETURNS (
    OMESSAGE VARCHAR(256))
AS
declare variable PCOUNT integer;
declare variable PNOMEN_ID integer;
declare variable PORDERED double precision;
declare variable PDR_KILK double precision;
begin
  select count(distinct ao.ao_client_id) from autoorders ao
   where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1
    into pcount;
  if (:pcount > 1) then
  begin
    omessage = 'Різних клієнтів: ' || cast(:pcount as varchar(5));
    suspend;
  end

  select count(ao.autoorder_id) from autoorders ao
   where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1 and
         ao.ao_date < (cast('today' as date) - 7)
    into pcount;
  if (:pcount > 0) then
  begin
    omessage = 'Прострочених (старших 7 днів) замовлень: ' || cast(:pcount as varchar(5));
    suspend;
  end

  select count(ao.autoorder_id)
    from autoorders ao
         inner join t_document_autoorder da on ao.autoorder_id = da.autoorder_id
         inner join documents d on da.documents_id = d.document_id
   where ISINLISTSTR(:ilist_of_id, ao.autoorder_id) = 1 and
         d.doc_lock = 0
    into pcount;
  if (:pcount > 0) then
  begin
    omessage = 'Замовлень на основі яких уже є створені НЕ зафіксовані прихідні: ' || cast(:pcount as varchar(5));
    suspend;
  end

  pcount = 0;
  for select distinct aor.aor_nomen_id
        from ao_records aor
       where ISINLISTSTR(:ilist_of_id, aor.aor_autoorder_id) = 1
        into pnomen_id
  do begin
      select first(1) aor.aor_ordered
        from ao_records aor
       where ISINLISTSTR(:ilist_of_id, aor.aor_autoorder_id) = 1  and
             aor.aor_nomen_id = :pnomen_id
       order by aor.ao_record_id desc
        into pordered;
     if (:pordered is null) then pordered = 0;

     select sum(dr.kilk)
       from docrec dr
            inner join t_document_autoorder da on da.documents_id = dr.document_id
      where ISINLISTSTR(:ilist_of_id, da.autoorder_id) = 1 and
            dr.nomen_id = :pnomen_id
       into pdr_kilk;
     if (:pdr_kilk is null) then pdr_kilk = 0;

    if (:pdr_kilk < :pordered) then
      pcount = :pcount + 1;
  end

  if (:pcount = 0) then
  begin
    omessage = 'Усі позиції замовлення вже у документах';
    suspend;
  end

end^


ALTER PROCEDURE PS_AO_DEL_REPEAT_RECS (
    IAUTOORDER_ID INTEGER)
AS
declare variable pao_record_id integer;
declare variable paor_nomen_id integer;
declare variable pcount integer;
begin
  for select r.ao_record_id, r.aor_nomen_id
       from ao_records r
      where r.aor_autoorder_id = :iautoorder_id
      into :pao_record_id, :paor_nomen_id
  do begin
      delete from ao_records ar
      where ar.ao_record_id > :pao_record_id and
            ar.aor_nomen_id  = :paor_nomen_id;
  end
end^


ALTER PROCEDURE PS_AO_DEL_ZERO_RECS (
    IAUTOORDER_ID INTEGER)
AS
begin
  delete from ao_records ar
  where ar.aor_autoorder_id = :iautoorder_id and
        ar.aor_ordered      = 0;
end^


ALTER PROCEDURE PS_AO_RECORD_DEL (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  ocaption = 'записів в замовленні';
  ocount = 0;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from ao_records aor
      where aor.ao_record_id = :iao_record_id;
  end
end^


ALTER PROCEDURE PS_AO_RECORD_GRP_INS (
    AUTOORDER_ID INTEGER,
    GRP_ID INTEGER)
AS
declare variable p_flag_id smallint;
declare variable p_date_in date;
declare variable p_date_out date;
declare variable p_begin double precision;
declare variable p_arrival double precision;
declare variable p_charge double precision;
declare variable p_end double precision;
declare variable p_min_rest double precision;
declare variable p_nomen_id integer;
declare variable p_analysed_days integer;
declare variable p_ordered_days integer;
declare variable p_ordered double precision;
declare variable p_is_visible smallint;
declare variable pis_exist integer;
declare variable ptype_nomen integer;
declare variable pis_active smallint;
declare variable pw3_nomen_id integer;
begin
p_flag_id = 0; /* not add */
if (:grp_id is null) then grp_id=0;

select ao.ao_date, ao.ao_date - ao.ao_analysed_days, ao.ao_analysed_days,
       ao.ao_ordered_days
  from autoorders ao
 where ao.autoorder_id = :autoorder_id
  into p_date_out, p_date_in, p_analysed_days, p_ordered_days;
   if (:p_date_out      is null) then p_flag_id       = 0;
   if (:p_analysed_days is null) then p_analysed_days = 0;
   if (:p_ordered_days  is null) then p_ordered_days  = 0;
 /* add the all group ------------------------------------------------------- */
begin
  for select nv.nomen_id, nv.min_rest, sum(nv.begin_k), sum(nv.arrival_k), sum(nv.charge_k), sum(nv.end_k)
        from aog_grp_view(:grp_id, :p_date_in, :p_date_out) nv
    group by nv.nomen_id, nv.min_rest
        into p_nomen_id, p_min_rest, p_begin, p_arrival, p_charge, p_end
  do begin
   select n.is_visible, n.is_exist, n.is_active, n.type_nomen, n.w3_nomen_id
     from nomen n
    where n.nomen_id = :p_nomen_id
     into p_is_visible, pis_exist, pis_active, ptype_nomen, pw3_nomen_id;
   if ((:pw3_nomen_id is not null) and                    --зв'язаний
       ((:p_is_visible = 1)or(:p_is_visible is null)) and --видимий
       ((:pis_exist    = 1)or(:pis_exist    is null)) and --існуючий
       ((:pis_active   = 1)or(:pis_active   is null)) and --активний
       ((:ptype_nomen  = 0)or(:ptype_nomen  is null)))then
   begin
     if (:p_min_rest  is null) then p_min_rest = 0.000;
     if (:p_begin     is null) then p_begin    = 0.000;
     if (:p_arrival   is null) then p_arrival  = 0.000;
     if (:p_charge    is null) then p_charge   = 0.000;
     if (:p_end       is null) then p_end      = 0.000;
     if (:p_analysed_days = 0) then
     begin
       p_ordered = 0.000;
     end
     else begin
       p_ordered=((:p_charge / :p_analysed_days) * :p_ordered_days) - :p_end + :p_min_rest;
     end
     if (:p_ordered < 0.000) then p_ordered = 0.000;
     p_ordered = cast(around(:p_ordered/100)*100 as integer);
     insert into ao_records (aor_autoorder_id, aor_nomen_id, aor_begin, aor_arrival,
                             aor_charge, aor_end, aor_min_rest, aor_ordered)
      values (:autoorder_id, :p_nomen_id, :p_begin, :p_arrival,
              :p_charge,  :p_end,  :p_min_rest, :p_ordered);
   end
  end
 end
end^


ALTER PROCEDURE PS_AO_RECORD_INS (
    IAUTOORDER_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER)
AS
declare variable TDATE_IN date;
declare variable TDATE_OUT date;
declare variable TBEGIN double precision;
declare variable TARRIVAL double precision;
declare variable TCHARGE double precision;
declare variable TEND double precision;
declare variable TMIN_REST double precision;
declare variable TANALYSED_DAYS integer;
declare variable TORDERED_DAYS integer;
declare variable TORDERED double precision;
declare variable TUSE_PERIOD smallint;
declare variable TDATE0 date;
declare variable TDATE1 date;
declare variable TDAYS_COUNT integer;
declare variable TREST double precision;
declare variable TSDP double precision;
declare variable TCHECK_K double precision;
declare variable PBEGIN double precision;
declare variable PARRIVAL double precision;
declare variable PCHARGE double precision;
declare variable PEND double precision;
declare variable PCHECK_K double precision;
begin
 if (:inomen_id is null) then inomen_id=0;

 select ao.ao_date, ao.ao_date - ao.ao_analysed_days, ao.ao_analysed_days,
        ao.ao_ordered_days, ao.ao_use_period, ao.ao_date0, ao.ao_date1
   from autoorders ao
  where ao.autoorder_id = :iautoorder_id
   into tdate_out, tdate_in, tanalysed_days,
        tordered_days, tuse_period, tdate0, tdate1;

 if (:tuse_period = 1) then
 begin
   tdate_in  = :tdate0;
   tdate_out = :tdate1;
 end

  select n.minkilk from nomen n
   where n.nomen_id = :inomen_id
    into tmin_rest;

  if (:tmin_rest is null) then tmin_rest = 0.000;
  tdate1 = :tdate_out;
  tdays_count = 0;
  pbegin   = 0.0;
  parrival = 0.0;
  pcharge  = 0.0;
  pend     = 0.0;
  pcheck_k = 0.0;
  for select nv.date_d, sum(nv.begin_k), sum(nv.arrival_k), sum(nv.charge_k), sum(nv.end_k), sum(nv.check_k)
        from aog_nomen_view(:inomen_id, :tdate_in, :tdate_out) nv
    group by nv.date_d
    order by nv.date_d desc
        into tdate0,  tbegin, tarrival, tcharge, tend, tcheck_k
  do begin
    pbegin   = :pbegin + :tbegin;
    parrival = :parrival + :tarrival;
    pcharge  = :pcharge + :tcharge;
    pend     = :pend + :tend;
    pcheck_k = :pcheck_k + :tcheck_k;

    trest = :trest + :tbegin;
    if (:tdate0 <= :tdate_out) then
    begin
      if ((:trest > (tcharge + 0.000001))or((:trest < 0.000001)and(:tbegin < 0))) then
      begin
        if (:tdate1 > :tdate_out) then tdate1 = :tdate_out + 1;
        tdays_count = :tdays_count + (:tdate1 - :tdate0);
      end
      else if (:tcheck_k > 0.0001) then
        tdays_count = :tdays_count + 1;
    end
    tdate1 = :tdate0;
  end
  if (:tdays_count > (:tdate_out - :tdate_in)) then tdays_count = (:tdate_out - :tdate_in);

/*$$IBEC$$   select sum(nv.begin_k), sum(nv.arrival_k), sum(nv.charge_k), sum(nv.end_k), sum(nv.check_k)
    from aog_nomen_view(:inomen_id, :tdate_in, :tdate_out) nv
    into tbegin, tarrival, tcharge, tend, tcheck_k; $$IBEC$$*/

    tbegin   = :pbegin;
    tarrival = :parrival;
    tcharge  = :pcharge;
    tend     = :pend;
    tcheck_k = :pcheck_k;

  if (:tbegin   is null) then tbegin    = 0.000;
  if (:tarrival is null) then tarrival  = 0.000;
  if (:tcharge  is null) then tcharge   = 0.000;
  if (:tcheck_k is null) then tcheck_k  = 0.000;
  select first(1) r.rest from rst r
   where r.nomen_id = :inomen_id
    into trest;
  if (:tend     is null) then tend      = 0.000;
  if (:trest    is null) then trest     = 0.000;
  if (:tdays_count = 0) then begin
    tordered = :tmin_rest- :trest;
    tsdp = 0.00;
  end
  else begin
    tsdp = around(:tcheck_k / :tdays_count);
    tordered = (tsdp * :tordered_days) - :trest + :tmin_rest;
  end

  if (:tordered < 0.000) then tordered = 0.000;
  tordered = cast(around(:tordered/100)*100 as integer);

  oao_record_id = gen_id(gen_ao_record_id, 1);
  insert into ao_records (ao_record_id, aor_autoorder_id, aor_nomen_id, aor_begin,
                          aor_arrival, aor_charge, aor_end, aor_min_rest, aor_ordered,
                          aor_middldaily_sales, aor_days_was, aor_check)
             values (:oao_record_id, :iautoorder_id, :inomen_id, :tbegin,
                     :tarrival, :tcharge, :tend, :tmin_rest, :tordered,
                     :tsdp, :tdays_count, :tcheck_k);
  suspend;
end^


ALTER PROCEDURE PS_AO_RECORD_VIEW (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12))
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
declare variable tautoorder_id integer;
begin
/*  */
 select aor.aor_autoorder_id from ao_records aor
     where aor.ao_record_id = :iao_record_id
   into :tautoorder_id;

 select ao.ao_analysed_days, ao.ao_ordered_days
  from autoorders ao
  where ao.autoorder_id=:tautoorder_id
  into :tanalysed_days, :tordered_days;
 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days is null) then tordered_days = 0;

 select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, n.datex_name, n.brutto, s.si_name
      from ao_records aor left join nomen n on aor.aor_nomen_id=n.nomen_id,
           si s
      where aor.ao_record_id = :iao_record_id and
            n.si_id = s.si_id
      into :oao_record_id, :onomen_id, :onomen_code, :onomen_name,
           :obegin, :oarrival, :ocharge, :oend,
           :omin_rest, :oordered, :odatex_name, :obrutto, :osi_name;

  if (:ocharge is null) then ocharge=0.000;
  if (:oend is null) then oend=0.000;
  if (:omin_rest is null) then omin_rest=0.000;
  if (:tanalysed_days = 0) then begin orec_order = 0.000; end
   else begin
    orec_order=((:ocharge / :tanalysed_days) * :tordered_days) - :oend + :omin_rest;
   end
  orec_order = cast(around(:orec_order / 100) * 100 as integer);
  if (:oordered is null) then oordered = :orec_order;
  suspend;
end^


ALTER PROCEDURE PS_AO_RECORD_VIEW_V1 (
    IAO_RECORD_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION)
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
declare variable tautoorder_id integer;
declare variable pmaxgoods_id integer;
declare variable p_sdp double precision;
declare variable prest double precision;
begin
/*  */
 select aor.aor_autoorder_id from ao_records aor
  where aor.ao_record_id = :iao_record_id
   into tautoorder_id;

 select ao.ao_analysed_days, ao.ao_ordered_days
   from autoorders ao
  where ao.autoorder_id = :tautoorder_id
   into tanalysed_days, tordered_days;
 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days  is null) then tordered_days = 0;

 select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, n.datex_name, n.brutto, s.si_name,
            aor.aor_middldaily_sales
       from ao_records aor
            left join nomen n on aor.aor_nomen_id = n.nomen_id
            left join si s on n.si_id = s.si_id
      where aor.ao_record_id = :iao_record_id
       into oao_record_id, onomen_id, onomen_code, onomen_name,
            obegin, oarrival, ocharge, oend,
            omin_rest, oordered, odatex_name, obrutto, osi_name,
            p_sdp;

  if (:ocharge    is null) then ocharge   = 0.000;
  if (:oend       is null) then oend      = 0.000;
  if (:omin_rest  is null) then omin_rest = 0.000;
  select first(1) r.rest from rst r
   where r.nomen_id = :onomen_id
    into prest;
  if (:prest      is null) then prest     = 0.000;
  if (:tanalysed_days = 0) then
  begin
    orec_order = :omin_rest - :prest;
  end else begin
    orec_order = (:p_sdp * :tordered_days) - :prest + :omin_rest;
  end
  orec_order = cast(around(:orec_order / 100) * 100 as integer);
  if (:oordered is null) then oordered = :orec_order;

    select max(g.goods_id)
    from goods g
   where g.nomen_id = :onomen_id
    into pmaxgoods_id;

  select g.goods_inprice
    from goods g
   where g.goods_id = :pmaxgoods_id
    into olast_inprice;
  suspend;
end^


ALTER PROCEDURE PS_AO_RECORDS_PRINT (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION,
    OBARCODE VARCHAR(20),
    OW3_NOMEN_ID INTEGER)
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
declare variable pmaxgoods_id integer;
declare variable p_sdp double precision;
declare variable prest double precision;
declare variable pbarcode_id integer;
begin
 select ao.ao_analysed_days, ao.ao_ordered_days
   from autoorders ao
  where ao.autoorder_id = :autoorder_id
   into tanalysed_days, tordered_days;
 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days  is null) then tordered_days = 0;
 for select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, n.datex_name, n.brutto, s.si_name,
            aor.aor_middldaily_sales, n.w3_nomen_id
       from ao_records aor
            left join nomen n on aor.aor_nomen_id = n.nomen_id
            left join si s on n.si_id = s.si_id
      where aor.aor_autoorder_id = :autoorder_id
       into oao_record_id, onomen_id, onomen_code, onomen_name,
            obegin, oarrival, ocharge, oend,
            omin_rest, oordered, odatex_name, obrutto, osi_name,
            p_sdp, ow3_nomen_id
 do begin
  if (:ocharge   is null) then ocharge   = 0.000;
  if (:oend      is null) then oend      = 0.000;
  if (:omin_rest is null) then omin_rest = 0.000;
  select first(1) r.rest from rst r
   where r.nomen_id = :onomen_id
    into prest;

  select max(nb.barcode_id) from nom_bar nb
   where nb.nomen_id = :onomen_id
    into pbarcode_id;
  select b.code from barcode b
   where b.barcode_id = :pbarcode_id
    into obarcode;

  if (:prest      is null) then prest     = 0.000;
  if (:tanalysed_days = 0) then begin
    orec_order = 0.000;
  end else begin
    orec_order = (:p_sdp * :tordered_days) - :prest + :omin_rest;
  end
  orec_order = cast(around(:orec_order / 100) * 100 as integer);
  if (:oordered is null) then oordered = :orec_order;

  select max(g.goods_id)
    from goods g
   where g.nomen_id = :onomen_id
    into pmaxgoods_id;

  select g.goods_inprice
    from goods g
   where g.goods_id = :pmaxgoods_id
    into olast_inprice;
  suspend;
 end
end^


ALTER PROCEDURE PS_AO_RECORDS_VIEW (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12))
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
begin
 select ao.ao_analysed_days, ao.ao_ordered_days
  from autoorders ao
  where ao.autoorder_id=:autoorder_id
  into :tanalysed_days, :tordered_days;
 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days is null) then tordered_days = 0;
 for select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, n.datex_name, n.brutto, s.si_name
      from ao_records aor left join nomen n on aor.aor_nomen_id=n.nomen_id,
           si s
      where aor.aor_autoorder_id=:autoorder_id and
            n.si_id = s.si_id
      into :oao_record_id, :onomen_id, :onomen_code, :onomen_name,
           :obegin, :oarrival, :ocharge, :oend,
           :omin_rest, :oordered, :odatex_name, :obrutto, :osi_name
 do begin
  if (:ocharge   is null) then ocharge   = 0.000;
  if (:oend      is null) then oend      = 0.000;
  if (:omin_rest is null) then omin_rest = 0.000;
  if (:tanalysed_days = 0) then begin orec_order = 0.000; end
   else begin
    orec_order=((:ocharge / :tanalysed_days) * :tordered_days) - :oend + :omin_rest;
   end
  orec_order = cast(around(:orec_order / 100) * 100 as integer);
  if (:oordered is null) then oordered = :orec_order;
  suspend;
 end
end^


ALTER PROCEDURE PS_AO_RECORDS_VIEW_V1 (
    AUTOORDER_ID INTEGER)
RETURNS (
    OAO_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN DOUBLE PRECISION,
    OARRIVAL DOUBLE PRECISION,
    OCHARGE DOUBLE PRECISION,
    OEND DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION)
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
declare variable pmaxgoods_id integer;
declare variable p_sdp double precision;
declare variable prest double precision;
begin
 select ao.ao_analysed_days, ao.ao_ordered_days
   from autoorders ao
  where ao.autoorder_id = :autoorder_id
   into tanalysed_days, tordered_days;
 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days  is null) then tordered_days = 0;
 for select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, n.datex_name, n.brutto, s.si_name,
            aor.aor_middldaily_sales
       from ao_records aor
            left join nomen n on aor.aor_nomen_id = n.nomen_id
            left join si s on n.si_id = s.si_id
      where aor.aor_autoorder_id = :autoorder_id
       into oao_record_id, onomen_id, onomen_code, onomen_name,
            obegin, oarrival, ocharge, oend,
            omin_rest, oordered, odatex_name, obrutto, osi_name,
            p_sdp
 do begin
  if (:ocharge   is null) then ocharge   = 0.000;
  if (:oend      is null) then oend      = 0.000;
  if (:omin_rest is null) then omin_rest = 0.000;
  select first(1) r.rest from rst r
   where r.nomen_id = :onomen_id
    into prest;

  if (:prest      is null) then prest     = 0.000;
  if (:tanalysed_days = 0) then begin
    orec_order = :omin_rest - :prest;
  end else begin
    orec_order = (:p_sdp * :tordered_days) - :prest + :omin_rest;
  end
  orec_order = cast(around(:orec_order / 100) * 100 as integer);
  if (:oordered is null) then oordered = :orec_order;

  select max(g.goods_id)
    from goods g
   where g.nomen_id = :onomen_id
    into pmaxgoods_id;

  select g.goods_inprice
    from goods g
   where g.goods_id = :pmaxgoods_id
    into olast_inprice;
  suspend;
 end
end^


ALTER PROCEDURE PS_AUTOORDER_DEL (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  ocaption = 'записів в замовленні';
  select count(ar.ao_record_id) from ao_records ar
      where ar.aor_autoorder_id = :iautoorder_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from autoorders a
      where a.autoorder_id = :iautoorder_id;
  end
end^


ALTER PROCEDURE PS_AUTOORDER_DETAIL (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OAUTOORDER_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OBEGIN_K DOUBLE PRECISION,
    OARRIVAL_K DOUBLE PRECISION,
    OCHARGE_K DOUBLE PRECISION,
    OEND_K DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OREC_ORDER DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION)
AS
declare variable tanalysed_days integer;
declare variable tordered_days integer;
declare variable prest double precision;
declare variable p_sdp double precision;
begin
 select ao.ao_analysed_days, ao.ao_ordered_days
   from autoorders ao where ao.autoorder_id = :iautoorder_id
   into tanalysed_days, tordered_days;

 if (:tanalysed_days is null) then tanalysed_days = 0;
 if (:tordered_days  is null) then tordered_days = 0;
 for select aor.ao_record_id, aor.aor_nomen_id, n.nomen_code, n.nomen_name,
            aor.aor_begin, aor.aor_arrival, aor.aor_charge, aor.aor_end,
            aor.aor_min_rest, aor.aor_ordered, aor.aor_middldaily_sales
       from ao_records aor left join nomen n on aor.aor_nomen_id=n.nomen_id
      where aor.aor_autoorder_id = :iautoorder_id
       into oautoorder_record_id, onomen_id, onomen_code, onomen_name,
            obegin_k, oarrival_k, ocharge_k, oend_k,
            omin_rest, oordered, p_sdp
 do begin
  if (:ocharge_k is null) then ocharge_k = 0.000;
  if (:oend_k    is null) then oend_k    = 0.000;
  if (:omin_rest is null) then omin_rest = 0.000;
  select first(1) r.rest from rst r
   where r.nomen_id = :onomen_id
    into prest;
  if (:p_sdp      is null) then p_sdp = 0;
  if (:prest      is null) then prest = 0.000;
/*$$IBEC$$   if (:tanalysed_days = 0) then begin
    orec_order = :omin_rest - :prest;
  end else begin $$IBEC$$*/
    orec_order = (:p_sdp * :tordered_days) - :prest + :omin_rest;
/*$$IBEC$$   end $$IBEC$$*/

  orec_order = cast(around(:orec_order/100)*100 as integer);
  if (:oordered is null) then oordered = :orec_order;
  suspend;
 end
end^


ALTER PROCEDURE PS_AUTOORDER_FIX (
    IAUTOORDER_ID INTEGER)
AS
begin
  delete from ao_records aor
   where aor.aor_autoorder_id = :iautoorder_id and
         aor.aor_ordered between -0.000001 and 0.000001;

  update autoorders
     set ao_conditions = absrizn(ao_conditions, 1)
   where autoorder_id = :iautoorder_id;
end^


ALTER PROCEDURE PS_AUTOORDER_HEADER_VIEW (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(30),
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OAUTOORDER_ID INTEGER,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_ADRESS VARCHAR(50),
    OCLIENT_PHONE VARCHAR(24),
    OOBJECT_NAME VARCHAR(50),
    OOBJECT_ADRESS VARCHAR(50),
    OOBJECT_PHONE VARCHAR(24),
    ODATE_IN DATE)
AS
declare variable puser_id integer;
begin
  select ao_conditions, ao_note, ao_date, ao_client_id, ao_staff_id,
         ao_analysed_days, ao_ordered_days, user_id, date_in
    from autoorders a
   where a.autoorder_id = :iautoorder_id
    into ois_fixed, otoken, odate, oclient_id, ostaff_id,
         oanalysed_days, oordered_days, puser_id, odate_in;

  oautoorder_id = :iautoorder_id;

  select cl.name,  cl.deliv_addr, cl.phone
    from clients cl
   where clients_id = :oclient_id
    into oclient_name, oclient_adress, oclient_phone;

  select cl.name,  cl.deliv_addr, cl.phone
    from clients cl
   where clients_id = 1
    into oobject_name, oobject_adress, oobject_phone;

    if (:puser_id is null) then
    begin
      select surname||' '||firstchar(name)||'.'||firstchar(patronymic)||'.' from staff
       where staff_id = :ostaff_id
        into ostaff_name;
    end else begin
      select u.user_surname ||' '|| firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.' as PIB
        from t_users u where u.user_id = :puser_id
        into ostaff_name;
    end
  suspend;
end^


ALTER PROCEDURE PS_AUTOORDER_INS (
    ITOKEN VARCHAR(30),
    ICLIENT_ID INTEGER,
    ILIABLE_ID INTEGER,
    IANALYSED INTEGER,
    IORDERED INTEGER)
RETURNS (
    OAUTOORDER_ID INTEGER)
AS
begin
  oautoorder_id = gen_id(gen_autoorder_id, 1);

  insert into autoorders (autoorder_id, ao_note, ao_client_id, user_id, ao_analysed_days, ao_ordered_days)
    values (:oautoorder_id, :itoken, :iclient_id, :iliable_id, :ianalysed, :iordered);
  suspend;
end^


ALTER PROCEDURE PS_AUTOORDER_VIEW (
    IAUTOORDER_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(30),
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OCLIENT_NAME VARCHAR(50),
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OAUTOORDER_ID INTEGER,
    OIN_SUM_PDV DOUBLE PRECISION)
AS
declare variable puser_id integer;
begin
  select ao_conditions, ao_note, ao_date, ao_client_id, ao_staff_id,
         ao_analysed_days, ao_ordered_days, user_id
    from autoorders a
   where a.autoorder_id = :iautoorder_id
    into ois_fixed, otoken, odate, oclient_id, ostaff_id,
         oanalysed_days, oordered_days, puser_id;

  oautoorder_id = :iautoorder_id;

  select name from clients
   where clients_id = :oclient_id
    into oclient_name;

    if (:puser_id is null) then
    begin
      select surname||' '||firstchar(name)||'.'||firstchar(patronymic)||'.' from staff
       where staff_id = :ostaff_id
        into ostaff_name;
    end else begin
      select u.user_surname ||' '|| firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.' as PIB
        from t_users u where u.user_id = :puser_id
        into ostaff_name;
    end
    select sum(rv.olast_inprice * rv.oordered) from ps_ao_records_view_v1(:iautoorder_id) rv
      into oin_sum_pdv;
    if (:oin_sum_pdv is null) then oin_sum_pdv = 0.00;
  suspend;
end^


ALTER PROCEDURE PS_AUTOORDERS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(30),
    OAUTOORDER_ID INTEGER,
    OCLIENT_ID INTEGER,
    OSTAFF_ID INTEGER,
    ODATE DATE,
    OIS_FIXED SMALLINT,
    OCLIENT_NAME VARCHAR(50),
    OSTAFF_NAME VARCHAR(50),
    OANALYSED_DAYS SMALLINT,
    OORDERED_DAYS SMALLINT,
    OIN_SUM_PDV DOUBLE PRECISION)
AS
declare variable puser_id integer;
begin
  for select ao_conditions, autoorder_id, ao_note, ao_date, ao_client_id, user_id,
             ao_analysed_days, ao_ordered_days, ao_staff_id
        from autoorders a
       where ao_date between :idate0 and :idate1
        into ois_fixed, oautoorder_id, otoken, odate, oclient_id, puser_id,
             oanalysed_days, oordered_days, ostaff_id
  do begin
    select name from clients
     where clients_id = :oclient_id
      into oclient_name;

    if (:puser_id is null) then
    begin
      select surname||' '||firstchar(name)||'.'||firstchar(patronymic)||'.' from staff
       where staff_id = :ostaff_id
        into ostaff_name;
    end else begin
      select u.user_surname ||' '|| firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.' as PIB
        from t_users u where u.user_id = :puser_id
        into ostaff_name;
    end
    select sum(rv.olast_inprice * rv.oordered) from ps_ao_records_view_v1(:oautoorder_id) rv
      into oin_sum_pdv;
    if (:oin_sum_pdv is null) then oin_sum_pdv = 0.00;
    suspend;
    oclient_id   = null;
    ostaff_id    = null;
    oclient_name = null;
    ostaff_name  = null;
    oin_sum_pdv  = null;
  end
end^


ALTER PROCEDURE PS_BANK_DEL (
    IBANK_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  ocaption = 'рахунків';
  select count(a.account_id) from clientaccount a
      where a.banks_id = :ibank_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from banks b
      where b.banks_id = :ibank_id;
  end
end^


ALTER PROCEDURE PS_BANK_INS (
    INAME VARCHAR(40),
    IMFO VARCHAR(20))
RETURNS (
    OBANK_ID INTEGER)
AS
begin
  obank_id = GEN_ID(GEN_BANKS_ID,1);
  insert into banks(banks_id, name, mfo)
     values (:obank_id, :iname, :imfo);
  suspend;
end^


ALTER PROCEDURE PS_BARCODE_INS (
    IBARCODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
RETURNS (
    OBARCODE_ID INTEGER)
AS
begin
  /* Procedure Text */
  select max(b.barcode_id) from barcode b
      where b.code = :ibarcode
  into :obarcode_id;

  if (obarcode_id is null) then
  begin
    obarcode_id = GEN_ID(GEN_BARCODE_ID,1);
    insert into barcode(barcode_id, code)
      values(:obarcode_id, :ibarcode);
  end

  insert into nom_bar(nomen_id, barcode_id, barcode_type_id, out_price)
    values (:inomen_id, :obarcode_id, :ibarcode_type_id, :iout_price);

  suspend;
end^


ALTER PROCEDURE PS_BARCODE_UPD (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
AS
begin
  /* Procedure Text */

  update nom_bar nb
    set nb.out_price = :iout_price,
        nb.barcode_type_id = :ibarcode_type_id
   where nb.nomen_id = :inomen_id and
         nb.barcode_id = :ibarcode_id;
end^


ALTER PROCEDURE PS_BARCODES_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OBARCODE VARCHAR(27),
    OOUT_PRICE DOUBLE PRECISION,
    OBARCODE_TYPE_ID INTEGER,
    OTYPE_NAME VARCHAR(20))
AS
begin
  for select b.barcode_id, b.code, nb.barcode_type_id, nb.out_price from nom_bar nb, barcode b
      where nb.nomen_id = :inomen_id and
            b.barcode_id = nb.barcode_id
    into :obarcode_id, :obarcode, :obarcode_type_id, :oout_price
  do begin
    if (:obarcode_type_id is null) then
      obarcode_type_id = 0;

    select bt.type_name from t_barcode_types bt
        where bt.barcode_type_id = :obarcode_type_id
      into :otype_name;

    suspend;

    obarcode_type_id = null;
  end
end^


ALTER PROCEDURE PS_CALC_RECORD_DEL (
    ICALC_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;
  ocount = 0;
  ocaption = '';

  /*
  ocaption = '';
  select count() from
      where _id = :i_id
    into :ocount;
  tsuma = tsuma + :ocount;
  suspend;
  */

  if (:tsuma = 0) then
  begin
    delete from t_calc_records cr where cr.calc_record_id = :icalc_record_id;
  end

  suspend;
end^


ALTER PROCEDURE PS_CALC_RECORD_INS (
    ICALCULATION_ID INTEGER,
    INOMEN_ID INTEGER,
    IINPUT_QUANTITY DOUBLE PRECISION,
    INETTO DOUBLE PRECISION)
RETURNS (
    OCALC_RECORD_ID INTEGER)
AS
begin
  ocalc_record_id = gen_id(gen_t_calc_records_id, 1);

  insert into t_calc_records(calc_record_id, calculation_id, nomen_id, input_quantity, netto)
     values(:ocalc_record_id, :icalculation_id, :inomen_id, :iinput_quantity, :inetto);
  suspend;
end^


ALTER PROCEDURE PS_CALC_RECORD_UPD (
    ICALC_RECORD_ID INTEGER,
    IINPUT_QUANTITY DOUBLE PRECISION,
    INETTO DOUBLE PRECISION)
RETURNS (
    OCALC_RECORD_ID INTEGER)
AS
begin
  ocalc_record_id = :icalc_record_id;

  update t_calc_records cr set
         cr.input_quantity = :iinput_quantity,
         cr.netto          = :inetto
   where cr.calc_record_id = :icalc_record_id;

  suspend;
end^


ALTER PROCEDURE PS_CALC_RECORD_VIEW (
    ICALC_RECORD_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OINPUT_QUANTITY DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION)
AS
begin
  select cr.calc_record_id, cr.calculation_id, cr.nomen_id, cr.input_quantity,
         cr.netto
    from t_calc_records cr where cr.calc_record_id = :icalc_record_id
    into ocalc_record_id, ocalculation_id, onomen_id, oinput_quantity,
         onetto;

  select n.nomen_name from nomen n where n.nomen_id = :onomen_id into :onomen_name;

  select r.last_inprice from rst r where r.nomen_id = :onomen_id
  into :oin_price;

  oin_sum = oin_price * :oinput_quantity;

  suspend;
end^


ALTER PROCEDURE PS_CALC_RECORDS_VIEW (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OINPUT_QUANTITY DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION)
AS
begin
  for select cr.calc_record_id, cr.calculation_id, cr.nomen_id, cr.input_quantity,
             cr.netto
        from t_calc_records cr where cr.calculation_id = :icalculation_id
        into ocalc_record_id, ocalculation_id, onomen_id, oinput_quantity,
             onetto
  do begin
    select n.nomen_name from nomen n where n.nomen_id = :onomen_id into :onomen_name;

    select r.last_inprice from rst r where r.nomen_id = :onomen_id
    into :oin_price;

    oin_sum = oin_price * :oinput_quantity;

    suspend;
  end
end^


ALTER PROCEDURE PS_CALCULATION_DEL (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;
  ocount = 0;
  ocaption = '';

  /*
  ocaption = '';
  select count() from
      where _id = :i_id
    into :ocount;
  tsuma = tsuma + :ocount;
  suspend;
  */

  if (:tsuma = 0) then
  begin
    delete from t_calc_records cr where cr.calculation_id = :icalculation_id;
    delete from t_calculations c where c.calculation_id = :icalculation_id;
  end

  suspend;
end^


ALTER PROCEDURE PS_CALCULATION_HEADER (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODATEX_NAME VARCHAR(26),
    OTYPEPDV_ID INTEGER,
    OBRUTTO DOUBLE PRECISION,
    OSI_ID INTEGER,
    OOUT_PRICE DOUBLE PRECISION,
    OSG_ID INTEGER,
    OSI_NAME VARCHAR(12),
    OOBJECT_NAME VARCHAR(50),
    OIN_PRICE DOUBLE PRECISION,
    OIN_PRICE_PDV DOUBLE PRECISION)
AS
begin
  select c.output_quantity, c.nomen_id, n.nomen_code, n.nomen_name, n.datex_name,
         n.typepdv_id, n.brutto, n.si_id, n.out_price, n.sg_id, s.si_name
    from t_calculations c inner join nomen n on (c.nomen_id = n.nomen_id)
         inner join si s on (s.si_id = n.si_id)
   where c.calculation_id = :icalculation_id
    into ooutput_quantity, onomen_id, onomen_code, onomen_name, odatex_name,
         otypepdv_id, obrutto, osi_id, oout_price, osg_id, osi_name;
  ocalculation_id = :icalculation_id;

  select c.name from clients c
   where c.clients_id = 1
    into oobject_name;

  select sum(OLAST_INPRICE / ONOM_BRUTTO * OBRUTTO)
    from ps_calculation_print(:icalculation_id)
    into oin_price;

  oin_price_pdv = :oin_price;
  suspend;
end^


ALTER PROCEDURE PS_CALCULATION_INFO (
    ICALCULATION_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
DECLARE VARIABLE TCALCULATION_ID INTEGER;
DECLARE VARIABLE TNOMEN_NAME VARCHAR(40);
DECLARE VARIABLE TOUTPUT_QUANTITY VARCHAR(20);
DECLARE VARIABLE TREST VARCHAR(20);
DECLARE VARIABLE TIN_PRICE VARCHAR(20);
DECLARE VARIABLE TOUT_PRICE VARCHAR(20);
begin
  select ocalculation_id, onomen_name, ooutput_quantity, orest, oin_price, oout_price
  from ps_calculation_view(:icalculation_id)
  into :TCALCULATION_ID, :TNOMEN_NAME, :TOUTPUT_QUANTITY, :TREST, :TIN_PRICE, :TOUT_PRICE;

  odescript = 'Внутрішній код (id): ' || :TCALCULATION_ID;
  suspend;

  odescript = 'Продукція: ' || :TNOMEN_NAME;
  suspend;

  odescript = 'Вихід: ' || :TOUTPUT_QUANTITY;
  suspend;

  odescript = 'Залишок: ' || :TREST;
  suspend;

  odescript = 'Ціна закупки: ' || :TIN_PRICE;
  suspend;

  odescript = 'Ціна реалізації: ' || :TOUT_PRICE;
  suspend;
end^


ALTER PROCEDURE PS_CALCULATION_INS (
    INOMEN_ID INTEGER,
    IOUTPUT_QUANTITY DOUBLE PRECISION)
RETURNS (
    OCALCULATION_ID INTEGER)
AS
begin
  ocalculation_id = gen_id(gen_t_calculations_id, 1);

  insert into t_calculations(calculation_id, nomen_id, output_quantity)
  values(:ocalculation_id, :inomen_id, :ioutput_quantity);
  suspend;
end^


ALTER PROCEDURE PS_CALCULATION_PRINT (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALC_RECORD_ID INTEGER,
    ONOMEN_ID INTEGER,
    OBRUTTO DOUBLE PRECISION,
    ONETTO DOUBLE PRECISION,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODATEX_NAME VARCHAR(26),
    OTYPEPDV_ID INTEGER,
    ONOM_BRUTTO DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OSG_ID INTEGER,
    OSI_NAME VARCHAR(12),
    OLAST_INPRICE DOUBLE PRECISION,
    OLAST_IN_KILK DOUBLE PRECISION,
    OSI_ID INTEGER)
AS
declare variable pmax_goods_id integer;
declare variable pmin_docgoods_id integer;
begin
  for select cr.calc_record_id, cr.nomen_id, cr.input_quantity, cr.netto,
             n.nomen_code, n.nomen_name, n.datex_name, n.typepdv_id, n.brutto,
             n.out_price, n.sg_id, s.si_name, s.si_id
        from t_calc_records cr inner join nomen n on (cr.nomen_id = n.nomen_id)
             inner join si s on (n.si_id = s.si_id)
       where cr.calculation_id = :icalculation_id
        into ocalc_record_id, onomen_id, obrutto, onetto,
             onomen_code, onomen_name, odatex_name, otypepdv_id, onom_brutto,
             oout_price, osg_id, osi_name, osi_id
  do begin
    select max(g.goods_id) from goods g
     where g.nomen_id = :onomen_id
      into pmax_goods_id;

    select min(dg.docgoods_id) from docgoods dg
     where dg.goods_id = :pmax_goods_id
      into pmin_docgoods_id;

    select g.goods_inprice from goods g
     where g.goods_id = :pmax_goods_id
      into olast_inprice;

    select dg.kilk from docgoods dg
     where dg.docgoods_id = :pmin_docgoods_id
      into olast_in_kilk;

    suspend;
  end
end^


ALTER PROCEDURE PS_CALCULATION_UPD (
    ICALCULATION_ID INTEGER,
    IOUTPUT_QUANTITY DOUBLE PRECISION)
RETURNS (
    OCALCULATION_ID INTEGER)
AS
begin
  ocalculation_id = icalculation_id;

  update t_calculations c set
    c.output_quantity = :ioutput_quantity
  where c.calculation_id = :icalculation_id;
  suspend;
end^


ALTER PROCEDURE PS_CALCULATION_VIEW (
    ICALCULATION_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
DECLARE VARIABLE T_INPUT_QUANTITY DOUBLE PRECISION;
DECLARE VARIABLE T_NOMEN_ID INTEGER;
DECLARE VARIABLE T_LAST_INPRICE DOUBLE PRECISION;
begin
  select c.calculation_id, c.nomen_id, c.output_quantity from t_calculations c
  where c.calculation_id = :icalculation_id
  into :ocalculation_id, :onomen_id, :ooutput_quantity;

  select n.nomen_name, n.out_price from nomen n where n.nomen_id = :onomen_id
  into :onomen_name, :oout_price;

  select r.rest from rst r where r.nomen_id = :onomen_id into :orest;

  oin_price = 0.0;
  for select cr.input_quantity, cr.nomen_id from t_calc_records cr
  where cr.calculation_id = :ocalculation_id into :T_INPUT_QUANTITY, :T_NOMEN_ID
  do begin
    select r.last_inprice from rst r where r.nomen_id = :T_NOMEN_ID
    into :T_LAST_INPRICE;

    oin_price = oin_price + T_INPUT_QUANTITY * T_LAST_INPRICE;
  end
  oin_price = oin_price / ooutput_quantity;

  suspend;
end^


ALTER PROCEDURE PS_CALCULATIONS_VIEW (
    IGRP_ID INTEGER)
RETURNS (
    OCALCULATION_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OOUTPUT_QUANTITY DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
declare variable t_input_quantity double precision;
declare variable t_nomen_id integer;
declare variable t_last_inprice double precision;
declare variable pgrp_id integer;
begin
 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into pgrp_id
 do begin
  for select c.calculation_id, c.nomen_id, c.output_quantity,
              n.nomen_name, n.out_price   
        from t_calculations c, nomen n
       where c.nomen_id = n.nomen_id and
             n.grp_id   = :pgrp_id
        into ocalculation_id, onomen_id, ooutput_quantity,
             onomen_name, oout_price
  do begin

    select r.rest from rst r where r.nomen_id = :onomen_id into :orest;

    select sum(cr.input_quantity * r.last_inprice)
      from t_calc_records cr
           join rst r on r.nomen_id = cr.nomen_id
     where cr.calculation_id = :ocalculation_id
      into oin_price;
    if (:ooutput_quantity < 1) then
      oin_price = oin_price * ooutput_quantity;
    else
      oin_price = oin_price / ooutput_quantity;
    suspend;
  end
 end
end^


ALTER PROCEDURE PS_CLIENT_DEL (
    ICLIENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;

  ocaption = 'аналітичних карток';
  select count(g.goods_id) from goods g
      where g.clients_id = :iclient_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  ocaption = 'документів';
  select count(d.document_id) from documents d
      where ((d.clients_id =  :iclient_id) or
             (d.objects_id = :iclient_id))
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  ocaption = 'дисконтних карток';
  select count(k.kards_id) from kards k
      where k.clients_id = :iclient_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from clientaccount ca
      where ca.clients_id = :iclient_id;
    delete from clients c
      where c.clients_id = :iclient_id;
  end
end^


ALTER PROCEDURE PS_CLIENT_DETAIL (
    ICLIENT_ID INTEGER)
RETURNS (
    OACCOUNT_ID INTEGER,
    OACCOUNT_NUM VARCHAR(20),
    ONAME VARCHAR(40),
    OMFO VARCHAR(20))
AS
DECLARE VARIABLE TCLIENTS_ID INTEGER;
begin
  for select ca.account_id, ca.account_num, b.name, b.mfo
           from clientaccount ca, banks b
      where ca.clients_id = :iclient_id and
            b.banks_id = ca.banks_id
   into :oaccount_id, :oaccount_num, :oname, :omfo
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_CLIENT_INS (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20))
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = GEN_ID(GEN_CLIENTS_ID,1);

  insert into clients (clients_id, grpc_id, clients_code, shortname, name, typeclient_id,
    adress, phone, director, typeprop_id, is_opt, num_ugody, date_ugody, numpdv, zkpo,
    ispdv, ipn)
  values (:oclient_id, :igrpc_id, :icode, :ishort_name, :ifull_name, :itypeclient_id,
    :iadress, :iphone, :idirector, :itypeprop_id, :iis_contract, :inum_contract, :idate_contract, :inum_pdv, :izkpo,
    :iis_pdv, :iipn);
  suspend;
end^


ALTER PROCEDURE PS_CLIENT_INS_V1 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50))
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = GEN_ID(GEN_CLIENTS_ID,1);

  insert into clients (clients_id, grpc_id, clients_code, shortname, name, typeclient_id,
    adress, phone, director, typeprop_id, is_opt, num_ugody, date_ugody, numpdv, zkpo,
    ispdv, ipn, deliv_addr)
  values (:oclient_id, :igrpc_id, :icode, :ishort_name, :ifull_name, :itypeclient_id,
    :iadress, :iphone, :idirector, :itypeprop_id, :iis_contract, :inum_contract, :idate_contract, :inum_pdv, :izkpo,
    :iis_pdv, :iipn, :ideliv_addr);
  suspend;
end^


ALTER PROCEDURE PS_CLIENT_INS_V2 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50),
    IEMAIL VARCHAR(60))
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = GEN_ID(GEN_CLIENTS_ID,1);

  insert into clients (clients_id, grpc_id, clients_code, shortname, name, typeclient_id,
    adress, phone, director, typeprop_id, is_opt, num_ugody, date_ugody, numpdv, zkpo,
    ispdv, ipn, deliv_addr, email)
  values (:oclient_id, :igrpc_id, :icode, :ishort_name, :ifull_name, :itypeclient_id,
    :iadress, :iphone, :idirector, :itypeprop_id, :iis_contract, :inum_contract, :idate_contract, :inum_pdv, :izkpo,
    :iis_pdv, :iipn, :ideliv_addr, :iemail);
  suspend;
end^


ALTER PROCEDURE PS_CLIENT_INS_V3 (
    IGRPC_ID INTEGER,
    ICODE VARCHAR(7),
    ISHORT_NAME VARCHAR(30),
    IFULL_NAME VARCHAR(50),
    ITYPECLIENT_ID INTEGER,
    IADRESS VARCHAR(50),
    IPHONE VARCHAR(24),
    IDIRECTOR VARCHAR(40),
    ITYPEPROP_ID INTEGER,
    IIS_CONTRACT INTEGER,
    INUM_CONTRACT VARCHAR(20),
    IDATE_CONTRACT DATE,
    INUM_PDV VARCHAR(20),
    IZKPO VARCHAR(20),
    IIS_PDV INTEGER,
    IIPN VARCHAR(20),
    IDELIV_ADDR VARCHAR(50),
    IEMAIL VARCHAR(60),
    IDISC_PERCENT DOUBLE PRECISION,
    IAMOUNT_DAYS SMALLINT,
    IPOSSIBLE_DEBT DOUBLE PRECISION,
    IIS_VISIBLE INTEGER)
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = GEN_ID(GEN_CLIENTS_ID,1);

  insert into clients (clients_id, grpc_id, clients_code, shortname, name, typeclient_id,
    adress, phone, director, typeprop_id, is_opt, num_ugody, date_ugody, numpdv, zkpo,
    ispdv, ipn, deliv_addr, email, disc_percent, amount_days, possible_debt, is_visible)
  values (:oclient_id, :igrpc_id, :icode, :ishort_name, :ifull_name, :itypeclient_id,
    :iadress, :iphone, :idirector, :itypeprop_id, :iis_contract, :inum_contract, :idate_contract, :inum_pdv, :izkpo,
    :iis_pdv, :iipn, :ideliv_addr, :iemail, :idisc_percent, :iamount_days, :ipossible_debt, :iis_visible);
  suspend;
end^


ALTER PROCEDURE PS_CLIENT_SYNC_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
begin
  /* by kardcode */
       select c.oclient_id, c.ocode, c.oshort_name, c.ofull_name, c.oadress,
              c.ois_pdv, c.otypeclient_id, c.odeliv_addr, c.ozkpo, c.ophone, c.oemail,
              c.odisc_percent, c.oamount_days, c.opossible_debt, c.ois_active,
              c.ow3_client_id, c.okards_cnt
         from ps_client_view(:iclient_id) c
         into oclient_id, ocode, oshort_name, ofull_name, oadress,
              ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
              odisc_percent, oamount_days, opossible_debt, ois_active,
              ow3_client_id, okards_cnt;

     if (:ow3_client_id is not null) then
     begin
       select cs.typeclient_id, cs.name, cs.adress, cs.zkpo, cs.is_pdv, cs.is_active
         from t_clients_sync cs
        where cs.w3_client_id = :ow3_client_id
         into ow3_typeclient_id, ow3_name, ow3_adress, ow3_zkpo, ow3_is_pdv, ow3_is_active;
     end else
     begin
       ow3_typeclient_id = null; ow3_name = null; ow3_adress = null; ow3_zkpo = null; ow3_is_pdv = null; ow3_is_active = null;
     end

     suspend;

end^


ALTER PROCEDURE PS_CLIENT_TMP_DEL (
    ICLIENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
begin
  ocaption = '';
  ocount = 0;
  suspend;

  if (:ocount = 0) then
  begin
    delete from t_clients_tmp ct
     where ct.client_id = :iclient_id;
  end
end^


ALTER PROCEDURE PS_CLIENT_TMP_INS (
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    INOTE VARCHAR(512))
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = gen_id(gen_t_clients_tmp_id, 1);

  insert into t_clients_tmp(client_id, typeclient_id, name, adress, zkpo, is_pdv, is_active, note)
       values(:oclient_id, :itypeclient_id, :iname, :iadress, :izkpo, :iis_pdv, :iis_active, :inote);

  suspend;
end^


ALTER PROCEDURE PS_CLIENT_TMP_LIKE_INS (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER)
AS
declare variable ptypeclient_id integer;
declare variable pname varchar(50);
declare variable padress varchar(100);
declare variable pzkpo varchar(20);
declare variable pis_pdv smallint;
declare variable pis_active smallint;
declare variable pnote varchar(512);
begin
  oclient_id = GEN_ID(gen_t_clients_tmp_id, 1);

  select c.typeclient_id, c.name, c.adress, c.zkpo, c.is_pdv, c.is_active, c.note
     from t_clients_tmp c
   where c.client_id = :iclient_id
    into ptypeclient_id, pname, padress, pzkpo, pis_pdv, pis_active, pnote;

  insert into t_clients_tmp (client_id, typeclient_id, name, adress, zkpo, is_pdv, is_active, note)
    values (:oclient_id, :ptypeclient_id, :pname, :padress, :pzkpo, :pis_pdv, :pis_active, :pnote);

  suspend;
end^


ALTER PROCEDURE PS_CLIENT_TMP_UPD (
    ICLIENT_ID INTEGER,
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    INOTE VARCHAR(512))
RETURNS (
    OCLIENT_ID INTEGER)
AS
begin
  oclient_id = iclient_id;

  update t_clients_tmp c set
    c.typeclient_id = :itypeclient_id,
    c.name          = :iname,
    c.adress        = :iadress,
    c.zkpo          = :izkpo,
    c.is_pdv        = :iis_pdv,
    c.is_active     = :iis_active,
    c.note          = :inote
  where c.client_id = :iclient_id;

  suspend;
end^


ALTER PROCEDURE PS_CLIENT_TMP_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ODATE_LAST_MODEFICATION DATE,
    OTYPECLIENT_NAME VARCHAR(40),
    ONOTE VARCHAR(512))
AS
begin
  select c.client_id, c.typeclient_id, c.name, c.adress, c.zkpo,
         c.is_pdv, c.is_active, c.date_last_modefication, tc.typeclient_name,
         c.note
    from t_clients_tmp c join
         typeclient tc on c.typeclient_id = tc.typeclient_id
   where c.client_id = :iclient_id
    into oclient_id, otypeclient_id, oname, oadress, ozkpo,
         ois_pdv, ois_active, odate_last_modefication, otypeclient_name,
         onote;
    suspend;
end^


ALTER PROCEDURE PS_CLIENT_UNITE (
    ICLIENT0_ID INTEGER,
    ICLIENT1_ID INTEGER)
RETURNS (
    OENABLED INTEGER,
    OMESSAGE VARCHAR(255))
AS
declare variable TTYPE0_ID integer;
declare variable TTYPE1_ID integer;
declare variable TMARKER varchar(64);
begin
  oenabled = 1;
  if (:iclient1_id < 100) then
  /*Виключення можливості видалення службового клієнта*/
  begin
    ttype0_id = :iclient0_id;
    iclient0_id = :iclient1_id;
    iclient1_id = :ttype0_id;
  end

  if ((:iclient1_id > 110)/*$$IBEC$$  and (:iclient0_id > 100) $$IBEC$$*/) then
  begin
    select c.marker  from t_configs c
     where c.config_id = 1 and
           c.module = 'store_clients'
      into tmarker;

    select c.typeclient_id from clients c
      where c.clients_id = :iclient0_id
     into :ttype0_id;

    select c.typeclient_id from clients c
      where c.clients_id = :iclient1_id
     into :ttype1_id;

    if (((:ttype0_id <> 1) and (:ttype1_id <> 1))or(:tmarker = 'srv')) then
    begin
      update goods g
          set g.clients_id = :iclient0_id
        where g.clients_id = :iclient1_id;

      update documents d
          set d.clients_id = :iclient0_id
        where d.clients_id = :iclient1_id;

      update documents d
          set d.objects_id = :iclient0_id
        where d.objects_id = :iclient1_id;

      update kards k
          set k.clients_id = :iclient0_id
        where k.clients_id = :iclient1_id;

      update clientaccount ca
          set ca.clients_id = :iclient0_id
        where ca.clients_id = :iclient1_id;

      delete from clients c
        where c.clients_id = :iclient1_id;
    end
    else
    begin
      oenabled = 0;
      omessage = 'Не можна об"єднувати склади';
    end
  end
  else
  begin
    oenabled = 0;
    omessage = 'Не можна об''єднувати двох службових клієнтів';
  end

  suspend;
end^


ALTER PROCEDURE PS_CLIENT_UNITE_INFO (
    ICLIENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
DECLARE VARIABLE TCODE VARCHAR(7);
DECLARE VARIABLE TFULLNAME VARCHAR(50);
DECLARE VARIABLE TNAME VARCHAR(30);
DECLARE VARIABLE TADRESS VARCHAR(50);
DECLARE VARIABLE TPHONE VARCHAR(24);
begin
  select c.clients_code, c.name, c.shortname, c.adress, c.phone from clients c
      where c.clients_id = :iclient_id
    into :tcode, :tfullname, :tname, :tadress, :tphone;

  odescript = 'Код: ' || :tcode;
  suspend;

  odescript = 'Повна назва: ' || :tfullname;
  suspend;

  odescript = 'Коротка назва: ' || :tname;
  suspend;

  odescript = 'Адреса: ' || :tadress;
  suspend;

  odescript = 'Телефон: ' || :tphone;
  suspend;
end^


ALTER PROCEDURE PS_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    ODELIV_ADDR VARCHAR(50),
    OZKPO VARCHAR(20),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
begin
  /* by kardcode */
  for select first(1) c.clients_id, c.clients_code, c.shortname, c.name,
             c.adress, c.ispdv, c.typeclient_id, c.deliv_addr, c.zkpo, c.phone, c.email,
             c.disc_percent, c.amount_days, c.possible_debt, c.is_active,
             c.w3_client_id
        from clients c
       where c.clients_id = :iclient_id
        into oclient_id, ocode, oshort_name, ofull_name,
             oadress, ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
             odisc_percent, oamount_days, opossible_debt, ois_active,
             ow3_client_id
   do begin
       select count(k.kards_id) from kards k
        where k.clients_id = :oclient_id
         into okards_cnt;
       suspend;
       ozkpo = null;
   end
end^


ALTER PROCEDURE PS_CLIENTS_LINK_VIEW
RETURNS (
    W3_CLIENT_ID INTEGER,
    TYPECLIENT_ID INTEGER,
    NAME VARCHAR(50),
    ADRESS VARCHAR(50),
    ZKPO VARCHAR(20),
    IS_PDV SMALLINT,
    IS_ACTIVE SMALLINT,
    DATE_LAST_MODEFICATION DATE,
    IS_VISIBLE SMALLINT)
AS
begin
 for select cs.w3_client_id, cs.typeclient_id, cs.name, cs.adress, cs.zkpo, cs.is_pdv,
            cs.is_active, cs.date_last_modefication, cs.is_visible
       from t_clients_sync cs
      where cs.is_active = 1 and
            cs.is_visible = 1
       into w3_client_id, typeclient_id, name, adress, zkpo, is_pdv,
            is_active, date_last_modefication, is_visible
 do begin
  suspend;
 end
end^


ALTER PROCEDURE PS_CLIENTS_SYNC_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
begin
  /* by kardcode */
   for select c.oclient_id, c.ocode, c.oshort_name, c.ofull_name, c.oadress,
              c.ois_pdv, c.otypeclient_id, c.odeliv_addr, c.ozkpo, c.ophone, c.oemail,
              c.odisc_percent, c.oamount_days, c.opossible_debt, c.ois_active,
              c.ow3_client_id, c.okards_cnt
         from ps_clients_view(:iflag, :igrpc_id) c
         into oclient_id, ocode, oshort_name, ofull_name, oadress,
              ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
              odisc_percent, oamount_days, opossible_debt, ois_active,
              ow3_client_id, okards_cnt
   do begin
     if (:ow3_client_id is not null) then
     begin
       select cs.typeclient_id, cs.name, cs.adress, cs.zkpo, cs.is_pdv, cs.is_active
         from t_clients_sync cs
        where cs.w3_client_id = :ow3_client_id
         into ow3_typeclient_id, ow3_name, ow3_adress, ow3_zkpo, ow3_is_pdv, ow3_is_active;
     end else
     begin
       ow3_typeclient_id = null; ow3_name = null; ow3_adress = null; ow3_zkpo = null; ow3_is_pdv = null; ow3_is_active = null;
     end

     suspend;
   end
end^


ALTER PROCEDURE PS_CLIENTS_SYNC_VIEW_1 (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER,
    OW3_TYPECLIENT_ID INTEGER,
    OW3_NAME VARCHAR(50),
    OW3_ADRESS VARCHAR(50),
    OW3_ZKPO VARCHAR(20),
    OW3_IS_PDV SMALLINT,
    OW3_IS_ACTIVE SMALLINT)
AS
begin
  /* by kardcode */
   for select c.oclient_id, c.ocode, c.oshort_name, c.ofull_name, c.oadress,
              c.ois_pdv, c.otypeclient_id, c.odeliv_addr, c.ozkpo, c.ophone, c.oemail,
              c.odisc_percent, c.oamount_days, c.opossible_debt, c.ois_active,
              c.ow3_client_id, c.okards_cnt
         from ps_clients_view_1(:iflag, :igrpc_id, :ifilter) c
         into oclient_id, ocode, oshort_name, ofull_name, oadress,
              ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
              odisc_percent, oamount_days, opossible_debt, ois_active,
              ow3_client_id, okards_cnt
   do begin
     if (:ow3_client_id is not null) then
     begin
       select cs.typeclient_id, cs.name, cs.adress, cs.zkpo, cs.is_pdv, cs.is_active
         from t_clients_sync cs
        where cs.w3_client_id = :ow3_client_id
         into ow3_typeclient_id, ow3_name, ow3_adress, ow3_zkpo, ow3_is_pdv, ow3_is_active;
     end else
     begin
       ow3_typeclient_id = null; ow3_name = null; ow3_adress = null; ow3_zkpo = null; ow3_is_pdv = null; ow3_is_active = null;
     end

     suspend;
   end
end^


ALTER PROCEDURE PS_CLIENTS_TMP_VIEW
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ODATE_LAST_MODEFICATION DATE,
    OTYPECLIENT_NAME VARCHAR(40),
    ONOTE VARCHAR(512))
AS
begin
  for select c.client_id, c.typeclient_id, c.name, c.adress, c.zkpo,
             c.is_pdv, c.is_active, c.date_last_modefication, tc.typeclient_name,
             c.note
        from t_clients_tmp c join
             typeclient tc on c.typeclient_id = tc.typeclient_id
        into oclient_id, otypeclient_id, oname, oadress, ozkpo,
             ois_pdv, ois_active, odate_last_modefication, otypeclient_name,
             onote
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_CLIENTS_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    OZKPO VARCHAR(20),
    ODELIV_ADDR VARCHAR(50),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
declare variable PIS_VISIBLE integer;
begin
 pis_visible = -1;
 if (:iflag > 10) then
 begin
   pis_visible = 0;
   iflag = :iflag - 10;
 end
 for select rgrpc_id from t_grpc_childs(:igrpc_id)
       into ogrpc_id
 do begin
   for select c.clients_id, c.clients_code, c.shortname, c.name, c.adress,
              c.ispdv, c.typeclient_id, c.deliv_addr, c.zkpo, c.phone, c.email,
              c.disc_percent, c.amount_days, c.possible_debt, c.is_active,
              c.w3_client_id
         from clients c
        where c.grpc_id = :ogrpc_id and
              c.is_visible > :pis_visible
         into oclient_id, ocode, oshort_name, ofull_name, oadress,
              ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
              odisc_percent, oamount_days, opossible_debt, ois_active,
              ow3_client_id
   do begin
     if (((:iflag = 1) and (:otypeclient_id = 1)) or
         ((:iflag = 2) and (:otypeclient_id in(3, 4))) or
         ((:iflag = 3) and (:otypeclient_id in(2, 4))) or
         ((:iflag = 4) /*and (:otypeclient_id in(1, 2, 3, 4, 5))*/) or
         ((:iflag = 5) and (:otypeclient_id = 5))) then
     begin
       select count(k.kards_id) from kards k
        where k.clients_id = :oclient_id
         into okards_cnt;
       suspend;
       ozkpo = null;
       ow3_client_id = null;
     end
   end
 end
end^


ALTER PROCEDURE PS_CLIENTS_VIEW_1 (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT,
    OKARDS_CNT VARCHAR(6),
    ODELIV_ADDR VARCHAR(50),
    OZKPO VARCHAR(20),
    OPHONE VARCHAR(24),
    OEMAIL VARCHAR(60),
    ODISC_PERCENT DOUBLE PRECISION,
    OAMOUNT_DAYS SMALLINT,
    OPOSSIBLE_DEBT DOUBLE PRECISION,
    OIS_ACTIVE SMALLINT,
    OW3_CLIENT_ID INTEGER)
AS
declare variable PIS_VISIBLE integer;
begin
  /* by kardcode */
 pis_visible = -1;
 if (:iflag > 10) then
 begin
   pis_visible = 0;
   iflag = :iflag - 10;
 end
 for select rgrpc_id from t_grpc_childs(:igrpc_id)
       into ogrpc_id
 do begin
   for select c.clients_id, c.clients_code, c.shortname, c.name, c.adress,
              c.ispdv, c.typeclient_id, c.deliv_addr, c.zkpo ,c.phone, c.email,
              c.disc_percent, c.amount_days, c.possible_debt, c.is_active,
              c.w3_client_id
         from clients c
              join kards k on (k.clients_id = c.clients_id)
        where c.grpc_id = :ogrpc_id and
              k.kardcode like (:ifilter) and
              c.is_visible > :pis_visible
         into oclient_id, ocode, oshort_name, ofull_name, oadress,
              ois_pdv, otypeclient_id, odeliv_addr, ozkpo, ophone, oemail,
              odisc_percent, oamount_days, opossible_debt, ois_active,
              ow3_client_id
   do begin
     if (((:iflag = 1) and (:otypeclient_id = 1)) or
         ((:iflag = 2) and (:otypeclient_id in(3, 4))) or
         ((:iflag = 3) and (:otypeclient_id in(2, 4))) or
         ((:iflag = 4) /*and (:otypeclient_id in(1, 2, 3, 4, 5))*/) or
         ((:iflag = 5) and (:otypeclient_id = 5))) then
     begin
       select count(k.kards_id) from kards k
        where k.clients_id = :oclient_id
         into okards_cnt;
       suspend;
       ozkpo=null;
     end
   end
 end
end^


ALTER PROCEDURE PS_COUPON_ARTICLE_INS (
    ISKU_EAN_ID BIGINT,
    ICOUPON_EAN_ID BIGINT,
    IDISCOUNT_VALUE DOUBLE PRECISION,
    ISKU_NAME VARCHAR(40),
    ISKU_QUANTITY DOUBLE PRECISION,
    IPRODUCER VARCHAR(40),
    IPRODUCER_OKPO VARCHAR(20),
    ITRADE_MARK VARCHAR(40),
    IUNIT_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OSKU_EAN_ID BIGINT)
AS
declare variable prec_count integer;
begin
  osku_ean_id = :isku_ean_id;
  select count(ca.sku_ean_id) from t_coupon_articles ca
   where ca.sku_ean_id = :isku_ean_id and
         ca.coupon_ean_id = :icoupon_ean_id
    into prec_count;

  if (:prec_count = 0) then
  begin
    insert into t_coupon_articles(sku_ean_id, coupon_ean_id, discount_value,
        sku_name, sku_quantity, producer, producer_okpo, trade_mark, unit_id, nomen_id)
    values(:isku_ean_id, :icoupon_ean_id,
        :idiscount_value, :isku_name, :isku_quantity, :iproducer, :iproducer_okpo,
        :itrade_mark, :iunit_id, :inomen_id);
  end else begin
    update t_coupon_articles
       set discount_value = :idiscount_value,
           sku_name       = :isku_name,
           sku_quantity   = :isku_quantity,
           producer       = :iproducer,
           producer_okpo  = :iproducer_okpo,
           trade_mark     = :itrade_mark,
           unit_id        = :iunit_id,
           nomen_id       = :inomen_id
     where sku_ean_id     = :isku_ean_id and
           coupon_ean_id  = :icoupon_ean_id and
           (discount_value != :idiscount_value or
            sku_name       != :isku_name       or
            sku_quantity   != :isku_quantity   or
            producer       != :iproducer       or
            producer_okpo  != :iproducer_okpo  or
            trade_mark     != :itrade_mark     or
            unit_id        != :iunit_id        or
            nomen_id       != :inomen_id);
  end
  suspend;
end^


ALTER PROCEDURE PS_COUPON_DISCOUNT_INS (
    IID INTEGER,
    IDESCRIPTION VARCHAR(512))
RETURNS (
    OID INTEGER)
AS
declare variable prec_count integer;
begin
  oid = :iid;
  select count(id) from t_coupon_discounts
   where id = :iid
    into prec_count;

  if (:prec_count = 0) then
  begin
    insert into t_coupon_discounts(id, discount_description) values(:iid, :idescription);
  end else begin
    update t_coupon_discounts
       set discount_description  = :idescription
     where id = :iid and
           discount_description != :idescription;
  end
  suspend;
end^


ALTER PROCEDURE PS_COUPON_PROP_INS (
    ICOUPON_EAN_ID BIGINT,
    ISTART_DATE DATE,
    IEND_DATE DATE,
    IDISCOUNT_ID INTEGER)
RETURNS (
    OCOUPON_EAN_ID BIGINT)
AS
declare variable prec_count integer;
begin
  ocoupon_ean_id = :icoupon_ean_id;

  select count(coupon_ean_id) from t_coupon_props
   where coupon_ean_id = :icoupon_ean_id
    into prec_count;

  if (:prec_count = 0) then
  begin
    insert into t_coupon_props(coupon_ean_id, start_date, end_date, discount_id)
                values(:icoupon_ean_id, :istart_date, :iend_date, :idiscount_id);
  end else begin
    update t_coupon_props
       set start_date  = :istart_date,
           end_date    = :iend_date,
           discount_id = :idiscount_id
     where coupon_ean_id = :icoupon_ean_id and
           (start_date  != :istart_date or
            end_date    != :iend_date   or
            discount_id != :idiscount_id);
  end
  suspend;
end^


ALTER PROCEDURE PS_COUPON_PROP_STATUS (
    ICOUPON_EAN_ID BIGINT,
    IDOCUMENT_ID INTEGER)
RETURNS (
    OIS_CORRECT INTEGER,
    OSUM DOUBLE PRECISION,
    OSKU_QUANTITY DOUBLE PRECISION,
    ODISCOUNT_VALUE DOUBLE PRECISION)
AS
declare variable pprop_count integer;
declare variable pdocrec_kilk double precision;
declare variable pincl_count integer;
begin
  ois_correct = 0;
  osum = 0.0;
  odiscount_value = 0.0;
  osku_quantity = 1;

  select count(coupon_ean_id)
    from t_coupon_props cp
   where cp.coupon_ean_id = :icoupon_ean_id and
         cast('today' as date) between cp.start_date and cp.end_date
    into pprop_count;
  if (:pprop_count > 0) then
  begin
    ois_correct = 1;
    select sum(dr.kilk) from docrec dr
     where dr.document_id = :idocument_id and
           dr.nomen_id in (select nomen_id from t_coupon_articles
                            where coupon_ean_id = :icoupon_ean_id and
                                  nomen_id is not null)
      into pdocrec_kilk;
    if (:pdocrec_kilk > 0) then
    begin
      select first(1) ca.discount_value, ca.sku_quantity
        from t_coupon_articles ca
       where ca.coupon_ean_id = :icoupon_ean_id
        into odiscount_value, osku_quantity;

      if (:osku_quantity > 0) then
        pincl_count = :pdocrec_kilk / :osku_quantity;
      else pincl_count = 0;
      if ((:pincl_count * :osku_quantity - 0.000001) > :pdocrec_kilk) then
         pincl_count = :pincl_count - 1;
      osum = :pincl_count * :odiscount_value;
    end
  end
  suspend;
end^


ALTER PROCEDURE PS_COUPON_RECALC_QUANTITY (
    IDOCUMENT_ID INTEGER,
    ICOUPON_EAN_ID BIGINT)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
declare variable psum double precision;
declare variable pcoup_quantity double precision;
declare variable pcoup_value double precision;
declare variable pdiscount_value double precision;
declare variable pdocrec_id integer;
declare variable pdr_quantity double precision;
declare variable pdelta_sum double precision;
begin
  select around3(cp.osum), cp.osku_quantity, cp.odiscount_value
    from ps_coupon_prop_status(:icoupon_ean_id, :idocument_id) cp
    into psum, pcoup_quantity, pcoup_value;
  osum = :psum;

  if (:pcoup_quantity = 0) then pcoup_quantity = 1;
  pdiscount_value = around3(pcoup_value / pcoup_quantity);

 /* if ((:pdiscount_value > 0)and(:psum > 0)) then  */
  begin
    for select dr.docrec_id, dr.kilk
          from docrec dr join t_dr_prop dp on dr.docrec_id = dp.docrec_id
         where dr.document_id   = :idocument_id and
               dp.coupon_ean_id = :icoupon_ean_id
          into pdocrec_id, pdr_quantity
    do begin
      pdelta_sum = around3(pdr_quantity * pdiscount_value);

      if (:psum < 0.0001) then
      begin
        pdr_quantity = 0.0;
      end else
      if (:psum > :pdelta_sum) then
      begin
        psum = :psum - :pdelta_sum;
      end else /*:psum <= :pdelta_sum*/
      begin
        pdr_quantity = around(:psum / :pdiscount_value);
        psum = 0.0;
      end

      update t_dr_prop dp
         set dp.sku_quantity  = :pdr_quantity
       where dp.docrec_id     = :pdocrec_id     and
             dp.coupon_ean_id = :icoupon_ean_id and
             dp.sku_quantity != :pdr_quantity;

      /*Виправлення помилки при необхідності (використовується в KAS_SET_COUPON)*/
      update t_dr_prop dp
         set dp.discount_value  = :pdiscount_value
       where dp.docrec_id       = :pdocrec_id     and
             dp.coupon_ean_id   = :icoupon_ean_id and
             dp.discount_value != :pdiscount_value;
    end
  end
  suspend;
end^


ALTER PROCEDURE PS_COUPON_SALES_EXPORT
RETURNS (
    OID INTEGER,
    OPURCHASE_DATE DATE,
    OCHECK_NUMBER VARCHAR(14),
    OPOS_ID VARCHAR(24),
    OSHOP_ID INTEGER,
    OSKU_EAN_ID BIGINT,
    OSKU_QUANTITY DOUBLE PRECISION,
    OSKU_START_PRICE DOUBLE PRECISION,
    OSKU_SALE_PRICE DOUBLE PRECISION,
    OCOUPON_EAN_ID BIGINT)
AS
declare variable t_document_id integer;
declare variable t_nomen_id integer;
declare variable pkilk integer;
declare variable pprice double precision;
declare variable ppercent double precision;
declare variable pis_in_discount smallint;
begin
  for select dp.docrec_id, dp.coupon_ean_id, dp.sku_quantity, dr.date_cr,
             dr.document_id, dr.nomen_id, dr.kilk, dr.price, d.doc_num, k.rn,
             d.disc_persent, dr.is_in_discount
        from t_dr_prop dp
             join docrec dr on (dp.docrec_id = dr.docrec_id)
             left join documents d on (d.document_id = dr.document_id)
             left join kasses k on (k.kasses_id = d.kasses_id)
       where dp.sku_quantity > 0 and
             d.doc_lock > 0
    order by dr.document_id
        into oid, ocoupon_ean_id, osku_quantity, opurchase_date,
             t_document_id, t_nomen_id, pkilk, pprice, ocheck_number, opos_id,
             ppercent, pis_in_discount
  do begin
    if (opos_id is null) then opos_id = '';

    if (:pis_in_discount = 0) then
    begin
      ppercent = 0.0;
    end

    select gs.oprice_pdv from ps_get_sum(:oid, :ppercent, 0.0) gs
      into osku_sale_price;

    osku_start_price = around(calcpricepdv(:pprice, :ppercent, 0, 6));

    select ca.sku_ean_id from t_coupon_articles ca
     where ca.nomen_id = :t_nomen_id and
           ca.coupon_ean_id = :ocoupon_ean_id
      into osku_ean_id;

    oshop_id = 1;
    suspend;
  end
end^


ALTER PROCEDURE PS_COUPON_SHOPS_EXPORT
RETURNS (
    OID INTEGER,
    OSHOP_NAME VARCHAR(50),
    OSHOP_ADDRESS VARCHAR(50),
    OSHOP_DESCRIPTION VARCHAR(512),
    ONETWORK_ID INTEGER)
AS
begin
  select cast(c.clients_code as integer) - 1000000, c.adress, c.name, c.shortname
    from clients c
   where c.clients_id = 1
    into onetwork_id, oshop_address, oshop_name, oshop_description;

  oid = 1;
  suspend;
end^


ALTER PROCEDURE PS_COUPON_UNIT_INS (
    IID INTEGER,
    IDESCRIPTION VARCHAR(40))
RETURNS (
    OID INTEGER)
AS
declare variable prec_count integer;
begin
  oid = :iid;
  select count(id) from t_coupon_units
   where id = :iid
    into prec_count;

  if (:prec_count = 0) then
  begin
    insert into t_coupon_units(id, unit_description) values(:iid, :idescription);
  end else begin
    update t_coupon_units
       set unit_description = :idescription
     where id = :iid and
           unit_description != :idescription;
  end
  suspend;
end^


ALTER PROCEDURE PS_DECREASE_INS (
    IDECR_NAME VARCHAR(256),
    IDECR_VALUE DOUBLE PRECISION,
    IDECR_TYPE_ID INTEGER)
RETURNS (
    ODECR_ID INTEGER)
AS
begin
  idecr_value = AROUND(:idecr_value);
  odecr_id = GEN_ID(GEN_T_DECREASE_ID,1);
  insert into t_decrease (decr_id, decr_name, decr_value, decr_type_id)
                  values (:odecr_id,:idecr_name,:idecr_value,:idecr_type_id);
  suspend;
end^


ALTER PROCEDURE PS_DECREASES_VIEW
RETURNS (
    ODECR_ID INTEGER,
    ODECR_NAME VARCHAR(256),
    ODECR_VALUE DOUBLE PRECISION,
    ODECR_TYPE_NAME VARCHAR(100))
AS
begin
for select d.decr_id, d.decr_name, d.decr_value, dt.name
      from t_decrease d, t_decr_type dt
    where d.decr_type_id = dt.decr_type_id
    into :odecr_id, :odecr_name, :odecr_value, :odecr_type_name
    do begin
      suspend;
    end
end^


ALTER PROCEDURE PS_DOC_AUTOORDERS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    ODOC_KILK DOUBLE PRECISION,
    OORDERED DOUBLE PRECISION,
    ODOC_SUM_OUT DOUBLE PRECISION,
    ODOC_SUM_OUT_PDV DOUBLE PRECISION,
    OAO_SUM_OUT_PDV DOUBLE PRECISION,
    ODOC_SUM_IN DOUBLE PRECISION,
    ODOC_SUM_IN_PDV DOUBLE PRECISION,
    OAO_SUM_IN_PDV DOUBLE PRECISION,
    OAO_LAST_INPRICE DOUBLE PRECISION)
AS
declare variable PCOUNT_REC integer;
begin
  for select prv.onomen_id, prv.oordered, prv.olast_inprice, (prv.olast_inprice * prv.oordered),
             (prv.oordered * n.out_price), n.w3_nomen_id, prv.onomen_code, prv.onomen_name
        from autoorders ao
             inner join t_document_autoorder da on da.autoorder_id = ao.autoorder_id
             left join ps_ao_records_view_v1(ao.autoorder_id) prv on 1 = 1
             inner join nomen n on prv.onomen_id = n.nomen_id
       where da.documents_id = :idocument_id
       order by prv.oao_record_id
        into onomen_id, oordered, oao_last_inprice, oao_sum_in_pdv,
             oao_sum_out_pdv, ow3_nomen_id, onomen_code, onomen_name
  do begin
    pcount_rec = 0;
    odoc_kilk  = 0;
    odoc_sum_out = 0;
    odoc_sum_in  = 0;
    odoc_sum_out_pdv = 0;
    odoc_sum_in_pdv  = 0;
    for select rv.okilk, rv.osum_out, rv.osum_out_pdv, rv.osum_in, rv.osum_in_pdv
          from ps_document_records_view_v1(:idocument_id) rv
         where rv.onomen_id = :onomen_id
          into odoc_kilk, odoc_sum_out, odoc_sum_out_pdv, odoc_sum_in, odoc_sum_in_pdv
    do begin
      pcount_rec = :pcount_rec + 1;
      suspend;
    end
    if (:pcount_rec = 0) then suspend;
  end
end^


ALTER PROCEDURE PS_DOC_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    BORG DOUBLE PRECISION,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    OROLL_TAX_ID INTEGER,
    OAUTH_NAME VARCHAR(40),
    OAUTH_NUM VARCHAR(12),
    OAUTH_DATE DATE,
    OUSERNAME VARCHAR(60),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DELIV_ADDR_S VARCHAR(50),
    DELIV_ADDR_D VARCHAR(50),
    BASE_REESTR_ID INTEGER,
    BASE_REESTR_DATE DATE)
AS
declare variable tclient_id integer;
declare variable tobject_id integer;
declare variable tauth_id integer;
declare variable tcounts integer;
declare variable p_sum_in double precision;
declare variable tpay_type_id integer;
declare variable tt integer;
declare variable p_disc_persent double precision;
begin
 select d.doc_num, d.doc_mark, d.doc_date, d.typedoc_id,
        d.objects_id, d.clients_id, d.staff_id,
        d.lock_date, d.oplata_type, d.auth_id, d.disc_persent
   from documents d
  where d.document_id=:idocument_id
   into doc_num, doc_mark, doc_date, typedoc_id,
        tobject_id, tclient_id, staff_id,
        lock_date, tpay_type_id, tauth_id, p_disc_persent;

 if (:tpay_type_id = 1) then oplata_type = 'готівка';
 if (:tpay_type_id = 2) then oplata_type = 'перерахунок';
 if (:tpay_type_id = 1) then doc_tip     = 'готівка';
 if (:tpay_type_id = 2) then doc_tip     = 'з розрахункового рахунку';

 select td.typedoc_name
   from typedoc td
  where td.typedoc_id = :typedoc_id
   into typedoc_name;
 
 select s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
   from staff s
  where s.staff_id = :staff_id
   into staff_name;

 if (staff_id is null) then staff_name=null;

 select drs.sum_out, drs.sum_out_pdv, drs.sum_in
   from s_docrec_sum(:idocument_id, :p_disc_persent) drs
   into doc_sum, doc_sumpdv, p_sum_in;

 if (p_sum_in   is null) then p_sum_in = 0.000;
 if (doc_sum    is null) then doc_sum  = 0.000;
 if (doc_sumpdv is null) then doc_sumpdv = 0.000;
 if (not(/*around(*/p_sum_in/*)*/=0.000)) then
 doc_pdv = 0.000;
 doc_pdv = :doc_sumpdv - :doc_sum;
 des_sumdoc = decpart(around(:doc_sumpdv));
 out_sumpdv = around(:doc_sumpdv);
 

 select max(rt.reestr_id) from reestr rt
  where rt.document_id = :idocument_id
   into tcounts;
 
 if (tcounts is null) then
 begin
   select max(rt.reestr_id) from reestr rt into oroll_tax_id;
   oroll_tax_id = :oroll_tax_id + 1;
 end else
   oroll_tax_id = :tcounts;

 select first(1) r.reestr_id, r.td_date
   from documents d
        inner join reestr r on r.document_id = d.document_id
  where d.doc_num = :doc_num
  order by r.reestr_id desc
   into base_reestr_id, base_reestr_date;



 select name, zkpo, ispdv, ipn, numpdv, adress, phone, shortname, typeprop_id,
        deliv_addr
   from clients
  where clients_id = :tobject_id
   into name_s, zkpo_s, ispdv_s, ipn_s, numpdv_s, adress_s, phone_s, shortname_s, tt,
        deliv_addr_s;

 select tp.name from typeprop tp
  where tp.typeprop_id = :tt
   into n_name_s;

 select name, zkpo, ispdv, ipn, numpdv, adress, phone, shortname, typeprop_id,
        deliv_addr
   from clients
  where clients_id = :tclient_id
   into name_d, zkpo_d, ispdv_d, ipn_d, numpdv_d, adress_d, phone_d, shortname_d, tt,
        deliv_addr_d;

 select tp.name from typeprop tp
  where tp.typeprop_id = :tt
   into n_name_d;

 --актуально лише для гуртової версії, мабуть
 select a.auth_num, a.auth_date, a.auth_name
   from auth a
  where a.auth_id = :tauth_id
   into oauth_num, oauth_date, oauth_name;

 if (:tauth_id is null) then
  begin
    oauth_name='';
  end
     --    select doc_borg from rc_debitorka_y(:src_id) where client_id=:dst_id  into :borg;
 --if (:borg is null) then borg=0;
 --borg = around(:borg);

 --
 select u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
   from t_users u
  where u.user_login = user
   into ousername;
 suspend;

end^


ALTER PROCEDURE PS_DOCREC_PRINT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    OSG_ID INTEGER,
    P_IN_SUM DOUBLE PRECISION,
    P_IN_SUM_VAT DOUBLE PRECISION,
    ODATEX_NAME VARCHAR(26),
    OBRUTTO NUMERIC(9,3),
    REAL_DISC_PERCENT DOUBLE PRECISION,
    PRICE_BY_DATE DOUBLE PRECISION,
    BAR_CODE VARCHAR(30),
    W3_NOMEN_ID INTEGER)
AS
declare variable P_TYPEPDV_ID integer;
declare variable P_TYPEPDV_PDV double precision;
declare variable P_IN_PRICE double precision;
declare variable P_DISC_PERSENT double precision;
declare variable P_TYPEDOC_ID integer;
declare variable P_MAKER_ID integer;
declare variable P_TARA_ID integer;
declare variable P_OBJECTS_ID integer;
declare variable P_NOMEN_PDV integer;
declare variable PDOC_DATE date;
declare variable P_NOM_BAR_COUNT integer;
declare variable P_NOM_BAR_ID integer;
begin
 select d.disc_persent, d.typedoc_id, d.objects_id, d.doc_date
   from documents d
  where d.document_id = :document_id
   into p_disc_persent, p_typedoc_id, p_objects_id, pdoc_date;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, around3(dr.price), dr.kilk,
            tp.typepdv_id, tp.pdv,
            '('||cast(cast(dr.typepdv_pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name, '', 1.00,
            s.si_name, dr.typepdv_id, dr.typepdv_pdv, n.is_weight, 1, 0, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, sg_id,
            n.datex_name, n.brutto, n.w3_nomen_id
       from docrec dr
            left join nomen n on (dr.nomen_id = n.nomen_id)
            join typepdv tp on (tp.typepdv_id = dr.typepdv_id)
            join si s on (s.si_id = n.si_id)
      where dr.document_id=:document_id
      order by dr.docrec_id
       into docrec_id, nomen_id, nomen_code, nomen_name, general_price, kilk,
            p_typepdv_id, p_typepdv_pdv, type_pdv, packs, in_pack,
            si_name, typepdv_id, typepdv_pdv, is_weight, p_tara_id, p_maker_id, nomen_price,
            disc_persent, p_nomen_pdv, p_in_sum_vat, p_in_sum, osg_id,
            odatex_name, obrutto, w3_nomen_id
 do begin
  p_sum_in     = :p_in_sum_vat;
  sum_pdv      = 0.000;
  sum_out      = 0.000;
  out_price    = 0.000;
  extra_sum    = 0.000;
  extra_p      = 0.000;
  maker_name   = null;
  p_in_sum_vat = absrizn(0, :p_in_sum_vat);
  p_in_sum     = absrizn(0, :p_in_sum);

  if ((:disc_persent is null)or(:disc_persent = 0)) then
  begin
    disc_persent  = :p_disc_persent;
  end

  select oprice_pdv, osum_pdv from ps_get_sum(:docrec_id, :p_disc_persent, :disc_persent)
    into out_price_pdv, sum_out_pdv;

  if (kilk<>0) then
  begin
   p_in_price = :p_in_sum/:kilk;
   extra_sum = :sum_out_pdv-:p_in_sum_vat;

   sum_out = calcsum(:sum_out_pdv, :extra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

   extra_sum = :sum_out-:p_in_sum;
   if (:extra_sum <> 0.000) then extra_p=(:extra_sum / :sum_out) * 100;

   out_price = :sum_out/:kilk;

   select oprice from ps_price_by_date(:nomen_id, :pdoc_date)
    into price_by_date;
   real_disc_percent = :out_price_pdv / (:price_by_date / 100) - 100;
   real_disc_percent = - :real_disc_percent;

   if (:p_typedoc_id = 1) then
   begin
    if (:sum_out_pdv <> 0.000) then
    begin
      extra_sum = (:kilk*:nomen_price) - :sum_out_pdv;
      extra_p   = (((:kilk*:nomen_price)*100)/:sum_out_pdv)-100;
    end
    else begin
     extra_sum = 0.000;
     extra_p = 0.000;
    end
  end

  sum_pdv=:sum_out_pdv-:sum_out;

  end /* if (kilk<>0) then */
  else begin
   out_price = null;
   sum_out   = null;
   type_pdv  = null;
   sum_pdv   = null;
   sum_out_pdv = null;
   extra_sum = null;
   extra_p   = null;
  end /* if (kilk<>0) else */
  disc_persent = :disc_persent*100;
  sumtov_pdv = null;
  if (:p_typepdv_id = 1) then
   begin
     sumtov_pdv =:sum_out;
     /*$$IBEC$$ sum_out = null; $$IBEC$$*/
   end
     p_typepdv_id = -1;

   select count(nb.nom_bar_id) from nom_bar nb
    where nb.nomen_id = :nomen_id
     into p_nom_bar_count;
  if (:p_nom_bar_count is null) then p_nom_bar_count = 0;
  if (:p_nom_bar_count > 0) then
  begin
    select max(nb.nom_bar_id) from nom_bar nb
     where nb.nomen_id = :nomen_id
      into p_nom_bar_id;
    select b.code
     from nom_bar nb
          left join barcode b on b.barcode_id = nb.barcode_id
     where nb.nom_bar_id = :p_nom_bar_id
      into bar_code;
    if (:p_nom_bar_count>1) then bar_code = :bar_code||'/'||cast(:p_nom_bar_count as varchar(2));
  end
  else begin
    bar_code = '';
  end

  suspend;
 end
end^


ALTER PROCEDURE PS_DOCREC_SUM (
    DOCREC_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_docrec_id integer;
declare variable p_kilk double precision;
declare variable p_main_price double precision;
declare variable p_price_out_pdv double precision;
declare variable p_sum_out_pdv double precision;
declare variable p_sum_in_pdv double precision;
declare variable p_sum_in double precision;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_disc_persent double precision;
declare variable p_sum_disc_persent double precision;
declare variable p_count_rec integer;
begin
  p_count_rec = 1;
 if ((:disc_persent is null)or(:disc_persent < 0.000)) then disc_persent = 0.000;

 select dr.docrec_id, dr.kilk, dr.price, dr.typepdv_id, dr.typepdv_pdv,
        dr.disc_persent, dr.insum_pdv, dr.insum
   from docrec dr
  where dr.docrec_id = :docrec_id
   into p_docrec_id, p_kilk, p_main_price, p_typepdv_id, p_typepdv_pdv,
        p_disc_persent, p_sum_in_pdv, p_sum_in;

  if ((:p_disc_persent is null)or(:p_disc_persent=0.000)) then
    p_sum_disc_persent = :disc_persent;
  else
    p_sum_disc_persent = :p_disc_persent;

  select osum_pdv, oprice_pdv from ps_get_sum(:docrec_id, :disc_persent, :p_disc_persent)
    into p_sum_out_pdv, p_price_out_pdv;

  sum_in_pdv  = :p_sum_in_pdv;
  sum_out_pdv = :p_sum_out_pdv;
  sum_in  = :p_sum_in;
  sum_out = calcsum(:p_sum_out_pdv, :p_sum_out_pdv-:p_sum_in_pdv, :p_typepdv_pdv, :p_typepdv_id, 0);

 if (:p_count_rec <> 0) then
   avg_disc_persent = (:p_sum_disc_persent/:p_count_rec);
 else
   avg_disc_persent = :disc_persent;
 suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD1_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
declare variable tgoods_id integer;
begin
  tsuma = 0;

  ocaption = 'записів в реалізації';
  select dg.goods_id
    from docgoods dg
   where dg.docrec_id = :idocrec_id
    into :tgoods_id;

  select count(dg.docgoods_id)
    from docgoods dg
   where dg.docrec_id <> :idocrec_id and
          dg.goods_id = :tgoods_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from goods g
      where g.goods_id = :tgoods_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD1_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable tgoods_id integer;
declare variable tclient integer;
declare variable tis_pdv smallint;
declare variable ttypepdv_id integer;
declare variable tdiscount double precision;
declare variable tprice double precision;
begin
  select d.objects_id, d.disc_persent from documents d
   where d.document_id = :idocument_id
    into tclient, tdiscount;

  select n.typepdv_id from nomen n
   where n.nomen_id = :inomen_id
    into ttypepdv_id;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  select c.ispdv from clients c
   where c.clients_id = :tclient
    into tis_pdv;

  if (:tis_pdv is null) then
    tis_pdv = 1;

  tprice = :iprice;
  if (:tis_pdv = 0) then
  begin
    tprice = calcsumpdv(:iprice, 0.000, 0.000, :ttypepdv_id, 0);
    ttypepdv_id = 1;
  end

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :inomen_id, :idocument_id, :ikilk, :iprice, :ttypepdv_id, 0.00);

  iprice = calcpricepdv(:tprice, :tdiscount, :idiscount, 0);

  tgoods_id = GEN_ID(GEN_GOODS_ID,1);
  insert into goods(goods_id, nomen_id, objects_id, clients_id, goods_rest, goods_inprice)
     values (:tgoods_id, :inomen_id, 1, :tclient, 0.00, :iprice);

  insert into docgoods (docrec_id, goods_id, kilk)
     values (:odocrec_id, :tgoods_id, 0.00);

  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD1_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tgoods_id integer;
declare variable tclient integer;
declare variable tnomen_id integer;
declare variable tis_pdv smallint;
declare variable ttypepdv_id integer;
declare variable tdiscount double precision;
declare variable tdiscount_old double precision;
declare variable tkilk_old double precision;
declare variable tprice_old double precision;
begin
  select dr.kilk, dr.price, dr.disc_persent, dr.typepdv_id, nomen_id
   from docrec dr
  where dr.docrec_id = :idocrec_id
   into tkilk_old, tprice_old, tdiscount_old, ttypepdv_id, tnomen_id;

  update docrec dr
     set dr.price = :iprice,
         dr.kilk = :ikilk,
         dr.disc_persent = :idiscount
   where dr.docrec_id = :idocrec_id;

  if ((:tprice_old <> :iprice) or (:tdiscount_old <> :idiscount)) then
  begin
    select dg.goods_id from docgoods dg
     where dg.docrec_id = :idocrec_id
      into tgoods_id;

    select g.clients_id from goods g
     where g.goods_id = :tgoods_id
      into tclient;

    select c.ispdv from clients c
     where c.clients_id = :tclient
      into tis_pdv;

    if (:tis_pdv is null) then
      tis_pdv = 1;

    if (:tis_pdv = 0) then
    begin
      select n.typepdv_id from nomen n
       where n.nomen_id = :tnomen_id
        into ttypepdv_id;

      iprice = calcsumpdv(:iprice, 0.000, 0.000, :ttypepdv_id, 0);
    end
    else
      select oprice_pdv from ps_get_sum(:idocrec_id, :tdiscount, :idiscount)
        into iprice;
  end

  update goods g
     set g.goods_inprice = :iprice
   where g.goods_id = :tgoods_id;

  okilk = :ikilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD10_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable pmarker varchar(64);
begin
/*$$IBEC$$     select marker from t_configs c
   where c.module = 'store_documents' and
         c.config_id = 2
    into pmarker;

  if (:pmarker = 'no') then
  begin $$IBEC$$*/
    suspend;

    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
/*$$IBEC$$   end else
  begin
    select p.ocount, p.ocaption from ps_docrec_td2_del(:idocrec_id) p
      into ocount, ocaption;
    suspend;
  end $$IBEC$$*/
end^


ALTER PROCEDURE PS_DOCREC_TD10_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable ttypepdv_id integer;
declare variable pmarker varchar(64);
begin
/*$$IBEC$$   select marker from t_configs c
   where c.module = 'store_documents' and
         c.config_id = 2
    into pmarker;

  if (:pmarker = 'no') then
  begin $$IBEC$$*/
    select n.typepdv_id from nomen n
     where n.nomen_id = :inomen_id
      into ttypepdv_id;

    odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

    insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :inomen_id, :idocument_id, :ikilk, :iprice, :ttypepdv_id, 0.00);
/*$$IBEC$$   end else
  begin
    select p.odocrec_id from ps_docrec_td2_ins(:idocument_id, :inomen_id, :ikilk, :iprice, :idiscount) p
      into odocrec_id;
  end $$IBEC$$*/

  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD10_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable pmarker varchar(64);
begin
/*$$IBEC$$   select marker from t_configs c
   where c.module = 'store_documents' and
         c.config_id = 2
    into pmarker;

  if (:pmarker = 'no') then
  begin $$IBEC$$*/
    update docrec dr
       set dr.kilk = :ikilk,
           dr.price = :iprice,
           dr.disc_persent = :idiscount
     where dr.docrec_id = :idocrec_id;
     okilk = :ikilk;
/*$$IBEC$$   end else
  begin
    select p.okilk from ps_docrec_td2_upd(:idocrec_id,:ikilk,:iprice,:idiscount) p
      into okilk;
  end $$IBEC$$*/

  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD15_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
DECLARE VARIABLE TGOODS_ID INTEGER;
DECLARE VARIABLE TKILK DOUBLE PRECISION;
begin
  tsuma = 0;

  select okilk from  PS_DOCREC_TD15_UPD (:idocrec_id, 0, 0, 0)
    into :tkilk;

  suspend;

  if (:tsuma = 0) then
  begin
    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD15_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable ttypepdv_id integer;
declare variable tnomen_id integer;
declare variable tkilk double precision;
declare variable pinsum_pdv double precision;
declare variable ptypepdv_id integer;
declare variable ptypepdv_pdv double precision;
begin
/*$$IBEC$$   select g.nomen_id from goods g
   where g.goods_id = :igoods_id
    into tnomen_id;

  select n.typepdv_id from nomen n
   where n.nomen_id = :tnomen_id
    into ttypepdv_id;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :tnomen_id, :idocument_id, :ikilk, :iprice, :ttypepdv_id, 0.00);

  insert into docgoods (docrec_id, goods_id, kilk)
     values (:odocrec_id, :igoods_id, :ikilk);

  update goods g
      set g.goods_rest = g.goods_rest - :ikilk
    where g.goods_id = :igoods_id; $$IBEC$$*/
  select di.odocrec_id from ps_docrec_td6_ins(:idocument_id, :igoods_id, :ikilk, :iprice, :idiscount) di
    into odocrec_id;

  select sum(dg.insum_pdv) from docgoods dg
   where dg.docrec_id = :odocrec_id
    into pinsum_pdv;
  select n.typepdv_id, tp.pdv
    from nomen n
         inner join docrec dr on dr.nomen_id = n.nomen_id
         inner join typepdv tp on n.typepdv_id = tp.typepdv_id
   where dr.docrec_id = :odocrec_id
    into ptypepdv_id, ptypepdv_pdv;
  update docrec dr
     set dr.insum_pdv   = :pinsum_pdv,
         dr.typepdv_id  = :ptypepdv_id,
         dr.typepdv_pdv = :ptypepdv_pdv
   where dr.docrec_id = :odocrec_id;
  if (:ikilk != 0) then
  update docrec dr
     set dr.price = :pinsum_pdv / :ikilk
   where dr.docrec_id = :odocrec_id;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD15_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tkilk double precision;
declare variable tdocgoods_id integer;
declare variable tgoods_id integer;
declare variable pinsum_pdv double precision;
declare variable ptypepdv_id integer;
declare variable ptypepdv_pdv double precision;
begin
/*$$IBEC$$   okilk = :ikilk;
  update docrec dr
     set dr.kilk = :ikilk,
         dr.price = :iprice,
         dr.disc_persent = :idiscount
   where dr.docrec_id = :idocrec_id;

  select first(1) docgoods_id, goods_id, dg.kilk from docgoods dg
   where dg.docrec_id = :idocrec_id
    into tdocgoods_id, tgoods_id, tkilk;

  update docgoods dg
     set dg.kilk = :ikilk
   where dg.docgoods_id = :tdocgoods_id;

  update goods g
     set g.goods_rest = g.goods_rest + (:tkilk - :ikilk)
   where g.goods_id = :tgoods_id; $$IBEC$$*/

   select du.okilk from ps_docrec_td6_upd(:idocrec_id, :ikilk, :iprice) du
     into okilk;

 select sum(dg.insum_pdv) from docgoods dg
   where dg.docrec_id = :idocrec_id
    into pinsum_pdv;
  select n.typepdv_id, tp.pdv
    from nomen n
         inner join docrec dr on dr.nomen_id = n.nomen_id
         inner join typepdv tp on n.typepdv_id = tp.typepdv_id
   where dr.docrec_id = :idocrec_id
    into ptypepdv_id, ptypepdv_pdv;
  update docrec dr
     set dr.insum_pdv   = :pinsum_pdv,
         dr.typepdv_id  = :ptypepdv_id,
         dr.typepdv_pdv = :ptypepdv_pdv
   where dr.docrec_id = :idocrec_id;
  if (:ikilk != 0) then
  update docrec dr
     set dr.price = :pinsum_pdv / :ikilk
   where dr.docrec_id = :idocrec_id;

  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD17_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
DECLARE VARIABLE TKILK DOUBLE PRECISION;
begin
  tsuma = 0;

  select okilk from  PS_DOCREC_TD17_UPD (:idocrec_id, 0)
    into :tkilk;

  suspend;

  if (:tsuma = 0) then
  begin
    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD17_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable tnomen_id integer;
declare variable ttypepdv_id integer;
declare variable tkilk double precision;
declare variable tprice double precision;
begin
  select g.nomen_id, g.goods_inprice, n.typepdv_id from nomen n, goods g
      where g.goods_id = :igoods_id and
            g.nomen_id = n.nomen_id
    into :tnomen_id, :tprice, :ttypepdv_id;

  if (tprice != iprice) then
    tprice = :iprice;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :tnomen_id, :idocument_id, 0.0, :tprice, :ttypepdv_id, 0.00);

  insert into docgoods (goods_id, docrec_id, kilk)
     values (:igoods_id, :odocrec_id, 0.00);

  select okilk from  PS_DOCREC_TD17_UPD (:odocrec_id, :ikilk)
    into :tkilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD17_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tgoods_id integer;
declare variable tdocgoods_id integer;
declare variable tnomen_id integer;
declare variable tkilk_old double precision;
begin
  select dr.kilk, nomen_id
      from docrec dr
    where dr.docrec_id = :idocrec_id
  into :tkilk_old, :tnomen_id;

  select dg.docgoods_id, dg.goods_id from docgoods dg
    where dg.docrec_id = :idocrec_id
  into :tdocgoods_id, :tgoods_id;

  update docrec dr
     set dr.kilk = :ikilk
    where dr.docrec_id = :idocrec_id;

  update docgoods dg
      set dg.kilk = :ikilk
    where dg.docgoods_id = :tdocgoods_id;

  update goods g
      set g.goods_rest = g.goods_rest + :tkilk_old - :ikilk
    where g.goods_id = :tgoods_id;

  execute procedure s_sliv_minusov(1, :tnomen_id);

  okilk = :ikilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD17_UPD_V1 (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tgoods_id integer;
declare variable tdocgoods_id integer;
declare variable tnomen_id integer;
declare variable tkilk_old double precision;
begin
  select dr.kilk, nomen_id
      from docrec dr
    where dr.docrec_id = :idocrec_id
  into :tkilk_old, :tnomen_id;

  select dg.docgoods_id, dg.goods_id from docgoods dg
    where dg.docrec_id = :idocrec_id
  into :tdocgoods_id, :tgoods_id;

  update docrec dr
     set dr.kilk  = :ikilk,
         dr.price = :iprice
    where dr.docrec_id = :idocrec_id;

  update docgoods dg
      set dg.kilk = :ikilk
    where dg.docgoods_id = :tdocgoods_id;

  update goods g
      set g.goods_rest = g.goods_rest + :tkilk_old - :ikilk
    where g.goods_id = :tgoods_id;

  execute procedure s_sliv_minusov(1, :tnomen_id);

  okilk = :ikilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD2_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
DECLARE VARIABLE TGOODS_ID INTEGER;
DECLARE VARIABLE TKILK DOUBLE PRECISION;
begin
  tsuma = 0;

  select okilk from  PS_DOCREC_TD2_UPD (:idocrec_id, 0, 0, 0)
    into :tkilk;

  suspend;

  if (:tsuma = 0) then
  begin
    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD2_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable ttypepdv_id integer;
declare variable tkilk double precision;
begin
  select n.typepdv_id
      from nomen n
    where n.nomen_id = :inomen_id
  into :ttypepdv_id;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :inomen_id, :idocument_id, :ikilk, :iprice, :ttypepdv_id, 0.00);


  select okilk from  PS_DOCREC_TD2_UPD (:odocrec_id, :ikilk, :iprice, :idiscount)
    into :tkilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD2_INS_V1 (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION,
    IGOODS_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable ttypepdv_id integer;
declare variable tkilk double precision;
begin
  select n.typepdv_id
      from nomen n
    where n.nomen_id = :inomen_id
  into :ttypepdv_id;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :inomen_id, :idocument_id, :ikilk, :iprice, :ttypepdv_id, 0.00);


  select okilk from  PS_DOCREC_TD2_UPD_V1 (:odocrec_id, :ikilk, :iprice, :idiscount, :igoods_id)
    into :tkilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD2_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK DOUBLE PRECISION)
AS
declare variable tgoods_rest double precision;
declare variable tmin_kilk double precision;
declare variable tkilk double precision;
declare variable tdocgoods_id integer;
declare variable tin_kilk double precision;
declare variable tobject_id integer;
declare variable tgoods_id integer;
declare variable tnomen_id integer;
begin
  tobject_id = 1;
  okilk = :ikilk;
  update docrec dr
      set dr.kilk = :ikilk,
          dr.price = :iprice,
          dr.disc_persent = :idiscount
    where dr.docrec_id = :idocrec_id;

  select dr.nomen_id from docrec dr
    where dr.docrec_id = :idocrec_id
  into :tnomen_id;

  select  sum(dg.kilk) from docgoods dg
    where dg.docrec_id = :idocrec_id
  into :tkilk;

  if (:tkilk is null) then
    tkilk = 0.0;

  tin_kilk = :ikilk;

/*------------ Aey ?ico?aieo oa ?ae?a -----------------------------*/
  if (:tkilk < :ikilk) then
  begin
    ikilk = :ikilk - :tkilk;

    for select d.docgoods_id, g.goods_id, g.goods_rest from docgoods d, goods g
      where d.docrec_id = :idocrec_id and
            g.goods_id = d.goods_id and
            g.goods_rest > 0.0
    into  :tdocgoods_id, :tgoods_id, :tgoods_rest
    do begin

      tmin_kilk = Min2(:ikilk, :tgoods_rest);

      if (:tmin_kilk > 0.0) then
      begin
        ikilk = :ikilk - :tmin_kilk;

        update goods g
            set g.goods_rest = g.goods_rest - :tmin_kilk
          where g.goods_id = :tgoods_id;

        update docgoods
            set kilk = kilk + :tmin_kilk
          where docgoods_id = :tdocgoods_id;
      end
    end

    if (:ikilk > 0) then
    begin
   /* ????????? ????? ?? ??????? ?????? */
      for select gg.goods_id, gg.goods_rest from goods gg
        where    gg.nomen_id = :tnomen_id and
                 gg.objects_id = :tobject_id and
                 gg.goods_rest > 0.0
          order by gg.goods_id
      into :tgoods_id, :tgoods_rest
      do begin

        tmin_kilk = Min2(:ikilk, :tgoods_rest);

        if (:tmin_kilk > 0.0) then
        begin
          ikilk = :ikilk - :tmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest - :tmin_kilk
            where g.goods_id = :tgoods_id;

          insert into docgoods (goods_id, docrec_id, kilk)
            values  (:tgoods_id, :idocrec_id, :tmin_kilk);
        end
      end
    end
    if (:ikilk > 0) then
    begin
   /* ????????? ?? ??????? ?????? ? ??????????? ????? */

      tgoods_id = null;
      select max(goods_id) from goods g
          where g.nomen_id = :tnomen_id and
                g.objects_id = :tobject_id
        into :tgoods_id;
      update goods g
          set g.goods_rest = g.goods_rest - :ikilk
        where g.goods_id = :tgoods_id;
      insert into docgoods (goods_id, docrec_id, kilk)
        values(:tgoods_id, :idocrec_id, :ikilk);
    end
  end
/* ------------------------------------------- */
  else if (:tkilk > :ikilk) then
  begin
    ikilk = :tkilk - :ikilk;
    for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
      where    d.docrec_id = :idocrec_id and
               d.goods_id = g.goods_id and
               g.goods_rest < 0.0
    into :tdocgoods_id, :tkilk, :tgoods_id, :tgoods_rest
    do begin
      tmin_kilk = Min2(:ikilk, -:tgoods_rest);
      tmin_kilk = Min2(:tkilk, :tmin_kilk);
      if (:tmin_kilk > 0.0) then
      begin
        ikilk = :ikilk - :tmin_kilk;
        update goods g
            set g.goods_rest = g.goods_rest + :tmin_kilk
          where g.goods_id = :tgoods_id;
        update docgoods d
            set d.kilk = d.kilk - :tmin_kilk
          where d.docgoods_id = :tdocgoods_id;
      end
    end
    if (:ikilk > 0.0) then
    begin
      for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
        where    d.docrec_id = :idocrec_id and
                 d.goods_id = g.goods_id and
                 g.goods_rest >= 0.0
      into :tdocgoods_id, :tkilk, :tgoods_id, :tgoods_rest
      do begin
        tmin_kilk = Min2(:ikilk, :tkilk);
        if (:tmin_kilk > 0.0) then
        begin
          ikilk = :ikilk - :tmin_kilk;
          update goods g
              set g.goods_rest = g.goods_rest + :tmin_kilk
            where g.goods_id = :tgoods_id;
          update docgoods d
              set d.kilk = d.kilk - :tmin_kilk
            where d.docgoods_id = :tdocgoods_id;
        end
      end
    end
  end
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD2_UPD_V1 (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION,
    IGOODS_ID INTEGER)
RETURNS (
    OKILK DOUBLE PRECISION)
AS
declare variable tgoods_rest double precision;
declare variable tmin_kilk double precision;
declare variable tkilk double precision;
declare variable tdocgoods_id integer;
declare variable tin_kilk double precision;
declare variable tobject_id integer;
declare variable tgoods_id integer;
declare variable tnomen_id integer;
begin
  tobject_id = 1;
  okilk = :ikilk;
  update docrec dr
      set dr.kilk  = :ikilk,
          dr.price = :iprice,
          dr.disc_persent = :idiscount
    where dr.docrec_id = :idocrec_id;

  select dr.nomen_id from docrec dr
    where dr.docrec_id = :idocrec_id
  into :tnomen_id;

  select  sum(dg.kilk) from docgoods dg
    where dg.docrec_id = :idocrec_id
  into :tkilk;

  if (:tkilk is null) then
    tkilk = 0.0;

  tin_kilk = :ikilk;

/*------------ Збільшення кількості товару ------------------*/
  if (:tkilk < :ikilk) then
  begin
    ikilk = :ikilk - :tkilk;
    ----------------------------------------------------------
    --  Спроба зняти потрібну кількість з вказаного goodsa  --
    ----------------------------------------------------------
    select g.goods_rest from goods g
     where g.goods_id = :igoods_id
    into  :tgoods_rest;

    tmin_kilk = Min2(:ikilk, :tgoods_rest);
    if (:tmin_kilk > 0.0) then
    begin
      ikilk = :ikilk - :tmin_kilk;

      update goods g
         set g.goods_rest = g.goods_rest - :tmin_kilk
      where g.goods_id   = :igoods_id;

      select dg.docgoods_id from docgoods dg
       where dg.docrec_id = :idocrec_id and
             dg.goods_id  = :igoods_id
      into :tdocgoods_id;

      if (:tdocgoods_id is null) then
        insert into docgoods (goods_id, docrec_id, kilk)
                     values  (:igoods_id, :idocrec_id, :tmin_kilk);
      else
        update docgoods
           set kilk = kilk + :tmin_kilk
         where docgoods_id = :tdocgoods_id;

    end
    -------------------------------------------------
    -- ** спроба зняти з гудсів документу          **
    -------------------------------------------------
    if (:ikilk > 0) then
    begin
    for select dg.docgoods_id, g.goods_id, g.goods_rest from docgoods dg, goods g
      where dg.docrec_id = :idocrec_id and
            g.goods_id = dg.goods_id and
            g.goods_rest > 0.0
    into  :tdocgoods_id, :tgoods_id, :tgoods_rest
    do begin

      tmin_kilk = Min2(:ikilk, :tgoods_rest);

      if (:tmin_kilk > 0.0) then
      begin
        ikilk = :ikilk - :tmin_kilk;

        update goods g
            set g.goods_rest = g.goods_rest - :tmin_kilk
          where g.goods_id = :tgoods_id;

        update docgoods
            set kilk = kilk + :tmin_kilk
          where docgoods_id = :tdocgoods_id;
      end
    end
    end
    -------------------------------------------------
    -- ** спроба зняти з решти гудсів              **
    -------------------------------------------------
    if (:ikilk > 0) then
    begin
      for select gg.goods_id, gg.goods_rest from goods gg
        where    gg.nomen_id   = :tnomen_id  and
                 gg.objects_id = :tobject_id and
                 gg.goods_rest > 0.0
          order by gg.goods_id
      into :tgoods_id, :tgoods_rest
      do begin

        tmin_kilk = Min2(:ikilk, :tgoods_rest);

        if (:tmin_kilk > 0.0) then
        begin
          ikilk = :ikilk - :tmin_kilk;

          update goods g
             set g.goods_rest = g.goods_rest - :tmin_kilk
           where g.goods_id   = :tgoods_id;

          insert into docgoods (goods_id, docrec_id, kilk)
            values  (:tgoods_id, :idocrec_id, :tmin_kilk);
        end
      end
    end
    -------------------------------------------------
    -- ** зняття в мінус                           **
    -------------------------------------------------
    if (:ikilk > 0) then
    begin
      tgoods_id = null;
      select max(goods_id) from goods g
          where g.nomen_id = :tnomen_id and
                g.objects_id = :tobject_id
        into :tgoods_id;
      update goods g
          set g.goods_rest = g.goods_rest - :ikilk
        where g.goods_id = :tgoods_id;
      insert into docgoods (goods_id, docrec_id, kilk)
        values(:tgoods_id, :idocrec_id, :ikilk);
    end
  end
/* --------- Зменшення кількості --------------- */
  else if (:tkilk > :ikilk) then
  begin
    ikilk = :tkilk - :ikilk;
    for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
      where    d.docrec_id  = :idocrec_id and
               d.goods_id   = g.goods_id and
               g.goods_rest < 0.0
    into :tdocgoods_id, :tkilk, :tgoods_id, :tgoods_rest
    do begin
      tmin_kilk = Min2(:ikilk, -:tgoods_rest);
      tmin_kilk = Min2(:tkilk, :tmin_kilk);
      if (:tmin_kilk > 0.0) then
      begin
        ikilk = :ikilk - :tmin_kilk;
        update goods g
            set g.goods_rest = g.goods_rest + :tmin_kilk
          where g.goods_id = :tgoods_id;
        update docgoods d
           set d.kilk = d.kilk - :tmin_kilk
         where d.docgoods_id = :tdocgoods_id;
      end
    end
    if (:ikilk > 0.0) then
    begin
      for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
        where    d.docrec_id   = :idocrec_id and
                 d.goods_id    = g.goods_id and
                 g.goods_rest >= 0.0
      into :tdocgoods_id, :tkilk, :tgoods_id, :tgoods_rest
      do begin
        tmin_kilk = Min2(:ikilk, :tkilk);
        if (:tmin_kilk > 0.0) then
        begin
          ikilk = :ikilk - :tmin_kilk;
          update goods g
              set g.goods_rest = g.goods_rest + :tmin_kilk
            where g.goods_id = :tgoods_id;
          update docgoods d
              set d.kilk = d.kilk - :tmin_kilk
            where d.docgoods_id = :tdocgoods_id;
        end
      end
    end
  end
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD4_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tkilk double precision;
declare variable tdocgoods_id integer;
declare variable tobject_id integer;
declare variable tgoods_id integer;
declare variable tnomen_id integer;
begin
  tobject_id = 1;
  okilk = :ikilk;
  update docrec dr
     set dr.kilk = :ikilk
   where dr.docrec_id = :idocrec_id;
      /*
  select dr.nomen_id
    from docrec dr
   where dr.docrec_id = :idocrec_id
    into tnomen_id;

  select docgoods_id, goods_id, dg.kilk
    from docgoods dg
   where dg.docrec_id = :idocrec_id
    into tdocgoods_id, tgoods_id, tkilk;

  if (:tkilk is null) then
    tkilk = 0.0;

  update docgoods dg
      set dg.kilk = :ikilk
    where dg.docgoods_id = :tdocgoods_id;

  update goods g
      set g.goods_rest = g.goods_rest - (:ikilk - :tkilk)
    where g.goods_id = :tgoods_id;   */

  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD6_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
declare variable tgoods_id integer;
declare variable tkilk double precision;
begin
  tsuma = 0;

  select okilk from  PS_DOCREC_TD6_UPD (:idocrec_id, 0, 0)
    into :tkilk;

  suspend;

  if (:tsuma = 0) then
  begin
    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD6_INS (
    IDOCUMENT_ID INTEGER,
    IGOODS_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable tnomen_id integer;
declare variable tkilk double precision;
declare variable tprice double precision;
begin
/*Увага!! Дана процедура використовується в інших процедурах*/
  select g.nomen_id, g.goods_inprice from goods g
   where g.goods_id = :igoods_id
    into tnomen_id, tprice;

  if ((:iprice is null)or(:iprice = 0.0)) then iprice = :tprice;
  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :tnomen_id, :idocument_id, :ikilk, :iprice, 1, 0.00);
/*$$IBEC$$ 
  insert into docgoods (goods_id, docrec_id, kilk, inprice, inprice_pdv)
     values (:igoods_id, :odocrec_id, 0.00, :tprice, :tprice); $$IBEC$$*/

  select okilk from  PS_DOCREC_TD6_UPD (:odocrec_id, :ikilk, :iprice)
    into tkilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD6_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tkilk double precision;
declare variable tdocgoods_id integer;
declare variable tobject_id integer;
declare variable tgoods_id integer;
declare variable tnomen_id integer;
declare variable tinsum double precision;
declare variable tgoods_inprice double precision;
declare variable tgoods_rest double precision;
declare variable tcurrent_kilk double precision;
declare variable ptypepdv_pdv double precision;
begin
/*Увага!! Дана процедура використовується в інших процедурах*/
  tobject_id = 1;
  okilk = :ikilk;

  select dr.nomen_id, dr.kilk, dr.price * dr.kilk from docrec dr 
   where dr.docrec_id = :idocrec_id
    into tnomen_id, tkilk, tinsum;

/*Новий алгоритм: списування йде з багатьох гудсів*/
  tinsum = 0.0;
  tkilk = :ikilk;
  /*"Зливання" всіх докгудсів в ноль*/
  for select dg.goods_id, dg.kilk, dg.docgoods_id
        from docgoods dg
       where dg.docrec_id = :idocrec_id
        into tgoods_id, tgoods_rest, tdocgoods_id
  do begin
    update docgoods dg
       set dg.kilk = 0.0
     where dg.docgoods_id = :tdocgoods_id;
    update goods g
       set g.goods_rest = g.goods_rest + :tgoods_rest
     where g.goods_id = :tgoods_id;
  end

  /*Виконання переміщення товарів з найстаріших гудсів*/
  for select g.goods_id, g.goods_rest, g.goods_inprice
        from goods g
       where g.nomen_id = :tnomen_id and
             g.goods_rest > 0.001
       order by g.goods_id
        into tgoods_id, tgoods_rest, tgoods_inprice
  do begin
    if (:tkilk > 0.0001) then
    begin
      tcurrent_kilk = min2(:tkilk, :tgoods_rest);

      update goods g
         set g.goods_rest = g.goods_rest - :tcurrent_kilk
       where g.goods_id = :tgoods_id;
/*$$IBEC$$       tdocgoods_id = null;
      select dg.docgoods_id from docgoods dg
       where dg.docrec_id = :idocrec_id and
             dg.goods_id  = :tgoods_id
        into tdocgoods_id;
      if (:tdocgoods_id is null) then
      begin $$IBEC$$*/
        insert into docgoods (goods_id, docrec_id, kilk, inprice, inprice_pdv)
             values (:tgoods_id, :idocrec_id, :tcurrent_kilk, :tgoods_inprice, :tgoods_inprice);
/*$$IBEC$$       end else
      begin
        update docgoods dg
           set dg.kilk = :tcurrent_kilk,
               dg.inprice = :tgoods_inprice,
               dg.inprice_pdv = :tgoods_inprice
         where dg.docgoods_id = :tdocgoods_id;
      end $$IBEC$$*/
      tinsum = :tinsum + :tgoods_inprice * :tcurrent_kilk;
      tkilk = :tkilk - :tcurrent_kilk;
    end
  end
  if (:tkilk > 0.0001) then
  /*Якщо не вистачило "плюсових" приходів*/
  begin
    select first(1) g.goods_id, g.goods_rest, g.goods_inprice
      from goods g
     where g.nomen_id = :tnomen_id
     order by g.goods_id desc
      into tgoods_id, tgoods_rest, tgoods_inprice;

    tcurrent_kilk = :tkilk;

      update goods g
         set g.goods_rest = g.goods_rest - :tcurrent_kilk
       where g.goods_id = :tgoods_id;

    insert into docgoods (goods_id, docrec_id, kilk, inprice, inprice_pdv)
       values (:tgoods_id, :idocrec_id, :tcurrent_kilk, :tgoods_inprice, :tgoods_inprice);

      tinsum = :tinsum + :tgoods_inprice * :tcurrent_kilk;
  end

  if ((:ikilk != 0.0)and(:tinsum != 0.0)) then
  begin
    iprice = :tinsum / :ikilk;
  end

  select tp.pdv from nomen n left join typepdv tp on n.typepdv_id = tp.typepdv_id
   where n.nomen_id = :tnomen_id
    into ptypepdv_pdv;

  iprice = :iprice / (1 + :ptypepdv_pdv);

  update docrec dr
     set dr.kilk = :ikilk,
         dr.price = :iprice
   where dr.docrec_id = :idocrec_id;
  execute procedure tmp_fix_dr6(:idocrec_id);

suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD7_DEL (
    IDOCREC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
declare variable tgoods_id integer;
declare variable tprew_document_id integer;
declare variable pdocgoods_id integer;
declare variable pgoods_id integer;
declare variable pdelta_kilk double precision;
begin
  tsuma = 0;

  ocaption = 'записів в реалізації';
  select dg.goods_id
    from docgoods dg
   where dg.docrec_id = :idocrec_id
    into tgoods_id;

  select count(dg.docgoods_id)
    from docgoods dg
   where dg.docrec_id <> :idocrec_id and
         dg.goods_id = :tgoods_id
    into ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    /*Видалення корегуючої*/
    select d.document_id from documents d
     where d.prew_document_id = (select first(1) dr.document_id from docrec dr where dr.docrec_id = :idocrec_id) and
           d.clients_id = 95
      into tprew_document_id;
    if (:tprew_document_id is not null) then
    begin
      for select dg.docgoods_id, dg.goods_id, dg.kilk
            from docrec dr
                 left join docgoods dg on dr.docrec_id = dg.docrec_id
           where dr.document_id = :tprew_document_id and
                 dr.nomen_id = (select first(1) dr.nomen_id from docrec dr where dr.docrec_id = :idocrec_id)
            into pdocgoods_id, pgoods_id, pdelta_kilk
      do begin
        update goods g
           set g.goods_rest = g.goods_rest + :pdelta_kilk
         where g.goods_id = :pgoods_id;
        delete from docgoods dg
         where dg.docgoods_id  = :pdocgoods_id;
      end

      delete from docrec dr
       where dr.document_id = :tprew_document_id and
             dr.nomen_id = (select first(1) dr.nomen_id from docrec dr where dr.docrec_id = :idocrec_id);
    end

    delete from docgoods dg
      where dg.docrec_id = :idocrec_id;
    delete from goods g
      where g.goods_id = :tgoods_id;
    delete from docrec dr
      where dr.docrec_id = :idocrec_id;
  end
end^


ALTER PROCEDURE PS_DOCREC_TD7_INS (
    IDOCUMENT_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    ODOCREC_ID INTEGER)
AS
declare variable tgoods_id integer;
declare variable tclient integer;
declare variable tis_pdv smallint;
declare variable ttypepdv_id integer;
declare variable tdiscount double precision;
declare variable tprice double precision;
declare variable ttypepdv_pdv double precision;
declare variable tprice_pdv double precision;
declare variable tdocgoods_id integer;
begin
  select d.objects_id, d.disc_persent from documents d
   where d.document_id = :idocument_id
    into tclient, tdiscount;

  select n.typepdv_id, tp.pdv
    from nomen n left join typepdv tp on n.typepdv_id = tp.typepdv_id
   where n.nomen_id = :inomen_id
    into ttypepdv_id, ttypepdv_pdv;

  odocrec_id = GEN_ID(GEN_DOCREC_ID,1);

  select c.ispdv from clients c
   where c.clients_id = :tclient
    into tis_pdv;

  if (:tis_pdv is null) then
    tis_pdv = 1;

  /*Створити новий тип документу "Прихідне внутрішнє переміщення"
    (В докрекові Ціна = ЦЗ без ПДВ, в докгудсові по докрекові,
    в гудсові ціна закупки з ПДВ, якщо пдв = 20%).*/
  iprice = calcpricepdv(:iprice, :tdiscount, :idiscount, 0);
  tprice_pdv = :iprice;
/*$$IBEC$$   if (:tis_pdv = 0) then
  begin
    tprice_pdv = calcsumpdv(:iprice, 0.000, 0.000, :ttypepdv_id, 0);
    ttypepdv_id = 1;
  end else $$IBEC$$*/
    tprice_pdv = :tprice_pdv * (1 + :ttypepdv_pdv);

  insert into docrec (docrec_id, nomen_id, document_id, kilk, price, typepdv_id, typepdv_pdv)
     values (:odocrec_id, :inomen_id, :idocument_id, :ikilk, :iprice, 1, 0.00);

  tgoods_id = GEN_ID(GEN_GOODS_ID,1);
  insert into goods(goods_id, nomen_id, objects_id, clients_id, goods_rest, goods_inprice)
     values (:tgoods_id, :inomen_id, 1, :tclient, 0.00, :tprice_pdv);

  insert into docgoods (docrec_id, goods_id, kilk)
     values (:odocrec_id, :tgoods_id, 0.00);

  update docgoods dg
     set dg.inprice = :iprice,
         dg.inprice_pdv = :iprice
   where dg.docrec_id = :odocrec_id and
         dg.goods_id  = :tgoods_id;

/*$$IBEC$$   update docrec dr
     set dr.insum_pdv = :iprice * :ikilk,
         dr.insum     = :iprice * :ikilk
   where dr.docrec_id = :odocrec_id; $$IBEC$$*/
  suspend;
end^


ALTER PROCEDURE PS_DOCREC_TD7_UPD (
    IDOCREC_ID INTEGER,
    IKILK DOUBLE PRECISION,
    IPRICE DOUBLE PRECISION,
    IDISCOUNT DOUBLE PRECISION)
RETURNS (
    OKILK INTEGER)
AS
declare variable tgoods_id integer;
declare variable tclient integer;
declare variable tnomen_id integer;
declare variable tis_pdv smallint;
declare variable ttypepdv_id integer;
declare variable tdiscount double precision;
declare variable tdiscount_old double precision;
declare variable tkilk_old double precision;
declare variable tprice_old double precision;
declare variable ttypepdv_pdv double precision;
declare variable tprice_pdv double precision;
begin
  select dr.kilk, dr.price, dr.disc_persent, dr.typepdv_id, nomen_id
   from docrec dr
  where dr.docrec_id = :idocrec_id
   into tkilk_old, tprice_old, tdiscount_old, ttypepdv_id, tnomen_id;

  tprice_pdv = :iprice;
  begin
    select cl.ispdv, g.goods_id
      from docgoods dg
           left join goods g on g.goods_id = dg.goods_id
           left join clients cl on g.clients_id = cl.clients_id
     where dg.docrec_id = :idocrec_id
      into tis_pdv, tgoods_id;

    if (:tis_pdv is null) then
      tis_pdv = 1;

    select n.typepdv_id, tp.pdv
      from nomen n left join typepdv tp on n.typepdv_id = tp.typepdv_id
     where n.nomen_id = :tnomen_id
      into ttypepdv_id, ttypepdv_pdv;

    if (:tis_pdv = 0) then
    begin
      iprice = calcsumpdv(:iprice, 0.000, 0.000, :ttypepdv_id, 0);
      tprice_pdv = :iprice;
    end else
    begin
      tprice_pdv = :iprice * (1 + :ttypepdv_pdv);
    end
  end

  update goods g
     set g.goods_inprice = :tprice_pdv
   where g.goods_id = :tgoods_id;

  update docgoods dg
     set dg.inprice = :iprice
   where dg.goods_id = :tgoods_id and
         dg.docrec_id = :idocrec_id;

    update docrec dr
     set /*$$IBEC$$ dr.insum_pdv = :iprice * :ikilk,
         dr.insum     = :iprice * :ikilk, $$IBEC$$*/
         dr.price = :iprice,
         dr.kilk = :ikilk,
         dr.disc_persent = :idiscount
   where dr.docrec_id = :idocrec_id;

  okilk = :ikilk;
  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_CREATE_LIKE (
    IDOCUMENT_ID INTEGER,
    ITYPEDOC_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OENABLED INTEGER,
    OMESSAGE VARCHAR(128))
AS
declare variable ttypedoc_id integer;
declare variable tdoc_num varchar(14);
declare variable tlast_doc_num varchar(14);
declare variable tclient_id integer;
declare variable tobject_id integer;
declare variable tnomen_id integer;
declare variable tgoods_id integer;
declare variable tdiscount double precision;
declare variable tkilk double precision;
declare variable tprice double precision;
declare variable ttypepay_id integer;
declare variable tdocrec_id integer;
declare variable ttypepdv_id integer;
declare variable tdocgoods_cnt integer;
declare variable tgoods_cnt integer;
declare variable tsum double precision;
declare variable tsum_pdv double precision;
declare variable tdoc_date date;
declare variable tdoc_lock smallint;
declare variable tinsum_pdv double precision;
declare variable puser_nik varchar(3);
declare variable plastcheck integer;
declare variable plast_doc_num varchar(14);
declare variable pdiscont_id integer;
declare variable pdisc_persent double precision;
declare variable ttypepdv_pdv double precision;
declare variable poplata_type smallint;
declare variable pdocrec_id integer;
declare variable prest double precision;
declare variable pnomen_name varchar(40);
declare variable pnomen_code varchar(7);
begin
  oenabled = 1;
  select d.typedoc_id, d.doc_num, d.disc_persent, d.clients_id, d.objects_id,
         d.oplata_type, d.doc_date, d.doc_lock, d.discont_id, d.oplata_type
    from documents d
   where d.document_id = :idocument_id
    into ttypedoc_id, tdoc_num, tdiscount, tclient_id, tobject_id,
         ttypepay_id, tdoc_date, tdoc_lock, pdiscont_id, poplata_type;

  if ((:ttypedoc_id in (1)) and (:itypedoc_id = 17)) then
  begin
    odocument_id = gen_id(gen_documents_id, 1);

    select odoc_num from ps_document_number
    into :tlast_doc_num;

    insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
        doc_lock, user_name, blok, clients_id, disc_persent, oplata_type, oplata_state)
      values (:odocument_id, :tlast_doc_num, :tdoc_num, 'today', :itypedoc_id, :tclient_id,
        0, user, 0, :tobject_id, :tdiscount, :ttypepay_id, 0);

    tdiscount = null;
    for select dr.nomen_id, dr.kilk, dr.price, dr.disc_persent, dg.goods_id, dr.typepdv_id
                from docrec dr, docgoods dg
        where dr.document_id = :idocument_id and
              dr.docrec_id = dg.docrec_id
      into :tnomen_id, :tkilk, :tprice, :tdiscount, :tgoods_id, :ttypepdv_id
    do begin
      tdocrec_id = GEN_ID(GEN_DOCREC_ID,1);
      insert into docrec(docrec_id, document_id, nomen_id, kilk, price, disc_persent, typepdv_id, typepdv_pdv)
        values (:tdocrec_id, :odocument_id, :tnomen_id, :tkilk, :tprice, :tdiscount, :ttypepdv_id, 0);
      insert into docgoods(goods_id, kilk, docrec_id)
         values (:tgoods_id, :tkilk, :tdocrec_id);
      update goods g
          set g.goods_rest = g.goods_rest - :tkilk
        where g.goods_id = :tgoods_id;
      tdiscount = null;
      execute procedure s_sliv_minusov(1, :tnomen_id);
    end
   -- execute procedure ps_document_ins_or_upd_td16(:idocument_id);
  end  else

  if ((:ttypedoc_id in (1)) and (:itypedoc_id = 4)) then
  begin
    update documents d
        set d.typedoc_id = 4
      where d.document_id = :idocument_id;
    odocument_id = :idocument_id;
  end  else

  if ((:ttypedoc_id in (4)) and (:itypedoc_id = 1)) then
  begin
    update documents d
        set d.typedoc_id = 1
      where d.document_id = :idocument_id;

    for select dr.docrec_id, dr.kilk, dr.price, dr.nomen_id from docrec dr
        where dr.document_id = :idocument_id
      into :tdocrec_id, :tkilk, :tprice, :tnomen_id
    do begin
      select count(dg.docgoods_id) from docgoods dg
          where dg.docrec_id = :tdocrec_id
        into :tdocgoods_cnt;
      if ((:tdocgoods_cnt = 0) or (:tdocgoods_cnt is null)) then
      begin
        tgoods_id = gen_id(gen_goods_id, 1);
        insert into goods (goods_id, nomen_id, clients_id, objects_id, goods_rest, goods_inprice)
          values (:tgoods_id, :tnomen_id, 100, 1, :tkilk, :tprice);
        insert into docgoods(goods_id, docrec_id, kilk, inprice)
          values(:tgoods_id, :tdocrec_id, :tkilk, :tprice);
      end
      tdocgoods_cnt = null;
    end
    odocument_id = :idocument_id;
  end else

  if ((:ttypedoc_id in (2)) and (:itypedoc_id = 11)) then
  begin
    update documents d
        set d.typedoc_id = 11
      where d.document_id = :idocument_id;

    update docrec dr
       set dr.price = around(dr.price)
     where dr.document_id = :idocument_id;

    odocument_id = :idocument_id;
  end  else

  if ((:ttypedoc_id in (2)) and (:itypedoc_id = 10000)) then
  begin
    select d.clients_id, d.disc_persent from documents d
       where d.document_id = :idocument_id
     into :tclient_id, :tdiscount;

    select DRS.SUM_OUT, DRS.SUM_OUT_PDV
        from S_DOCREC_SUM(:idocument_id, :tdiscount) DRS
    INTO :tsum, :tsum_pdv;

    insert into t_pacts (client_id, document_id, pact_sum, pact_sum_pdv)
       values (:tclient_id, :idocument_id, :tsum, :tsum_pdv);

    odocument_id = :idocument_id;
  end else

  if ((:ttypedoc_id in (2)) and (:itypedoc_id = 2)) then
  begin
    odocument_id = gen_id(gen_documents_id, 1);

    select odoc_num from ps_document_number
      into :tlast_doc_num;

    insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
        doc_lock, user_name, blok, clients_id, disc_persent, oplata_type, oplata_state)
      values (:odocument_id, :tlast_doc_num, :tdoc_num, :tdoc_date, :itypedoc_id, :tobject_id,
        0, user, 0, :tclient_id, :tdiscount, :ttypepay_id, 0);

    tdiscount = null;
    for select dr.nomen_id, dr.kilk, dr.price, dr.disc_persent, dr.typepdv_id
                from docrec dr
        where dr.document_id = :idocument_id
      into :tnomen_id, :tkilk, :tprice, :tdiscount, :ttypepdv_id
    do begin
      select odocrec_id from PS_DOCREC_TD2_INS(:odocument_id, :tnomen_id, :tkilk, :tprice, :tdiscount)
        into tdocrec_id;

      tdiscount = null;
    end

  end else

  if ((:ttypedoc_id in (11, 10)) and (:itypedoc_id = 2)) then
  begin
    for select dr.nomen_id, dr.kilk
          from docrec dr
         where dr.document_id = :idocument_id
          into tnomen_id, tkilk
    do begin
      select count(g.goods_id) from goods g
          where nomen_id = :tnomen_id
        into tgoods_cnt;
      if (:tgoods_cnt = 0) then
      begin
        oenabled = 0;
        omessage = 'На один, чи кілька записів не було приходів.';
      end

      if (:ttypedoc_id = 10) then
      begin
        select r.rest
          from rst r
         where r.nomen_id = :tnomen_id
          into :prest;

        if (:prest < :tkilk) then
        begin
          oenabled = 0;
          select n.nomen_name, n.nomen_code
            from nomen n
           where n.nomen_id = :tnomen_id
            into pnomen_name, pnomen_code;
          omessage = 'Недостатній залишок товару: ' || :pnomen_name || ' (Код: ' || :pnomen_code || ').';
        end
      end

      tgoods_cnt = null;
    end

    if (:oenabled <> 0) then
    begin
      update documents d
          set d.typedoc_id = 2
        where d.document_id = :idocument_id;
    end
    odocument_id = :idocument_id;
  end else

  if ((:ttypedoc_id in (2, 11)) and (:itypedoc_id = 4)) then
  begin
  /*-- Створення повернення від покупця --*/
    if ((:ttypedoc_id = 2)and(:tdoc_lock < 1)) then
      begin
        oenabled = 0;
        omessage = 'Потрібно зафіксувати дану розхідну накладну.';
      end

    if (:oenabled <> 0) then
    begin
      if (:tdoc_num is not null) then
      begin
        odocument_id = gen_id(gen_documents_id, 1);

        select u.nick, u.last_doc
          from t_users u
         where upper(u.user_login) = user
          into :puser_nik, :plastcheck;

        if (:puser_nik is null) then
        begin
          puser_nik = 'Sys';
          plastcheck = 0;
        end

        update t_users u
           set u.last_doc = :plastcheck + 1
         where upper(u.user_login) = user;

        plast_doc_num = gendocnum(:puser_nik, :plastcheck);

        insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
            doc_lock, user_name, blok, clients_id, disc_persent, discont_id, oplata_type)
        values (:odocument_id, :plast_doc_num, :tdoc_num, 'today', 4, :tclient_id,
            0, user, 0, object(), :tdiscount, :pdiscont_id, :poplata_type);

        pdisc_persent = null;
        for select dr.nomen_id, dr.kilk, dr.price, dr.disc_persent, dr.typepdv_id,
                   dr.typepdv_pdv, dr.insum_pdv, dr.docrec_id
              from docrec dr
             where dr.document_id = :idocument_id
              into tnomen_id, tkilk, tprice, pdisc_persent, ttypepdv_id,
                   ttypepdv_pdv, tinsum_pdv, tdocrec_id
        do begin
            pdocrec_id = gen_id(gen_docrec_id, 1);
            insert into docrec(docrec_id, document_id, nomen_id, kilk, price, disc_persent,
                               typepdv_id, typepdv_pdv)
                values (:pdocrec_id, :odocument_id, :tnomen_id, :tkilk, :tprice, :pdisc_persent,
                              :ttypepdv_id, :ttypepdv_pdv);

            tgoods_id = GEN_ID(GEN_GOODS_ID,1);
            insert into goods(goods_id, nomen_id, objects_id, clients_id, goods_rest, goods_inprice)
                values (:tgoods_id, :tnomen_id, 1, :tclient_id, 0.00, (:tinsum_pdv / :tkilk));

            insert into docgoods (docrec_id, goods_id, kilk)
                values (:pdocrec_id, :tgoods_id, 0.00);
        pdisc_persent = null;
        end
      end
    end
  end else

  if ((:ttypedoc_id = 1) and (:itypedoc_id = 2)) then
  begin
  /*-- Створення розхідної на основі прихідної --*/
    odocument_id = gen_id(gen_documents_id, 1);

    select odoc_num from ps_document_number
      into :tlast_doc_num;

    insert into documents(document_id, doc_num, doc_mark, doc_date, typedoc_id, objects_id,
        doc_lock, user_name, blok, clients_id, disc_persent, oplata_type, oplata_state)
      values (:odocument_id, :tlast_doc_num, :tdoc_num, :tdoc_date, :itypedoc_id, :tclient_id,
        0, user, 0, :tobject_id, :tdiscount, :ttypepay_id, 0);

    tdiscount = null;
    for select dr.nomen_id, dr.kilk, dr.price, dr.disc_persent, dr.typepdv_id
          from docrec dr
         where dr.document_id = :idocument_id
      into :tnomen_id, :tkilk, :tprice, :tdiscount, :ttypepdv_id
    do begin
      select odocrec_id from PS_DOCREC_TD2_INS(:odocument_id, :tnomen_id, :tkilk, :tprice, :tdiscount)
        into tdocrec_id;

      tdiscount = null;
    end

  end else

  if (:odocument_id is null) then
  begin
    odocument_id = 0;
    oenabled = 0;
    omessage = 'Дана маніпуляція неможлива з даним документом.';
  end

  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_DEL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable TSUMA integer;
begin
  tsuma = 0;

  ocaption = 'записів в документі';
  select count(dr.docrec_id) from docrec dr
   where dr.document_id = :idocument_id
    into ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  ocaption = 'надруковано податкових';
  select count(r.reestr_id) from reestr r
   where r.document_id = :idocument_id
    into ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_doc_prop
     where document_id = :idocument_id;

    delete from documents d
     where d.document_id = :idocument_id;
  end
end^


ALTER PROCEDURE PS_DOCUMENT_FIX (
    DOCUMENT_ID INTEGER)
AS
declare variable PNOMEN_ID integer;
declare variable POBJECTS_ID integer;
declare variable PCLIENTS_ID integer;
declare variable PSTAFF_ID integer;
declare variable KILK double precision;
declare variable DOCREC_ID integer;
declare variable P_GOODS_ID integer;
declare variable P_DOCGOODS_ID integer;
declare variable IN_KILK double precision;
declare variable P_TYPEDOC_ID integer;
declare variable FLAG integer;
declare variable PRICE double precision;
declare variable DISC_PERCENT double precision;
declare variable PMARKER varchar(64);
begin
  select d.typedoc_id, d.objects_id, d.clients_id, d.staff_id, absrizn(d.doc_lock, 1)
    from documents d
   where d.document_id=:document_id
    into p_typedoc_id, pobjects_id, pclients_id, pstaff_id, flag;

  if (flag in (0, 1)) then begin
   if (:p_typedoc_id not in (11)) then begin
/*    if ((:p_typedoc_id = 2) and (:flag = 1)) then
     if (:pstaff_id is null) then
      flag = 0;*/
    update documents d
       set d.doc_lock = :flag
     where d.document_id = :document_id;
   end
  end

  if (:p_typedoc_id in (1, 4, 7) and ((:flag = 1) or (:flag = 2))) then
  begin
    for select dr.docrec_id, dr.kilk, dr.nomen_id
          from docrec dr
         where dr.document_id = :document_id
          into :docrec_id, :kilk, :pnomen_id
    do begin
      select dg.goods_id, dg.docgoods_id, dg.kilk
        from docgoods dg
       where dg.docrec_id = :docrec_id
        into :p_goods_id, :p_docgoods_id, :in_kilk;

      kilk= :kilk - :in_kilk;

      update goods g
         set g.goods_rest = g.goods_rest+:kilk,
             g.clients_id = :pobjects_id
       where g.goods_id   = :p_goods_id;

      update docgoods dg
         set dg.kilk        = dg.kilk+:kilk
       where dg.docgoods_id = :p_docgoods_id;

      execute procedure s_sliv_minusov(1, :pnomen_id);
    end
    if (:p_typedoc_id in (7)) then
        execute procedure ps_document_ins_or_upd_td16(:document_id);
/*$$IBEC$$     if ((:flag = 2)and(:p_typedoc_id in (1))) then
        execute procedure ps_document_ins_or_upd_td16(:document_id); $$IBEC$$*/
  end

  select marker from t_configs c
   where c.module = 'store_documents' and
         c.config_id = 2
    into pmarker;

  if ((:pmarker != 'no')and(:p_typedoc_id = 10)) then
  begin
    if  ((:flag = 1)or(:flag = 2)) then
    begin
      for select dr.docrec_id, dr.kilk, dr.price, dr.disc_persent
            from docrec dr
           where dr.document_id = :document_id
            into docrec_id, kilk, price, disc_percent
      do begin
        select okilk from  PS_DOCREC_TD2_UPD (:docrec_id, :kilk, :price, :disc_percent)
          into kilk;
      end
    end else
    if (:flag = 0) then
    begin
      for select dr.docrec_id
            from docrec dr
           where dr.document_id = :document_id
            into docrec_id
      do begin
        for select dg.goods_id, dg.kilk from docgoods dg
             where dg.docrec_id = :docrec_id
              into p_goods_id, kilk
        do begin
          update goods g
             set g.goods_rest = g.goods_rest + :kilk
           where g.goods_id = :p_goods_id;
        end
        delete from docgoods dg
         where dg.docrec_id = :docrec_id;
      end
    end
  end

end^


ALTER PROCEDURE PS_DOCUMENT_INFO (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
declare variable tdocument_id integer;
declare variable tdoc_num varchar(14);
declare variable tdoc_mark varchar(14);
declare variable tdoc_date varchar(20);
declare variable tobject_id integer;
declare variable tobject_name varchar(50);
declare variable tclient_id integer;
declare variable tclient_name varchar(50);
begin
  select d.document_id, d.doc_num, d.doc_mark, d.doc_date, d.objects_id, d.clients_id  from documents d
      where d.document_id = :idocument_id
    into :tdocument_id, :tdoc_num, :tdoc_mark, :tdoc_date, :tobject_id, :tclient_id;

  odescript = 'Внутрішній код (id): ' || tdocument_id;
  suspend;

  odescript = 'Номер: ' || tdoc_num;
  suspend;

  odescript = 'Примітка: ' || tdoc_mark;
  suspend;

  odescript = 'Дата: ' || tdoc_date;
  suspend;

  select c.name from clients c
      where c.clients_id = :tobject_id
    into :tobject_name;
  odescript = 'Від кого: ' || tobject_name;
  suspend;

  select c.name from clients c
      where c.clients_id = :tclient_id
    into :tclient_name;
  odescript = 'Кому: ' || tclient_name;
  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_INS (
    ITOKEN VARCHAR(14),
    IDOC_NUM VARCHAR(14),
    IDOC_DATE DATE,
    ICLIENT_ID INTEGER,
    IOBJECT_ID INTEGER,
    ILIABLE_ID INTEGER,
    IPERSENT DOUBLE PRECISION,
    ITYPEDOC_ID INTEGER,
    ITYPEPAY_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER)
AS
begin
  odocument_id = GEN_ID(GEN_DOCUMENTS_ID,1);

  insert into documents (blok, doc_lock, document_id, doc_num, doc_date, doc_mark, clients_id,
        objects_id, staff_id, disc_persent, typedoc_id, oplata_type)
                 values (0, 0, :odocument_id, :idoc_num, :idoc_date, :itoken, :iclient_id,
       :iobject_id, :iliable_id, :ipersent, :itypedoc_id, :itypepay_id);
  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_INS_OR_UPD_TD16 (
    IDOCUMENT_ID INTEGER)
AS
declare variable pmarker varchar(64);
declare variable pdoc_lock smallint;
declare variable pout_doc_id integer;
declare variable pdoc_date date;
declare variable pgoods_id integer;
declare variable pgoods_rest double precision;
declare variable pnomen_id integer;
declare variable pmgoods_id integer;
declare variable pmgoods_rest double precision;
declare variable pgoods_inprice double precision;
declare variable pmgoods_inprice double precision;
declare variable pdocrec_id integer;
declare variable pdelta_kilk double precision;
declare variable ptypepdv_id integer;
declare variable ptypepdv_pdv double precision;
declare variable pdocgoods_id integer;
begin
  select c.marker from t_configs c
   where c.module = 'store_general' and
         c.config_id = 5
    into pmarker;
  if (:pmarker = 'td16') then
  begin
  /* Загальні налаштування */
    select d.doc_lock, d.doc_date
      from documents d
     where d.document_id = :idocument_id
      into pdoc_lock, pdoc_date;

  begin
/*Знаходження/Створення корегуючої*/
  select d.document_id from documents d
   where d.prew_document_id = :idocument_id and
         d.clients_id = 95
    into pout_doc_id;
  if (:pout_doc_id is null) then
  begin
  /* створення розхідної коригуючої */
    select dc.rdocument_id from s_doc_create(16) dc into :pout_doc_id;
    update documents d
       set d.objects_id  = 1,
           d.clients_id  = 95,
           d.doc_date    = :pdoc_date,
           d.blok        = 1,
           d.doc_lock    = 2,
           d.oplata_type = 3,
           d.prew_document_id = :idocument_id
     where d.document_id=:pout_doc_id;
    end
  end

    if (:pdoc_lock > 0) then
    begin
    /*Створення записів*/
      for select g.goods_id, g.goods_rest, g.nomen_id, g.goods_inprice
            from docrec dr
                 left join docgoods dg on dg.docrec_id = dr.docrec_id
                 left join goods g on g.goods_id = dg.goods_id
           where dr.document_id = :idocument_id and
                 g.goods_rest > 0
            into pgoods_id, pgoods_rest, pnomen_id, pgoods_inprice
    do begin
      select tp.typepdv_id, tp.pdv
        from nomen n left join typepdv tp on tp.typepdv_id = n.typepdv_id
       where n.nomen_id = :pnomen_id
        into ptypepdv_id, ptypepdv_pdv;

      for select g.goods_id, g.goods_rest, g.goods_inprice from goods g
           where g.nomen_id   = :pnomen_id and
                 g.objects_id = 1          and
                 g.goods_id   < :pgoods_id and
                 g.goods_rest < 0
        order by goods_id
            into pmgoods_id, pmgoods_rest, pmgoods_inprice
      do begin
        if (:pgoods_rest > 0) then
        begin
          pdelta_kilk = (-1) * :pmgoods_rest;
          if (:pdelta_kilk > :pgoods_rest) then
            pdelta_kilk = :pgoods_rest;

          begin
          pdocrec_id = gen_id(gen_docrec_id, 1);
          insert into docrec (docrec_id, document_id, nomen_id, kilk, price, disc_persent, typepdv_id, typepdv_pdv)
            values(:pdocrec_id, :pout_doc_id, :pnomen_id, 0.0, :pgoods_inprice, 0.0, :ptypepdv_id, :ptypepdv_pdv);
          /*Корегуємо мінусовий гудс*/
          insert into docgoods (goods_id, docrec_id, kilk)
            values(:pmgoods_id, :pdocrec_id, -:pdelta_kilk);
          update goods g
             set g.goods_rest = g.goods_rest + :pdelta_kilk
           where g.goods_id = :pmgoods_id;
          /*Корегуємо додатній гудс*/
          insert into docgoods (goods_id, docrec_id, kilk)
            values(:pgoods_id, :pdocrec_id, :pdelta_kilk);
          update goods g
             set g.goods_rest = g.goods_rest - :pdelta_kilk
           where g.goods_id = :pgoods_id;
          end
          pgoods_rest = :pgoods_rest - :pdelta_kilk;
        end
      end
    end
    end else
    if (:pdoc_lock = 0) then
    begin
    /*Видалення записів*/
      for select dg.docgoods_id, dg.goods_id, dg.kilk
            from docrec dr
                 left join docgoods dg on dr.docrec_id = dg.docrec_id
           where dr.document_id = :pout_doc_id
            into pdocgoods_id, pgoods_id, pdelta_kilk
      do begin
        update goods g
           set g.goods_rest = g.goods_rest + :pdelta_kilk
         where g.goods_id = :pgoods_id;
        delete from docgoods dg
         where dg.docgoods_id  = :pdocgoods_id;
      end

      delete from docrec dr
       where dr.document_id = :pout_doc_id;
    end
  end
end^


ALTER PROCEDURE PS_DOCUMENT_LIKE_TYPES (
    ITYPEDOC_ID INTEGER)
RETURNS (
    OID INTEGER,
    ONAME VARCHAR(40))
AS
begin
  if (itypedoc_id = 1) then
  begin
    oid = 4;
    oname = 'Перетворити в повернення від покупця.';
    suspend;
    oid = 17;
    oname = 'Створити повернення постачальнику.';
    suspend;
    oid = 2;
    oname = 'Створити розхідну накладну.';
    suspend;
  end
  if (itypedoc_id = 4) then
  begin
    oid = 1;
    oname = 'Перетворити в прихідну.';
    suspend;
  end
  if (itypedoc_id = 2) then
  begin
    oid = 11;
    oname = 'Перетворити в чек.';
    suspend;
    oid = 2;
    oname = 'Клонувати накладну.';
    suspend;
    oid = 10000;
    oname = 'Створити договір.';
    suspend;
  end
  if (itypedoc_id in (10, 11)) then
  begin
    oid = 2;
    oname = 'Перетворити в розхідну.';
    suspend;
  end
  if (itypedoc_id in (2, 11)) then
  begin
    oid = 4;
    oname = 'Створити повернення від покупця.';
    suspend;
  end
end^


ALTER PROCEDURE PS_DOCUMENT_NUMBER
RETURNS (
    ODOC_NUM VARCHAR(14))
AS
DECLARE VARIABLE TDOCNUM INTEGER;
DECLARE VARIABLE TUSER_NIK VARCHAR(4);
begin
  select u.nick, u.last_doc from t_users u
    where upper(u.user_login) = user
  into :tuser_nik, :tdocnum;

  if (:tuser_nik is null) then
  begin
    tuser_nik = 'sys';
    select count(d.document_id) from documents d
      where d.user_name = user
    into :tdocnum;
  end
  if (:tuser_nik is not null) then
  begin
    update t_users u
      set u.last_doc = :tdocnum + 1
    where upper(u.user_login) = user;
  end

  odoc_num = gendocnum(:tuser_nik, :tdocnum);

  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_RECORD_VIEW (
    IDOCREC_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26))
AS
declare variable tdocument_id integer;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable tdisc_persent double precision;
declare variable ttypedoc_id integer;
declare variable p_nomen_pdv integer;
declare variable textra_sum double precision;
declare variable p_sum_in double precision;
declare variable tgrp_id integer;
begin
  select dr.document_id from docrec dr
   where dr.docrec_id = :idocrec_id
    into tdocument_id;

  select d.disc_persent, d.typedoc_id from documents d
   where d.document_id = :tdocument_id
    into tdisc_persent, ttypedoc_id;

 select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price,
        dr.kilk, tp.typepdv_id, tp.pdv, '('||cast(cast(tp.pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name,
        dr.typepdv_id, dr.typepdv_pdv, n.out_price,
        dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.grp_id, n.datex_name
   from docrec dr, nomen n, typepdv tp
  where dr.docrec_id  = :idocrec_id and
        dr.nomen_id   = n.nomen_id  and
        tp.typepdv_id = dr.typepdv_id
  order by dr.docrec_id
   into odocrec_id, onomen_id, onomen_code, onomen_name, ogeneral_price,
        okilk, p_typepdv_id, p_typepdv_pdv, otype_pdv,
        otypepdv_id, otypepdv_pdv, onomen_price,
        odisc_persent, p_nomen_pdv, osum_in_pdv, osum_in, tgrp_id, oshort_name;

  p_sum_in = :osum_in_pdv;
  osum_pdv = 0.000;
  osum_out = 0.000;
  oout_price = 0.000;
  textra_sum = 0.000;
/*  extra_p = 0.000; */

  osum_in_pdv = absrizn(0, :osum_in_pdv);
  osum_in = absrizn(0, :osum_in);

  select g.grp_name from grp g
   where g.grp_id = :tgrp_id
    into ogrp_name;

  if (:odisc_persent is null) then
  begin
    odisc_persent = :tdisc_persent;
  end

  select oprice_pdv, osum_pdv from ps_get_sum(:odocrec_id, :tdisc_persent, :odisc_persent)
    into oout_price_pdv, osum_out_pdv;

  if (:okilk <> 0) then
  begin
    p_in_price = :osum_in / :okilk;
    textra_sum = :osum_out_pdv - :osum_in_pdv;

    osum_out = calcsum(:osum_out_pdv, :textra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

    oout_price = :osum_out / :okilk;
    osum_pdv   = :osum_out_pdv - :osum_out;
  end /* if (kilk<>0) then */
  else begin
    oout_price   = null;
    osum_out     = null;
    otype_pdv    = null;
    osum_pdv     = null;
    osum_out_pdv = null;
    textra_sum   = null;
  end /* if (kilk<>0) else */
  odisc_persent = :odisc_persent * 100;

  suspend;

end^


ALTER PROCEDURE PS_DOCUMENT_RECORD_VIEW_V1 (
    IDOCREC_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OLAST_INPRICE DOUBLE PRECISION,
    OAVG_MARKUP DOUBLE PRECISION,
    OOUT_PRICE_MARKUP DOUBLE PRECISION,
    ONOM_ID INTEGER)
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable tdisc_persent double precision;
declare variable ttypedoc_id integer;
declare variable p_nomen_pdv integer;
declare variable textra_sum double precision;
declare variable p_sum_in double precision;
declare variable tgrp_id integer;
declare variable pmax_goods_id integer;
declare variable pkilk double precision;
declare variable pgoods_rest double precision;
declare variable pgoods_kilk double precision;
declare variable pgoods_inprice double precision;
declare variable pdocument_id integer;
begin
  select d.disc_persent, d.typedoc_id, d.document_id
    from documents d join docrec dr on d.document_id = dr.document_id
   where dr.docrec_id = :idocrec_id
    into tdisc_persent, ttypedoc_id, pdocument_id;
  if (:tdisc_persent < 0) then tdisc_persent = 0;

     select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price,
            dr.kilk, tp.typepdv_id, tp.pdv, '('||cast(cast(tp.pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name,
            dr.typepdv_id, dr.typepdv_pdv, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.grp_id, n.datex_name
       from docrec dr
            join nomen n on (dr.nomen_id = n.nomen_id)
            join typepdv tp on (tp.typepdv_id = dr.typepdv_id)
      where dr.docrec_id = :idocrec_id
   --order by dr.docrec_id
       into odocrec_id, onomen_id, onomen_code, onomen_name, ogeneral_price,
            okilk, p_typepdv_id, p_typepdv_pdv, otype_pdv,
            otypepdv_id, otypepdv_pdv, onomen_price,
            odisc_persent, p_nomen_pdv, osum_in_pdv, osum_in, tgrp_id, oshort_name;

  osum_pdv   = 0.000;
  osum_out   = 0.000;
  oout_price = 0.000;
  textra_sum = 0.000;
/*  extra_p = 0.000; */

  osum_in_pdv = absrizn(0, :osum_in_pdv);
  osum_in = absrizn(0, :osum_in);

  select g.grp_name from grp g
   where g.grp_id = :tgrp_id
    into ogrp_name;

  if (:odisc_persent is null) then
  begin
    odisc_persent = :tdisc_persent;
  end

  select oprice_pdv, osum_pdv from ps_get_sum(:odocrec_id, :tdisc_persent, :odisc_persent)
    into oout_price_pdv, osum_out_pdv;

  if (:okilk <> 0) then
  begin
    textra_sum = :osum_out_pdv - :osum_in_pdv;

    osum_out = calcsum(:osum_out_pdv, :textra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

    oout_price = :osum_out/:okilk;
    olast_inprice = 0;
    select max(g.goods_id) from goods g
     where g.nomen_id = :onomen_id
      into pmax_goods_id;

    select g.goods_inprice from goods g
     where g.goods_id = :pmax_goods_id
      into olast_inprice;

    osum_pdv = :osum_out_pdv - :osum_out;

  end /* if (kilk<>0) then */
  else begin
   oout_price   = null;
   osum_out     = null;
   otype_pdv    = null;
   osum_pdv     = null;
   osum_out_pdv = null;
   textra_sum   = null;
/*   extra_p=null; */
  end /* if (kilk<>0) else */

  p_sum_in   = :osum_in_pdv;
  if (:ttypedoc_id = 10) then
  begin
    select sum(g.goods_rest) from goods g
     where g.nomen_id = :onomen_id and
           g.goods_rest > 0.001
      into pgoods_kilk;
    if ((:pgoods_kilk > :okilk)and(:okilk > 0.001)) then
    begin
      pkilk = :okilk;
      p_sum_in = 0.0;
      for select g.goods_rest, g.goods_inprice
            from goods g
           where g.nomen_id = :onomen_id and
                 g.goods_rest > 0
        order by g.goods_id desc
            into pgoods_rest, pgoods_inprice
      do begin
         if (:pkilk > 0.001) then
         begin
           p_sum_in = min2(:pgoods_rest, :pkilk) * :pgoods_inprice;
           pkilk = :pkilk - min2(:pgoods_rest, :pkilk);
         end
      end
    end else /*if ((:pgoods_kilk > :okilk)and(:okilk > 0.001)) then*/
      p_sum_in = :olast_inprice * :okilk;
  end
  if (:osum_out_pdv = 0) then
    oavg_markup = 0;
  else
    oavg_markup = (:osum_out_pdv - :p_sum_in)/:osum_out_pdv * 100;

  odisc_persent = :odisc_persent * 100;
  oout_price_markup = (:oout_price_pdv - :onomen_price)/:onomen_price * 100;
  select count(docrec_id) from docrec
   where document_id = :pdocument_id
    into onom_id;

  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_RECORDS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26))
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable tdisc_persent double precision;
declare variable ttypedoc_id integer;
declare variable p_nomen_pdv integer;
declare variable textra_sum double precision;
declare variable p_sum_in double precision;
declare variable tgrp_id integer;
begin
  select d.disc_persent, d.typedoc_id
    from documents d
   where d.document_id=:idocument_id
    into tdisc_persent, ttypedoc_id;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price, dr.kilk, tp.typepdv_id, tp.pdv,
            '('||cast(cast(tp.pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name,
            dr.typepdv_id, dr.typepdv_pdv, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.grp_id, n.datex_name
       from docrec dr, nomen n, typepdv tp
      where dr.document_id=:idocument_id and
            dr.nomen_id=n.nomen_id and
            tp.typepdv_id=dr.typepdv_id
      order by dr.docrec_id
       into odocrec_id, onomen_id, onomen_code, onomen_name, ogeneral_price, okilk, p_typepdv_id, p_typepdv_pdv,
            otype_pdv,
            otypepdv_id, otypepdv_pdv, onomen_price,
            odisc_persent, p_nomen_pdv, osum_in_pdv, osum_in, tgrp_id, oshort_name
 do begin
  p_sum_in = :osum_in_pdv;
  osum_pdv = 0.000;
  osum_out = 0.000;
  oout_price = 0.000;
  textra_sum = 0.000;
/*  extra_p = 0.000; */

  osum_in_pdv = absrizn(0, :osum_in_pdv);
  osum_in = absrizn(0, :osum_in);

  select g.grp_name from grp g
      where g.grp_id = :tgrp_id
    into :ogrp_name;


  if (:odisc_persent is null) then
  begin
    odisc_persent=:tdisc_persent;
  end

  select oprice_pdv, osum_pdv from ps_get_sum(:odocrec_id, :tdisc_persent, :odisc_persent)
    into oout_price_pdv, osum_out_pdv;

  if (:okilk<>0) then
  begin
    p_in_price = :osum_in/:okilk;
    textra_sum = :osum_out_pdv-:osum_in_pdv;

    osum_out   = calcsum(:osum_out_pdv, :textra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);
    oout_price = :osum_out / :okilk;
    osum_pdv   = :osum_out_pdv - :osum_out;

  end /* if (kilk<>0) then */
  else begin
   oout_price   = null;
   osum_out     = null;
   otype_pdv    = null;
   osum_pdv     = null;
   osum_out_pdv = null;
   textra_sum   = null;
  end /* if (kilk<>0) else */
  odisc_persent = :odisc_persent*100;
  suspend;
 end
end^


ALTER PROCEDURE PS_DOCUMENT_RECORDS_VIEW_V1 (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OLAST_INPRICE DOUBLE PRECISION,
    OAVG_MARKUP DOUBLE PRECISION,
    OOUT_PRICE_MARKUP DOUBLE PRECISION,
    ONOM_ID INTEGER)
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable tdisc_persent double precision;
declare variable ttypedoc_id integer;
declare variable p_nomen_pdv integer;
declare variable textra_sum double precision;
declare variable p_sum_in double precision;
declare variable tgrp_id integer;
declare variable pmax_goods_id integer;
declare variable pkilk double precision;
declare variable pgoods_rest double precision;
declare variable pgoods_kilk double precision;
declare variable pgoods_inprice double precision;
begin
  select d.disc_persent, d.typedoc_id
    from documents d
   where d.document_id = :idocument_id
    into tdisc_persent, ttypedoc_id;
  if (:tdisc_persent < 0) then tdisc_persent = 0;
  onom_id = 0;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price,
            dr.kilk, tp.typepdv_id, tp.pdv, '('||cast(cast(tp.pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name,
            dr.typepdv_id, dr.typepdv_pdv, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.grp_id, n.datex_name
       from docrec dr
            join nomen n on (dr.nomen_id = n.nomen_id)
            join typepdv tp on (tp.typepdv_id = dr.typepdv_id)
      where dr.document_id = :idocument_id
   order by dr.docrec_id
       into odocrec_id, onomen_id, onomen_code, onomen_name, ogeneral_price,
            okilk, p_typepdv_id, p_typepdv_pdv, otype_pdv,
            otypepdv_id, otypepdv_pdv, onomen_price,
            odisc_persent, p_nomen_pdv, osum_in_pdv, osum_in, tgrp_id, oshort_name
 do begin
  osum_pdv   = 0.000;
  osum_out   = 0.000;
  oout_price = 0.000;
  textra_sum = 0.000;
/*  extra_p = 0.000; */

  osum_in_pdv = absrizn(0, :osum_in_pdv);
  osum_in = absrizn(0, :osum_in);

  select g.grp_name from grp g
   where g.grp_id = :tgrp_id
    into ogrp_name;

  if (:odisc_persent is null) then
  begin
    odisc_persent = :tdisc_persent;
  end

  select oprice_pdv, osum_pdv from ps_get_sum(:odocrec_id, :tdisc_persent, :odisc_persent)
    into oout_price_pdv, osum_out_pdv;

  if (:okilk <> 0) then
  begin
    textra_sum = :osum_out_pdv - :osum_in_pdv;

    osum_out = calcsum(:osum_out_pdv, :textra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

    oout_price = :osum_out/:okilk;
    olast_inprice = 0;
    select max(g.goods_id) from goods g
     where g.nomen_id = :onomen_id
      into pmax_goods_id;

    select g.goods_inprice from goods g
     where g.goods_id = :pmax_goods_id
      into olast_inprice;

    osum_pdv = :osum_out_pdv - :osum_out;

  end /* if (kilk<>0) then */
  else begin
   oout_price   = null;
   osum_out     = null;
   otype_pdv    = null;
   osum_pdv     = null;
   osum_out_pdv = null;
   textra_sum   = null;
/*   extra_p=null; */
  end /* if (kilk<>0) else */

  p_sum_in   = :osum_in_pdv;
  if (:ttypedoc_id = 10) then
  begin
    select sum(g.goods_rest) from goods g
     where g.nomen_id = :onomen_id and
           g.goods_rest > 0.001
      into pgoods_kilk;
    if ((:pgoods_kilk > :okilk)and(:okilk > 0.001)) then
    begin
      pkilk = :okilk;
      p_sum_in = 0.0;
      for select g.goods_rest, g.goods_inprice
            from goods g
           where g.nomen_id = :onomen_id and
                 g.goods_rest > 0
        order by g.goods_id desc
            into pgoods_rest, pgoods_inprice
      do begin
         if (:pkilk > 0.001) then
         begin
           p_sum_in = min2(:pgoods_rest, :pkilk) * :pgoods_inprice;
           pkilk = :pkilk - min2(:pgoods_rest, :pkilk);
         end
      end
    end else /*if ((:pgoods_kilk > :okilk)and(:okilk > 0.001)) then*/
      p_sum_in = :olast_inprice * :okilk;
  end
  if (:osum_out_pdv = 0) then
    oavg_markup = 0;
  else
    oavg_markup = (:osum_out_pdv - :p_sum_in)/:osum_out_pdv * 100;

  odisc_persent = :odisc_persent * 100;

  oout_price_markup = (:onomen_price - (:oout_price * 1.2))/:onomen_price * 100;
  onom_id = :onom_id + 1;
  suspend;
 end
end^


ALTER PROCEDURE PS_DOCUMENT_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_docrec_id integer;
declare variable p_kilk double precision;
declare variable p_main_price double precision;
declare variable p_price_out_pdv double precision;
declare variable p_sum_out_pdv double precision;
declare variable p_sum_in_pdv double precision;
declare variable p_sum_in double precision;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_disc_persent double precision;
declare variable p_sum_disc_persent double precision;
declare variable p_count_rec integer;
begin
  /* procedure text */
 sum_out_pdv = 0.000;
 sum_out     = 0.000;
 sum_in_pdv  = 0.000;
 sum_in      = 0.000;
 if (:disc_persent is null) then disc_persent = 0.000;
 p_sum_disc_persent = 0.000;
 p_count_rec = 0;
 for select dr.docrec_id, dr.kilk, dr.price, dr.typepdv_id, dr.typepdv_pdv,
            dr.disc_persent, dr.insum_pdv, dr.insum
       from docrec dr
      where dr.document_id=:documents_id
       into p_docrec_id, p_kilk, p_main_price, p_typepdv_id, p_typepdv_pdv,
            p_disc_persent, p_sum_in_pdv, p_sum_in
 do begin
  if ((:p_disc_persent is null)or(:p_disc_persent=0.000)) then begin
    p_sum_disc_persent = :p_sum_disc_persent + :disc_persent;
   end
  else begin
    p_sum_disc_persent = :p_sum_disc_persent + :p_disc_persent;
   end

  p_count_rec = :p_count_rec + 1;

  select oprice_pdv, osum_pdv from ps_get_sum(:p_docrec_id, :disc_persent, :p_disc_persent)
    into p_price_out_pdv, p_sum_out_pdv;

  sum_in_pdv  = :sum_in_pdv  + :p_sum_in_pdv;
  sum_out_pdv = :sum_out_pdv + :p_sum_out_pdv;

  sum_in  = :sum_in  + :p_sum_in;
  sum_out = :sum_out + calcsum(:p_sum_out_pdv, :p_sum_out_pdv-:p_sum_in_pdv, :p_typepdv_pdv, :p_typepdv_id, 0);

 end
 if (:p_count_rec <> 0) then begin
   avg_disc_persent = (:p_sum_disc_persent / :p_count_rec);
  end
 else begin
  avg_disc_persent=:disc_persent;
 end
 suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_TD1_GRP_INS (
    IDOCUMENT_ID INTEGER,
    IGRP_ID INTEGER)
AS
declare variable PNOMEN_ID integer;
declare variable PREST double precision;
declare variable PLAST_INPRICE double precision;
declare variable PDOCREC_ID integer;
begin
 igrp_id = null;

   for select distinct n.nomen_id
         from autoorders ao
              join t_document_autoorder da on ao.autoorder_id = da.autoorder_id
              left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
              inner join nomen n on aor.aor_nomen_id = n.nomen_id
        where da.documents_id = :idocument_id and
              ((n.is_exist   = 1)or(n.is_exist is null))
         into pnomen_id
   do begin
      if (not(exists(select * from docrec dr where dr.document_id = :idocument_id and dr.nomen_id = :pnomen_id))) then
      begin
        select first(1) aor.aor_ordered
          from autoorders ao
               join t_document_autoorder da on ao.autoorder_id = da.autoorder_id
               join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where da.documents_id = :idocument_id and
               aor.aor_nomen_id = :pnomen_id
         order by aor.ao_record_id desc
          into prest;

        select first(1) g.goods_inprice from goods g
         where g.nomen_id = :pnomen_id
         order by g.goods_id desc
          into plast_inprice;

        select pd.odocrec_id from ps_docrec_td1_ins(:idocument_id, :pnomen_id, :prest, :plast_inprice, 0) pd
          into pdocrec_id;

      end
   end
end^


ALTER PROCEDURE PS_DOCUMENT_UNITE_INFO (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
DECLARE VARIABLE TDOCUMENT_ID VARCHAR(20);
DECLARE VARIABLE TDOC_NUM VARCHAR(14);
DECLARE VARIABLE TDOC_DATE VARCHAR(20);
DECLARE VARIABLE TDOC_MARK VARCHAR(27);
begin
  select d.document_id, d.doc_num, d.doc_date, d.doc_mark from documents d
      where d.document_id = :idocument_id
    into :tdocument_id, :tdoc_num, :tdoc_date, :tdoc_mark;

  odescript = 'ID: ' || tdocument_id;
  suspend;

  odescript = 'Дата: ' || tdoc_date;
  suspend;

  odescript = 'Номер: ' || tdoc_num;
  suspend;

  odescript = 'Примітка: ' || tdoc_mark;
  suspend;
end^


ALTER PROCEDURE PS_DOCUMENT_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    OIS_PRINT_TAX SMALLINT,
    OSTAFFNAME VARCHAR(40))
AS
declare variable p_disc_persent double precision;
declare variable p_clients_id integer;
declare variable p_objects_id integer;
declare variable p_staff_id integer;
declare variable tshow_tax smallint;
declare variable tshow_nakl smallint;
declare variable tmarker varchar(64);
begin
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module = 'store_documents'
    into tmarker;
  if (:tmarker = 'yes') then tshow_tax = 1; else tshow_tax = 0;

  select c.marker from t_configs c
   where c.config_id = 2 and
         c.module = 'store_documents'
    into tmarker;
  if (:tmarker = 'yes') then tshow_nakl = 1; else tshow_nakl = 0;

  select d.document_id, d.doc_num, d.doc_mark, d.doc_date, d.typedoc_id,
         d.clients_id, d.objects_id, d.doc_lock, d.staff_id,
         d.disc_persent, d.lock_date, d.oplata_state, d.oplata_type, d.time_cr,
         d.notarization, d.kards_id
    from documents d
   where d.document_id = :idocument_id
    into odocument_id, onumber, otoken, odate, otypedoc_id,
         p_clients_id, p_objects_id, ois_fixed, p_staff_id,
         p_disc_persent, odate_fix, ooplata_state, ooplata_type_id, otime_cr,
         onotarization, okards_id;
  if (:p_disc_persent < 0) then p_disc_persent = 0;

  select c.shortname, c.name
    from clients c
   where c.clients_id = :p_objects_id
    into osrc_name, osrc_fullname;
   select c.shortname, c.name
     from clients c
    where c.clients_id = :p_clients_id
     into odst_name, odst_fullname;

   if (:p_clients_id = 1) then
     oarrow = 0;
   if (:p_objects_id = 1) then
     oarrow = 1;

   if (:p_clients_id is null) then begin
    odst_name     = null;
    odst_fullname = null;
   end
   if (:p_objects_id is null) then begin
    osrc_name     = null;
    osrc_fullname = null;
   end

   if (tshow_tax = 1) then
   begin
     select count(r.reestr_id) from reestr r
         where r.document_id = :odocument_id
       into :ois_print_tax;
     ois_print_tax = min2(ois_print_tax, 1);
   end

   select drs.sum_out, drs.sum_out_pdv, drs.sum_in, drs.sum_in_pdv, (drs.avg_disc_persent*100)
     from s_docrec_sum(:odocument_id, :p_disc_persent) drs
     into osum_out, osum_out_pdv, osum_in, osum_in_pdv, odisc_persent;

  if (:p_staff_id is null) then
   ostaffname = '';
   else
  select s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
    from documents d, staff s
   where d.staff_id = s.staff_id and
         d.document_id = :odocument_id
    into ostaffname;

   suspend;
end^


ALTER PROCEDURE PS_DOCUMENTS_BY_NOMEN (
    INOMEN_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(10000),
    IPAYS VARCHAR(10000),
    IISPAYS VARCHAR(10000))
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OKARDS_ID INTEGER,
    OKILK DOUBLE PRECISION)
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_STAFF_ID INTEGER;
BEGIN
  FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.CLIENTS_ID, D.OBJECTS_ID, D.DOC_LOCK, D.STAFF_ID,
             D.DISC_PERSENT, D.OPLATA_STATE, D.OPLATA_TYPE,
             d.kards_id, dr.kilk
       from documents d, docrec dr
       where d.doc_date between :idate0 and :idate1 and
             dr.nomen_id = :inomen_id and
             dr.document_id = d.document_id and
             isinliststr(:itypes, d.typedoc_id) = 1 and
             isinliststr(:ipays, d.oplata_type) = 1 and
             isinliststr(:iispays, d.oplata_state) = 1
       INTO :odocument_id, :onumber, :otoken, :odate, :otypedoc_id,
            :P_CLIENTS_ID, :P_OBJECTS_ID, :ois_fixed, :P_STAFF_ID,
            :P_DISC_PERSENT, :ooplata_state, :ooplata_type_id,
            :okards_id, :okilk

  DO BEGIN
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_OBJECTS_ID
    into :osrc_name, :osrc_fullname;
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_CLIENTS_ID
    into :odst_name, :odst_fullname;

   IF (:P_CLIENTS_ID IS NULL) THEN BEGIN
    odst_name=NULL;
    odst_fullname=NULL;
   END
   IF (:P_OBJECTS_ID IS NULL) THEN BEGIN
    osrc_name=NULL;
    osrc_fullname=NULL;
   END

   SELECT DRS.SUM_OUT, DRS.SUM_OUT_PDV, DRS.SUM_IN, DRS.SUM_IN_PDV, (DRS.AVG_DISC_PERSENT*100)
    FROM S_DOCREC_SUM(:odocument_id, :P_DISC_PERSENT) DRS
    INTO :osum_out, :osum_out_pdv, :osum_in, :osum_in_pdv, :odisc_persent;

   SUSPEND;
   okards_id = NULL;
  END
END^


ALTER PROCEDURE PS_DOCUMENTS_DETAIL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ODOCREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OTYPE_PDV VARCHAR(45),
    OOUT_PRICE DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OGENERAL_PRICE DOUBLE PRECISION,
    ONOMEN_PRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OSHORT_NAME VARCHAR(26))
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable tdisc_persent double precision;
declare variable ttypedoc_id integer;
declare variable p_nomen_pdv integer;
declare variable textra_sum double precision;
declare variable p_sum_in double precision;
declare variable pall_discount_value double precision;
begin
  select d.disc_persent, d.typedoc_id
    from documents d
   where d.document_id = :idocument_id
    into tdisc_persent, ttypedoc_id;
  if (:tdisc_persent < 0) then tdisc_persent = 0;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price,
            dr.kilk, tp.typepdv_id, tp.pdv, '('||cast(cast(tp.pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name,
            dr.typepdv_id, dr.typepdv_pdv, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.datex_name
       from docrec dr
            right join nomen n on (dr.nomen_id = n.nomen_id)
            join typepdv tp on (dr.typepdv_id = tp.typepdv_id)
      where dr.document_id = :idocument_id
      order by dr.docrec_id
       into odocrec_id, onomen_id, onomen_code, onomen_name, ogeneral_price,
            okilk, p_typepdv_id, p_typepdv_pdv, otype_pdv,
            otypepdv_id, otypepdv_pdv, onomen_price,
            odisc_persent, p_nomen_pdv, osum_in_pdv, osum_in, oshort_name
 do begin

  p_sum_in = :osum_in_pdv;
  osum_pdv = 0.000;
  osum_out = 0.000;
  oout_price = 0.000;
  textra_sum = 0.000;
/*  extra_p = 0.000; */

/*$$IBEC$$   osum_in_pdv = absrizn(0, :osum_in_pdv);
  osum_in = absrizn(0, :osum_in); $$IBEC$$*/

  if ((:odisc_persent is null)or(:odisc_persent = 0)) then
  begin
    odisc_persent = :tdisc_persent;
  end

  select gs.osum_pdv, gs.oprice_pdv from ps_get_sum(:odocrec_id, :odisc_persent, :tdisc_persent) gs
    into osum_out_pdv, oout_price_pdv;

  if (:okilk <> 0) then
  begin
    p_in_price = :osum_in / :okilk;
    textra_sum = :osum_out_pdv - :osum_in_pdv;

    osum_out = calcsum(:osum_out_pdv, :textra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);
    oout_price = :osum_out / :okilk;
    osum_pdv = :osum_out_pdv - :osum_out;
  end /* if (kilk<>0) then */
  else begin
    oout_price   = null;
    osum_out     = null;
    otype_pdv    = null;
    osum_pdv     = null;
    osum_out_pdv = null;
    textra_sum   = null;
  end /* if (kilk<>0) else */
  odisc_persent = :odisc_persent * 100;
  suspend;
 end
end^


ALTER PROCEDURE PS_DOCUMENTS_PRICES (
    IDOCUMENT_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
declare variable p_last_date_upd date;
declare variable p_doc_date date;
declare variable pis_in_discount smallint;
declare variable pout_price double precision;
begin
/*$$IBEC$$   select cast(max(d.doc_date) as date) from documents d
   where d.document_id = :idocument_id
    into p_doc_date; $$IBEC$$*/

  for select n.nomen_id, n.nomen_code, n.nomen_name, n.out_price, n.is_in_discount, dr.price
        from docrec dr, nomen n
       where dr.document_id = :idocument_id and
             dr.nomen_id = n.nomen_id
        into nomen_id, nomen_code, nomen_name, out_price, pis_in_discount, pout_price
  do begin
/*$$IBEC$$     select cast(max(pj.date_time) as date)
      from pricejournal pj
     where pj.nomen_id=:nomen_id
      into p_last_date_upd;

    if (:p_last_date_upd is null) then p_last_date_upd='04.04.4004'; $$IBEC$$*/
    if (:pis_in_discount = 1) then
      begin
        is_check_disc = 1;
        is_check = 0;
      end else
      begin
        is_check_disc = 0;
        is_check = 1;
      end

    /*$$IBEC$$ if (:p_doc_date < :p_last_date_upd) then $$IBEC$$*/
    if (:pout_price between :out_price - 0.0001 and :out_price + 0.0001) then
    begin
      is_check_disc = 0;
      is_check = 0;
    end
    suspend;
  end
end^


ALTER PROCEDURE PS_DOCUMENTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(10000),
    IPAYS VARCHAR(10000),
    IISPAYS VARCHAR(10000))
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    OIS_PRINT_TAX SMALLINT,
    OSTAFFNAME VARCHAR(40),
    OCLIENTS_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OZKPO VARCHAR(20),
    OW3_CLIENTS_ID INTEGER)
AS
declare variable p_disc_persent double precision;
declare variable p_staff_id integer;
declare variable tshow_tax smallint;
declare variable tshow_nakl smallint;
declare variable tmarker varchar(64);
declare variable pobjects_zkpo varchar(20);
declare variable pclients_zkpo varchar(20);
declare variable pw3_client_id integer;
declare variable pw3_object_id integer;
begin
/*  if (:idate0 > '01.05.2008') then
    idate0 = '01.05.2008';
  */
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module = 'store_documents'
    into tmarker;
  if (:tmarker = 'yes') then tshow_tax = 1; else tshow_tax = 0;

  select c.marker from t_configs c
   where c.config_id = 2 and
         c.module = 'store_documents'
    into tmarker;
  if (:tmarker = 'yes') then tshow_nakl = 1; else tshow_nakl = 0;

  for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, d.typedoc_id,
             d.clients_id, d.objects_id, d.doc_lock, d.staff_id,
             d.disc_persent, d.lock_date, d.oplata_state, d.oplata_type, d.time_cr,
             d.notarization, d.kards_id
        from documents d
       where d.doc_date between :idate0 and :idate1 and
             isinliststr(:itypes, d.typedoc_id) = 1 and
             isinliststr(:ipays, d.oplata_type) = 1 and
             isinliststr(:iispays, d.oplata_state) = 1
        into odocument_id, onumber, otoken, odate, otypedoc_id,
             oclients_id, oobjects_id, ois_fixed, p_staff_id,
             p_disc_persent, odate_fix, ooplata_state, ooplata_type_id, otime_cr,
             onotarization, okards_id
  do begin
   if (:p_disc_persent < 0) then p_disc_persent = 0;
   select drs.sum_out, drs.sum_out_pdv, drs.sum_in, drs.sum_in_pdv, (drs.avg_disc_persent*100)
     from s_docrec_sum(:odocument_id, :p_disc_persent) drs
     into osum_out, osum_out_pdv, osum_in, osum_in_pdv, odisc_persent;

   select c.shortname, c.name, c.zkpo, c.w3_client_id from clients c
    where c.clients_id = :oobjects_id
     into osrc_name, osrc_fullname, pobjects_zkpo, pw3_object_id;

   select c.shortname, c.name, c.zkpo, c.w3_client_id from clients c
    where c.clients_id = :oclients_id
     into odst_name, odst_fullname, pclients_zkpo, pw3_client_id;

   if (:oclients_id = 1) then
   begin
     oarrow = 0;
     ozkpo = :pobjects_zkpo;
     ow3_clients_id = :pw3_object_id;
   end
   if (:oobjects_id = 1) then
   begin
     oarrow = 1;
     ozkpo = :pclients_zkpo;
     ow3_clients_id = :pw3_client_id;
   end

   if (:oclients_id is null) then begin
     odst_name     = null;
     odst_fullname = null;
   end
   if (:oobjects_id is null) then begin
     osrc_name     = null;
     osrc_fullname = null;
   end

   if (tshow_tax = 1) then
   begin
     select count(r.reestr_id) from reestr r
      where r.document_id = :odocument_id
       into ois_print_tax;
     ois_print_tax = min2(ois_print_tax, 1);
   end

  if (:p_staff_id is null) then
    ostaffname = '';
  else
    select s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
      from documents d, staff s
     where d.staff_id    = s.staff_id and
           d.document_id = :odocument_id
      into ostaffname;

   suspend;
   onotarization = null;
   okards_id     = null;
   ois_print_tax = null;
  end
end^


ALTER PROCEDURE PS_GET_ALL_SUMS (
    IDOCREC_ID INTEGER,
    IPERCENT0 DOUBLE PRECISION,
    IPERCENT1 DOUBLE PRECISION)
RETURNS (
    OSUM_PDV DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION,
    OIN_SUM_PDV DOUBLE PRECISION,
    OOUT_SUM_PDV DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
declare variable pdoc_lock smallint;
declare variable pkilk double precision;
declare variable pdoc_date date;
declare variable pnomen_id integer;
begin
  select osum_pdv, oprice_pdv from ps_get_sum(:idocrec_id, :ipercent0, :ipercent1)
    into osum_pdv, oprice_pdv;

 select d.doc_lock, d.doc_date, dr.kilk, dr.nomen_id
   from docrec dr join documents d on (d.document_id = dr.document_id)
  where dr.docrec_id = :idocrec_id
   into pdoc_lock, pdoc_date, pkilk, pnomen_id;

  if (:pdoc_lock > 0) then
  begin
    select oprice from ps_price_by_date(:pnomen_id, :pdoc_date)
      into oout_price;
    select oprice from ps_inprice_by_date(:pnomen_id, :pdoc_date)
      into oin_price;
    oin_sum_pdv  = pkilk * oin_price;
    oout_sum_pdv = pkilk * oout_price;
  end
  else begin
    oin_sum_pdv  = 0.0;
    oout_sum_pdv = 0.0;
  end
  suspend;
end^


ALTER PROCEDURE PS_GET_HAPPY_CHECK (
    ISUM DOUBLE PRECISION)
RETURNS (
    OUSED INTEGER)
AS
declare variable PID integer;
begin
  oused = 0;
  select first(1) hp.id from t_happy_check hp
   where hp.is_used = 0 and
         hp.happy_date = 'today' and
         cast((hp.happy_date + hp.happy_time) as timestamp) <= 'now'  and
         :isum between hp.happy_sum0 and hp.happy_sum1
    into pid;
  if (:pid is not null) then
  begin
    update t_happy_check hc
       set hc.is_used = 1
     where hc.id = :pid;
    oused = 1;
  end
  suspend;
end^


ALTER PROCEDURE PS_GET_ORDERED (
    IDOCUMENTS_ID INTEGER,
    INOMEN_ID INTEGER)
RETURNS (
    OAOR_ORDERED DOUBLE PRECISION,
    OIS_WEIGHT INTEGER,
    OKILK DOUBLE PRECISION,
    OCOUNT_NOT_AO_DOCREC INTEGER)
AS
declare variable PLAST_AUTOORDER_ID integer;
begin
  select max(ao.autoorder_id)
    from t_document_autoorder da
         inner join autoorders ao on ao.autoorder_id  = da.autoorder_id
         left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
   where aor.aor_nomen_id = :inomen_id and
         da.documents_id = :idocuments_id
    into plast_autoorder_id;

  select first(1) aor.aor_ordered, n.is_weight
    from autoorders ao
         join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         join nomen n on aor.aor_nomen_id = n.nomen_id
   where ao.autoorder_id = :plast_autoorder_id and
         aor.aor_nomen_id = :inomen_id
   order by aor.ao_record_id desc
    into oaor_ordered, ois_weight;

  if (:oaor_ordered is null) then oaor_ordered = 0.0;

  select sum(dr.kilk)
    from t_document_autoorder da
         inner join documents d on da.documents_id = d.document_id
         left join docrec dr on dr.document_id = d.document_id
   where da.autoorder_id = :plast_autoorder_id and
         da.documents_id != :idocuments_id and
         d.doc_lock != 0 and
         dr.nomen_id = :inomen_id
    into okilk;

  if (:okilk is null) then okilk = 0.0;

  okilk = :oaor_ordered - :okilk;
  if (:okilk < 0.00001) then okilk = 0.0;

  select count(dr.docrec_id)
    from docrec dr
         where dr.document_id = :idocuments_id and
               dr.nomen_id not in (select distinct aor.aor_nomen_id
                                     from t_document_autoorder da
                                          inner join ao_records aor on da.autoorder_id = aor.aor_autoorder_id
                                    where da.documents_id = :idocuments_id)
    into ocount_not_ao_docrec;
  if (:ocount_not_ao_docrec is null) then ocount_not_ao_docrec = 0;
  suspend;
end^


ALTER PROCEDURE PS_GET_SUM (
    IDOCREC_ID INTEGER,
    IPERCENT0 DOUBLE PRECISION,
    IPERCENT1 DOUBLE PRECISION)
RETURNS (
    OSUM_PDV DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION)
AS
declare variable PPRICE double precision;
declare variable PKILK double precision;
declare variable PALL_DISCOUNT_VALUE double precision;
declare variable PIS_IN_DISCOUNT smallint;
declare variable PTYPEDOC_ID integer;
begin
  if (:ipercent0 is null) then ipercent0 = 0.0;
  if (:ipercent1 is null) then ipercent1 = 0.0;

  select dr.kilk, (dr.price), dr.is_in_discount, d.typedoc_id
    from docrec dr
         inner join documents d on dr.document_id = d.document_id
   where dr.docrec_id = :idocrec_id
    into pkilk, pprice, pis_in_discount, ptypedoc_id;

  if (:pis_in_discount = 0) then
  begin
    ipercent0 = 0.0;
    ipercent1 = 0.0;
  end

  select sum(dp.sku_quantity * dp.discount_value)
    from t_dr_prop dp
   where dp.docrec_id = :idocrec_id
    into pall_discount_value;

  if (:pall_discount_value is null) then pall_discount_value = 0.0;
  osum_pdv = /*$$IBEC$$ around $$IBEC$$*/(calcpricepdv((:pkilk * :pprice - :pall_discount_value), :ipercent0, :ipercent1, 6));

  if (:pkilk = 0.0) then
    oprice_pdv = :pprice;
  else
    oprice_pdv = :osum_pdv / :pkilk;

  if (:ptypedoc_id in (4, 11)) then
    osum_pdv = around(:osum_pdv);

  suspend;
end^


ALTER PROCEDURE PS_GET_YESNO
RETURNS (
    ID INTEGER,
    NAME VARCHAR(10))
AS
begin
  id = 0; name = 'Ні';
  suspend;
  id = 1; name = 'Так';
  suspend;
end^


ALTER PROCEDURE PS_INPRICE_BY_DATE (
    INOMEN_ID INTEGER,
    IDATE DATE)
RETURNS (
    OPRICE DOUBLE PRECISION)
AS
begin

  select mr.in_price from t_markup_records mr
   where mr.markup_record_id = (select max(mr.markup_record_id) from t_markup_records mr
                                 where mr.date_upd <= :idate and mr.nomen_id = :inomen_id)
    into oprice;

  if (:oprice is null) then
   begin
     select goods_inprice from goods g
      where g.goods_id = (select max(g.goods_id) from goods g
                           where g.nomen_id = :inomen_id and
                                 g.doc_date <= :idate   and
                                 g.clients_id > 95 and      g.clients_id != 99)
       into oprice;

     if (:oprice is null) then oprice = 0.01;
   end
  suspend;
end^


ALTER PROCEDURE PS_KARD_DEL (
    IKARD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;

  ocaption = 'документів';
  select count(d.document_id) from documents d
      where d.kards_id = :ikard_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from kards k
      where k.kards_id = :ikard_id;
  end
end^


ALTER PROCEDURE PS_KARD_DETAIL (
    IKARD_ID INTEGER,
    ICOUNT INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOCNUM VARCHAR(14),
    OSUM_PDV NUMERIC(9,2),
    OPERCENT DOUBLE PRECISION,
    OIN_SUM_PDV NUMERIC(9,2),
    ODOC_DATE DATE)
AS
begin
  for select first(:icount) d.document_id, d.doc_num, d.disc_persent, d.doc_date
        from documents d
       where d.kards_id = :ikard_id
    order by d.document_id desc
        into odocument_id, odocnum, opercent, odoc_date
  do begin
    select sum(around(gs.osum_pdv)), sum(dr.insum_pdv)
      from docrec dr,
           ps_get_sum(dr.docrec_id, :opercent, dr.disc_persent) gs
     where dr.document_id = :odocument_id
      into osum_pdv, oin_sum_pdv;
    opercent = :opercent * 100;
    suspend;
  end
end^


ALTER PROCEDURE PS_KARD_INS (
    IDISCONT_ID INTEGER,
    ICLIENT_ID INTEGER,
    IKARDCODE VARCHAR(13),
    IKARD_NAME VARCHAR(50),
    IIS_BLOCK INTEGER)
RETURNS (
    OKARD_ID INTEGER)
AS
begin
  okard_id = GEN_ID(GEN_KARDS_ID,1);

  insert into kards (kards_id, clients_id, discont_id,  kardcode, name, is_block)
      values (:okard_id, :iclient_id, :idiscont_id, :ikardcode, :ikard_name, :iis_block);
  suspend;
end^


ALTER PROCEDURE PS_KARD_VIEW (
    IKARDS_ID INTEGER)
RETURNS (
    OKARDS_ID INTEGER,
    ODISCONT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OKARDCODE VARCHAR(13),
    OKAS_NAME VARCHAR(50),
    OIS_BLOCK SMALLINT,
    OSHORT_NAME VARCHAR(30),
    ONAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OPHONE VARCHAR(24),
    OPERCENT DOUBLE PRECISION,
    OEMAIL VARCHAR(60))
AS
begin
  select k.discont_id, k.clients_id, k.kardcode, k.name, k.is_block,
                c.shortname, c.name, c.adress, c.phone, c.email , d.procent
    from kards k, clients c, discont d
      where k.clients_id = c.clients_id and
            k.discont_id = d.discont_id and
            k.kards_id = :ikards_id
   into :odiscont_id, :oclients_id, :okardcode, :okas_name, :ois_block,
                :oshort_name, :oname, :oadress, :ophone, :oemail, :opercent;

  suspend;
end^


ALTER PROCEDURE PS_KARDS_VIEW
RETURNS (
    OKARDS_ID INTEGER,
    ODISCONT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OKARDCODE VARCHAR(13),
    OKAS_NAME VARCHAR(50),
    OIS_BLOCK SMALLINT,
    OSHORT_NAME VARCHAR(30),
    ONAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OPHONE VARCHAR(24),
    OPERCENT DOUBLE PRECISION,
    OEMAIL VARCHAR(60))
AS
begin
  for select k.kards_id, k.discont_id, k.clients_id, k.kardcode, k.name, k.is_block,
                c.shortname, c.name, c.adress, c.phone, c.email, d.procent
    from kards k, clients c, discont d
      where k.clients_id = c.clients_id and
            k.discont_id = d.discont_id
   into :okards_id, :odiscont_id, :oclients_id, :okardcode, :okas_name, :ois_block,
                :oshort_name, :oname, :oadress, :ophone, :oemail, :opercent
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_LC_DOC_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(10000),
    ODOCUMENT_ID INTEGER,
    ODELIV_ADDR_D VARCHAR(50),
    ODELIV_ADDR_S VARCHAR(50))
AS
DECLARE VARIABLE TCLIENT_ID INTEGER;
DECLARE VARIABLE TOBJECT_ID INTEGER;
DECLARE VARIABLE TAUTH_ID INTEGER;
DECLARE VARIABLE P_SUM_IN DOUBLE PRECISION;
DECLARE VARIABLE TPAY_TYPE_ID INTEGER;
DECLARE VARIABLE TT INTEGER;
DECLARE VARIABLE TTM VARCHAR(45);
begin
 odocument_id = :idocument_id;

 SELECT D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.OBJECTS_ID, D.CLIENTS_ID, D.STAFF_ID,
             D.lock_date, D.OPLATA_TYPE, d.auth_id
       FROM DOCUMENTS D
       WHERE D.DOCUMENT_ID=:idocument_id
       INTO :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :tobject_id, :tclient_id, :STAFF_ID,
            :LOCK_DATE, :TPAY_TYPE_ID, :tauth_id;

 if (:TPAY_TYPE_ID = 1) then OPLATA_TYPE='Готівка';
 if (:TPAY_TYPE_ID = 2) then OPLATA_TYPE='Перерахунок';
 if (:TPAY_TYPE_ID = 1) then DOC_TIP = 'готівка';
 if (:TPAY_TYPE_ID = 2) then DOC_TIP = 'з розрахункового рахунку';

 SELECT TD.TYPEDOC_NAME
      FROM TYPEDOC TD
      WHERE TD.TYPEDOC_ID=:TYPEDOC_ID
    INTO :TYPEDOC_NAME;

 otm = '';
 for select distinct '"' || m.maker_name || '" ' from docrec dr, nomen n, maker m
       where dr.nomen_id = n.nomen_id and
             n.maker_id = m.maker_id and
             dr.document_id = :idocument_id
   into :ttm
 do begin
   otm = :otm || :ttm;
 end

 SELECT SUM(DV.SUM_OUT), SUM(DV.SUM_OUT_PDV), SUM(DV.P_SUM_IN)
     FROM S_DOCREC_VIEW(:IDOCUMENT_ID) DV
     INTO :DOC_SUM, :DOC_SUMPDV, :P_SUM_IN;

 IF (P_SUM_IN IS NULL) THEN P_SUM_IN=0.000;
 IF (DOC_SUM IS NULL) THEN DOC_SUM=0.000;
 IF (DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
 if (NOT(/*around(*/P_SUM_IN/*)*/=0.000)) THEN
 DOC_PDV=0.000;
 DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
 DES_SUMDOC = decpart(around(:doc_sumpdv));
 OUT_SUMPDV = around(:doc_sumpdv);

 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director, deliv_addr
      from clients
      where CLIENTS_ID = :tobject_id
   into name_s, zkpo_s, ispdv_s, ipn_s, numpdv_s, adress_s, phone_s, SHORTNAME_S, tt, director_s, :odeliv_addr_s;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tobject_id
   into :oaccount_num_s, :obank_name_s, :omfo_s;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_s;

 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director, deliv_addr
       from clients
       where CLIENTS_ID = :tclient_id
      into name_d, zkpo_d, ispdv_d, ipn_d, numpdv_d, adress_d, phone_d, SHORTNAME_D, tt, director_d, :odeliv_addr_d;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tclient_id
   into :oaccount_num_d, :obank_name_d, :omfo_d;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_d;

 suspend;

end^


ALTER PROCEDURE PS_LC_DOCREC_PRINT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION,
    OLC_NOMEN_NAME VARCHAR(255),
    OGRP_NAME VARCHAR(40))
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable p_disc_persent double precision;
declare variable p_typedoc_id integer;
declare variable p_maker_id integer;
declare variable p_tara_id integer;
declare variable p_objects_id integer;
declare variable p_ispdv integer;
declare variable p_nomen_pdv integer;
declare variable p_in_sum double precision;
declare variable p_in_sum_vat double precision;
declare variable tgrp_id integer;
declare variable tmaker_id integer;
begin
 select d.disc_persent, d.typedoc_id, d.objects_id
  from documents d
  where d.document_id=:document_id
  into :p_disc_persent, :p_typedoc_id, :p_objects_id;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, around3(dr.price), dr.kilk, tp.typepdv_id, tp.pdv,
            '('||cast(cast(dr.typepdv_pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name, '', 1.00,
            s.si_name, dr.typepdv_id, dr.typepdv_pdv, n.is_weight, 1, 0, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum, n.grp_id, n.maker_id
      from docrec dr,
           nomen n,
           typepdv tp,
           si s
      where dr.document_id=:document_id and
            dr.nomen_id=n.nomen_id and
            tp.typepdv_id=dr.typepdv_id and
            s.si_id=n.si_id
      order by dr.docrec_id
      into :docrec_id, :nomen_id, :nomen_code, :nomen_name, :general_price, :kilk,
           :p_typepdv_id, :p_typepdv_pdv, :type_pdv, :packs, :in_pack,
           :si_name, :typepdv_id, :typepdv_pdv, :is_weight, :p_tara_id, :p_maker_id, :nomen_price,
           :disc_persent, :p_nomen_pdv, :p_in_sum_vat, :p_in_sum, :tgrp_id, :tmaker_id
 do begin
  p_sum_in=:p_in_sum_vat;
  sum_pdv=0.000;
  sum_out=0.000;
  out_price=0.000;
  extra_sum=0.000;
  extra_p=0.000;
  maker_name=null;
  p_in_sum_vat=absrizn(0, :p_in_sum_vat);
  p_in_sum=absrizn(0, :p_in_sum);

  select m.maker_name from maker m
        where m.maker_id = :tmaker_id
    into maker_name;
  olc_nomen_name = :nomen_name;
  if (:maker_name is not null) then
    olc_nomen_name = :nomen_name || ' тм ' || maker_name;

  select g.grp_name from grp g
        where g.grp_id = :tgrp_id
     into :ogrp_name;

  if (disc_persent is null) then begin
    disc_persent=:p_disc_persent;
   end

  select oprice_pdv, osum_pdv from ps_get_sum(:docrec_id, :p_disc_persent, :disc_persent)
    into out_price_pdv, sum_out_pdv;

  if (kilk<>0) then begin
   p_in_price=:p_in_sum/:kilk;
   extra_sum=:sum_out_pdv-:p_in_sum_vat;

   sum_out=calcsum(:sum_out_pdv, :extra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

   extra_sum=:sum_out-:p_in_sum;
   if (:extra_sum <> 0.000) then extra_p=(:extra_sum / :sum_out) * 100;

   out_price=:sum_out/:kilk;

  if (:p_typedoc_id=1) then begin
   if (:sum_out_pdv <> 0.000) then
   begin
      extra_sum=(:kilk*:nomen_price) - :sum_out_pdv;
      extra_p=(((:kilk*:nomen_price)*100)/:sum_out_pdv)-100;
   end
   else begin
     extra_sum = 0.000;
     extra_p = 0.000;
   end
  end

  sum_pdv=:sum_out_pdv-:sum_out;

  end /* if (kilk<>0) then */
  else begin
   out_price=null;
   sum_out=null;
   type_pdv=null;
   sum_pdv=null;
   sum_out_pdv=null;
   extra_sum=null;
   extra_p=null;
  end /* if (kilk<>0) else */
  disc_persent=:disc_persent*100;
  sumtov_pdv = null;
  if (:p_typepdv_id = 1) then
   begin
   sumtov_pdv =:sum_out;
   sum_out = null;
   end
   p_typepdv_id = -1;
  suspend;
 end
end^


ALTER PROCEDURE PS_LC_PACT_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(1000))
AS
DECLARE VARIABLE TCLIENT_ID INTEGER;
DECLARE VARIABLE TOBJECT_ID INTEGER;
DECLARE VARIABLE TAUTH_ID INTEGER;
DECLARE VARIABLE P_SUM_IN DOUBLE PRECISION;
DECLARE VARIABLE TPAY_TYPE_ID INTEGER;
DECLARE VARIABLE TT INTEGER;
DECLARE VARIABLE TTM VARCHAR(40);
begin
 select p.token, p.date_begin, p.date_end, p.document_id, p.month_sum, p.is_month_percent, p.pact_sum, p.pact_sum_pdv, p.client_id from t_pacts p
     where p.pact_id = :idocument_id
   into :otoken, :odate_begin, :odate_end, :idocument_id, :omonth_sum, :ois_month_percent, :doc_sum, :doc_sumpdv, :tclient_id;

 SELECT D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.OBJECTS_ID, /*D.CLIENTS_ID,*/ D.STAFF_ID,
             D.lock_date, D.OPLATA_TYPE, d.auth_id
       FROM DOCUMENTS D
       WHERE D.DOCUMENT_ID=:idocument_id
       INTO :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :tobject_id, /*:tclient_id,*/ :STAFF_ID,
            :LOCK_DATE, :TPAY_TYPE_ID, :tauth_id;

 if (:TPAY_TYPE_ID = 1) then OPLATA_TYPE='Готівка';
 if (:TPAY_TYPE_ID = 2) then OPLATA_TYPE='Перерахунок';
 if (:TPAY_TYPE_ID = 1) then DOC_TIP = 'готівка';
 if (:TPAY_TYPE_ID = 2) then DOC_TIP = 'з розрахункового рахунку';

 SELECT TD.TYPEDOC_NAME
      FROM TYPEDOC TD
      WHERE TD.TYPEDOC_ID=:TYPEDOC_ID
    INTO :TYPEDOC_NAME;

 otm = '';
 for select distinct '"' || m.maker_name || '" ' from docrec dr, nomen n, maker m
       where dr.nomen_id = n.nomen_id and
             n.maker_id = m.maker_id and
             dr.document_id = :idocument_id
   into :ttm
 do begin
   otm = :otm || :ttm;
 end

 IF (P_SUM_IN IS NULL) THEN P_SUM_IN=0.000;
 IF (DOC_SUM IS NULL) THEN DOC_SUM=0.000;
 IF (DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
 if (NOT(/*around(*/P_SUM_IN/*)*/=0.000)) THEN
 DOC_PDV=0.000;
 DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
 DES_SUMDOC = decpart(around(:doc_sumpdv));
 OUT_SUMPDV = around(:doc_sumpdv);
 
 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director
      from clients
      where CLIENTS_ID = :tobject_id
   into name_s, zkpo_s, ispdv_s, ipn_s, numpdv_s, adress_s, phone_s, SHORTNAME_S, tt, director_s;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tobject_id
   into :oaccount_num_s, :obank_name_s, :omfo_s;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_s;

 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director
       from clients
       where CLIENTS_ID = :tclient_id
      into name_d, zkpo_d, ispdv_d, ipn_d, numpdv_d, adress_d, phone_d, SHORTNAME_D, tt, director_d;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tclient_id
   into :oaccount_num_d, :obank_name_d, :omfo_d;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_d;

 suspend;

end^


ALTER PROCEDURE PS_LIABLE_INS (
    ISURNAME VARCHAR(20),
    INAME VARCHAR(20),
    IPATRONYMIC VARCHAR(20),
    IIS_RESPONSIBLE INTEGER)
RETURNS (
    OLIABLE_ID INTEGER)
AS
begin
  oliable_id = GEN_ID(gen_staff_id,1);

  insert into staff (staff_id, surname, name, patronymic, responsible)
      values (:oliable_id, :isurname, :iname, :ipatronymic, :iis_responsible);
  suspend;
end^


ALTER PROCEDURE PS_LIGHT_INS_OR_UPD (
    IDOCUMENT_ID INTEGER,
    ILIGHT SMALLINT)
AS
begin
  if (exists(select * from t_documents_prm dp
              where dp.document_id = :idocument_id)) then
  begin
    update t_documents_prm dp
       set light = :ilight
     where document_id = :idocument_id and
           light != :ilight;
  end else
  begin
    insert into t_documents_prm(document_id, light)
       values(:idocument_id, :ilight);
  end
end^


ALTER PROCEDURE PS_LINK_CLIENT_SYNC (
    ICLIENT_SYNK_ID_LIST VARCHAR(1000),
    IW3_CLIENT_ID INTEGER)
AS
declare variable pclient_sync_id integer;
begin
  for select c.clients_id
        from clients c
       where isinliststr(:iclient_synk_id_list, c.clients_id) <> 0
        into pclient_sync_id
  do begin
    update clients
       set w3_client_id   = :iw3_client_id
     where clients_id = :pclient_sync_id;
  end
end^


ALTER PROCEDURE PS_LINK_NOMEN_SYNC (
    INOMEN_SYNK_ID_LIST VARCHAR(1000),
    IW3_NOMEN_ID INTEGER)
AS
declare variable pnomen_sync_id integer;
begin
  for select n.nomen_id
        from nomen n
       where isinliststr(:inomen_synk_id_list, n.nomen_id) <> 0
        into :pnomen_sync_id
  do begin
    update nomen
       set w3_nomen_id   = :iw3_nomen_id
     where nomen_id = :pnomen_sync_id;
  end
end^


ALTER PROCEDURE PS_MAKER_INS (
    IMAKER_NAME VARCHAR(40))
RETURNS (
    OMAKER_ID INTEGER)
AS
begin
  omaker_id = GEN_ID(gen_maker_id,1);

  insert into maker (maker_id, maker_name)
      values (:omaker_id, :imaker_name);
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_DEL (
    IMARKUP_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  ocaption = 'записів в акті';
  select count(mr.markup_record_id) from t_markup_records mr
      where mr.markup_id = :imarkup_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_markups m
      where m.markup_id = :imarkup_id;
  end
end^


ALTER PROCEDURE PS_MARKUP_DETAIL (
    IMARKUP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OREST DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION)
AS
declare variable tis_fixed smallint;
declare variable tdocrec_id integer;
declare variable tcurrent_rest double precision;
begin
  select m.is_fixed
      from t_markups m
    where m.markup_id = :imarkup_id
  into :tis_fixed;

  for select mr.docrec_id, n.nomen_id, n.nomen_code, n.nomen_name, mr.rest, mr.in_price, mr.out_price
        from t_markup_records mr, nomen n
      where mr.nomen_id = n.nomen_id and
            mr.markup_id = :imarkup_id
    into :tdocrec_id, :onomen_id, :onomen_code, :onomen_name, :orest, :oin_price, :oout_price
  do begin
    if ((:tis_fixed is null) or (:tis_fixed = 0)) then
    begin
      select r.rest from rst r
          where r.objects_id = 1 and
                r.nomen_id = :onomen_id
        into :orest;

      if (:tdocrec_id is not null) then
      begin
        tcurrent_rest = 0.00;
        select sum(g.goods_rest) from docgoods dg, goods g
            where dg.docrec_id = :tdocrec_id and
                  dg.goods_id = g.goods_id
          into :tcurrent_rest;
        orest = minus(:orest, :tcurrent_rest);
      end
    end

    suspend;
    tdocrec_id = null;
  end
end^


ALTER PROCEDURE PS_MARKUP_DOCUMENT_INS (
    IDOCUMENT_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP DOUBLE PRECISION)
RETURNS (
    OMARKUP_ID INTEGER)
AS
DECLARE VARIABLE TNUMBER VARCHAR(14);
DECLARE VARIABLE TTOKEN VARCHAR(14);
DECLARE VARIABLE TIN_PRICE DOUBLE PRECISION;
DECLARE VARIABLE TMARKUP_RECORD_ID INTEGER;
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TGOODS_ID INTEGER;
DECLARE VARIABLE TIN_PRICE_OLD DOUBLE PRECISION;
DECLARE VARIABLE TDOCREC_ID INTEGER;
begin
  select d.doc_num, d.doc_mark from documents d
     where d.document_id = :idocument_id
   into :tnumber, :ttoken;

  omarkup_id = GEN_ID(GEN_T_MARKUPS_ID,1);
  insert into t_markups(markup_id, is_fixed, token)
     values (:omarkup_id, 0, :ttoken);

  for select dr.nomen_id, dr.price, g.goods_id, dr.docrec_id from docrec dr, docgoods dg, goods g
      where dr.document_id = :idocument_id and
            dr.docrec_id = dg.docrec_id and
            dg.goods_id = g.goods_id
    into  :tnomen_id, :tin_price, :tgoods_id, :tdocrec_id
  do begin
    select first 1 goods_inprice from goods
        where nomen_id = :tnomen_id and
              clients_id > 100 and
              goods_id < :tgoods_id
      order by goods_id desc
     into :tin_price_old;

    tmarkup_record_id = GEN_ID(GEN_T_MARKUP_RECORDS_ID,1);
    insert into t_markup_records (markup_record_id, markup_id, nomen_id, in_price, in_price_old, docrec_id)
      values (:tmarkup_record_id, :omarkup_id, :tnomen_id, :tin_price, :tin_price_old, :tdocrec_id);
    execute procedure ps_markup_record_around(:tmarkup_record_id, :imarkup_around_id, :imarkup);
  end
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_DOCUMENT_INS_V1 (
    IDOCUMENT_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP_TYPE INTEGER,
    IMARKUP DOUBLE PRECISION)
RETURNS (
    OMARKUP_ID INTEGER)
AS
declare variable tnumber varchar(14);
declare variable ttoken varchar(14);
declare variable tin_price double precision;
declare variable tgoods_in_price double precision;
declare variable tmarkup_record_id integer;
declare variable tnomen_id integer;
declare variable tgoods_id integer;
declare variable tin_price_old double precision;
declare variable tdocrec_id integer;
declare variable ttypedoc_id integer;
begin
  select d.doc_num, d.doc_mark, d.typedoc_id from documents d
   where d.document_id = :idocument_id
    into tnumber, ttoken, ttypedoc_id;

  omarkup_id = GEN_ID(GEN_T_MARKUPS_ID,1);
  insert into t_markups(markup_id, is_fixed, token)
     values (:omarkup_id, 0, :ttoken);

  for select dr.nomen_id, dr.price, g.goods_inprice, g.goods_id, dr.docrec_id
        from docrec dr
             join docgoods dg on dg.docrec_id = dr.docrec_id
             join goods g on g.goods_id = dg.goods_id
       where dr.document_id = :idocument_id
        into tnomen_id, tin_price, tgoods_in_price, tgoods_id, tdocrec_id
  do begin
    if ((:imarkup_type = 1)or
        (:ttypedoc_id  = 7)) then
      tin_price = :tgoods_in_price;

    select first(1) goods_inprice
      from goods g/*$$IBEC$$ 
           join docgoods dg on g.goods_id    = dg.goods_id
           join docrec   dr on dr.docrec_id  = dg.docrec_id
           join documents d on d.document_id = dr.document_id $$IBEC$$*/
     where g.nomen_id   = :tnomen_id and
           g.clients_id > 100 and
           g.goods_id   < :tgoods_id  /*$$IBEC$$ and
           d.typedoc_id in (1, 6, 7) $$IBEC$$*/
     order by g.goods_id desc
      into tin_price_old;

    tmarkup_record_id = GEN_ID(GEN_T_MARKUP_RECORDS_ID,1);
    insert into t_markup_records (markup_record_id, markup_id, nomen_id, in_price, in_price_old, docrec_id)
      values (:tmarkup_record_id, :omarkup_id, :tnomen_id, :tin_price, :tin_price_old, :tdocrec_id);

    execute procedure ps_markup_record_around(:tmarkup_record_id, :imarkup_around_id, :imarkup);
    tin_price     = null;
    tin_price_old = null;
  end
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_INS (
    ITOKEN VARCHAR(14))
RETURNS (
    OMARKUP_ID INTEGER)
AS
begin
  omarkup_id = GEN_ID(GEN_T_MARKUPS_ID,1);
  insert into t_markups(markup_id, is_fixed, token)
     values (:omarkup_id, 0, :itoken);

  suspend;
end^


ALTER PROCEDURE PS_MARKUP_PRINT (
    IMARKUP_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    OUSER_NAME VARCHAR(60))
AS
DECLARE VARIABLE TUSERID INTEGER;
begin
  osum_in = 0.000;
  osum_out = 0.000;

  select is_fixed, markup_id, token, time_ins, USER_FIX_ID
      from t_markups
      where markup_id = :imarkup_id
    into :ois_fixed, :omarkup_id, :otoken, :odate, :tuserid;

  select sum(mr.in_price * mr.rest), sum(mr.out_price* mr.rest) from  t_markup_records mr
      where mr.markup_id = :omarkup_id
    into :osum_in, :osum_out;
  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
       from t_users u
        where u.user_id = :tuserid
   into :OUSER_NAME;

  suspend;
end^


ALTER PROCEDURE PS_MARKUP_RECORD_AROUND (
    IMARKUP_RECORD_ID INTEGER,
    IMARKUP_AROUND_ID INTEGER,
    IMARKUP DOUBLE PRECISION)
AS
declare variable tin_price double precision;
declare variable tout_price double precision;
declare variable tnomen_id integer;
declare variable tnomen_out_price double precision;
declare variable tis_markup_block smallint;
declare variable trecom_markup double precision;
declare variable tis_outprice_block smallint;
begin
  select in_price, nomen_id from t_markup_records mr
   where markup_record_id = :imarkup_record_id
    into tin_price, tnomen_id;

  select n.is_markup_block, n.recommended_markup, n.out_price, n.is_outprice_block
    from nomen n
   where n.nomen_id = :tnomen_id
    into tis_markup_block, trecom_markup, tnomen_out_price, tis_outprice_block;

  if (:tis_markup_block = 1) then
    imarkup = :trecom_markup;

  imarkup = 1 + (:imarkup / 100);
  tin_price  = :tin_price * :imarkup;
  tout_price = :tin_price;

  if ((:imarkup_around_id = 0) or (:imarkup_around_id is null)) then
  /*Некоректні вхідні дані*/
  begin
    tout_price = :tnomen_out_price;
  end
  else if (:imarkup_around_id = 1) then
  /*До двох знаків на 0,09*/
  begin
    tout_price = around(:tin_price/10 + 0.002000001)*10 - 0.01;
  end
  else if (:imarkup_around_id = 2) then
  /*До двох знаків*/
  begin
    tout_price = around(:tin_price + 0.002000001);
  end
  else if (:imarkup_around_id = 3) then
  /*До одного знаку*/
  begin
    tout_price = around(:tin_price/10 + 0.002000001)*10;
  end

  if ((:tis_markup_block = 0)and(:imarkup between -1.0000001 and 1.0000001)or
      (:tis_outprice_block = 1)) then
    tout_price = :tnomen_out_price;

  if ((((:tout_price-:tnomen_out_price)/:tnomen_out_price) < -0.005) or
      (((:tout_price-:tnomen_out_price)/:tnomen_out_price) > 0.005)) then
  begin
    update t_markup_records mr
       set mr.out_price = :tout_price
     where markup_record_id = :imarkup_record_id;
  end else
  begin
    update t_markup_records mr
       set mr.out_price = :tnomen_out_price
     where markup_record_id = :imarkup_record_id;
  end
end^


ALTER PROCEDURE PS_MARKUP_RECORD_DEL (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;

  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_markup_records mr
      where mr.markup_record_id = :imarkup_record_id;
  end
end^


ALTER PROCEDURE PS_MARKUP_RECORD_INS (
    IMARKUP_ID INTEGER,
    INOMEN_ID INTEGER,
    IMARKUP DOUBLE PRECISION,
    IMARKUP_AROUND_ID SMALLINT)
RETURNS (
    OMARKUP_RECORD_ID INTEGER)
AS
declare variable tin_price double precision;
declare variable tin_price_old double precision;
declare variable pgoods_id integer;
declare variable pmax_docrec_id integer;
declare variable tin_price_tmp double precision;
begin
    select first(1) dg.goods_id, dg.inprice_pdv
      from documents d
           left join docrec dr
                left join docgoods dg on dr.docrec_id  = dg.docrec_id
            on d.document_id = dr.document_id
     where dr.nomen_id   = :inomen_id and
           d.doc_date > cast('today' as date) - 30 and
           d.typedoc_id in (1, 6, 7)
     order by dg.goods_id desc
      into pgoods_id, tin_price;

  if (:pgoods_id is null) then
  begin
  for select first(2) goods_inprice from goods
      where nomen_id = :inomen_id and
            clients_id > 100
    order by goods_id desc
   into tin_price_tmp
  do begin
    if (:tin_price is null) then
      tin_price = tin_price_tmp;
    else
      tin_price_old = tin_price_tmp;
  end
  end else
  begin
     select first(1) max(g.goods_id), g.goods_inprice
      from goods g
     where g.nomen_id   = :inomen_id and
           g.clients_id > 100 and
           g.goods_id   < :pgoods_id
     group by g.goods_inprice
      into pgoods_id, tin_price_old;
  end

  if (:tin_price is null) then
    tin_price = 1;
  if (:tin_price_old is null) then
    tin_price_old = 0;

  omarkup_record_id = gen_id(GEN_T_MARKUP_RECORDS_ID,1);
  insert into t_markup_records (markup_record_id, markup_id, nomen_id, in_price, in_price_old)
      values (:omarkup_record_id, :imarkup_id, :inomen_id, :tin_price, :tin_price_old);
  execute procedure ps_markup_record_around(:omarkup_record_id, :imarkup_around_id, :imarkup);
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_RECORD_PRINT (
    IMARKUP_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OOUT_PRICE_OLD DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION)
AS
begin
  for select n.nomen_code, n.nomen_name, around(n.out_price), around(mr.in_price),
            around(mr.in_price_old), around(mr.out_price), around(mr.out_price_old), mr.rest
      from t_markup_records mr, nomen n
      where mr.markup_id = :imarkup_id and
            mr.nomen_id = n.nomen_id
      order by mr.markup_record_id
   into :ocode, :ofull_name, :oout_price_curr, :oin_price, :oin_price_old, :oout_price, :oout_price_old,  :orest
  do
  begin

     suspend;
  end
end^


ALTER PROCEDURE PS_MARKUP_RECORD_VIEW (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  select n.nomen_code, n.nomen_name, n.out_price, mr.in_price, mr.in_price_old, mr.out_price, mr.nomen_id
      from t_markup_records mr, nomen n
    where mr.nomen_id = n.nomen_id and
          mr.markup_record_id = :imarkup_record_id
   into :ocode, :ofull_name, :oout_price_curr, :oin_price, :oin_price_old, :oout_price, :onomen_id;
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_RECORD_VIEW_V1 (
    IMARKUP_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  select n.nomen_code, n.nomen_name, n.out_price, mr.in_price, mr.in_price_old, mr.out_price, mr.nomen_id
      from t_markup_records mr, nomen n
    where mr.nomen_id = n.nomen_id and
          mr.markup_record_id = :imarkup_record_id
   into :ocode, :ofull_name, :oout_price_curr, :oin_price, :oin_price_old, :oout_price, :onomen_id;
  suspend;
end^


ALTER PROCEDURE PS_MARKUP_RECORDS_VIEW (
    IMARKUP_ID INTEGER)
RETURNS (
    OMARKUP_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  for select mr.rest, mr.markup_record_id, n.nomen_code, n.nomen_name, n.out_price, mr.in_price, mr.in_price_old, mr.out_price, mr.nomen_id
      from t_markup_records mr, nomen n
    where mr.nomen_id = n.nomen_id and
          mr.markup_id = :imarkup_id
  into :orest, :omarkup_record_id, :ocode, :ofull_name, :oout_price_curr, :oin_price, :oin_price_old, :oout_price, :onomen_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_MARKUP_RECORDS_VIEW_V1 (
    IMARKUP_ID INTEGER)
RETURNS (
    OMARKUP_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE_OLD DOUBLE PRECISION,
    OOUT_PRICE_CURR DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  for select mr.rest, mr.markup_record_id, n.nomen_code, n.nomen_name, n.out_price, mr.in_price, mr.in_price_old, mr.out_price, mr.nomen_id
      from t_markup_records mr, nomen n
    where mr.nomen_id = n.nomen_id and
          mr.markup_id = :imarkup_id
  into :orest, :omarkup_record_id, :ocode, :ofull_name, :oout_price_curr, :oin_price, :oin_price_old, :oout_price, :onomen_id
  do begin
    suspend;
    oin_price = null;
    oin_price_old = null;
  end
end^


ALTER PROCEDURE PS_MARKUP_VIEW (
    IMARKUP_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT)
AS
begin
  osum_in = 0.000;
  osum_out = 0.000;

  select is_fixed, markup_id, token, time_ins from t_markups
      where markup_id = :imarkup_id
    into :ois_fixed, :omarkup_id, :otoken, :odate;

  select sum(mr.in_price), sum(mr.out_price) from  t_markup_records mr
      where mr.markup_id = :omarkup_id
    into :osum_in, :osum_out;
  suspend;
end^


ALTER PROCEDURE PS_MARKUPS_PRICES (
    IMARKUP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
declare variable p_last_date_upd date;
declare variable p_doc_date date;
declare variable pis_in_discount smallint;
declare variable pout_price double precision;
begin
/*$$IBEC$$   select cast(max(m.time_fix) as date) from t_markups m
   where m.markup_id = :imarkup_id
    into p_doc_date; $$IBEC$$*/

  for select n.nomen_id, n.nomen_code, n.nomen_name, mr.out_price, n.is_in_discount, mr.out_price_old
        from t_markup_records mr, nomen n
       where mr.markup_id = :imarkup_id and
             mr.nomen_id  = n.nomen_id
        into nomen_id, nomen_code, nomen_name, out_price, pis_in_discount, pout_price
  do begin
/*$$IBEC$$     select cast(max(pj.date_time) as date)
      from pricejournal pj
     where pj.nomen_id=:nomen_id
      into p_last_date_upd;

    if (:p_last_date_upd is null) then p_last_date_upd = '04.04.4004'; $$IBEC$$*/
    if (:pis_in_discount = 1) then
      begin
        is_check_disc = 1;
        is_check = 0;
      end else
      begin
        is_check_disc = 0;
        is_check = 1;
      end

    if (:pout_price between :out_price - 0.0001 and :out_price + 0.0001) then
    begin
      is_check_disc = 0;
      is_check = 0;
    end
    suspend;
  end
end^


ALTER PROCEDURE PS_MARKUPS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(14),
    OMARKUP_ID INTEGER,
    OPRINT_CNT INTEGER,
    ODATE DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OIS_FIXED SMALLINT)
AS
begin
  for select is_fixed, markup_id, token, time_ins, print_cnt  from t_markups m
      where time_ins between :idate0 and :idate1
    into :ois_fixed, :omarkup_id, :otoken, :odate, :oprint_cnt
  do begin
    osum_in = 0.000;
    osum_out = 0.000;
    select sum(mr.in_price * mr.rest), sum(mr.out_price* mr.rest) from  t_markup_records mr
        where mr.markup_id = :omarkup_id
      into :osum_in, :osum_out;
    suspend;
  end
end^


ALTER PROCEDURE PS_MOVING_BY_CLIENT (
    IDATE0 DATE,
    IDATE1 DATE,
    ICLIENT_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT)
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_STAFF_ID INTEGER;
BEGIN
  FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.CLIENTS_ID, D.OBJECTS_ID, D.DOC_LOCK, D.STAFF_ID,
             D.DISC_PERSENT, D.LOCK_DATE, D.OPLATA_STATE, D.OPLATA_TYPE, d.time_cr,
             d.notarization, d.kards_id
       from documents d
       where d.doc_date between :idate0 and :idate1 and
             ((d.clients_id = :iclient_id) or (d.objects_id = :iclient_id))
       INTO :odocument_id, :onumber, :otoken, :odate, :otypedoc_id,
            :P_CLIENTS_ID, :P_OBJECTS_ID, :ois_fixed, :P_STAFF_ID,
            :P_DISC_PERSENT, :odate_fix, :ooplata_state, :ooplata_type_id, :otime_cr,
            :onotarization, :okards_id
  DO BEGIN
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_OBJECTS_ID
    into :osrc_name, :osrc_fullname;
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_CLIENTS_ID
    into :odst_name, :odst_fullname;

   if (:p_clients_id = 1) then
     oarrow = 0;
   if (:p_objects_id = 1) then
     oarrow = 1;

   IF (:P_CLIENTS_ID IS NULL) THEN BEGIN
    odst_name=NULL;
    odst_fullname=NULL;
   END
   IF (:P_OBJECTS_ID IS NULL) THEN BEGIN
    osrc_name=NULL;
    osrc_fullname=NULL;
   END

   SELECT DRS.SUM_OUT, DRS.SUM_OUT_PDV, DRS.SUM_IN, DRS.SUM_IN_PDV, (DRS.AVG_DISC_PERSENT*100)
    FROM S_DOCREC_SUM(:odocument_id, :P_DISC_PERSENT) DRS
    INTO :osum_out, :osum_out_pdv, :osum_in, :osum_in_pdv, :odisc_persent;

   SUSPEND;
   onotarization = NULL;
   okards_id = NULL;
  END
END^


ALTER PROCEDURE PS_MOVING_BY_KARD (
    IDATE0 DATE,
    IDATE1 DATE,
    IKARD_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT)
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_STAFF_ID INTEGER;
BEGIN
  FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.CLIENTS_ID, D.OBJECTS_ID, D.DOC_LOCK, D.STAFF_ID,
             D.DISC_PERSENT, D.LOCK_DATE, D.OPLATA_STATE, D.OPLATA_TYPE, d.time_cr,
             d.notarization, d.kards_id
       from documents d
       where d.doc_date between :idate0 and :idate1 and
             d.kards_id = :ikard_id
       INTO :odocument_id, :onumber, :otoken, :odate, :otypedoc_id,
            :P_CLIENTS_ID, :P_OBJECTS_ID, :ois_fixed, :P_STAFF_ID,
            :P_DISC_PERSENT, :odate_fix, :ooplata_state, :ooplata_type_id, :otime_cr,
            :onotarization, :okards_id
  DO BEGIN
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_OBJECTS_ID
    into :osrc_name, :osrc_fullname;
   select c.shortname, c.name
       from clients c
    where c.clients_id=:P_CLIENTS_ID
    into :odst_name, :odst_fullname;

   if (:p_clients_id = 1) then
     oarrow = 0;
   if (:p_objects_id = 1) then
     oarrow = 1;

   IF (:P_CLIENTS_ID IS NULL) THEN BEGIN
    odst_name=NULL;
    odst_fullname=NULL;
   END
   IF (:P_OBJECTS_ID IS NULL) THEN BEGIN
    osrc_name=NULL;
    osrc_fullname=NULL;
   END

   SELECT DRS.SUM_OUT, DRS.SUM_OUT_PDV, DRS.SUM_IN, DRS.SUM_IN_PDV, (DRS.AVG_DISC_PERSENT*100)
    FROM S_DOCREC_SUM(:odocument_id, :P_DISC_PERSENT) DRS
    INTO :osum_out, :osum_out_pdv, :osum_in, :osum_in_pdv, :odisc_persent;

   SUSPEND;
   onotarization = NULL;
   okards_id = NULL;
  END
END^


ALTER PROCEDURE PS_MOVING_BY_NOMEN (
    IDATE0 DATE,
    IDATE1 DATE,
    INOMEN_ID INTEGER)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ONUMBER VARCHAR(14),
    OTOKEN VARCHAR(14),
    ODATE DATE,
    OTYPEDOC_ID INTEGER,
    OSRC_NAME VARCHAR(30),
    OSRC_FULLNAME VARCHAR(50),
    ODST_NAME VARCHAR(30),
    ODST_FULLNAME VARCHAR(50),
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OIS_FIXED SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    ODATE_FIX DATE,
    OOPLATA_STATE INTEGER,
    OOPLATA_TYPE_ID INTEGER,
    OTIME_CR TIME,
    ONOTARIZATION VARCHAR(12),
    OKARDS_ID INTEGER,
    OARROW SMALLINT,
    ODOCREC_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OPRICE_PDV DOUBLE PRECISION,
    ODISCOUNT DOUBLE PRECISION,
    OSTAFF VARCHAR(65))
AS
declare variable p_disc_persent double precision;
declare variable p_clients_id integer;
declare variable p_objects_id integer;
declare variable p_staff_id integer;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
begin
  for select d.document_id, d.doc_num, d.doc_mark, d.doc_date, d.typedoc_id,
             d.clients_id, d.objects_id, d.doc_lock, d.staff_id,
             d.disc_persent, d.lock_date, d.oplata_state, d.oplata_type, d.time_cr,
             d.notarization, d.kards_id, dr.kilk, dr.docrec_id, dr.price, dr.typepdv_id,
             dr.typepdv_pdv
        from documents d, docrec dr
       where d.doc_date between :idate0 and :idate1 and
             d.document_id = dr.document_id and
             dr.nomen_id   = :inomen_id
        into odocument_id, onumber, otoken, odate, otypedoc_id,
             p_clients_id, p_objects_id, ois_fixed, p_staff_id,
             p_disc_persent, odate_fix, ooplata_state, ooplata_type_id, otime_cr,
             onotarization, okards_id, okilk, odocrec_id, oprice_pdv, p_typepdv_id,
             p_typepdv_pdv
  do begin
   select c.shortname, c.name from clients c
    where c.clients_id = :p_objects_id
     into osrc_name, osrc_fullname;

   select c.shortname, c.name from clients c
    where c.clients_id = :p_clients_id
     into odst_name, odst_fullname;

   if (:p_clients_id = 1) then oarrow = 0; else
   oarrow = 1;

   if (:p_clients_id is null) then begin
     odst_name     = null;
     odst_fullname = null;
   end
   if (:p_objects_id is null) then begin
     osrc_name     = null;
     osrc_fullname = null;
   end

   select drs.sum_out, drs.sum_out_pdv, drs.sum_in, drs.sum_in_pdv, (drs.avg_disc_persent*100)
     from ps_docrec_sum(:odocrec_id, :p_disc_persent) drs
     into osum_out, osum_out_pdv, osum_in, osum_in_pdv, odisc_persent;

   oprice = calcsum(:oprice_pdv, 0, :p_typepdv_pdv, :p_typepdv_id, 0);

   suspend;
   onotarization = null;
   okards_id = null;
  end
end^


ALTER PROCEDURE PS_NOMEN_BY_GRUP (
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
declare variable pgrp_id integer;
begin
 for select rgrp_id from t_grp_childs(:igrp_id)
    into :pgrp_id
  do begin
     for select n.nomen_id
           from nomen n
          where n.grp_id = :pgrp_id and
                ((n.is_exist = 1)or(n.is_exist is null))
           into onomen_id
     do 
      suspend;
   end
end^


ALTER PROCEDURE PS_NOMEN_DEL (
    INOMEN_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  tsuma = 0;

  ocaption = 'аналітичних карток';
  select count(g.goods_id) from goods g
      where g.nomen_id = :inomen_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  ocaption = 'записів в документах';
  select count(dr.docrec_id) from docrec dr
      where dr.nomen_id =  :inomen_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  ocaption = 'записів в ревізіях';
  select count(rr.rev_records_id) from rev_records rr
      where rr.nomen_id = :inomen_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  ocaption = 'записів в автозамовленнях';
  select count(ar.ao_record_id) from ao_records ar
      where ar.aor_nomen_id = :inomen_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  ocaption = 'записів в актах переоцінки';
  select count(mr.markup_record_id) from t_markup_records mr
      where mr.nomen_id = :inomen_id
    into :ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from pricejournal pr
      where pr.nomen_id = :inomen_id;
    delete from rst rt
      where rt.nomen_id = :inomen_id;
    delete from nom_bar nb
      where nb.nomen_id = :inomen_id;
    delete from nomen n
      where n.nomen_id = :inomen_id;
  end
end^


ALTER PROCEDURE PS_NOMEN_DETAIL (
    INOMEN_ID INTEGER)
RETURNS (
    OGRP_NAME VARCHAR(40),
    OSG_NAME VARCHAR(30),
    OTYPEPDV_NAME VARCHAR(45),
    OPDV DOUBLE PRECISION)
AS
DECLARE VARIABLE PSG_ID INTEGER;
begin
  select n.sg_id, g.grp_name, tp.typepdv_name, tp.pdv  from nomen n, grp g, typepdv tp
     where n.nomen_id = :inomen_id and
           n.grp_id = g.grp_id and
           n.typepdv_id = tp.typepdv_id
    into :psg_id, :ogrp_name, :otypepdv_name, :opdv;

  if (:psg_id is null) then
    psg_id = 0;

  select sg.sg_name from specials_groups sg
     where sg.sg_id = :psg_id
   into :osg_name;

  suspend;
end^


ALTER PROCEDURE PS_NOMEN_DETAIL_GOODS (
    INOMEN_ID INTEGER,
    ICOUNT INTEGER)
RETURNS (
    OGOODS_ID INTEGER,
    OCLIENT_NAME VARCHAR(50),
    ODOC_NUM VARCHAR(14),
    OIN_PRICE_PDV DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    ODOC_MARK VARCHAR(14),
    ODOC_DATE DATE,
    OIN_SUM_PDV DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
DECLARE VARIABLE TCLIENTS_ID INTEGER;
DECLARE VARIABLE TTYPEPDV_ID INTEGER;
begin
  select n.typepdv_id from nomen n
      where n.nomen_id = :inomen_id
    into :ttypepdv_id;

  for select first(:icount) g.goods_id, g.clients_id, g.goods_rest, g.goods_inprice
           from goods g
      where g.nomen_id = :inomen_id
     order by g.goods_id desc
   into :ogoods_id, :tclients_id, :orest, :oin_price_pdv
  do begin
    oin_sum_pdv = :oin_price_pdv * :orest;
    oin_price = calcsum(:oin_price_pdv, 0.00, 0.00, :ttypepdv_id, 6);
    oin_sum = :oin_price * :orest;
    select c.name from clients c
        where c.clients_id = :tclients_id
      into :oclient_name;

    select d.doc_num, d.doc_date, d.doc_mark from documents d, docrec dr, docgoods dg
        where d.document_id = dr.document_id and
              dr.docrec_id = dg.docrec_id and
              dg.goods_id = :ogoods_id and
              dr.nomen_id = :inomen_id and
              d.objects_id = :tclients_id and
              d.typedoc_id in (1,6,12,14,7)
      into :odoc_num, :odoc_date, :odoc_mark;

    suspend;
  end
end^


ALTER PROCEDURE PS_NOMEN_INS (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
DECLARE VARIABLE TNEW_CODE INTEGER;
DECLARE VARIABLE TCODE VARCHAR(7);
begin
  select max(cast(n.nomen_code as integer)) from nomen n
    into :tnew_code;
  tcode = tosix(:tnew_code + 1);
  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, :tcode, :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_INS_V1 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
DECLARE VARIABLE TNEW_CODE INTEGER;
DECLARE VARIABLE TCODE VARCHAR(7);
begin
  select max(cast(n.nomen_code as integer)) from nomen n
    into :tnew_code;
  tcode = tosix(:tnew_code + 1);
  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price, is_visible, is_active)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, :tcode, :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00, :iis_visible, :iis_active);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_INS_V2 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
DECLARE VARIABLE TNEW_CODE INTEGER;
DECLARE VARIABLE TCODE VARCHAR(7);
begin
/*  select max(cast(n.nomen_code as integer)) from nomen n
      where n.nomen_code = cast(GEN_LAST_NOMEN_CODE as varchar(7))
        into :tcode;
  */

  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price, is_visible, is_active)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, '000000', :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00, :iis_visible, :iis_active);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_INS_V3 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
declare variable tnew_code integer;
declare variable tcode varchar(7);
begin
/*  select max(cast(n.nomen_code as integer)) from nomen n
      where n.nomen_code = cast(GEN_LAST_NOMEN_CODE as varchar(7))
        into :tcode;
  */

  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price, is_visible, is_active,
                  maker_id, decrease_id)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, '000000', :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00, :iis_visible, :iis_active,
                  :imaker_id, :idecr_id);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_INS_V4 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER,
    ITYPE_NOMEN SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
declare variable tnew_code integer;
declare variable tcode varchar(7);
begin
/*  select max(cast(n.nomen_code as integer)) from nomen n
      where n.nomen_code = cast(GEN_LAST_NOMEN_CODE as varchar(7))
        into :tcode;
  */

  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price, is_visible, is_active,
                  maker_id, decrease_id, type_nomen)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, '000000', :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00, :iis_visible, :iis_active,
                  :imaker_id, :idecr_id, :itype_nomen);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_INS_V5 (
    IGRP_ID INTEGER,
    ISG_ID INTEGER,
    ISI_ID INTEGER,
    IFULL_NAME VARCHAR(40),
    ISHORT_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    INETTO DOUBLE PRECISION,
    IMIN_REST DOUBLE PRECISION,
    IIS_DIVIDEND SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IMAKER_ID INTEGER,
    IDECR_ID INTEGER,
    ITYPE_NOMEN SMALLINT,
    IIS_IN_DISCOUNT SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER)
AS
declare variable tnew_code integer;
declare variable tcode varchar(7);
begin
/*  select max(cast(n.nomen_code as integer)) from nomen n
      where n.nomen_code = cast(GEN_LAST_NOMEN_CODE as varchar(7))
        into :tcode;
  */

  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, nomen_name, datex_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price, is_visible, is_active,
                  maker_id, decrease_id, type_nomen, is_in_discount)
    values (:onomen_id, :igrp_id, :isg_id, :isi_id, '000000', :ifull_name, :ishort_name,
                  :itypepdv_id, :inetto, :imin_rest, :iis_dividend, 1.00, :iis_visible, :iis_active,
                  :imaker_id, :idecr_id, :itype_nomen, :iis_in_discount);
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_LIKE_INS (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
DECLARE VARIABLE TNEW_CODE INTEGER;
DECLARE VARIABLE TCODE VARCHAR(7);
DECLARE VARIABLE TGRP_ID INTEGER;
DECLARE VARIABLE TSG_ID INTEGER;
DECLARE VARIABLE TSI_ID INTEGER;
DECLARE VARIABLE TTYPEPDV_ID INTEGER;
DECLARE VARIABLE TNETTO DOUBLE PRECISION;
DECLARE VARIABLE TMIN_REST DOUBLE PRECISION;
DECLARE VARIABLE TIS_DIVIDEND SMALLINT;
DECLARE VARIABLE TMARKER VARCHAR(64);
DECLARE VARIABLE TDATEX_NAME VARCHAR(26);
DECLARE VARIABLE TNOMEN_NAME VARCHAR(40);
begin
  select c.marker from t_configs c
      where c.config_id = 3 and
          c.module = 'store_nomen'
    into :tmarker;

  select max(cast(n.nomen_code as integer)) from nomen n
    into :tnew_code;
  tcode = tosix(:tnew_code + 1);
  onomen_id = GEN_ID(GEN_NOMEN_ID, 1);

  select n.grp_id, n.sg_id, n.si_id, n.typepdv_id, n.brutto,
                n.minkilk, n.is_weight, datex_name, nomen_name from nomen n
       where n.nomen_id = :inomen_id
    into :tgrp_id, :tsg_id, :tsi_id, :ttypepdv_id, :tnetto,
                :tmin_rest, :tis_dividend, :tdatex_name, :tnomen_name;

  if (:tmarker = 'no') then
  begin
    tdatex_name = '';
    tnomen_name = '';
  end

  insert into nomen (nomen_id, grp_id, sg_id, si_id, nomen_code, datex_name, nomen_name,
                  typepdv_id, brutto, minkilk, is_weight, out_price)
    values (:onomen_id, :tgrp_id, :tsg_id, :tsi_id, :tcode, :tdatex_name, :tnomen_name,
                  :ttypepdv_id, :tnetto, :tmin_rest, :tis_dividend, 1.00);

  suspend;
end^


ALTER PROCEDURE PS_NOMEN_LINK_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
declare variable pgrp_id integer;
BEGIN

   select n.code, n.ekka_name, n.name, n.receipt_date,
              n.grp_id
       from t_nomens_sync n
         where n.w3_nomen_id = :inomen_id
     into :ocode, :oekka_name, :oname, :oreceipt_date,
          :pgrp_id ;

       select gs.grp_fullname
         from t_grps_sync gs
        where gs.grp_id = :pgrp_id
         into :ogrp_fullname;

       select count(nb.code_int) from t_nom_bars_sync nb
           where nb.w3_nomen_id = :inomen_id
         into :obarcodes_cnt;

       ogrp_id = :pgrp_id;
     suspend;
END^


ALTER PROCEDURE PS_NOMEN_LIST_RECORD_VIEW (
    INOMEN_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
begin
  if ((:imode = 0) or (:imode is null)) then
  begin
    select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
           rt.last_inprice, rt.rest, n.grp_id
      from nomen n, rst rt
     where n.nomen_id = rt.nomen_id and
           n.nomen_id = :inomen_id  and
           rt.objects_id = 1
      into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
           oprice_in, orest, ogrp_id;
  end
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_LIST_RECORD_VIEW_V1 (
    INOMEN_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
declare variable tmaker_id integer;
begin
  if ((:imode = 0) or (:imode is null)) then
  begin
    select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
           rt.last_inprice, rt.rest, n.grp_id, n.w3_nomen_id, n.maker_id
      from nomen n, rst rt
     where n.nomen_id = rt.nomen_id and
           n.nomen_id = :inomen_id and
           rt.objects_id = 1
      into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
           oprice_in, orest, ogrp_id, ow3_nomen_id, tmaker_id;
  end

  select count(nb.nom_bar_id) from nom_bar nb
   where nb.nomen_id = :onomen_id
    into obarcodes_cnt;

  select g.grp_name from grp g
   where g.grp_id = :ogrp_id
    into ogrp_name;

  select m.maker_name
    from maker m
   where m.maker_id = :tmaker_id
    into omaker_name;


  suspend;
  ogrp_name = null;
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER)
AS
begin
  for select rgrp_id from t_grp_childs(:igrp_id)
    into ogrp_id
  do begin
    if ((:imode = 0) or (:imode is null)) then
    begin
    for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
               rt.last_inprice, rt.rest
          from nomen n, rst rt
         where n.nomen_id = rt.nomen_id and
               n.grp_id = :ogrp_id and
               rt.objects_id = 1  and
               ((n.is_exist = 1)or(n.is_exist is null))
          into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
               oprice_in, orest
      do begin
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_0 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
begin
  ifilter = strupper1(:ifilter);

  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module = 'store_nomens'
    into tmarker;

  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into ogrp_id, ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 strupper1(n.nomen_code) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible
      do begin
      if (:imode = 1) then
        begin
          if ((pis_visible = 1) or (pis_visible is null)) then
          begin
            select count(nb.nom_bar_id) from nom_bar nb
              where nb.nomen_id = :onomen_id
            into :obarcodes_cnt;

            if (:tmarker <> 'no') then
            select m.maker_name
               from maker m
             where m.maker_id = :tmaker_id
             into :omaker_name;
            suspend;
            omaker_name = null;
            tmaker_id = null;
          end
        end else
        begin
          select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

          if (:tmarker <> 'no') then
           select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
           into :omaker_name;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_0_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
declare variable pis_active integer;
begin
  ifilter = strupper1(:ifilter);
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  /*
    mode = 1 - лише видимий товар (активність не береться до уваги)
    mode = 0 - весь товар крім неактивного
  */
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 strupper1(n.nomen_code) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active
      do begin
       if (((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))) or /* лише видимий товар */
           ((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
            (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_0_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
declare variable TMARKER varchar(64);
declare variable TMAKER_ID integer;
declare variable PIS_VISIBLE integer;
declare variable PIS_ACTIVE integer;
declare variable PTYPE_NOMEN integer;
declare variable PCALCULATION_COUNT integer;
declare variable PNOMEN_COUNT integer;
declare variable PW3_NOMEN_ID integer;
declare variable PDOCUMENT_ID integer;
declare variable PKILK double precision;
declare variable PLAST_AUTOORDER_ID integer;
begin
  ifilter = strupper1(:ifilter);
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

  if (:imode = 20) then
  begin
    pdocument_id = :igrp_id;
    igrp_id = null;
  end
  /*
    mode = 0 - весь звичайний товар крім неактивного
    mode = 1 - лише видимий товар та продукція (активність не береться до уваги) (весь крім не видимого, не існуючого та сировини)
    mode = 2 - лише видимі сировина і продукція (активність не береться до уваги)
    mode = 3 - лише видима продукція (активність не береться до уваги)
    mode = 4 - лише продукція з калькуляціями (інші властивості не беруться до уваги)
    mode = 5 - весь товар крім неактивного
    mode = 6 - весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини
    mode = 7 - весь крім невидимого
    mode is null - всі товари
  */
  if ((:imode != 20)or(:imode is null)) then begin
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into ogrp_id, ogrp_name
  do begin

  select count(nomen_id) from nomen
   where grp_id = :ogrp_id
    into pnomen_count;

  if (:pnomen_count > 0) then
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 strupper1(n.nomen_code) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;

       if (((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))and((:ptype_nomen = 0)or(:ptype_nomen is null))) or /* лише активний товар без сировини*/
           ((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 0)or(:ptype_nomen = 2)or(:ptype_nomen is null))) or /* весь крім не видимого, не існуючого та сировини*/
           ((:imode = 2)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 1)or(:ptype_nomen = 2))) or /*лише видимі сировина та продукція*/
           ((:imode = 3)and((:pis_visible = 1)or(:pis_visible is null))and(:ptype_nomen = 2)) or /*лише видима продукція*/
           ((:imode = 4)and(:pcalculation_count > 0)and(:ptype_nomen = 2)and((:pis_active  = 1)or(:pis_active  is null)))or    /* лише продукція з калькуляціями (інші властивості не беруться до уваги) */
           ((:imode = 5)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
           ((:imode = 6)and((:pw3_nomen_id is not null)and((:pis_visible = 1)or(:pis_visible is null))and((:pis_active  = 1)or(:pis_active  is null)))and((:ptype_nomen = 0)or(:ptype_nomen is null)))or /* весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини */
           ((:imode = 7)and((:pis_visible = 1)or(:pis_visible is null))) or /* весь крім невидимого */
           (:imode is null)) /* активність та видимість не враховується */
          then
       begin

        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
  end
  end

      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from autoorders ao
                 inner join t_document_autoorder da on da.autoorder_id = ao.autoorder_id
                 left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
                 inner join nomen n on aor.aor_nomen_id = n.nomen_id
                 inner join rst rt on n.nomen_id = rt.nomen_id
           where da.documents_id = :pdocument_id and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 strupper1(n.nomen_code) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      if (not(exists(select * from docrec dr where dr.document_id = :pdocument_id and dr.nomen_id = :onomen_id))) then
      begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;
         select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

      if (:imode = 20) then begin
        select max(ao.autoorder_id)
          from t_document_autoorder da
               inner join autoorders ao on ao.autoorder_id  = da.autoorder_id
               left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where aor.aor_nomen_id = :onomen_id and
               da.documents_id = :pdocument_id
          into plast_autoorder_id;

        select first(1) aor.aor_ordered
          from autoorders ao
               join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where ao.autoorder_id = :plast_autoorder_id and
               aor.aor_nomen_id = :onomen_id
         order by aor.ao_record_id desc
          into orest;

        if (:orest is null) then orest = 0.0;

        select sum(dr.kilk)
          from t_document_autoorder da
               inner join documents d on da.documents_id = d.document_id
               left join docrec dr on dr.document_id = d.document_id
         where da.autoorder_id = :plast_autoorder_id and
               da.documents_id != :pdocument_id and
               d.doc_lock != 0 and
               dr.nomen_id = :onomen_id
          into pkilk;

        if (:pkilk is null) then pkilk = 0.0;
        orest = :orest - :pkilk;
        if (:orest < 0.00001) then orest = 0.0;

      end

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         if (:orest > 0) then
            suspend;
         omaker_name = null;
         tmaker_id = null;
      end
      end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
begin
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

  for select rgrp_id from t_grp_childs(:igrp_id)
    into :ogrp_id
  do begin
    if ((:imode = 0) or (:imode is null)) then
    begin
      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id
        from nomen n, rst rt, nom_bar nb, barcode b
            where n.nomen_id    = rt.nomen_id   and
                  n.grp_id      = :ogrp_id      and
                  rt.objects_id = 1             and
                  nb.nomen_id   = n.nomen_id    and
                  nb.barcode_id = b.barcode_id  and
                  ((n.is_exist = 1)or(n.is_exist is null)) and
                  b.code like :ifilter
       into :onomen_id, :ocode, :ofull_name, :oshort_name, :oprice_out,
                 :oprice_in, :orest, :tmaker_id
      do begin
        select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;
       suspend;
       omaker_name = null;
       tmaker_id = null;
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_1_V1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
begin
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

  for select rgrp_id from t_grp_childs(:igrp_id)
    into :ogrp_id
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible
        from nomen n, rst rt, nom_bar nb, barcode b
            where n.nomen_id    = rt.nomen_id   and
                  n.grp_id      = :ogrp_id      and
                  rt.objects_id = 1             and
                  nb.nomen_id   = n.nomen_id    and
                  nb.barcode_id = b.barcode_id  and
                  b.code        = :ifilter      and
                  ((n.is_exist = 1)or(n.is_exist is null))
       into :onomen_id, :ocode, :ofull_name, :oshort_name, :oprice_out,
                 :oprice_in, :orest, :tmaker_id, :pis_visible
      do begin
        if (:imode = 1) then
        begin
          if ((pis_visible = 1) or (pis_visible is null)) then
          begin
            select count(nb.nom_bar_id) from nom_bar nb
              where nb.nomen_id = :onomen_id
            into :obarcodes_cnt;

            if (:tmarker <> 'no') then
            select m.maker_name
               from maker m
             where m.maker_id = :tmaker_id
             into :omaker_name;
            suspend;
            omaker_name = null;
            tmaker_id = null;
          end
        end else
        begin
          select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

          if (:tmarker <> 'no') then
           select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
           into :omaker_name;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_1_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
declare variable pis_active integer;
begin
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  /*
    mode = 1 - лише видимий товар (активність не береться до уваги)
    mode = 0 - весь товар крім неактивного
  */
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active
            from nomen n, rst rt, nom_bar nb, barcode b
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))and
                 nb.nomen_id    = n.nomen_id    and
                 nb.barcode_id  = b.barcode_id  and
                 b.code = :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active
      do begin
       if (((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))) or /* лише видимий товар */
           ((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
            (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_1_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(27))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
declare variable TMARKER varchar(64);
declare variable TMAKER_ID integer;
declare variable PIS_VISIBLE integer;
declare variable PIS_ACTIVE integer;
declare variable PTYPE_NOMEN integer;
declare variable PCALCULATION_COUNT integer;
declare variable PNOMEN_COUNT integer;
declare variable PW3_NOMEN_ID integer;
declare variable PDOCUMENT_ID integer;
declare variable PKILK double precision;
declare variable PLAST_AUTOORDER_ID integer;
begin
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  if (:imode = 20) then
  begin
    pdocument_id = :igrp_id;
    igrp_id = null;
  end
  /*
    mode = 0 - весь звичайний товар крім неактивного
    mode = 1 - лише видимий товар та продукція (активність не береться до уваги) (весь крім не видимого, не існуючого та сировини)
    mode = 2 - лише видимі сировина і продукція (активність не береться до уваги)
    mode = 3 - лише видима продукція (активність не береться до уваги)
    mode = 4 - лише продукція з калькуляціями (інші властивості не беруться до уваги)
    mode = 5 - весь товар крім неактивного
    mode = 6 - весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини
    mode = 7 - весь крім невидимого
    mode is null - всі товари
  */
  if ((:imode != 20)or(:imode is null)) then begin
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into ogrp_id, ogrp_name
  do begin

  select count(nomen_id) from nomen
   where grp_id = :ogrp_id
    into pnomen_count;

  if (:pnomen_count > 0) then
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from nomen n, rst rt, nom_bar nb, barcode b
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))and
                 nb.nomen_id    = n.nomen_id    and
                 nb.barcode_id  = b.barcode_id  and
                 b.code = :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;

       if (((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))and((:ptype_nomen = 0)or(:ptype_nomen is null))) or /* лише активний товар без сировини*/
           ((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 0)or(:ptype_nomen = 2)or(:ptype_nomen is null))) or /* весь крім не видимого, не існуючого та сировини*/
           ((:imode = 2)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 1)or(:ptype_nomen = 2))) or /*лише видимі сировина та продукція*/
           ((:imode = 3)and((:pis_visible = 1)or(:pis_visible is null))and(:ptype_nomen = 2)) or /*лише видима продукція*/
           ((:imode = 4)and(:pcalculation_count > 0)and(:ptype_nomen = 2)and((:pis_active  = 1)or(:pis_active  is null)))or    /* лише продукція з калькуляціями (інші властивості не беруться до уваги) */
           ((:imode = 5)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
           ((:imode = 6)and((:pw3_nomen_id is not null)and((:pis_visible = 1)or(:pis_visible is null))and((:pis_active  = 1)or(:pis_active  is null)))and((:ptype_nomen = 0)or(:ptype_nomen is null)))or /* весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини */
           ((:imode = 7)and((:pis_visible = 1)or(:pis_visible is null))) or /* весь крім невидимого */
           (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
  end

      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from autoorders ao
                 inner join t_document_autoorder da on da.autoorder_id = ao.autoorder_id
                 inner join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
                 inner join nomen n on aor.aor_nomen_id = n.nomen_id
                 inner join rst rt on n.nomen_id = rt.nomen_id
                 inner join nom_bar nb on nb.nomen_id    = n.nomen_id
                 inner join barcode b on nb.barcode_id  = b.barcode_id
           where da.documents_id = :pdocument_id and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 b.code = :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      if (not(exists(select * from docrec dr where dr.document_id = :pdocument_id and dr.nomen_id = :onomen_id))) then
      begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;
         select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

      if (:imode = 20) then begin
        select max(ao.autoorder_id)
          from t_document_autoorder da
               inner join autoorders ao on ao.autoorder_id  = da.autoorder_id
               left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where aor.aor_nomen_id = :onomen_id and
               da.documents_id = :pdocument_id
          into plast_autoorder_id;

        select first(1) aor.aor_ordered
          from autoorders ao
               join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where ao.autoorder_id = :plast_autoorder_id and
               aor.aor_nomen_id = :onomen_id
         order by aor.ao_record_id desc
          into orest;

        if (:orest is null) then orest = 0.0;

        select sum(dr.kilk)
          from t_document_autoorder da
               inner join documents d on da.documents_id = d.document_id
               left join docrec dr on dr.document_id = d.document_id
         where da.autoorder_id = :plast_autoorder_id and
               da.documents_id != :pdocument_id and
               d.doc_lock != 0 and
               dr.nomen_id = :onomen_id
          into pkilk;

        if (:pkilk is null) then pkilk = 0.0;
        orest = :orest - :pkilk;
        if (:orest < 0.00001) then orest = 0.0;

      end

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         if (:orest > 0) then
            suspend;
         omaker_name = null;
         tmaker_id = null;
      end
      end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
begin
  ifilter = strupper1(:ifilter);

  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode =1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible
        from nomen n, rst rt
            where n.nomen_id = rt.nomen_id and
                  n.grp_id = :ogrp_id and
                  rt.objects_id = 1 and
                  strupper1(n.nomen_name) like :ifilter
       into :onomen_id, :ocode, :ofull_name, :oshort_name, :oprice_out,
                 :oprice_in, :orest, :tmaker_id, :pis_visible
      do begin
        if (:imode = 1) then
        begin
          if ((pis_visible = 1) or (pis_visible is null)) then
          begin
            select count(nb.nom_bar_id) from nom_bar nb
              where nb.nomen_id = :onomen_id
            into :obarcodes_cnt;

            if (:tmarker <> 'no') then
            select m.maker_name
               from maker m
             where m.maker_id = :tmaker_id
             into :omaker_name;
            suspend;
            omaker_name = null;
            tmaker_id = null;
          end
        end   else
        begin
          select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

          if (:tmarker <> 'no') then
           select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
           into :omaker_name;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_2_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
declare variable pis_active integer;
begin
  ifilter = strupper1(:ifilter);

  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  /*
    mode = 1 - лише видимий товар (активність не береться до уваги)
    mode = 0 - весь товар крім неактивного
  */
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 strupper1(n.nomen_name) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active
      do begin
       if (((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))) or /* лише видимий товар */
           ((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
            (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_2_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
declare variable TMARKER varchar(64);
declare variable TMAKER_ID integer;
declare variable PIS_VISIBLE integer;
declare variable PIS_ACTIVE integer;
declare variable PTYPE_NOMEN integer;
declare variable PCALCULATION_COUNT integer;
declare variable PNOMEN_COUNT integer;
declare variable PW3_NOMEN_ID integer;
declare variable PDOCUMENT_ID integer;
declare variable PKILK double precision;
declare variable PLAST_AUTOORDER_ID integer;
begin
  ifilter = strupper1(:ifilter);

  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  if (:imode = 20) then
  begin
    pdocument_id = :igrp_id;
    igrp_id = null;
  end
  /*
    mode = 0 - весь звичайний товар крім неактивного
    mode = 1 - лише видимий товар та продукція (активність не береться до уваги) (весь крім не видимого, не існуючого та сировини)
    mode = 2 - лише видимі сировина і продукція (активність не береться до уваги)
    mode = 3 - лише видима продукція (активність не береться до уваги)
    mode = 4 - лише продукція з калькуляціями (інші властивості не беруться до уваги)
    mode = 5 - весь товар крім неактивного
    mode = 6 - весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини
    mode = 7 - весь крім невидимого
    mode is null - всі товари
  */
  if ((:imode != 20)or(:imode is null)) then begin
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into ogrp_id, ogrp_name
  do begin

  select count(nomen_id) from nomen
   where grp_id = :ogrp_id
    into pnomen_count;

  if (:pnomen_count > 0) then
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 ((n.is_exist   = 1)or(n.is_exist is null)) and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 strupper1(n.nomen_name) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;

       if (((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))and((:ptype_nomen = 0)or(:ptype_nomen is null))) or /* лише активний товар без сировини*/
           ((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 0)or(:ptype_nomen = 2)or(:ptype_nomen is null))) or /* весь крім не видимого, не існуючого та сировини*/
           ((:imode = 2)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 1)or(:ptype_nomen = 2))) or /*лише видимі сировина та продукція*/
           ((:imode = 3)and((:pis_visible = 1)or(:pis_visible is null))and(:ptype_nomen = 2)) or /*лише видима продукція*/
           ((:imode = 4)and(:pcalculation_count > 0)and(:ptype_nomen = 2)and((:pis_active  = 1)or(:pis_active  is null)))or    /* лише продукція з калькуляціями (інші властивості не беруться до уваги) */
           ((:imode = 5)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
           ((:imode = 6)and((:pw3_nomen_id is not null)and((:pis_visible = 1)or(:pis_visible is null))and((:pis_active  = 1)or(:pis_active  is null)))and((:ptype_nomen = 0)or(:ptype_nomen is null)))or /* весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини */
           ((:imode = 7)and((:pis_visible = 1)or(:pis_visible is null))) or /* весь крім невидимого */
           (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
 end

      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from autoorders ao
                 inner join t_document_autoorder da on da.autoorder_id = ao.autoorder_id
                 left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
                 inner join nomen n on aor.aor_nomen_id = n.nomen_id
                 inner join rst rt on n.nomen_id = rt.nomen_id
           where da.documents_id = :pdocument_id and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))and
                 strupper1(n.nomen_name) like :ifilter
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      if (not(exists(select * from docrec dr where dr.document_id = :pdocument_id and dr.nomen_id = :onomen_id))) then
      begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;
         select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

      if (:imode = 20) then begin
        select max(ao.autoorder_id)
          from t_document_autoorder da
               inner join autoorders ao on ao.autoorder_id  = da.autoorder_id
               left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where aor.aor_nomen_id = :onomen_id and
               da.documents_id = :pdocument_id
          into plast_autoorder_id;

        select first(1) aor.aor_ordered
          from autoorders ao
               join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where ao.autoorder_id = :plast_autoorder_id and
               aor.aor_nomen_id = :onomen_id
         order by aor.ao_record_id desc
          into orest;

        if (:orest is null) then orest = 0.0;

        select sum(dr.kilk)
          from t_document_autoorder da
               inner join documents d on da.documents_id = d.document_id
               left join docrec dr on dr.document_id = d.document_id
         where da.autoorder_id = :plast_autoorder_id and
               da.documents_id != :pdocument_id and
               d.doc_lock != 0 and
               dr.nomen_id = :onomen_id
          into pkilk;

        if (:pkilk is null) then pkilk = 0.0;
        orest = :orest - :pkilk;
        if (:orest < 0.00001) then orest = 0.0;

      end

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         if (:orest > 0) then
            suspend;
         omaker_name = null;
         tmaker_id = null;
      end
      end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_V1 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
begin
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible
        from nomen n, rst rt
            where n.nomen_id = rt.nomen_id and
                  n.grp_id = :ogrp_id and
                  rt.objects_id = 1
       into :onomen_id, :ocode, :ofull_name, :oshort_name, :oprice_out,
                 :oprice_in, :orest, :tmaker_id, :pis_visible
      do begin
        if (:imode = 1) then
        begin
          if ((pis_visible = 1) or (pis_visible is null)) then
          begin
            select count(nb.nom_bar_id) from nom_bar nb
              where nb.nomen_id = :onomen_id
            into :obarcodes_cnt;

            if (:tmarker <> 'no') then
            select m.maker_name
               from maker m
             where m.maker_id = :tmaker_id
             into :omaker_name;
            suspend;
            omaker_name = null;
            tmaker_id = null;
          end
        end else
        begin
          select count(nb.nom_bar_id) from nom_bar nb
            where nb.nomen_id = :onomen_id
          into :obarcodes_cnt;

          if (:tmarker <> 'no') then
           select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
           into :omaker_name;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end
      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_V2 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable pis_visible integer;
declare variable pis_active integer;
begin
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  /*
    mode = 1 - лише видимий товар (активність не береться до уваги)
    mode = 0 - весь товар крім неактивного
  */
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into :ogrp_id, :ogrp_name
  do begin
    if ((:imode = 0) or (:imode = 1) or (:imode is null)) then
    begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active
            from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active
      do begin
       if (((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))) or /* лише видимий товар */
           ((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
            (:imode is null)) /* активність та видимість не враховується */
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

         suspend;
         omaker_name = null;
         tmaker_id = null;
       end

      end
    end
  end
end^


ALTER PROCEDURE PS_NOMEN_LIST_VIEW_V3 (
    IGRP_ID INTEGER,
    IMODE SMALLINT)
RETURNS (
    ONOMEN_ID INTEGER,
    OGOODS_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OSHORT_NAME VARCHAR(26),
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OGRP_ID INTEGER,
    OBARCODES_CNT VARCHAR(10),
    OMAKER_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    OW3_NOMEN_ID VARCHAR(10))
AS
declare variable TMARKER varchar(64);
declare variable TMAKER_ID integer;
declare variable PIS_VISIBLE integer;
declare variable PIS_ACTIVE integer;
declare variable PTYPE_NOMEN integer;
declare variable PCALCULATION_COUNT integer;
declare variable PNOMEN_COUNT integer;
declare variable PW3_NOMEN_ID integer;
declare variable PDOCUMENT_ID integer;
declare variable PKILK double precision;
declare variable PLAST_AUTOORDER_ID integer;
begin
  select c.marker from  t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;
  if (:imode = 20) then
  begin
    pdocument_id = :igrp_id;
    igrp_id = null;
  end
  /*
    mode = 0 - весь звичайний товар крім неактивного
    mode = 1 - лише видимий товар та продукція (активність не береться до уваги) (весь крім не видимого, не існуючого та сировини)
    mode = 2 - лише видимі сировина і продукція (активність не береться до уваги)
    mode = 3 - лише видима продукція (активність не береться до уваги)
    mode = 4 - лише продукція з калькуляціями (інші властивості не беруться до уваги)
    mode = 5 - весь товар крім неактивного
    mode = 6 - весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини
    mode = 7 - весь крім невидимого
    mode is null - всі товари
  */
  if ((:imode != 20)or(:imode is null)) then begin
  for select rgrp_id, rgrp_name from t_grp_childs(:igrp_id)
    into ogrp_id, ogrp_name
  do begin

  select count(nomen_id) from nomen
   where grp_id = :ogrp_id
    into pnomen_count;

  if (:pnomen_count > 0) then
  begin
      for select n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
             from nomen n, rst rt
           where n.nomen_id     = rt.nomen_id   and
                 n.grp_id       = :ogrp_id      and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
      do begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;

       if (((:imode = 0)and((:pis_active  = 1)or(:pis_active  is null))and((:ptype_nomen = 0)or(:ptype_nomen is null))) or /* лише активний товар без сировини*/
           ((:imode = 1)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 0)or(:ptype_nomen = 2)or(:ptype_nomen is null))) or /* весь крім не видимого, не існуючого та сировини*/
           ((:imode = 2)and((:pis_visible = 1)or(:pis_visible is null))and((:ptype_nomen = 1)or(:ptype_nomen = 2))) or /*лише видимі сировина та продукція*/
           ((:imode = 3)and((:pis_visible = 1)or(:pis_visible is null))and(:ptype_nomen = 2)) or /*лише видима продукція*/
           ((:imode = 4)and(:pcalculation_count > 0)and(:ptype_nomen = 2)and((:pis_active  = 1)or(:pis_active  is null)))or    /* лише продукція з калькуляціями (інші властивості не беруться до уваги) */
           ((:imode = 5)and((:pis_active  = 1)or(:pis_active  is null))) or /* лише активний товар */
           ((:imode = 6)and((:pw3_nomen_id is not null)and((:pis_visible = 1)or(:pis_visible is null))and((:pis_active  = 1)or(:pis_active  is null)))and((:ptype_nomen = 0)or(:ptype_nomen is null)))or /* весь крім не зв'язаного, не видимого, не активного, не існуючого та сировини */
           ((:imode = 7)and((:pis_visible = 1)or(:pis_visible is null))) or /* весь крім невидимого */
           (:imode is null))
          then
       begin
        select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         suspend;
         omaker_name = null;
         tmaker_id = null;
       end
      end
    end
   end
  end

      for select distinct n.nomen_id, n.nomen_code, n.nomen_name, n.datex_name, n.out_price,
                 rt.last_inprice, rt.rest, n.maker_id, n.is_visible, n.is_active,
                 n.type_nomen, n.w3_nomen_id
            from autoorders ao
                 inner join t_document_autoorder da on da.autoorder_id = ao.autoorder_id
                 left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
                 inner join nomen n on aor.aor_nomen_id = n.nomen_id
                 inner join rst rt on n.nomen_id = rt.nomen_id
           where da.documents_id = :pdocument_id and
                 rt.objects_id  = 1             and
                 ((n.is_exist   = 1)or(n.is_exist is null))
            into onomen_id, ocode, ofull_name, oshort_name, oprice_out,
                 oprice_in, orest, tmaker_id, pis_visible, pis_active,
                 ptype_nomen, pw3_nomen_id
   do begin
      if (not(exists(select * from docrec dr where dr.document_id = :pdocument_id and dr.nomen_id = :onomen_id))) then
      begin
      select count(c.calculation_id)
        from t_calculations c
       where c.nomen_id = :onomen_id
        into pcalculation_count;
         select count(nb.nom_bar_id) from nom_bar nb
         where nb.nomen_id = :onomen_id
          into obarcodes_cnt;

      if (:imode = 20) then begin
        select max(ao.autoorder_id)
          from t_document_autoorder da
               inner join autoorders ao on ao.autoorder_id  = da.autoorder_id
               left join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where aor.aor_nomen_id = :onomen_id and
               da.documents_id = :pdocument_id
          into plast_autoorder_id;

        select first(1) aor.aor_ordered
          from autoorders ao
               join ao_records aor on ao.autoorder_id = aor.aor_autoorder_id
         where ao.autoorder_id = :plast_autoorder_id and
               aor.aor_nomen_id = :onomen_id
         order by aor.ao_record_id desc
          into orest;

        if (:orest is null) then orest = 0.0;

        select sum(dr.kilk)
          from t_document_autoorder da
               inner join documents d on da.documents_id = d.document_id
               left join docrec dr on dr.document_id = d.document_id
         where da.autoorder_id = :plast_autoorder_id and
               da.documents_id != :pdocument_id and
               d.doc_lock != 0 and
               dr.nomen_id = :onomen_id
          into pkilk;

        if (:pkilk is null) then pkilk = 0.0;
        orest = :orest - :pkilk;
        if (:orest < 0.00001) then orest = 0.0;

      end

        if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;
         ow3_nomen_id = :pw3_nomen_id;
         if (:orest > 0) then
            suspend;
         omaker_name = null;
         tmaker_id = null;
      end
      end
end^


ALTER PROCEDURE PS_NOMEN_SYNC_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
declare variable pgrp_id integer;
BEGIN
select nv.ocode, nv.oshort_name, nv.ofull_name, nv.ogrp_id, nv.omin_rest,
       nv.orest, nv.oout_price, nv.oin_price, nv.oin_sum, nv.obarcodes_cnt,
       nv.ois_visible, nv.osg_id, nv.omaker_name, nv.odecr_value,
       nv.ow3_nomen_id
  from ps_nomen_view(:inomen_id) nv
  into :ocode, :oshort_name, :ofull_name, :ogrp_id, :omin_rest,
       :orest, :oout_price, :oin_price, :oin_sum, :obarcodes_cnt,
       :ois_visible, :osg_id, :omaker_name, :odecr_value,
       :ow3_nomen_id;

    if (:ow3_nomen_id is not null) then
    begin
      select first(1) ns.grp_id, ns.name, ns.ekka_name
        from t_nomens_sync ns
       where ns.w3_nomen_id = :ow3_nomen_id
        into :pgrp_id, :oname, :oekka_name;

      select g.grp_fullname
       from t_grps_sync g
      where g.grp_id = :pgrp_id
       into :ogrp_fullname;
    end

    suspend;

END^


ALTER PROCEDURE PS_NOMEN_UNITE (
    INOMEN0_ID INTEGER,
    INOMEN1_ID INTEGER)
RETURNS (
    OENABLED INTEGER,
    OMESSAGE VARCHAR(255))
AS
declare variable TBARCODE_ID integer;
declare variable TATTACH_RES integer;
begin
    update goods g
      set g.nomen_id = :inomen0_id
    where g.nomen_id = :inomen1_id;

  update docrec dr
      set dr.nomen_id = :inomen0_id
    where dr.nomen_id = :inomen1_id;

  update pricejournal pr
      set pr.nomen_id = :inomen0_id
    where pr.nomen_id = :inomen1_id;

  update rev_records rr
      set rr.nomen_id = :inomen0_id
    where rr.nomen_id = :inomen1_id;

  update t_markup_records mr
      set mr.nomen_id = :inomen0_id
    where mr.nomen_id = :inomen1_id;

  update t_rec_fillings rf
     set rf.nomen_id = :inomen0_id
   where rf.nomen_id = :inomen1_id;

  for select nb.barcode_id
        from nom_bar nb
       where nb.nomen_id = :inomen1_id
    into :tbarcode_id
  do begin
    select RIS_EXIST from s_barcode_attach(:tbarcode_id, :inomen0_id)
      into :tattach_res;
  end

  delete from nom_bar nb
    where nb.nomen_id = :inomen1_id;
  delete from rst rt
    where rt.nomen_id = :inomen1_id;

  insert into t_nomens_log(nomen_id, new_nomen_id) values(:inomen1_id, :inomen0_id);

  delete from nomen n
    where n.nomen_id = :inomen1_id;

  oenabled = 1;
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_UNITE_INFO (
    INOMEN_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
declare variable tcode varchar(7);
declare variable tfullname varchar(40);
declare variable tname varchar(27);
declare variable tout_price numeric(9,2);
begin
  select n.nomen_code, n.nomen_name, n.datex_name, n.out_price from nomen n
      where n.nomen_id = :inomen_id
    into :tcode, :tfullname, :tname, :tout_price;

  odescript = 'Код: ' || tcode;
  suspend;

  odescript = 'Повна назва: ' || tfullname;
  suspend;

  odescript = 'Коротка назва: ' || tname;
  suspend;

  odescript = 'Ціна: ' || tout_price;
  suspend;
end^


ALTER PROCEDURE PS_NOMEN_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
declare variable pnomen_id integer;
declare variable pmaker_id integer;
declare variable pdecr_id integer;
BEGIN
  select n.nomen_id, n.grp_id, n.nomen_code, n.datex_name, n.nomen_name,
               n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
               n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id
       from nomen n, rst rt
         where n.nomen_id = :inomen_id and
               n.nomen_id = rt.nomen_id
     into :pnomen_id, :ogrp_id, :ocode, :oshort_name, :ofull_name,
        :omin_rest, :orest, :oout_price, :oin_price, :oin_sum,
        :ois_visible, :osg_id, :pmaker_id, :pdecr_id, :ow3_nomen_id;

  if (:ois_visible is null) then
    ois_visible = 0;
  if (:omin_rest is null) then
    omin_rest = 0.0;
  select count(nb.barcode_id) from nom_bar nb
         where nb.nomen_id = :pnomen_id
     into :obarcodes_cnt;

  select m.maker_name from maker m
         where m.maker_id = :pmaker_id
     into :omaker_name;
  select td.decr_value from t_decrease td
         where td.decr_id = :pdecr_id
     into :odecr_value;
  suspend;
END^


ALTER PROCEDURE PS_NOMEN_VIEW_V2 (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
declare variable pmaker_id integer;
declare variable pdecr_id integer;
BEGIN
  select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
         n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
         n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
         n.type_nomen
    from nomen n, rst rt
   where n.nomen_id = :inomen_id and
         n.nomen_id = rt.nomen_id
    into onomen_id, ocode, oshort_name, ofull_name,
         omin_rest, orest, oout_price, oin_price, oin_sum,
         ois_visible, osg_id, pmaker_id, pdecr_id, ow3_nomen_id,
         otype_nomen;

  if (:ois_visible is null) then
    ois_visible = 0;
  if (:omin_rest is null) then
    omin_rest = 0.0;

  if ((:otype_nomen = 0)or(:otype_nomen is null)) then
    otype_nomen_name = 'Звичайний товар'; else
  if (:otype_nomen = 1) then
    otype_nomen_name = 'Сировина'; else
  if (:otype_nomen = 2) then
    otype_nomen_name = 'Продукція';

  select count(nb.barcode_id) from nom_bar nb
   where nb.nomen_id = :onomen_id
    into obarcodes_cnt;

  select m.maker_name from maker m
   where m.maker_id = :pmaker_id
    into omaker_name;

  select td.decr_value from t_decrease td
   where td.decr_id = :pdecr_id
    into odecr_value;
  suspend;
END^


ALTER PROCEDURE PS_NOMEN_VIEW_V3 (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OSG_ID INTEGER,
    OMAKER_NAME VARCHAR(40),
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
declare variable pmaker_id integer;
declare variable pdecr_id integer;
BEGIN
  select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
         n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
         n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
         n.type_nomen, n.is_in_discount, n.is_active, n.is_exist
    from nomen n, rst rt
   where n.nomen_id = :inomen_id and
         n.nomen_id = rt.nomen_id
    into onomen_id, ocode, oshort_name, ofull_name,
         omin_rest, orest, oout_price, oin_price, oin_sum,
         ois_visible, osg_id, pmaker_id, pdecr_id, ow3_nomen_id,
         otype_nomen, ois_in_discount, ois_active, ois_exist;

  if (:ois_visible is null) then
    ois_visible = 0;
  if (:omin_rest is null) then
    omin_rest = 0.0;

  if ((:otype_nomen = 0)or(:otype_nomen is null)) then
    otype_nomen_name = 'Звичайний товар'; else
  if (:otype_nomen = 1) then
    otype_nomen_name = 'Сировина'; else
  if (:otype_nomen = 2) then
    otype_nomen_name = 'Продукція';

  select count(nb.barcode_id) from nom_bar nb
   where nb.nomen_id = :onomen_id
    into obarcodes_cnt;

  select m.maker_name from maker m
   where m.maker_id = :pmaker_id
    into omaker_name;

  select td.decr_value from t_decrease td
   where td.decr_id = :pdecr_id
    into odecr_value;
  suspend;
END^


ALTER PROCEDURE PS_NOMENS_LINK_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
declare variable pgrp_id integer;
BEGIN

 for select rgrp_id from t_grp_childs_link(:igrp_id)
   into :ogrp_id
 do begin
   for select n.w3_nomen_id, n.code, n.ekka_name, n.name, n.receipt_date,
              n.grp_id
       from t_nomens_sync n
         where n.grp_id = :ogrp_id
     into :onomen_id, :ocode, :oekka_name, :oname, :oreceipt_date,
          :pgrp_id
   do begin
       select gs.grp_fullname
         from t_grps_sync gs
        where gs.grp_id = :pgrp_id
         into :ogrp_fullname;

       select count(nb.code_int)
         from t_nom_bars_sync nb
        where nb.w3_nomen_id = :onomen_id
         into :obarcodes_cnt;
         suspend;
     end
   end
END^


ALTER PROCEDURE PS_NOMENS_LINK_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
declare variable pgrp_id integer;
BEGIN
 ifilter = strupper1(:ifilter);

 for select rgrp_id from t_grp_childs_link(:igrp_id)
   into :ogrp_id
 do begin
   for select n.w3_nomen_id, n.code, n.ekka_name, n.name, n.receipt_date,
              n.grp_id
       from t_nomens_sync n
         where n.grp_id = :ogrp_id and
               strupper1(n.code) like :ifilter
     into :onomen_id, :ocode, :oekka_name, :oname, :oreceipt_date,
          :pgrp_id
   do begin
       select gs.grp_fullname
         from t_grps_sync gs
        where gs.grp_id = :pgrp_id
         into :ogrp_fullname;

       select count(nb.code_int) from t_nom_bars_sync nb
           where nb.w3_nomen_id = :onomen_id
         into :obarcodes_cnt;
       suspend;
     end
   end
END^


ALTER PROCEDURE PS_NOMENS_LINK_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
declare variable pgrp_id integer;
declare variable pfilter_int bigint;
BEGIN
 begin
   pfilter_int = cast(:ifilter as bigint);
   when any do
   begin
     exit;
   end
 end

 for select rgrp_id from t_grp_childs_link(:igrp_id)
   into :ogrp_id
 do begin
   for select n.w3_nomen_id, n.code, n.ekka_name, n.name, n.receipt_date,
              n.grp_id
       from t_nomens_sync n, t_nom_bars_sync nb
         where n.grp_id       = :ogrp_id      and
               nb.w3_nomen_id = n.w3_nomen_id and
               nb.code_int    = :pfilter_int
     into :onomen_id, :ocode, :oekka_name, :oname, :oreceipt_date,
          :pgrp_id
   do begin
       select gs.grp_fullname
         from t_grps_sync gs
        where gs.grp_id = :pgrp_id
         into :ogrp_fullname;

       select count(nb.code_int) from t_nom_bars_sync nb
           where nb.w3_nomen_id = :onomen_id
         into :obarcodes_cnt;
         suspend;
     end
   end
END^


ALTER PROCEDURE PS_NOMENS_LINK_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OEKKA_NAME VARCHAR(26),
    ONAME VARCHAR(40),
    OGRP_FULLNAME VARCHAR(200),
    OBARCODES_CNT VARCHAR(6),
    ORECEIPT_DATE DATE,
    OGRP_ID INTEGER)
AS
declare variable pgrp_id integer;
BEGIN
  ifilter = strupper1(:ifilter);

 for select rgrp_id from t_grp_childs_link(:igrp_id)
   into :ogrp_id
 do begin
   for select n.w3_nomen_id, n.code, n.ekka_name, n.name, n.receipt_date,
              n.grp_id
       from t_nomens_sync n
         where n.grp_id = :ogrp_id and
               strupper1(n.name) like :ifilter
     into :onomen_id, :ocode, :oekka_name, :oname, :oreceipt_date,
          :pgrp_id
   do begin
       select gs.grp_fullname
         from t_grps_sync gs
        where gs.grp_id = :pgrp_id
         into :ogrp_fullname;

       select count(nb.code_int) from t_nom_bars_sync nb
           where nb.w3_nomen_id = :onomen_id
         into :obarcodes_cnt;
         suspend;
     end
   end
END^


ALTER PROCEDURE PS_NOMENS_PRICES (
    INOMENS_LIST VARCHAR(1000))
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER,
    IS_CHECK_DISC INTEGER)
AS
declare variable pis_in_discount smallint;
begin
  for select n.nomen_id, n.nomen_code, n.nomen_name, n.out_price, n.is_in_discount
        from nomen n
       where isinliststr(:inomens_list, n.nomen_id) = 1
        into nomen_id, nomen_code, nomen_name, out_price, pis_in_discount
  do begin
    if (:pis_in_discount = 1) then
      begin
        is_check_disc = 1;
        is_check = 0;
      end else
      begin
        is_check_disc = 0;
        is_check = 1;
      end
    suspend;
  end
end^


ALTER PROCEDURE PS_NOMENS_SYNC_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
declare variable pgrp_id integer;
BEGIN
for select nv.onomen_id, nv.ocode, nv.oshort_name, nv.ofull_name, nv.ogrp_id, nv.omin_rest,
       nv.orest, nv.oout_price, nv.oin_price, nv.oin_sum, nv.obarcodes_cnt,
       nv.ois_visible, nv.osg_id, nv.omaker_name, nv.odecr_value,
       nv.ow3_nomen_id
  from ps_nomens_view(:iflag, :igrp_id) nv
  into :onomen_id, :ocode, :oshort_name, :ofull_name, :ogrp_id, :omin_rest,
       :orest, :oout_price, :oin_price, :oin_sum, :obarcodes_cnt,
       :ois_visible, :osg_id, :omaker_name, :odecr_value,
       :ow3_nomen_id
  do begin
    if (:ow3_nomen_id is not null) then
    begin
      select first(1) ns.grp_id, ns.name, ns.ekka_name
        from t_nomens_sync ns
       where ns.w3_nomen_id = :ow3_nomen_id
        into :pgrp_id, :oname, :oekka_name;

      select g.grp_fullname
       from t_grps_sync g
      where g.grp_id = :pgrp_id
       into :ogrp_fullname;
    end
    else
    begin
      ogrp_fullname = null; oname = null; oekka_name = null;
    end

    suspend;
  end
END^


ALTER PROCEDURE PS_NOMENS_SYNC_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
declare variable pgrp_id integer;
BEGIN
for select nv.onomen_id, nv.ocode, nv.oshort_name, nv.ofull_name, nv.ogrp_id, nv.omin_rest,
       nv.orest, nv.oout_price, nv.oin_price, nv.oin_sum, nv.obarcodes_cnt,
       nv.ois_visible, nv.osg_id, nv.omaker_name, nv.odecr_value,
       nv.ow3_nomen_id
  from ps_nomens_view_0(:iflag, :igrp_id, :ifilter) nv
  into :onomen_id, :ocode, :oshort_name, :ofull_name, :ogrp_id, :omin_rest,
       :orest, :oout_price, :oin_price, :oin_sum, :obarcodes_cnt,
       :ois_visible, :osg_id, :omaker_name, :odecr_value,
       :ow3_nomen_id
  do begin
    if (:ow3_nomen_id is not null) then
    begin
      select first(1) ns.grp_id, ns.name, ns.ekka_name
        from t_nomens_sync ns
       where ns.w3_nomen_id = :ow3_nomen_id
        into :pgrp_id, :oname, :oekka_name;

      select g.grp_fullname
       from t_grps_sync g
      where g.grp_id = :pgrp_id
       into :ogrp_fullname;
    end
        else
    begin
      ogrp_fullname = null; oname = null; oekka_name = null;
    end
    suspend;
  end
END^


ALTER PROCEDURE PS_NOMENS_SYNC_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
declare variable pgrp_id integer;
BEGIN
for select nv.onomen_id, nv.ocode, nv.oshort_name, nv.ofull_name, nv.ogrp_id, nv.omin_rest,
       nv.orest, nv.oout_price, nv.oin_price, nv.oin_sum, nv.obarcodes_cnt,
       nv.ois_visible, nv.osg_id, nv.omaker_name, nv.odecr_value,
       nv.ow3_nomen_id
  from ps_nomens_view_1_v1(:iflag, :igrp_id, :ifilter) nv
  into :onomen_id, :ocode, :oshort_name, :ofull_name, :ogrp_id, :omin_rest,
       :orest, :oout_price, :oin_price, :oin_sum, :obarcodes_cnt,
       :ois_visible, :osg_id, :omaker_name, :odecr_value,
       :ow3_nomen_id
  do begin
    if (:ow3_nomen_id is not null) then
    begin
      select first(1) ns.grp_id, ns.name, ns.ekka_name
        from t_nomens_sync ns
       where ns.w3_nomen_id = :ow3_nomen_id
        into :pgrp_id, :oname, :oekka_name;

      select g.grp_fullname
       from t_grps_sync g
      where g.grp_id = :pgrp_id
       into :ogrp_fullname;
    end
        else
    begin
     ogrp_fullname = null; oname = null; oekka_name = null;
    end

    suspend;
  end
END^


ALTER PROCEDURE PS_NOMENS_SYNC_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OGRP_FULLNAME VARCHAR(200),
    ONAME VARCHAR(40),
    OEKKA_NAME VARCHAR(26))
AS
declare variable pgrp_id integer;
BEGIN
for select nv.onomen_id, nv.ocode, nv.oshort_name, nv.ofull_name, nv.ogrp_id, nv.omin_rest,
       nv.orest, nv.oout_price, nv.oin_price, nv.oin_sum, nv.obarcodes_cnt,
       nv.ois_visible, nv.osg_id, nv.omaker_name, nv.odecr_value,
       nv.ow3_nomen_id
  from ps_nomens_view_2(:iflag, :igrp_id, :ifilter) nv
  into :onomen_id, :ocode, :oshort_name, :ofull_name, :ogrp_id, :omin_rest,
       :orest, :oout_price, :oin_price, :oin_sum, :obarcodes_cnt,
       :ois_visible, :osg_id, :omaker_name, :odecr_value,
       :ow3_nomen_id
  do begin
    if (:ow3_nomen_id is not null) then
    begin
      select first(1) ns.grp_id, ns.name, ns.ekka_name
        from t_nomens_sync ns
       where ns.w3_nomen_id = :ow3_nomen_id
        into :pgrp_id, :oname, :oekka_name;

      select g.grp_fullname
       from t_grps_sync g
      where g.grp_id = :pgrp_id
       into :ogrp_fullname;
    end
        else
    begin
      ogrp_fullname = null; oname = null; oekka_name = null;
    end
    suspend;
  end
END^


ALTER PROCEDURE PS_NOMENS_VIEW (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
   into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id
         from nomen n, rst rt
        where n.grp_id     = :ogrp_id   and
              rt.nomen_id  = n.nomen_id and
              ((n.is_exist = 1)or(n.is_exist is null))
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id
   do begin
     if (:ois_visible is null) then ois_visible = 0;
     if ((:iflag = 0) and (:ois_visible = 1)) then
     begin
        if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end  else
     --or
      --((:iflag = 1) and (:ois_visible in(0, 1)))) then
     if (:iflag = 1) then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_0 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
   into :ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
               n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
               n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id
       from nomen n, rst rt
         where n.grp_id = :ogrp_id and
               rt.nomen_id = n.nomen_id and
               strupper1(n.nomen_code) like :ifilter and
               ((n.is_exist = 1)or(n.is_exist is null))
     into :onomen_id, :ocode, :oshort_name, :ofull_name,
        :omin_rest, :orest, :oout_price, :oin_price, :oin_sum,
        :ois_visible, :osg_id, :tmaker_id, :tdecrease_id, :ow3_nomen_id
   do begin
     if (:ois_visible is null) then ois_visible = 0;
     if ((:iflag = 0) and (:ois_visible = 1)) then
     begin
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

                if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end 
     else 
     --or
         --((:iflag = 1) and (:ois_visible in(0, 1)))) then
     if (:iflag = 1) then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

              if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end
   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_0_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen
         from nomen n, rst rt
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              strupper1(n.nomen_code) like :ifilter and
              ((n.is_exist = 1)or(n.is_exist is null))
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_0_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(20))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen, n.is_in_discount, n.is_active, n.is_exist
         from nomen n, rst rt
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              strupper1(n.nomen_code) like :ifilter and
              ((n.is_exist = 1)or(n.is_exist is null))
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen, ois_in_discount, ois_active, ois_exist
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
   into :ogrp_id
 do begin
   for select distinct n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
               n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
               n.is_visible, n.sg_id, n.maker_id, n.decrease_id
       from nomen n, rst rt, nom_bar nb, barcode b
         where n.grp_id = :ogrp_id and
               rt.nomen_id = n.nomen_id and
               nb.nomen_id = n.nomen_id and
               nb.barcode_id = b.barcode_id and
               b.code like (:ifilter)       and
               ((n.is_exist = 1)or(n.is_exist is null))
     into :onomen_id, :ocode, :oshort_name, :ofull_name,
        :omin_rest, :orest, :oout_price, :oin_price, :oin_sum,
        :ois_visible, :osg_id, :tmaker_id, :tdecrease_id
   do begin
     if (:ois_visible is null) then ois_visible = 0;
     if (((:iflag = 0) and (:ois_visible = 1)) or
         ((:iflag = 1) and (:ois_visible in(0, 1)))) then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end
   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_1_V1 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
   into :ogrp_id
 do begin
   for select distinct n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
               n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
               n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id
       from nomen n, rst rt, nom_bar nb, barcode b
         where n.grp_id = :ogrp_id and
               rt.nomen_id = n.nomen_id and
               nb.nomen_id = n.nomen_id and
               nb.barcode_id = b.barcode_id and
               ((n.is_exist = 1)or(n.is_exist is null)) and
               b.code = :ifilter
     into :onomen_id, :ocode, :oshort_name, :ofull_name,
        :omin_rest, :orest, :oout_price, :oin_price, :oin_sum,
        :ois_visible, :osg_id, :tmaker_id, :tdecrease_id, :ow3_nomen_id
   do begin
     if (:ois_visible is null) then ois_visible = 0;
     if ((:iflag = 0) and (:ois_visible = 1)) then
     begin
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end else 
     --or
     --  ((:iflag = 1) and (:ois_visible in(0, 1)))) then
     if (:iflag = 1) then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end
   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_1_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select distinct n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen
         from nomen n, rst rt, nom_bar nb, barcode b
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              nb.nomen_id = n.nomen_id and
              nb.barcode_id = b.barcode_id and
              ((n.is_exist = 1)or(n.is_exist is null)) and
              b.code = :ifilter
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_1_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
declare variable pcode_int bigint;
BEGIN
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

  begin
    pcode_int = cast(:ifilter as bigint);
    ifilter = cast(:pcode_int as varchar(27));
  when any do
  begin

  end
  end

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select distinct n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen, n.is_in_discount, n.is_active, n.is_exist
         from nomen n, rst rt, nom_bar nb, barcode b
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              nb.nomen_id = n.nomen_id and
              nb.barcode_id = b.barcode_id and
              ((n.is_exist = 1)or(n.is_exist is null)) and
              (b.code like '0'||'%'||:ifilter or
               b.code = :ifilter)
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen, ois_in_discount, ois_active, ois_exist
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
      where c.config_id = 1 and
            c.module = 'store_nomens'
    into :tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
   into :ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
               n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
               n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id
       from nomen n, rst rt
         where n.grp_id = :ogrp_id and
               rt.nomen_id = n.nomen_id and
               ((n.is_exist = 1)or(n.is_exist is null)) and
               strupper1(n.nomen_name) like :ifilter
     into :onomen_id, :ocode, :oshort_name, :ofull_name,
        :omin_rest, :orest, :oout_price, :oin_price, :oin_sum,
        :ois_visible, :osg_id, :tmaker_id, :tdecrease_id, ow3_nomen_id
   do begin
     if (:ois_visible is null) then ois_visible = 0;
     if ((:iflag = 0) and (:ois_visible = 1)) then
     begin
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end else 
     --or
         --((:iflag = 1) and (:ois_visible in(0, 1)))) then
     if (:iflag = 1) then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;
       if (:omin_rest is null) then
         omin_rest = 0.0;

       select count(nb.barcode_id) from nom_bar nb
           where nb.nomen_id = :onomen_id
         into :obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
             from maker m
           where m.maker_id = :tmaker_id
         into :omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0; else
       select td.decr_value from t_decrease td
         where td.decr_id = :tdecrease_id
        into :odecr_value;
       suspend;
       omaker_name = null;
       tmaker_id = null;
     end
   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_2_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen
         from nomen n, rst rt
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              ((n.is_exist = 1)or(n.is_exist is null)) and
              strupper1(n.nomen_name) like :ifilter
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_2_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER,
    IFILTER VARCHAR(256))
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  ifilter = strupper1(:ifilter);
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen, n.is_in_discount, n.is_active, n.is_exist
         from nomen n, rst rt
        where n.grp_id = :ogrp_id and
              rt.nomen_id = n.nomen_id and
              ((n.is_exist = 1)or(n.is_exist is null)) and
              strupper1(n.nomen_name) like :ifilter
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen, ois_in_discount, ois_active, ois_exist
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_V2 (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40))
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen
         from nomen n, rst rt
        where n.grp_id     = :ogrp_id   and
              rt.nomen_id  = n.nomen_id and
              ((n.is_exist = 1)or(n.is_exist is null))
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENS_VIEW_V3 (
    IFLAG INTEGER,
    IGRP_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(26),
    OFULL_NAME VARCHAR(40),
    OGRP_ID INTEGER,
    OMIN_REST DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OBARCODES_CNT VARCHAR(6),
    OIS_VISIBLE SMALLINT,
    OMAKER_NAME VARCHAR(40),
    OSG_ID INTEGER,
    ODECR_VALUE DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER,
    OTYPE_NOMEN SMALLINT,
    OTYPE_NOMEN_NAME VARCHAR(40),
    OIS_IN_DISCOUNT SMALLINT,
    OIS_ACTIVE SMALLINT,
    OIS_EXIST SMALLINT)
AS
declare variable tmarker varchar(64);
declare variable tmaker_id integer;
declare variable tdecrease_id integer;
BEGIN
  select c.marker from t_configs c
   where c.config_id = 1 and
         c.module    = 'store_nomens'
    into tmarker;

 for select rgrp_id from T_GRP_CHILDS(:igrp_id)
       into ogrp_id
 do begin
   for select n.nomen_id, n.nomen_code, n.datex_name, n.nomen_name,
              n.minkilk, rt.rest, n.out_price, rt.last_inprice, rt.rest_sum,
              n.is_visible, n.sg_id, n.maker_id, n.decrease_id, n.w3_nomen_id,
              n.type_nomen, n.is_in_discount, n.is_active, n.is_exist
         from nomen n, rst rt
        where n.grp_id     = :ogrp_id   and
              rt.nomen_id  = n.nomen_id and
              ((n.is_exist = 1)or(n.is_exist is null))
         into onomen_id, ocode, oshort_name, ofull_name,
              omin_rest, orest, oout_price, oin_price, oin_sum,
              ois_visible, osg_id, tmaker_id, tdecrease_id, ow3_nomen_id,
              otype_nomen, ois_in_discount, ois_active, ois_exist
   do begin
     if (:ois_visible is null) then ois_visible = 0;

     if (((:iflag = 0) and (:ois_visible = 1))or /* Лише видимий */
         (:iflag  = 1))                          /* Весь товар   */
     then
     begin
       if (:ois_visible is null) then
         ois_visible = 0;

       if (:omin_rest is null) then
         omin_rest = 0.0;

       if ((:otype_nomen = 0)or(:otype_nomen is null)) then
         otype_nomen_name = 'Звичайний товар'; else
       if (:otype_nomen = 1) then
         otype_nomen_name = 'Сировина'; else
       if (:otype_nomen = 2) then
         otype_nomen_name = 'Продукція';

       select count(nb.barcode_id) from nom_bar nb
        where nb.nomen_id = :onomen_id
         into obarcodes_cnt;

       if (:tmarker <> 'no') then
         select m.maker_name
           from maker m
          where m.maker_id = :tmaker_id
           into omaker_name;

       if (tdecrease_id is null) then
          odecr_value = 0;
       else
       select td.decr_value from t_decrease td
        where td.decr_id = :tdecrease_id
         into odecr_value;

       suspend;
       omaker_name = null;
       tmaker_id = null;
     end

   end
 END
END^


ALTER PROCEDURE PS_NOMENZVIT_P1 (
    IDATE DATE)
RETURNS (
    ONAMECLIENT VARCHAR(50),
    OSUM DOUBLE PRECISION,
    OINCOMINGDOC_SUM DOUBLE PRECISION,
    OMARKUPDOC DOUBLE PRECISION)
AS
declare variable tclient_id integer;
declare variable tdocument_id integer;
begin
  /* Procedure Text */
for select d.document_id, d.objects_id
    from DOCUMENTS d
    where (d.typedoc_id = 1) and (d.date_cr = :idate)
    order by d.document_id
    into :tdocument_id, :tclient_id

  do
  begin
      select  c.name
         from clients c
         where c.clients_id = :tclient_id
         into  :onameclient;

      /*сума приходу без ПДВ та торгова націнка по клієнтах */
      select around(sum(dr.insum)), around(sum((n.out_price-dr.price)*dr.kilk))
         from docrec dr, nomen n, documents d
         where (:tdocument_id = dr.document_id) AND
               (d.document_id = dr.document_id) and
               (d.typedoc_id != 10            ) and
               (n.nomen_id    = dr.nomen_id   ) and
               ((n.sg_id <> 4) or (n.sg_id is null))
         into  :oincomingdoc_sum, :omarkupdoc;

      /*переміщення*/
      osum = :oincomingdoc_sum - :omarkupdoc;

 suspend;
  end

END^


ALTER PROCEDURE PS_PACT_DEL (
    IPACT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TCOUNT INTEGER;
begin
  ocaption = '';
  ocount = 0;
  tcount = :ocount;
  suspend;

  if (tcount = 0) then/* залежностей немає - отже видаляємо */
  begin
    delete from t_pacts p where p.pact_id = :ipact_id;
  end
end^


ALTER PROCEDURE PS_PACT_INS (
    ITOKEN VARCHAR(14),
    ICLIENT_ID INTEGER,
    IPACT_SUM DOUBLE PRECISION,
    IPACT_SUM_PDV DOUBLE PRECISION,
    IDATE_BEGIN DATE,
    IDATE_END DATE)
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_pacts_id, 1);

  insert into t_pacts(pact_id, token, client_id, pact_sum, pact_sum_pdv, date_begin, date_end)
          values(:oid, :itoken, :iclient_id, :ipact_sum, :ipact_sum_pdv, :idate_begin, :idate_end);
  suspend;
end^


ALTER PROCEDURE PS_PACT_VIEW (
    IPACT_ID INTEGER)
RETURNS (
    OPACT_ID INTEGER,
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OCLIENT_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    OPACT_SUM DOUBLE PRECISION,
    OPACT_SUM_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHORTNAME VARCHAR(30),
    ODOCUMENT_NUM VARCHAR(14))
AS
BEGIN
  select p.pact_id, p.token, p.date_begin, p.date_end, p.client_id, p.document_id, p.pact_sum, p.pact_sum_pdv
                from t_pacts p
       where p.pact_id = :ipact_id
    into :opact_id, :otoken, :odate_begin, :odate_end, :oclient_id, :odocument_id, :opact_sum, :opact_sum_pdv;

  select c.name, c.shortname from clients c
      where c.clients_id = :oclient_id
    into :oclient_name, :oclient_shortname;

  if (:odocument_id is not null) then
  begin
    select d.doc_num from documents d
        where d.document_id = :odocument_id
      into :odocument_num;
  end

  suspend;
END^


ALTER PROCEDURE PS_PACTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPACT_ID INTEGER,
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OCLIENT_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    OPACT_SUM DOUBLE PRECISION,
    OPACT_SUM_PDV DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OCLIENT_SHORTNAME VARCHAR(30),
    ODOCUMENT_NUM VARCHAR(14))
AS
BEGIN
  for select p.pact_id, p.token, p.date_begin, p.date_end, p.client_id, p.document_id, p.pact_sum, p.pact_sum_pdv
                from t_pacts p
       where ((p.date_begin between :idate0 and :idate1) or (p.date_end between :idate0 and :idate1))
    into :opact_id, :otoken, :odate_begin, :odate_end, :oclient_id, :odocument_id, :opact_sum, :opact_sum_pdv
  do begin
    select c.name, c.shortname from clients c
        where c.clients_id = :oclient_id
      into :oclient_name, :oclient_shortname;

    if (:odocument_id is not null) then
    begin
      select d.doc_num from documents d
          where d.document_id = :odocument_id
        into :odocument_num;
    end

    suspend;
    odocument_id = null;
    odocument_num = null;
  end
END^


ALTER PROCEDURE PS_PAY_DEL (
    IPAY_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TCOUNT INTEGER;
begin
  ocaption = '';
  ocount = 0;
  tcount = :ocount;
  suspend;

  if (tcount = 0) then/* залежностей немає - отже видаляємо */
  begin
    delete from t_pays p where p.pay_id = :ipay_id;
  end
end^


ALTER PROCEDURE PS_PAY_INS (
    IPAY_TYPE_ID INTEGER,
    IDOCUMENT_ID INTEGER,
    IPAY_SUM DOUBLE PRECISION,
    IPAY_DATE DATE)
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_pays_id, 1);

  insert into t_pays(pay_id, pay_type_id, document_id, pay_sum, pay_date)
  values(:oid, :ipay_type_id, :idocument_id, :ipay_sum, :ipay_date);
  suspend;
end^


ALTER PROCEDURE PS_PAY_UPD (
    IPAY_ID INTEGER,
    IPAY_TYPE_ID INTEGER,
    IPAY_SUM DOUBLE PRECISION,
    IPAY_DATE DATE)
RETURNS (
    OID INTEGER)
AS
begin
  oid = ipay_id;

  update t_pays p set
    p.pay_type_id = :ipay_type_id,
    p.pay_sum = :ipay_sum,
    p.pay_date = :ipay_date
  where p.pay_id = :ipay_id;
  suspend;
end^


ALTER PROCEDURE PS_PAY_VIEW (
    IPAY_ID INTEGER)
RETURNS (
    OID INTEGER,
    OPAY_TYPE_ID INTEGER,
    OPAY_TYPE_NAME VARCHAR(50),
    ODOCUMENT_ID INTEGER,
    OPAY_SUM DOUBLE PRECISION,
    OPAY_DATE DATE)
AS
begin
  select p.pay_id, p.pay_type_id, pt.typepay_name, p.document_id, p.pay_sum, p.pay_date
  from t_pays p, typepay pt where p.pay_type_id = pt.typepay_id and
       p.pay_id = :ipay_id
  into :oid, :opay_type_id, :opay_type_name, :odocument_id, :opay_sum,
    :opay_date;
  suspend;
end^


ALTER PROCEDURE PS_PAYMENT_DEL (
    IPAYMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
begin
  ocaption = 'записів в зуєстрі';
  select count(rr.id) from t_payment_recs rr
   where rr.payment_id = :ipayment_id
    into ocount;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_payments r
      where r.id = :ipayment_id;
  end
end^


ALTER PROCEDURE PS_PAYMENT_INS (
    ICLIENTS_ID INTEGER,
    ISTAFF_ID INTEGER,
    IPAY_DATE DATE)
RETURNS (
    OPAYMENT_ID INTEGER)
AS
begin
  opayment_id = GEN_ID(GEN_T_PAYMENTS_ID,1);
  insert into t_payments(id, clients_id, staff_id, pay_date)
     values(:opayment_id, :iclients_id, :istaff_id, :ipay_date);
  suspend;
end^


ALTER PROCEDURE PS_PAYMENT_REC_INS (
    IPAYMENT_ID INTEGER,
    ICLIENTS_ID INTEGER,
    ICATEGORY VARCHAR(1),
    INOTE VARCHAR(20),
    IDOCDATE DATE,
    IFOUNDATION VARCHAR(20),
    ISUMA DOUBLE PRECISION)
RETURNS (
    OPAYMENT_REC_ID INTEGER)
AS
begin
  opayment_rec_id = GEN_ID(GEN_NEW_TABLE_ID,1);
  insert into t_payment_recs(id, payment_id, clients_id, category, note, docdate, foundation, suma)
    values(:opayment_rec_id, :ipayment_id, :iclients_id, :icategory, :inote, :idocdate, :ifoundation, :isuma);
  suspend;
end^


ALTER PROCEDURE PS_PAYMENT_REC_VIEW (
    IPAYMENT_REC_ID INTEGER)
RETURNS (
    OPAYMENT_REC_ID INTEGER,
    OPAYMENT_ID INTEGER,
    ONOM INTEGER,
    OCLIENT_ID INTEGER,
    ONOTE VARCHAR(20),
    ODOCDATE DATE,
    OFOUNDATION VARCHAR(20),
    OSUMA DOUBLE PRECISION,
    OCATEGORY VARCHAR(1))
AS
begin
  select pr.id, pr.payment_id, pr.clients_id, pr.note, pr.docdate, pr.foundation, pr.suma, pr.category
    from t_payment_recs pr
   where pr.payment_id = :ipayment_rec_id
    into opayment_rec_id, opayment_id, oclient_id, onote, odocdate, ofoundation, osuma, ocategory;

  select (count(pr.id) + 1) from t_payment_recs pr
   where pr.payment_id = :opayment_id
    into onom;

    suspend;
end^


ALTER PROCEDURE PS_PAYMENT_RECORD_DEL (
    IPAYMENT_RECORD_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
begin
  ocaption = 'записів в замовленні';
  ocount = 0;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_payment_recs aor
      where aor.id = :ipayment_record_id;
  end
end^


ALTER PROCEDURE PS_PAYMENT_RECS_VIEW (
    IPAYMENT_ID INTEGER)
RETURNS (
    OPAYMENT_REC_ID INTEGER,
    OPAYMENT_ID INTEGER,
    ONOM INTEGER,
    OCLIENT_ID INTEGER,
    ONOTE VARCHAR(20),
    ODOCDATE DATE,
    OFOUNDATION VARCHAR(20),
    OSUMA DOUBLE PRECISION,
    OCATEGORY VARCHAR(1))
AS
begin
  onom = 1;
  for select pr.id, pr.payment_id, pr.clients_id, pr.note, pr.docdate, pr.foundation, pr.suma, pr.category
        from t_payment_recs pr
       where pr.payment_id = :ipayment_id
        into opayment_rec_id, opayment_id, oclient_id, onote, odocdate, ofoundation, osuma, ocategory
  do begin
    suspend;
    onom = :onom + 1;
  end
end^


ALTER PROCEDURE PS_PAYMENT_VIEW (
    IPAYMENT_ID INTEGER)
RETURNS (
    OPAYMENT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    OPAY_DATE DATE,
    OSUM DOUBLE PRECISION)
AS
begin
  select p.id, p.clients_id, p.staff_id, p.pay_date, sum(pr.suma)
    from t_payments p
         left join t_payment_recs pr on pr.payment_id = p.id
   where p.id = :ipayment_id
   group by p.id, p.clients_id, p.staff_id, p.pay_date
    into opayment_id, oclients_id, ostaff_id, opay_date, osum;
  if (:osum is null) then osum = 0;
  suspend;
end^


ALTER PROCEDURE PS_PAYMENTS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OPAYMENT_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OSTAFF_ID INTEGER,
    OPAY_DATE DATE,
    OSUM DOUBLE PRECISION)
AS
begin
  for select p.id, p.clients_id, p.staff_id, p.pay_date, sum(pr.suma)
        from t_payments p
             left join t_payment_recs pr on pr.payment_id = p.id
       where p.pay_date between :idate0 and :idate1
        group by p.id, p.clients_id, p.staff_id, p.pay_date
        into opayment_id, oclients_id, ostaff_id, opay_date, osum
  do begin
      if (:osum is null) then osum = 0;
    suspend;
  end
end^


ALTER PROCEDURE PS_PAYS_RECALC (
    IDOCUMENT_ID INTEGER)
AS
declare variable tdiscount double precision;
declare variable tsum_out_pdv double precision;
declare variable tpay_sum_out_pdv double precision;
declare variable tpay_state integer;
declare variable tpay_prew_type integer;
declare variable tpay_type integer;
declare variable tdoc_pay_type integer;
begin
  select d.oplata_type, d.disc_persent from documents d
   where d.document_id = :idocument_id
    into tdoc_pay_type, tdiscount;

  select around(drs.sum_out_pdv)
    from S_DOCREC_SUM(:idocument_id, :tdiscount) drs
    into tsum_out_pdv;

  select sum(around(p.pay_sum)) from t_pays p
   where p.document_id = :idocument_id
    into tpay_sum_out_pdv;

  if ((:tpay_sum_out_pdv is null) or (:tpay_sum_out_pdv = 0)) then
    tpay_state = 0;
  else if (absrizn(:tsum_out_pdv, :tpay_sum_out_pdv) < 0.01) then
    tpay_state = 2;
  else if (:tsum_out_pdv > :tpay_sum_out_pdv) then
    tpay_state = 1;
  else if (:tsum_out_pdv < :tpay_sum_out_pdv) then
    tpay_state = 3;

/*  <null> або 0 - Нема проплати
1 - часткова проплата
2 - повна проплата
3 - переплата (для контролю)  */

  tpay_type = null;
  tpay_prew_type = null;
  for select p.pay_type_id from t_pays p
       where p.document_id = :idocument_id
        into tpay_type
  do begin
    if (:tpay_prew_type is not null) then
      if (:tpay_type <> :tpay_prew_type) then
        tpay_type = 4;
    tpay_prew_type = :tpay_type;
  end

  if (tpay_type is null) then
    tpay_type = :tdoc_pay_type;

  update documents d
         set d.oplata_state = :tpay_state,
             d.oplata_type = :tpay_type
    where d.document_id = :idocument_id;
end^


ALTER PROCEDURE PS_PAYS_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OID INTEGER,
    OPAY_TYPE_ID INTEGER,
    OPAY_TYPE_NAME VARCHAR(50),
    ODOCUMENT_ID INTEGER,
    OPAY_SUM DOUBLE PRECISION,
    OPAY_DATE DATE)
AS
begin
  for
  select p.pay_id, p.pay_type_id, pt.typepay_name, p.document_id, p.pay_sum, p.pay_date
  from t_pays p, typepay pt where p.pay_type_id = pt.typepay_id and
       p.document_id = :idocument_id
  into :oid, :opay_type_id, :opay_type_name, :odocument_id, :opay_sum,
    :opay_date
  do
  begin
    suspend;
  end
end^


ALTER PROCEDURE PS_POPUP_CLIENT_VIEW (
    ICLIENT_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT)
AS
BEGIN
  /* by kardcode */
  select c.clients_id, c.clients_code, c.shortname, c.name,
                   c.adress, c.ispdv, c.typeclient_id
       from clients c
         where c.clients_id = :iclient_id
     into :oclient_id, :ocode, :oshort_name, :ofull_name,
        oadress, :ois_pdv, :otypeclient_id;

  suspend;
END^


ALTER PROCEDURE PS_POPUP_CLIENTS_VIEW (
    IFLAG SMALLINT,
    IGRPC_ID INTEGER)
RETURNS (
    OCLIENT_ID INTEGER,
    OCODE VARCHAR(7),
    OSHORT_NAME VARCHAR(30),
    OFULL_NAME VARCHAR(50),
    OADRESS VARCHAR(50),
    OGRPC_ID INTEGER,
    OIS_PDV SMALLINT,
    OTYPECLIENT_ID SMALLINT)
AS
declare variable PW3_CLIENT_ID integer;
declare variable PIS_ACTIVE smallint;
declare variable PIS_VISIBLE smallint;
BEGIN
 /* by kardcode */
for select rgrpc_id from T_GRPC_CHILDS(:Igrpc_id)
      into ogrpc_id
do begin
  for select c.clients_id, c.clients_code, c.shortname, c.name,
             c.adress, c.ispdv, c.typeclient_id, c.w3_client_id, c.is_active,
             c.is_visible
        from clients c
       where c.grpc_id = :ogrpc_id and
             c.clients_id > 1 and c.is_visible > 0 and c.is_active > 0
        into oclient_id, ocode, oshort_name, ofull_name,
             oadress, ois_pdv, otypeclient_id, pw3_client_id, pis_active,
             pis_visible
  do begin
    if (((:iflag = 1) and (:otypeclient_id = 1)) or
        ((:iflag = 2) and (:otypeclient_id in(3, 4)) /*$$IBEC$$ and (:pw3_client_id is not null) $$IBEC$$*/) or
        ((:iflag = 7) and (:otypeclient_id in (3, 4))/*$$IBEC$$  and (:pw3_client_id is not null) $$IBEC$$*/ and (:pis_active = 1)) or
        ((:iflag = 3) and (:otypeclient_id in (2, 4)) /*$$IBEC$$ and (:pw3_client_id is not null) $$IBEC$$*/) or
        ((:iflag = 4) and (:otypeclient_id in (2, 4))/*$$IBEC$$  and (:pw3_client_id is not null) $$IBEC$$*/ and (:pis_active = 1)) or
        ((:iflag = 5) and (:otypeclient_id = 5) /*$$IBEC$$ and (:pw3_client_id is not null) $$IBEC$$*/) or
        ((:iflag = 6) and (:otypeclient_id in (2, 4, 5))/*$$IBEC$$  and (:pw3_client_id is not null) $$IBEC$$*/ and (:pis_active = 1) and (:pis_visible = 1))) then
    begin
      suspend;
    end
  end
END
END^


ALTER PROCEDURE PS_POPUP_DECREASE_VIEW (
    IDECR_ID INTEGER)
RETURNS (
    ODECR_ID INTEGER,
    ODECR_NAME VARCHAR(256),
    ODECR_VALUE DOUBLE PRECISION,
    ODECR_TYPE_NAME VARCHAR(100))
AS
begin
for select d.decr_id, d.decr_name, d.decr_value, dt.name
  from t_decrease d, t_decr_type dt
   where d.decr_id = :idecr_id and
         d.decr_type_id = dt.decr_type_id
   into :odecr_id, :odecr_name, :odecr_value, :odecr_type_name
  do begin 
  suspend;
  end
end^


ALTER PROCEDURE PS_POPUP_LIABLE_VIEW (
    ILIABLE_ID INTEGER)
RETURNS (
    OLIABLE_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(30),
    OJOB_NAME VARCHAR(30))
AS
DECLARE VARIABLE TSURNAME VARCHAR(20);
DECLARE VARIABLE TNAME VARCHAR(20);
DECLARE VARIABLE TPATRONYMIC VARCHAR(20);
DECLARE VARIABLE TJOBS_ID INTEGER;
BEGIN
  select s.staff_id, s.staff_id, s.surname, s.name, s.patronymic,
            s.jobs_id
      from  staff s
    where s.staff_id = :iliable_id
      into :oliable_id, :ocode, :tsurname, :tname, :tpatronymic,
           :tjobs_id;

  ofull_name=:tsurname||' '||firstchar(:tname)||'.'||firstchar(:tpatronymic)||'.';

  select j.jobs_name
     from jobs j
       where j.jobs_id=:tjobs_id
    into :ojob_name;
  suspend;
END^


ALTER PROCEDURE PS_POPUP_LIABLES_VIEW
RETURNS (
    OLIABLE_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(30),
    OJOB_NAME VARCHAR(30))
AS
DECLARE VARIABLE TSURNAME VARCHAR(20);
DECLARE VARIABLE TNAME VARCHAR(20);
DECLARE VARIABLE TPATRONYMIC VARCHAR(20);
DECLARE VARIABLE TJOBS_ID INTEGER;
DECLARE VARIABLE TUSER_ID INTEGER;
DECLARE VARIABLE TMAX_ENABLE INTEGER;
BEGIN
  select u.user_id from t_users u
      where u.user_login = user
    into :tuser_id;
  select o_result from P_HAS_USER_ACCESS(:tuser_id, 100207)
    into :tmax_enable;

  for select s.staff_id, s.staff_id, s.surname, s.name, s.patronymic,
            s.jobs_id
      from  staff s
      where s.responsible <= :tmax_enable
      INTO :oliable_id, :ocode, :tsurname, :tname, :tpatronymic,
           :tjobs_id
  do begin
    ofull_name=:tsurname||' '||firstchar(:tname)||'.'||firstchar(:tpatronymic)||'.';
    select j.jobs_name
       from jobs j
      where j.jobs_id=:tjobs_id
     into :ojob_name;
    suspend;
  end
END^


ALTER PROCEDURE PS_POPUP_MAKER_VIEW (
    IMAKER_ID INTEGER)
RETURNS (
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40))
AS
BEGIN
  select m.maker_id, m.maker_name from maker m
        where m.maker_id = :imaker_id
    into :omaker_id, :omaker_name;

  suspend;
END^


ALTER PROCEDURE PS_POPUP_MAKERS_VIEW
RETURNS (
    OMAKER_ID INTEGER,
    OMAKER_NAME VARCHAR(40))
AS
BEGIN
  for select m.maker_id, m.maker_name from maker m
    into :omaker_id, :omaker_name
  do begin

    suspend;
  end
END^


ALTER PROCEDURE PS_PRICE_BY_DATE (
    INOMEN_ID INTEGER,
    IDATE DATE)
RETURNS (
    OPRICE DOUBLE PRECISION)
AS
declare variable ppricejournal_id integer;
begin
  select max(pj.pricejournal_id) from pricejournal pj
   where cast(pj.date_time as date)  <= :idate and
          pj.nomen_id = :inomen_id
    into ppricejournal_id;
  select pg.out_price from pricejournal pg
   where pg.pricejournal_id = :ppricejournal_id
    into oprice;
  if (:oprice is null) then
   begin
    select n.out_price from nomen n
     where n.nomen_id = :inomen_id
      into oprice;
   end
  suspend;
end^


ALTER PROCEDURE PS_PRICE_JOURNAL (
    IDATE1 DATE,
    IDATE2 DATE,
    INOMEN_ID INTEGER)
RETURNS (
    ODATE_TIME TIMESTAMP,
    OOUT_PRICE DOUBLE PRECISION,
    OUSER_NAME VARCHAR(12),
    ONAME VARCHAR(60))
AS
begin
  idate2 = :idate2 + 1;
  for select p.date_time, around(p.out_price), p.user_name from pricejournal p
    where p.date_time between :idate1 and :idate2 and
          p.nomen_id = :inomen_id
  into :odate_time, :oout_price, :ouser_name
  do begin
    select  u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
      from t_users u
      where u.user_login= :ouser_name
    into :oname;
    suspend;
  end
end^


ALTER PROCEDURE PS_PRODUCT_REC_SET_COUNT (
    IPRODUCTION_REC_ID INTEGER)
AS
declare variable pcount double precision;
begin
  select sum(n.brutto * rf."COUNT")
    from nomen n, t_rec_fillings rf
   where n.nomen_id = rf.nomen_id and
         rf.production_rec_id = :iproduction_rec_id
    into pcount;
  if (:pcount is null) then pcount = 0;

  update t_production_recs r
     set r."COUNT" = :pcount
   where r.id = :iproduction_rec_id;
end^


ALTER PROCEDURE PS_PRODUCT_REC_TD1_INS (
    IPRODUCTION_DOC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
begin
  oproduction_rec_id = gen_id(gen_t_production_recs_id, 1);

  insert into t_production_recs(id, production_doc_id, nomen_id, "COUNT")
     values(:oproduction_rec_id, :iproduction_doc_id, :inomen_id, :icount);

  suspend;
end^


ALTER PROCEDURE PS_PRODUCT_REC_TD2_INS (
    IPRODUCTION_DOC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
declare variable pcalculation_id integer;
declare variable poutput_quantity double precision;
declare variable pnomen_id integer;
declare variable pinput_quantity double precision;
declare variable pcoeficient double precision;
declare variable pin_price double precision;
declare variable pgoods_id integer;
begin
  select max(c.calculation_id) from t_calculations c
   where c.nomen_id = :inomen_id
    into pcalculation_id;

  select c.output_quantity from t_calculations c
   where c.calculation_id = :pcalculation_id
    into poutput_quantity;

  oproduction_rec_id = gen_id(gen_t_production_recs_id, 1);
  insert into t_production_recs (id, production_doc_id, nomen_id, "COUNT")
                values(:oproduction_rec_id, :iproduction_doc_id, :inomen_id, :icount);

  pcoeficient = icount / :poutput_quantity;

  for select cr.nomen_id, cr.input_quantity
        from t_calc_records cr
       where cr.calculation_id = :pcalculation_id
        into pnomen_id, pinput_quantity
  do begin
     select max(G.goods_id) from  GOODS G
      where G.nomen_id= :pnomen_id and
            (g.clients_id > 95)and
            (g.clients_id != 99)
       into pgoods_id;

     if (:pgoods_id is null) then
       exception NONE_GOODS;

     select g.goods_inprice from  goods g
      where g.goods_id = :pgoods_id
       into pin_price;

    insert into t_rec_fillings(production_rec_id, nomen_id, "COUNT", in_price)
      values(:oproduction_rec_id, :pnomen_id, :pinput_quantity * :pcoeficient, :pin_price);
  end
  suspend;
end^


ALTER PROCEDURE PS_PRODUCT_REC_TD2_UPD (
    IPRODUCTION_REC_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OPRODUCTION_REC_ID INTEGER)
AS
declare variable pcoeficient double precision;
declare variable poutput_quantity double precision;
declare variable pcalculation_id integer;
declare variable pnomen_id integer;
declare variable pin_price double precision;
declare variable pinput_quantity double precision;
declare variable pgoods_id integer;
declare variable pdocrec_id integer;
declare variable pold_count double precision;
declare variable prec_fillings_id integer;
begin
  oproduction_rec_id = :iproduction_rec_id;

  select pr.docrec_id, pr."COUNT" from t_production_recs pr
   where id = :iproduction_rec_id
    into pdocrec_id, pold_count;

 if (:pdocrec_id is null) then
 begin
   delete from t_rec_fillings f where f.production_rec_id = :iproduction_rec_id;

   select max(c.calculation_id) from t_calculations c, t_production_recs pr
    where c.nomen_id = pr.nomen_id and
          pr.id = :iproduction_rec_id
     into pcalculation_id;

   select c.output_quantity from t_calculations c
    where c.calculation_id = :pcalculation_id
     into poutput_quantity;

   pcoeficient = :icount / :poutput_quantity;

   for select cr.nomen_id, cr.input_quantity
         from t_calc_records cr
        where cr.calculation_id = :pcalculation_id
         into pnomen_id, pinput_quantity
    do begin
       select max(G.goods_id) from  GOODS G
        where G.nomen_id = :pnomen_id and
              (g.clients_id > 95)and
              (g.clients_id != 99)
         into pgoods_id;

       if (:pgoods_id is null) then
         exception NONE_GOODS;

       select g.goods_inprice from  goods g
        where g.goods_id = :pgoods_id
         into pin_price;

      insert into t_rec_fillings(production_rec_id, nomen_id, "COUNT", in_price)
        values(:oproduction_rec_id, :pnomen_id, :pinput_quantity * :pcoeficient, :pin_price);
    end
  end else /* if (:pdocrec_id is null) then */
  begin
    pcoeficient = :icount / :pold_count;

    for select rf.id from t_rec_fillings rf
         where rf.production_rec_id = :iproduction_rec_id
          into prec_fillings_id
    do begin
      update t_rec_fillings rf
         set rf."COUNT" = rf."COUNT" * :pcoeficient
       where rf.id = :prec_fillings_id;
    end
  end

  update t_production_recs
     set "COUNT" = :icount
   where id = :iproduction_rec_id;

  suspend;
end^


ALTER PROCEDURE PS_PRODUCTION_DOC_DEL (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
begin
  tsuma = 0;

  ocaption = 'записів в документі';
  select count(ar.id) from t_PRODUCTION_recs ar
   where ar.PRODUCTION_doc_id = :idocument_id
    into ocount;
  tsuma = :tsuma + :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_PRODUCTION_docs d
      where d.id = :idocument_id;
  end
end^


ALTER PROCEDURE PS_PRODUCTION_DOC_FIX (
    IPRODUCTION_DOC_ID INTEGER)
AS
declare variable tis_fixed integer;
declare variable p_object_id integer;
declare variable pnomen_id integer;
declare variable pcount double precision;
declare variable pin_price double precision;
declare variable ptypepdv_id integer;
declare variable ptypepdv_pdv integer;
declare variable pdocrec_id integer;
declare variable prec_filling_id integer;
declare variable pproduction_rec_id integer;
declare variable pgoods_id integer;
declare variable pin_sum double precision;
declare variable p_document_id1 integer;
declare variable p_document_id2 integer;
declare variable ptype_doc integer;
declare variable pclient_id integer;
declare variable pdelta_count double precision;
declare variable pold_count double precision;
declare variable pnote varchar(14);
declare variable p_price_in_pdv double precision;
declare variable tkilk integer;
declare variable pin_sum_pdv double precision;
declare variable tgoods_id integer;
declare variable tgoods_rest double precision;
declare variable tgoods_inprice double precision;
declare variable tcurrent_kilk double precision;
declare variable p_docgoods_id integer;
declare variable pnomen_price double precision;
declare variable pdr_nomen_id integer;
begin
 select pd.doc_lock, pd.type_production_doc_id, pd.note
   from t_production_docs pd
  where pd.id = :iproduction_doc_id
   into tis_fixed, ptype_doc, pnote;

 if (:tis_fixed = 1) then
   exit;
   
 if (:ptype_doc = 1) then
   pclient_id = 96;
 if (:ptype_doc = 2) then
   pclient_id = 97;

 p_object_id = 1;
 /* створення прихідного внутрішнього переміщення (прихідної коригуючої)*/
 select first(1) dr.document_id
   from t_production_recs pr inner join docrec dr on (pr.docrec_id = dr.docrec_id)
  where pr.production_doc_id = :iproduction_doc_id
   into p_document_id1;
 if (p_document_id1 is null) then
 begin
    select dc.rdocument_id from s_doc_create(7) dc into p_document_id1;

    update documents d
       set d.objects_id  = :pclient_id,
           d.clients_id  = :p_object_id,
           d.doc_date    = 'today',
           d.blok        = 1,
           d.doc_lock    = 2,
           d.oplata_type = 3,
           d.doc_mark    = :pnote
     where d.document_id = :p_document_id1;
  end
 /* створення розхідного внутрішнього переміщення (розхідної коригуючої)*/
 select first(1) dr.document_id
   from t_rec_fillings rf inner join docrec dr on (rf.docrec_id = dr.docrec_id)
        inner join t_production_recs pr on (rf.production_rec_id = pr.id)
  where pr.production_doc_id = :iproduction_doc_id
   into p_document_id2;
 if (p_document_id2 is null) then
 begin
    select dc.rdocument_id from s_doc_create(6) dc into p_document_id2;

    update documents d
       set d.objects_id  = :p_object_id,
           d.clients_id  = :pclient_id,
           d.doc_date    = 'today',
           d.blok        = 1,
           d.doc_lock    = 2,
           d.oplata_type = 3,
           d.doc_mark    = :pnote
     where d.document_id = :p_document_id2;
 end

  for select rf.nomen_id, rf."COUNT", rf.in_price, rf.id, rf.docrec_id
        from t_production_recs pr inner join t_rec_fillings rf on (pr.id = rf.production_rec_id)
       where pr.production_doc_id = :iproduction_doc_id
        into pnomen_id, pcount, pin_price, prec_filling_id, pdocrec_id
  do begin
  /* Розхід товарів */
    select dr.nomen_id from docrec dr
     where dr.docrec_id = :pdocrec_id
      into pdr_nomen_id;
    if (:pdr_nomen_id != :pnomen_id) then
    begin /*Видалення невірного докрека*/
      update t_rec_fillings rf
         set rf.docrec_id = null
       where rf.id = :prec_filling_id;
      select dd.ocount from ps_docrec_td6_del(:pdocrec_id) dd
        into tkilk;
      pdocrec_id = null;
    end 

    if (:pdocrec_id is null) then
    begin
      tgoods_id = null;
      select first(1) g.goods_id, g.goods_rest, g.goods_inprice
        from goods g
       where g.nomen_id = :pnomen_id and
             g.goods_rest > 0.00001
       order by g.goods_id desc
        into tgoods_id, tgoods_rest, tgoods_inprice;
      if (:tgoods_id is null) then
      begin
        select first(1) g.goods_id, g.goods_rest, g.goods_inprice
          from goods g
         where g.nomen_id = :pnomen_id
         order by g.goods_id desc
          into tgoods_id, tgoods_rest, tgoods_inprice;
      end

      select di.odocrec_id from ps_docrec_td6_ins(:p_document_id2, :tgoods_id, :pcount, :pin_price, 0) di
        into pdocrec_id;
    end else
    begin
      select du.okilk from ps_docrec_td6_upd(:pdocrec_id, :pcount,  :pin_price) du
        into tkilk;
    end

    select dr.insum_pdv from docrec dr
     where dr.docrec_id = :pdocrec_id
      into pin_sum_pdv;
   if (:pcount = 0) then
     pin_price = :pin_price;
   else
     pin_price = :pin_sum_pdv / :pcount;

    update t_rec_fillings rf
       set rf.docrec_id = :pdocrec_id,
           rf.in_price  = :pin_price
     where rf.id = :prec_filling_id;
 end

  for select pr.nomen_id, pr."COUNT", pr.id, pr.docrec_id
        from t_production_recs pr
       where pr.production_doc_id = :iproduction_doc_id
        into pnomen_id, pcount, pproduction_rec_id, pdocrec_id
  do begin
  /* Прихід товарів */
    select sum(rf."COUNT" * rf.in_price) from t_rec_fillings rf
     where rf.production_rec_id = :pproduction_rec_id
      into pin_sum;

    if (:pcount  is null) then pcount = 0;
    if (:pin_sum is null) then pin_sum = 0;
    pin_price = 0;
    if (:pcount != 0) then
        pin_price = :pin_sum / :pcount;

    select tp.typepdv_id, tp.pdv, n.out_price
      from nomen n inner join typepdv tp on (tp.typepdv_id = n.typepdv_id)
     where n.nomen_id = :pnomen_id
      into ptypepdv_id, ptypepdv_pdv, pnomen_price;

    if (:pin_price = 0) then pin_price = :pnomen_price;
    pin_price = :pin_price / (1 + :ptypepdv_pdv);

    if (:pdocrec_id is null) then
    begin
      select di.odocrec_id from ps_docrec_td7_ins(:p_document_id1, :pnomen_id, :pcount, :pin_price, 0) di
        into pdocrec_id;
    end else
    begin
      select du.okilk from ps_docrec_td7_upd(:pdocrec_id, :pcount, :pin_price, 0) du
        into tkilk;
    end

    begin
    /*Фіксація докреку*/
       select dg.goods_id, dg.docgoods_id, dg.kilk
        from docgoods dg
       where dg.docrec_id = :pdocrec_id
        into pgoods_id, p_docgoods_id, tkilk;

      pcount = :pcount - :tkilk;

      update goods g
         set g.goods_rest = g.goods_rest + :pcount
       where g.goods_id   = :pgoods_id;

      update docgoods dg
         set dg.kilk        = dg.kilk + :pcount
       where dg.docgoods_id = :p_docgoods_id;

      execute procedure s_sliv_minusov(1, :pnomen_id);
    end

    update t_production_recs pr
       set pr.docrec_id = :pdocrec_id
     where pr.id = :pproduction_rec_id;
  end

 update t_production_docs pd
    set pd.doc_lock = 1
  where pd.id = :iproduction_doc_id;

 execute procedure ps_document_ins_or_upd_td16(:p_document_id1);
end^


ALTER PROCEDURE PS_PRODUCTION_DOC_HEADER (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    AUTH_NAME VARCHAR(80),
    DOC_MARK VARCHAR(14))
AS
declare variable pdocrec_id integer;
declare variable pclient_id integer;
declare variable pobject_id integer;
declare variable p_auth_id integer;
begin
 select first(1) pd.id, pd."DATE", pd.note, pr.docrec_id
   from t_production_docs pd inner join t_production_recs pr on (pd.id = pr.production_doc_id)
  where pd.id = :document_id
   into doc_num, doc_date, doc_mark, pdocrec_id;

 if (:pdocrec_id is not null) then
 begin
   select d.clients_id, d.objects_id, d.auth_id
     from docrec dr inner join documents d on (dr.document_id = d.document_id)
    where dr.docrec_id = :pdocrec_id
     into pclient_id, pobject_id, p_auth_id;

   select c.shortname, c.name from clients c
    where c.clients_id = :pobject_id
     into src_name, src_fullname;

   select c.shortname, c.name from clients c
    where c.clients_id = :pclient_id
     into dst_name, dst_fullname;
 end

 select '№ '||a.auth_num||' від '||cast(a.auth_date as varchar(11))||'р. через '||a.auth_name
   from auth a
  where a.auth_id = :p_auth_id
   into auth_name;
 if (:p_auth_id is null) then auth_name=null;

 suspend;
end^


ALTER PROCEDURE PS_PRODUCTION_DOC_INFO (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
declare variable pid integer;
declare variable pnote varchar(14);
declare variable ptype_doc_name varchar(60);
begin
  select pd.oid, pd.onote, pd.otype_doc_name
    from ps_production_doc_view(:iproduction_doc_id) pd
    into pid, pnote, ptype_doc_name;

  odescript = 'Внутрішній код (id): ' || :pid;
  suspend;

  odescript = 'Примітка: ' || :pnote;
  suspend;

  odescript = 'Тип документу: ' || :ptype_doc_name;
  suspend;

end^


ALTER PROCEDURE PS_PRODUCTION_DOC_INS (
    ITYPEDOC_ID INTEGER,
    INOTE VARCHAR(14),
    IDATE DATE)
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_production_docs_id, 1);
  insert into t_production_docs(id ,type_production_doc_id, note, "DATE")
       values(:oid, :itypedoc_id, :inote, :idate);
  suspend;
end^


ALTER PROCEDURE PS_PRODUCTION_DOC_VIEW (
    IID INTEGER)
RETURNS (
    OID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OIN_SUMM DOUBLE PRECISION,
    OTYPE_DOC_NAME VARCHAR(60),
    ONOTE VARCHAR(14),
    OTYPE_DOC_ID INTEGER)
AS
begin
  select ad.id, ad.doc_lock, ad."DATE", ad.type_production_doc_id, ad.note
    from t_PRODUCTION_docs ad
   where ad.id = :iid
    into oid, ois_fixed, odate, otype_doc_id, onote;

     select sum(rf."COUNT" * rf.in_price)
      from t_rec_fillings rf, t_PRODUCTION_recs ar
     where rf.production_rec_id = ar.id and
           ar.PRODUCTION_doc_id = :oid
      into oin_summ;

   select name
     from t_type_product_doc td
    where id = :otype_doc_id
     into otype_doc_name;

    suspend;

end^


ALTER PROCEDURE PS_PRODUCTION_DOCREC_PRINT (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION,
    OPRICE1 DOUBLE PRECISION,
    ONOMEN_ID1 INTEGER,
    ONOMEN_NAME1 VARCHAR(40),
    OSI_NAME1 VARCHAR(12),
    OCOUNT0 DOUBLE PRECISION,
    OPRICE0 DOUBLE PRECISION,
    ONOMEN_NAME0 VARCHAR(40),
    OSI_NAME0 VARCHAR(12),
    ONOMEN_ID0 INTEGER,
    OCOUNT1 DOUBLE PRECISION)
AS
declare variable pdocrec_id1 integer;
declare variable pproduction_rec_id integer;
declare variable pbrutto double precision;
declare variable pdocrec_id0 integer;
begin
  for select pr.docrec_id, pr.id
        from t_production_recs pr
       where pr.production_doc_id = : iproduction_doc_id
        into pdocrec_id1, pproduction_rec_id
  do begin
    select sum(rf."COUNT" * n.brutto)
      from t_rec_fillings rf inner join nomen n on (rf.nomen_id = n.nomen_id)
     where rf.production_rec_id = :pproduction_rec_id
      into osum;

    select n.nomen_id, n.nomen_name, s.si_name
      from docrec dr inner join nomen n on (dr.nomen_id = n.nomen_id)
           inner join si s on (n.si_id = s.si_id)
     where dr.docrec_id = :pdocrec_id1
      into onomen_id1, onomen_name1, osi_name1;

   for select rf.docrec_id, rf."COUNT"
         from t_rec_fillings rf
        where rf.production_rec_id = :pproduction_rec_id
         into pdocrec_id0, ocount0
   do begin
     select dr.price, n.nomen_id, n.nomen_name, s.si_name, n.brutto
       from docrec dr inner join nomen n on (dr.nomen_id = n.nomen_id)
            inner join si s on (n.si_id = s.si_id)
      where dr.docrec_id = :pdocrec_id0
       into oprice0, onomen_id0, onomen_name0, osi_name0, pbrutto;

     ocount1 = :pbrutto * :ocount0;
     oprice1 = :ocount0 * :oprice0;
     suspend;
     onomen_name1 = null;
     osi_name1    = null;
     osum         = null;
   end

  end
end^


ALTER PROCEDURE PS_PRODUCTION_DOCS_DETAIL (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OPRODUCTION_REC_ID INTEGER)
AS
declare variable pnomen_id integer;
begin
  for select pr.nomen_id, pr."COUNT", pr.id
        from t_production_recs pr
       where pr.production_doc_id = :iproduction_doc_id
        into pnomen_id, ocount, oproduction_rec_id
  do begin
    select nomen_name
      from nomen
     where nomen_id = :pnomen_id
      into onomen_name;

    select sum(rf."COUNT" * rf.in_price)
      from t_rec_fillings rf
     where rf.production_rec_id = :oproduction_rec_id
      into oin_sum;

    oin_price = :oin_sum / :ocount;

    suspend;
  end
end^


ALTER PROCEDURE PS_PRODUCTION_DOCS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE,
    ITYPES VARCHAR(1000))
RETURNS (
    OID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OIN_SUMM DOUBLE PRECISION,
    OTYPE_DOC_NAME VARCHAR(60),
    ONOTE VARCHAR(14),
    OTYPE_DOC_ID INTEGER)
AS
begin
  for select ad.id, ad.doc_lock, ad."DATE", ad.type_production_doc_id, ad.note
        from t_PRODUCTION_docs ad
       where ad."DATE" between :idate0 and :idate1 and
             isinliststr(:itypes, ad.type_production_doc_id) = 1
        into oid, ois_fixed, odate, otype_doc_id, onote
  do begin
     select sum(rf."COUNT" * rf.in_price)
      from t_rec_fillings rf, t_PRODUCTION_recs ar
     where rf.production_rec_id = ar.id and
           ar.PRODUCTION_doc_id = :oid
      into oin_summ;

   select name
     from t_type_product_doc td
    where id = :otype_doc_id
     into otype_doc_name;

    suspend;
  end
end^


ALTER PROCEDURE PS_PRODUCTION_REC_DEL (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable pdocrec_id integer;
declare variable prec_filling_id integer;
declare variable pcount integer;
begin
  ocount = 0;
  ocaption = '';
  select docrec_id from t_production_recs
   where id = :iproduction_rec_id
    into pdocrec_id;

  if (:pdocrec_id is not null) then
  begin
    select d.ocaption, d.ocount
      from PS_DOCREC_TD7_DEL(:pdocrec_id) d
      into ocaption, ocount;
  end

  if (:ocount = 0) then
  begin
    for select pr.id from t_rec_fillings pr
         where pr.production_rec_id = :iproduction_rec_id
          into prec_filling_id
    do begin
      select r.ocount from ps_rec_filling_del(:prec_filling_id) r
        into pcount;
    end

    delete from t_production_recs pr
      where pr.id = :iproduction_rec_id;
  end

  suspend;
end^


ALTER PROCEDURE PS_PRODUCTION_REC_DETAIL (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OREC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
declare variable ptype_doc_id integer;
declare variable pnomen_id integer;
declare variable pcalculation_id integer;
begin
/*  select pd.type_production_doc_id, pr.nomen_id
    from t_production_docs pd, t_production_recs pr
   where pr.production_doc_id = pd.id and
         pr.id = :iproduction_rec_id
    into ptype_doc_id, pnomen_id;

  if (:ptype_doc_id = 1) then
  begin                     */
   for select pr.id, pr.nomen_id, pr."COUNT", pr.in_price, pr.in_price * pr."COUNT"
         from T_REC_FILLINGS pr
        where pr.production_rec_id = :iproduction_rec_id
         into orec_id, onomen_id, ocount, oin_price, oin_sum
   do begin

    select n.nomen_name from nomen n
     where n.nomen_id = :onomen_id
      into onomen_name;

    suspend;
   end
 /* end else
  if (:ptype_doc_id = 2) then
  begin
    select c.calculation_id from t_calculations c
     where c.nomen_id = :pnomen_id
      into pcalculation_id;

    for select cr.ocalc_record_id, cr.onomen_id, cr.onomen_name, cr.oinput_quantity,
           cr.oin_price, cr.oin_sum
      from ps_calc_records_view(:pcalculation_id) cr
      into orec_id, onomen_id, onomen_name, ocount,
           oin_price, oin_sum
    do begin
      suspend;
    end
  end       */
end^


ALTER PROCEDURE PS_PRODUCTION_REC_INFO (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    ODESCRIPT VARCHAR(255))
AS
declare variable tnomen_name varchar(40);
begin
  select n.nomen_name
    from t_production_recs pd, nomen n
   where pd.nomen_id = n.nomen_id and
         pd.id = :iproduction_rec_id
    into tnomen_name;

  odescript = 'Внутрішній код (id): ' || :iproduction_rec_id;
  suspend;

  odescript = 'Сировина: ' || :TNOMEN_NAME;
  suspend;

end^


ALTER PROCEDURE PS_PRODUCTION_REC_VIEW (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
begin
  select pr.id, pr.nomen_id, pr."COUNT"
    from t_production_recs pr
   where pr.id = :iproduction_rec_id
    into oproduction_rec_id, onomen_id, ocount;

    select sum(rf."COUNT" * rf.in_price)
      from t_rec_fillings rf
     where rf.production_rec_id = :oproduction_rec_id
      into oin_sum;

    if (:ocount is null) then ocount = 0;
    if (:oin_sum is null) then oin_sum = 0;
    oin_price = 0;
    if (:ocount != 0) then
      oin_price = :oin_sum / :ocount;

  select n.nomen_name
    from nomen n
   where n.nomen_id = :onomen_id
    into onomen_name;

  suspend;
end^


ALTER PROCEDURE PS_PRODUCTION_RECS_VIEW (
    IPRODUCTION_DOC_ID INTEGER)
RETURNS (
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION)
AS
begin
 for select pr.id, pr.nomen_id, pr."COUNT"
       from t_production_recs pr
      where pr.production_doc_id = :iproduction_doc_id
       into oproduction_rec_id, onomen_id, ocount
 do begin

     select sum(rf."COUNT" * rf.in_price)
      from t_rec_fillings rf
     where rf.production_rec_id = :oproduction_rec_id
      into oin_sum;

    if (:ocount is null) then ocount = 0;
    if (:oin_sum is null) then oin_sum = 0;
    oin_price = 0;
    if (:ocount != 0) then
      oin_price = :oin_sum / :ocount;

  select n.nomen_name
    from nomen n
   where n.nomen_id = :onomen_id
    into onomen_name;

  suspend;
 end
end^


ALTER PROCEDURE PS_REALIS_BY_DOCUMENT (
    IDOCUMENT_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
DECLARE VARIABLE PNOMEN_ID INTEGER;
DECLARE VARIABLE PDATE DATE;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
begin
 osum = 0;
      for select dr.nomen_id, d.date_cr, dr.kilk
           from docrec dr, documents d
           where (dr.document_id = :idocument_id) and
                 (d.document_id = :idocument_id)
           into :pnomen_id, :pdate, :pkilk
          do begin
            select around(:osum + (pbd.oprice * :pkilk))
               from ps_price_by_date(:pnomen_id, :pdate) pbd
            into :osum;
          end
       suspend;
end^


ALTER PROCEDURE PS_REALIS_BY_DOCUMENT_SG (
    IDOCUMENT_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISPECIALS_GROUPS_ID INTEGER)
RETURNS (
    OSUM DOUBLE PRECISION)
AS
declare variable pnomen_id integer;
declare variable pdate date;
declare variable pkilk double precision;
begin
 osum = 0;
      for select dr.nomen_id, d.date_cr, dr.kilk
           from nomen n, documents d
                left join docrec dr on d.document_id = dr.document_id
           where  d.document_id = :idocument_id and
                  dr.typepdv_id = :itypepdv_id  and
                  dr.nomen_id   = n.nomen_id    and
                  n.sg_id       = :ispecials_groups_id
           into :pnomen_id, :pdate, :pkilk
          do begin
            select around(:osum + (pbd.oprice * :pkilk))
               from ps_price_by_date(:pnomen_id, :pdate) pbd
            into :osum;
          end
       suspend;
end^


ALTER PROCEDURE PS_REC_FILLING_DEL (
    IREC_FILLING_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable pdocrec_id integer;
declare variable tkilk double precision;
begin
  ocount = 0;
  ocaption = '';

  select docrec_id from t_rec_fillings
   where id = :irec_filling_id
    into pdocrec_id;

  delete from t_rec_fillings rf where rf.id = :irec_filling_id;

  if (:pdocrec_id is not null) then
  begin
    select d.ocount from ps_docrec_td6_del(:pdocrec_id) d
      into tkilk;
  end

  for select dr.docrec_id from docrec dr
       where dr.rec_fill_id = :irec_filling_id
        into pdocrec_id
  do begin
    select d.ocount from ps_docrec_td6_del(:pdocrec_id) d
      into tkilk;
  end

  suspend;
end^


ALTER PROCEDURE PS_REC_FILLING_INS (
    IPRODUCTION_REC_ID INTEGER,
    INOMEN_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OREC_FILLING_ID INTEGER)
AS
declare variable pin_price double precision;
declare variable pgoods_id integer;
begin
  orec_filling_id = gen_id(gen_t_rec_fillings_id, 1);

 select max(G.goods_id) from  GOODS G
  where G.nomen_id= :inomen_id and
         (g.clients_id > 95)and
         (g.clients_id != 99)
   into pgoods_id;

 if (:pgoods_id is null) then
   exception NONE_GOODS;

 select g.goods_inprice from  goods g
  where g.goods_id = :pgoods_id
   into pin_price;

  insert into t_rec_fillings(id, production_rec_id, nomen_id, "COUNT", in_price)
    values(:orec_filling_id, :iproduction_rec_id, :inomen_id, :icount, :pin_price);
  suspend;
end^


ALTER PROCEDURE PS_REC_FILLING_UPD (
    IREC_FILLING_ID INTEGER,
    ICOUNT DOUBLE PRECISION)
RETURNS (
    OREC_FILLING_ID INTEGER)
AS
declare variable pin_price double precision;
declare variable pgoods_id integer;
begin
  orec_filling_id = :irec_filling_id;

 select max(G.goods_id) from  GOODS G inner join t_rec_fillings r on (r.nomen_id = g.nomen_id)
  where r.id = :irec_filling_id and
              (g.clients_id > 95)and
              (g.clients_id != 99)
   into pgoods_id;

 if (:pgoods_id is null) then
   exception NONE_GOODS;

 select g.goods_inprice from  goods g
  where g.goods_id = :pgoods_id
   into pin_price;

  update t_rec_fillings rf
     set rf."COUNT"  = :icount,
         rf.in_price = :pin_price
   where rf.id = :irec_filling_id;

  suspend;
end^


ALTER PROCEDURE PS_REC_FILLING_VIEW (
    IREC_FILLING_ID INTEGER)
RETURNS (
    OREC_FILLING_ID INTEGER,
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OKILK DOUBLE PRECISION)
AS
begin
      select rf.id, rf.production_rec_id, rf.nomen_id, rf."COUNT", rf.in_price,
             n.nomen_name, rf.in_price * rf."COUNT", n.brutto * rf."COUNT"
        from t_rec_fillings rf, nomen n
       where rf.nomen_id = n.nomen_id and
             rf.id = :irec_filling_id
        into orec_filling_id, oproduction_rec_id, onomen_id, ocount, oin_price,
             onomen_name, oin_sum, okilk;

    suspend;

end^


ALTER PROCEDURE PS_REC_FILLINGS_VIEW (
    IPRODUCTION_REC_ID INTEGER)
RETURNS (
    OREC_FILLING_ID INTEGER,
    OPRODUCTION_REC_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_NAME VARCHAR(40),
    OCOUNT DOUBLE PRECISION,
    OIN_PRICE DOUBLE PRECISION,
    OIN_SUM DOUBLE PRECISION,
    OKILK DOUBLE PRECISION)
AS
begin
  for select rf.id, rf.production_rec_id, rf.nomen_id, rf."COUNT", rf.in_price,
             n.nomen_name, rf.in_price * rf."COUNT", n.brutto * rf."COUNT"
        from t_rec_fillings rf, nomen n
       where rf.nomen_id = n.nomen_id and
             rf.production_rec_id = :iproduction_rec_id
        into orec_filling_id, oproduction_rec_id, onomen_id, ocount, oin_price,
             onomen_name, oin_sum, okilk
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_RECULC_GRP_FULLNAME (
    IGRP_ID INTEGER,
    IGRP_FULLNAME VARCHAR(1000),
    IPREW_GRP_ID INTEGER)
AS
declare variable pprew_grp_id integer;
declare variable pgrp_name varchar(40);
begin
  select g.prew_grp_id, g.grp_name
    from grp g
   where g.grp_id = :iprew_grp_id
    into :pprew_grp_id, :pgrp_name;

  if ((:pprew_grp_id <  0)     or
      (:pprew_grp_id is null)) then
  begin
    update grp g
       set g.grp_fullname = :pgrp_name || ' \ ' || :igrp_fullname
     where g.grp_id = :igrp_id;
  end
  else
  begin
    execute procedure ps_reculc_grp_fullname(:igrp_id, (:pgrp_name || ' \ ' || :igrp_fullname), :pprew_grp_id);
  end
end^


ALTER PROCEDURE PS_RECULC_GRP_FULLNAMES
AS
declare variable pgrp_id integer;
begin
  for select g.grp_id
        from grp g
        into :pgrp_id
  do begin
  execute procedure PS_RECULC_GRP_FULLNAME(:pgrp_id, '', :pgrp_id);
  end
end^


ALTER PROCEDURE PS_REV_REC_CRY (
    IREVISION_ID INTEGER,
    INOMEN_ID INTEGER,
    IKILK DOUBLE PRECISION)
AS
declare variable kk double precision;
declare variable tgoods_id integer;
declare variable tprice_in double precision;
declare variable tprice_out double precision;
declare variable tkilk_old double precision;
declare variable orev_record_id integer;
BEGIN
 select sum(rr.kilk_new) from REV_RECORDS rr
         where rr.nomen_id=:inomen_id and rr.revision_id=:irevision_id
       into :kk;

 if (:kk is not null) then
 begin
  update REV_RECORDS rrv set
       rrv.kilk_new=:kk+:ikilk
 where rrv.nomen_id=:inomen_id;
 end else
 begin

 SELECT MAX(G.goods_id)
  FROM  GOODS G
  WHERE G.nomen_id = :inomen_id and
        g.clients_id > 100
  INTO :tgoods_id;

 if (:tgoods_id is null) then
   exception NONE_GOODS;

 select g.goods_inprice
  from  goods g
  where g.goods_id= :tgoods_id
  into :TPRICE_IN;

 SELECT N.OUT_PRICE
  FROM NOMEN N
  WHERE N.NOMEN_ID=:INOMEN_ID
  INTO :TPRICE_OUT;

 select sum(G.GOODS_REST)
   from goods g
  where G.NOMEN_ID=:INOMEN_ID
 into :tkilk_old;

 OREV_RECORD_ID = GEN_ID(GEN_REV_RECORDS_ID, 1);
 INSERT INTO REV_RECORDS(REV_RECORDS_ID, REVISION_ID,  NOMEN_ID,  PRICE_IN_PDV, PRICE_OUT_PDV, KILK_OLD, KILK_NEW)
                VALUES (:OREV_RECORD_ID,:IREVISION_ID,:INOMEN_ID, :TPRICE_IN, :TPRICE_OUT, :tkilk_old, :ikilk);
 end
END^


ALTER PROCEDURE PS_REV_RECORD_GRP_INS (
    IREVISION_ID INTEGER,
    IGRP_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER)
AS
declare variable pnomen_id integer;
declare variable pgoods_id integer;
declare variable tprice_in double precision;
declare variable tprice_out double precision;
declare variable tkilk_old double precision;
declare variable tkilk_new double precision;
begin
for select nbg.onomen_id from ps_nomen_by_grup(:igrp_id) nbg
    into pnomen_id
 do begin
 if (not exists (select * from rev_records rr
                     where rr.revision_id = :irevision_id and
                           rr.nomen_id = :pnomen_id)) then
  begin
  select max(g.goods_id)
  from  goods g
  where g.nomen_id= :pnomen_id and
       (g.clients_id > 100   or
        g.clients_id in (96, 97, 98))
   into pgoods_id;

 if (:pgoods_id is not null) then
 begin

 select g.goods_inprice from  goods g
  where g.goods_id= :pgoods_id
   into tprice_in;

 select n.out_price from nomen n
  where n.nomen_id=:pnomen_id
   into tprice_out;

  select sum(g.goods_rest) from goods g
   where g.nomen_id=:pnomen_id
    into tkilk_old;

 if ((:iflag = 0) or (:iflag is null)) then
   tkilk_new = :tkilk_old;
 else
   tkilk_new = 0.00;

 orev_record_id = gen_id(gen_rev_records_id, 1);
 insert into rev_records(rev_records_id, revision_id,  nomen_id,  price_in_pdv, price_out_pdv, kilk_old, kilk_new)
                values (:orev_record_id,:irevision_id,:pnomen_id, :tprice_in, :tprice_out, :tkilk_old, :tkilk_new);
 end
 end
 end
end^


ALTER PROCEDURE PS_REV_RECORD_INS (
    IREVISION_ID INTEGER,
    INOMEN_ID INTEGER,
    IFLAG INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER)
AS
declare variable tdocrec_id integer;
declare variable tprice_in double precision;
declare variable tprice_out double precision;
declare variable tkilk_old double precision;
declare variable tkilk_new double precision;
declare variable tgoods_id integer;
begin

 select max(g.goods_id) from  goods g
  where g.nomen_id = :inomen_id and
        (g.clients_id > 100   or
         g.clients_id in (96, 97, 98))
   into tgoods_id;

 if (:tgoods_id is null) then
   exception none_goods;

 select g.goods_inprice from  goods g
  where g.goods_id = :tgoods_id
   into tprice_in;

 select n.out_price from nomen n
  where n.nomen_id = :inomen_id
   into tprice_out;

  select sum(g.goods_rest) from goods g
   where g.nomen_id = :inomen_id
    into tkilk_old;

 if ((:iflag = 0) or (:iflag is null)) then
   tkilk_new = :tkilk_old;
 else
   tkilk_new = 0.00;

 orev_record_id = gen_id(gen_rev_records_id, 1);
 insert into rev_records(rev_records_id, revision_id,  nomen_id,  price_in_pdv, price_out_pdv, kilk_old, kilk_new)
                values (:orev_record_id,:irevision_id,:inomen_id, :tprice_in, :tprice_out, :tkilk_old, :tkilk_new);

 suspend;
end^


ALTER PROCEDURE PS_REV_RECORD_VIEW (
    IREV_RECORD_ID INTEGER)
RETURNS (
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OIN_PRICE_PDV DOUBLE PRECISION,
    OOUT_PRICE_PDV DOUBLE PRECISION,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  select n.nomen_code, n.nomen_name, rr.price_in_pdv, rr.price_out_pdv, rr.kilk_old, rr.kilk_new, N.nomen_id
      from rev_records rr, nomen n
    where rr.nomen_id = n.nomen_id and
          rr.rev_records_id = :irev_record_id
   into :ocode, :ofull_name, :oin_price_pdv, :oout_price_pdv, :okilk_old, :okilk_new, :onomen_id;
  suspend;
end^


ALTER PROCEDURE PS_REV_RECORDS_VIEW (
    IREVISION_ID INTEGER)
RETURNS (
    OREV_RECORD_ID INTEGER,
    OCODE VARCHAR(7),
    OFULL_NAME VARCHAR(40),
    OPRICE_IN_PDV DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OTYPE_PDV_ID INTEGER,
    OPDV DOUBLE PRECISION,
    ONOMEN_ID INTEGER)
AS
begin
  for select rr.rev_records_id, n.nomen_code, n.nomen_name, rr.price_in_pdv,  rr.price_out_pdv, rr.kilk_old,
             rr.kilk_new, n.typepdv_id, tp.pdv, rr.nomen_id
        from rev_records rr, nomen n, typepdv tp
       where rr.nomen_id = n.nomen_id and
             rr.revision_id = :irevision_id and
             n.typepdv_id = tp.typepdv_id
        into orev_record_id, ocode, ofull_name, OPRICE_IN_PDV, OPRICE_OUT_PDV, OKILK_OLD,
             OKILK_NEW, OTYPE_PDV_ID, Opdv, onomen_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_REVISION_DEL (
    IREVISION_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
DECLARE VARIABLE TSUMA INTEGER;
begin
  ocaption = 'записів в акті';
  select count(rr.rev_records_id) from rev_records rr
      where rr.revision_id = :irevision_id
    into :ocount;
  tsuma = :ocount;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from revision r
      where r.revision_id = :irevision_id;
  end
end^


ALTER PROCEDURE PS_REVISION_FIX (
    REVISION_ID INTEGER)
AS
declare variable p_objects_id integer;
declare variable p_rev_rec_id integer;
declare variable p_nomen_id integer;
declare variable p_price_in_pdv double precision;
declare variable p_price_out_pdv double precision;
declare variable p_kilk_old double precision;
declare variable p_kilk_new double precision;
declare variable p_kilk double precision;
declare variable p_documents_id1 integer;
declare variable p_documents_id2 integer;
declare variable p_goods_id integer;
declare variable p_docrec_id integer;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable tis_fixed integer;
declare variable tcurrent_kilk double precision;
declare variable tgoods_id integer;
declare variable tgoods_rest double precision;
declare variable tgoods_inprice double precision;
declare variable tkilk double precision;
declare variable pin_sum_pdv double precision;
begin

 select r.revision_lock
   from revision r
  where r.revision_id = :revision_id
   into tis_fixed;

 if (:tis_fixed = 1) then
   exit;
  /*Перерахунок наявних кількостей*/
/*$$IBEC$$   for select rr.rev_records_id, rr.nomen_id from rev_records rr
       where rr.revision_id = :revision_id
        into p_rev_rec_id, p_nomen_id
  do begin
    select sum(g.goods_rest)
      from goods g
     where g.objects_id = 1 and
           g.nomen_id   = :p_nomen_id
      into p_kilk_old;

    update rev_records
       set kilk_old       = :p_kilk_old
     where rev_records_id = :p_rev_rec_id;
  end $$IBEC$$*/

 p_objects_id = 1;
 /* створення прихідної коригуючої */
 select dc.rdocument_id from s_doc_create(14) dc into :p_documents_id1;
 update documents d
  set d.objects_id  = 98,
      d.clients_id  = :p_objects_id,
      d.doc_date    = 'today',
      d.blok        = 1,
      d.doc_lock    = 2,
      d.oplata_type = 3
  where d.document_id=:p_documents_id1;
 /* створення розхідної коригуючої */
 select dc.rdocument_id from s_doc_create(14) dc into :p_documents_id2;
 update documents d
  set d.objects_id  = :p_objects_id,
      d.clients_id  = 98,
      d.doc_date    = 'today',
      d.blok        = 1,
      d.doc_lock    = 2,
      d.oplata_type = 3
  where d.document_id=:p_documents_id2;

 for select rr.rev_records_id, rr.nomen_id, rr.price_in_pdv, rr.price_out_pdv,
            rr.kilk_old, rr.kilk_new
       from rev_records rr
      where rr.revision_id = :revision_id
       into p_rev_rec_id, p_nomen_id, p_price_in_pdv, p_price_out_pdv,
            p_kilk_old, p_kilk_new
 do begin
  p_kilk = aroundin(p_kilk_new - p_kilk_old, 4);
  select tp.typepdv_id, tp.pdv
    from nomen n, typepdv tp
   where n.nomen_id    = :p_nomen_id and
         tp.typepdv_id = n.typepdv_id
    into p_typepdv_id, p_typepdv_pdv;
/*  execute procedure s_killer_minusov(:p_nomen_id, :p_objects_id);*/
  if (:p_kilk > 0) then
  begin /* kilk_new > kilk_old збільшувати кількість*/
    select first(1) g.goods_inprice from goods g
     where g.nomen_id   = :p_nomen_id and
           g.objects_id = 1
     order by g.goods_id desc
      into p_price_in_pdv;

    p_goods_id = gen_id(gen_goods_id, 1);
    insert into goods (goods_id, nomen_id, objects_id, goods_rest, goods_inprice, clients_id)
       values (:p_goods_id, :p_nomen_id, :p_objects_id, :p_kilk, :p_price_in_pdv, 98);
    p_docrec_id = gen_id(gen_docrec_id,1);
    insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
       values (:p_docrec_id, :p_documents_id1, :p_nomen_id, :p_kilk, :p_price_in_pdv, :p_typepdv_id, :p_typepdv_pdv);
    insert into docgoods (goods_id, docrec_id, kilk)
       values (:p_goods_id, :p_docrec_id, :p_kilk);
    update rev_records rr
       set rr.price_in_pdv = :p_price_in_pdv,
           rr.price_out_pdv = :p_price_in_pdv
     where rr.rev_records_id = :p_rev_rec_id;
/*   execute procedure s_killer_minusov(:p_nomen_id, :p_objects_id);*/
  end
  if (:p_kilk < 0) then
  begin /* kilk_new < kilk_old зменшувати кількість*/
    tkilk = -:p_kilk;
    pin_sum_pdv = 0;
    for select g.goods_id, g.goods_rest, g.goods_inprice
          from goods g
         where g.nomen_id = :p_nomen_id and
               g.goods_rest > 0.00001
         order by g.goods_id
          into tgoods_id, tgoods_rest, tgoods_inprice
    do begin
      if (:tkilk > 0.00001) then
      begin
        tcurrent_kilk = min2(:tkilk, :tgoods_rest);

        p_docrec_id = gen_id(gen_docrec_id,1);
        insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
              values (:p_docrec_id, :p_documents_id2, :p_nomen_id, :tcurrent_kilk, :tgoods_inprice, :p_typepdv_id, :p_typepdv_pdv);

        update goods g
           set g.goods_rest = g.goods_rest - :tcurrent_kilk
         where g.goods_id = :tgoods_id;

         insert into docgoods (goods_id, docrec_id, kilk, inprice, inprice_pdv)
              values (:tgoods_id, :p_docrec_id, :tcurrent_kilk, :tgoods_inprice, :tgoods_inprice);

        update docrec dr
           set dr.price = dr.insum_pdv/dr.kilk
         where dr.docrec_id = :p_docrec_id;
        tkilk = :tkilk - :tcurrent_kilk;
        pin_sum_pdv = :pin_sum_pdv + :tcurrent_kilk * :tgoods_inprice;
      end
    end
    if (:tkilk > 0.00001) then
    /*Якщо не вистачило "плюсових" приходів*/
    begin
      select first(1) g.goods_id, g.goods_rest, g.goods_inprice
        from goods g
       where g.nomen_id = :p_nomen_id
       order by g.goods_id desc
        into tgoods_id, tgoods_rest, tgoods_inprice;

      tcurrent_kilk = :tkilk;

      p_docrec_id = gen_id(gen_docrec_id,1);
      insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
           values (:p_docrec_id, :p_documents_id2, :p_nomen_id, :tcurrent_kilk, :tgoods_inprice, :p_typepdv_id, :p_typepdv_pdv);
      update goods g
         set g.goods_rest = g.goods_rest - :tcurrent_kilk
       where g.goods_id = :tgoods_id;

      insert into docgoods (goods_id, docrec_id, kilk, inprice, inprice_pdv)
           values (:tgoods_id, :p_docrec_id, :tcurrent_kilk, :tgoods_inprice, :tgoods_inprice);

      update docrec dr
         set dr.price = dr.insum_pdv/dr.kilk
       where dr.docrec_id = :p_docrec_id;
      pin_sum_pdv = :pin_sum_pdv + :tcurrent_kilk * :tgoods_inprice;
    end

    update rev_records rr
       set rr.price_in_pdv = :pin_sum_pdv / (-:p_kilk),
           rr.price_out_pdv = :pin_sum_pdv / (-:p_kilk)
     where rr.rev_records_id = :p_rev_rec_id;
/* ----------------------- */
/*   execute procedure s_killer_minusov(:p_nomen_id, :p_objects_id);*/
  end
  if (:p_kilk = 0) then begin /* все добре!!! видалити rev_records_id */
/*$$IBEC$$    delete from rev_records rr
    where rr.rev_records_id=:p_rev_rec_id; $$IBEC$$*/
  end
 end
 update revision r
    set r.revision_lock = 1
  where r.revision_id   = :revision_id;

  execute procedure PS_DOCUMENT_INS_OR_UPD_TD16(:p_documents_id1);
end^


ALTER PROCEDURE PS_REVISION_INS (
    ITOKEN VARCHAR(14),
    IDATE DATE)
RETURNS (
    OREVISION_ID INTEGER)
AS
begin
  orevision_id = GEN_ID(GEN_REVISION_ID,1);
  insert into revision(REVISION_id, REVISION_LOCK, OBJECTS_ID, REVISION_MARK, IS_BLOCK, Revision_date )
     values (:orevision_id, 0, 1, :itoken,0, :idate);
  suspend;
end^


ALTER PROCEDURE PS_REVISION_NOMEN_EXPORT (
    IREVISION_ID INTEGER)
RETURNS (
    OBARCODE CHAR(30),
    ONOMEN_NAME CHAR(50),
    OKILK_OLD CHAR(9),
    OKILK_NEW CHAR(9),
    ONOMEN_CODE VARCHAR(7),
    OERROR_CODE INTEGER)
AS
declare variable tnomen_id integer;
declare variable tis_weight integer;
declare variable tmax_nom_bars_id integer;
declare variable tbarcode_id integer;
begin
  for select n.nomen_id, n.nomen_code, n.nomen_name, rr.kilk_old, rr.kilk_new,
             n.is_weight
        from rev_records rr
             join nomen n on (rr.nomen_id = n.nomen_id)
       where rr.revision_id = :irevision_id
        into tnomen_id, onomen_code, onomen_name, okilk_old, okilk_new,
             tis_weight
  do begin
    oerror_code = 0;
    if (:tis_weight <> 0) then
      oerror_code = 1;
    else
    begin
      select max(nb.nom_bar_id) from nom_bar nb
       where nb.nomen_id = :tnomen_id
        into tmax_nom_bars_id;

      if (:tmax_nom_bars_id is not null) then
      begin
        select nb.barcode_id from nom_bar nb
         where nb.nom_bar_id = :tmax_nom_bars_id
          into tbarcode_id;

        if (exists(select * from nom_bar nb
                   where nb.nomen_id <> :tnomen_id and
                         nb.barcode_id = :tbarcode_id)) then
          oerror_code = 2;
        else
          select b.code from nom_bar nb, barcode b
           where nb.barcode_id = b.barcode_id and
                 nb.nom_bar_id = :tmax_nom_bars_id
            into obarcode;
      end else
        oerror_code = 3;
    end
    suspend;
  end
end^


ALTER PROCEDURE PS_REVISION_NOMEN_IMPORT (
    IREVISION_ID INTEGER,
    IBARCODE VARCHAR(30),
    IKILK_NEW DOUBLE PRECISION,
    IMODE INTEGER)
RETURNS (
    OERROR_CODE INTEGER)
AS
declare variable trev_record_id integer;
declare variable tnomen_id integer;
declare variable pcode_int bigint;
begin
  select first(1) rr.rev_records_id
    from rev_records rr
         join nom_bar nb on (nb.nomen_id   = rr.nomen_id)
         join barcode b  on (nb.barcode_id = b.barcode_id)
   where rr.revision_id = :irevision_id and
         b.code = :ibarcode
    into trev_record_id;

  if (:trev_record_id is null) then
  begin
    begin
      pcode_int = cast(:ibarcode as bigint);
      ibarcode = cast(:pcode_int as varchar(27));
    when any do
    begin

    end
    end

    select first(1) nb.nomen_id from nom_bar nb, barcode b
     where nb.barcode_id = b.barcode_id and
           (b.code like '0'||'%'||:ibarcode or
            b.code = :ibarcode)
      into tnomen_id;

    if (:tnomen_id is not null) then
    begin
      select orev_record_id from ps_rev_record_ins(:irevision_id, :tnomen_id, 1)
        into trev_record_id;
    end
  end

  if (:trev_record_id is not null) then
  begin
    update rev_records rr
       set rr.kilk_new = rr.kilk_new + :ikilk_new
     where rr.rev_records_id = :trev_record_id;
  end

  suspend;
end^


ALTER PROCEDURE PS_REVISION_VIEW (
    IREVISION_ID INTEGER)
RETURNS (
    OREVISION_LOCK SMALLINT,
    OREVISION_DATE DATE,
    OREVISION_MARK VARCHAR(40),
    OUSER_CREATE VARCHAR(55),
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION,
    OUSER_LOCK VARCHAR(55),
    ODATE_LOCK DATE)
AS
DECLARE VARIABLE TUSER_CREATE VARCHAR(12);
DECLARE VARIABLE TUSER_LOCK VARCHAR(12);
BEGIN
   select r.user_create, r.revision_lock,  r.user_lock, r.date_lock, r.revision_mark
      from revision r
      where r.revision_id = :irevision_id
      into :TUSER_CREATE, :oREVISION_LOCK, :TUSER_LOCK, :oDATE_LOCK, :oREVISION_MARK;

  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
    FROM T_USERS U
    WHERE U.user_login=:TUSER_CREATE
    INTO :OUSER_CREATE;

  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
    FROM T_USERS U
    WHERE U.user_login=:TUSER_LOCK
    INTO :OUSER_LOCK;

  SELECT SUM(RR.SUM_IN), SUM(RR.SUM_IN_PDV), SUM(RR.SUM_OUT), SUM(RR.SUM_OUT_PDV)
    FROM S_REV_RECORDS_VIEW(:IREVISION_ID) RR
    INTO :OSUM_IN, :OSUM_IN_PDV, :OSUM_OUT, :OSUM_OUT_PDV;
  SUSPEND;
END^


ALTER PROCEDURE PS_REVISION_VIEW_V1 (
    IREVISION_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(55),
    OUSER_FIX VARCHAR(55),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TUSER_INS VARCHAR(12);
DECLARE VARIABLE TUSER_FIX VARCHAR(12);
begin
  select r.revision_id, r.revision_date, r.user_create, r.revision_lock, r.user_lock, r.date_lock, r.revision_mark
      from revision r
      where r.revision_id = :irevision_id
   into :orevision_id, :odate, :tuser_ins, :ois_fixed, :tuser_fix, :odate_fix, :otoken;

  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
  FROM T_USERS U
    WHERE U.user_login=:tuser_ins
  INTO :ouser_ins;

  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
  FROM T_USERS U
    WHERE U.user_login=:tuser_fix
  INTO :ouser_fix;

  select sum(rr.sum_in), sum(rr.sum_in_pdv), sum(rr.sum_out), sum(rr.sum_out_pdv)
     from s_rev_records_view(:orevision_id) rr
   into :osum_in, :osum_in_pdv, :osum_out, :osum_out_pdv;
  suspend;

end^


ALTER PROCEDURE PS_REVISION_VIEW_V2 (
    IREVISION_ID INTEGER)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(60),
    OUSER_FIX VARCHAR(60),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TUSER_INS VARCHAR(12);
DECLARE VARIABLE TUSER_FIX VARCHAR(12);
begin
  select r.revision_id, r.revision_date, r.user_create, r.revision_lock, r.user_lock, r.date_lock, r.revision_mark
      from revision r
      where r.revision_id = :irevision_id
   into :orevision_id, :odate, :tuser_ins, :ois_fixed, :tuser_fix, :odate_fix, :otoken;

  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
      from T_USERS U
      WHERE U.user_login=:tuser_ins
    INTO :ouser_ins;
  SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
      FROM t_USERS U
      WHERE U.user_login=:tuser_fix
    INTO :ouser_fix;

  select sum(rr.sum_in), sum(rr.sum_in_pdv), sum(rr.sum_out), sum(rr.sum_out_pdv)
     from s_rev_records_view(:orevision_id) rr
   into :osum_in, :osum_in_pdv, :osum_out, :osum_out_pdv;
  suspend;

end^


ALTER PROCEDURE PS_REVISIONS_VIEW (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(55),
    OUSER_FIX VARCHAR(55),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TUSER_INS VARCHAR(12);
DECLARE VARIABLE TUSER_FIX VARCHAR(12);
begin
  for select r.revision_id, r.revision_date, r.user_create, r.revision_lock, r.user_lock, r.date_lock, r.revision_mark
      from revision r
      where r.revision_date between :idate0 and :idate1
   into :orevision_id, :odate, :tuser_ins, :ois_fixed, :tuser_fix, :odate_fix, :otoken
  do begin
    SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
    FROM T_USERS U
      WHERE U.user_login=:tuser_ins
    INTO :ouser_ins;

    SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
    FROM T_USERS U
      WHERE U.user_login=:tuser_fix
    INTO :ouser_fix;

  select sum(rr.sum_in), sum(rr.sum_in_pdv), sum(rr.sum_out), sum(rr.sum_out_pdv)
     from s_rev_records_view(:orevision_id) rr
   into :osum_in, :osum_in_pdv, :osum_out, :osum_out_pdv;
  suspend;
 end
end^


ALTER PROCEDURE PS_REVISIONS_VIEW_V1 (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    OTOKEN VARCHAR(40),
    OREVISION_ID INTEGER,
    OIS_FIXED SMALLINT,
    ODATE DATE,
    OUSER_INS VARCHAR(60),
    OUSER_FIX VARCHAR(60),
    ODATE_FIX DATE,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
declare variable tuser_ins varchar(12);
declare variable tuser_fix varchar(12);
begin
  for select r.revision_id, r.revision_date, r.user_create, r.revision_lock, r.user_lock, r.date_lock, r.revision_mark
      from revision r
      where r.revision_date between :idate0 and :idate1
   into :orevision_id, :odate, :tuser_ins, :ois_fixed, :tuser_fix, :odate_fix, :otoken
  do begin
    SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
        FROM t_users U
        WHERE U.user_login=:tuser_ins
      INTO :ouser_ins;
    SELECT u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
        FROM T_USERS U
        WHERE U.user_login=:tuser_fix
      INTO :ouser_fix;

  select sum(rr.sum_in), sum(rr.sum_in_pdv), sum(rr.sum_out), sum(rr.sum_out_pdv)
    from s_rev_records_view(:orevision_id) rr
    into osum_in, osum_in_pdv, osum_out, osum_out_pdv;
  suspend;
 end
end^


ALTER PROCEDURE PS_REVVISION_DETAIL (
    IREVISION_ID INTEGER)
RETURNS (
    OREV_RECORDS_ID INTEGER,
    ONOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OKILK_OLD DOUBLE PRECISION,
    OKILK_NEW DOUBLE PRECISION,
    OPRICE_IN DOUBLE PRECISION,
    OPRICE_IN_PDV DOUBLE PRECISION,
    OPRICE_OUT DOUBLE PRECISION,
    OPRICE_OUT_PDV DOUBLE PRECISION,
    OSUM_IN_OLD DOUBLE PRECISION,
    OSUM_IN_PDV_OLD DOUBLE PRECISION,
    OSUM_IN_NEW DOUBLE PRECISION,
    OSUM_IN_PDV_NEW DOUBLE PRECISION,
    OSUM_OUT_OLD DOUBLE PRECISION,
    OSUM_OUT_PDV_OLD DOUBLE PRECISION,
    OSUM_OUT_NEW DOUBLE PRECISION,
    OSUM_OUT_PDV_NEW DOUBLE PRECISION,
    OKILK DOUBLE PRECISION,
    OSUM_IN DOUBLE PRECISION,
    OSUM_IN_PDV DOUBLE PRECISION,
    OSUM_OUT DOUBLE PRECISION,
    OSUM_OUT_PDV DOUBLE PRECISION)
AS
declare variable ttypepdv_id integer;
declare variable ttypepdv_pdv double precision;
begin
 for select rr.rev_records_id, rr.nomen_id, n.nomen_code, n.nomen_name,
            rr.kilk_old, rr.kilk_new, rr.price_in_pdv, rr.price_out_pdv,
            n.typepdv_id, tp.pdv
      from rev_records rr,
           nomen n,
           typepdv tp
      where rr.revision_id=:irevision_id and
            rr.nomen_id=n.nomen_id and
            n.typepdv_id=tp.typepdv_id
      into :orev_records_id, :onomen_id, :onomen_code, :onomen_name,
           :okilk_old, :okilk_new, :oprice_in_pdv, :oprice_out_pdv,
           :ttypepdv_id, :ttypepdv_pdv
 do begin
  osum_in_pdv_old=:okilk_old*:oprice_in_pdv;
  osum_in_pdv_new=:okilk_new*:oprice_in_pdv;
  osum_out_pdv_old=:okilk_old*:oprice_out_pdv;
  osum_out_pdv_new=:okilk_new*:oprice_out_pdv;
  okilk=:okilk_new-:okilk_old;
  osum_in_pdv=:osum_in_pdv_new-:osum_in_pdv_old;
  osum_out_pdv=:osum_out_pdv_new-:osum_out_pdv_old;
  if (ttypepdv_id=1) then begin
   oprice_in=:oprice_in_pdv;
   oprice_out=:oprice_out_pdv;
  end
  if (ttypepdv_id=2) then begin
   oprice_in=:oprice_in_pdv;
   oprice_out=:oprice_in_pdv + ((:oprice_out_pdv-:oprice_in_pdv)/(1+:ttypepdv_pdv));
  end
  if (ttypepdv_id=3) then begin
   oprice_in=:oprice_in_pdv/(1+:ttypepdv_pdv);
   oprice_out=:oprice_out_pdv/(1+:ttypepdv_pdv);
  end
  osum_in_old=:okilk_old*:oprice_in;
  osum_in_new=:okilk_new*:oprice_in;
  osum_out_old=:okilk_old*:oprice_out;
  osum_out_new=:okilk_new*:oprice_out;
  okilk=:okilk_new-:okilk_old;
  osum_in=:osum_in_new-:osum_in_old;
  osum_out=:osum_out_new-:osum_out_old;
  suspend;
 end
end^


ALTER PROCEDURE PS_ROLL_TAX_ADD (
    IDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE TCOUTNS INTEGER;
begin
 select count(rt.reestr_id) from reestr rt where rt.document_id=:idocument_id
  into :tcoutns;
  if (:tcoutns < 1 ) then
    insert into  reestr (DOCUMENT_ID) values (:idocument_id);
  else
    update reestr rt set rt.user_cr = user where rt.document_id=:idocument_id;
end^


ALTER PROCEDURE PS_ROLL_TAX_DEL (
    DAT1 DATE,
    DAT2 DATE)
RETURNS (
    RE_NUM INTEGER,
    RE_DAT DATE,
    RE_USE VARCHAR(12),
    D_DOK_NUM VARCHAR(14),
    D_DOK_SUM DOUBLE PRECISION,
    D_CLI VARCHAR(50))
AS
DECLARE VARIABLE CLIENT_IDS INTEGER;
begin
for select rt.reestr_id, rt.data, rt.user_cr, d.doc_num, d.doc_sum, d.clients_id
     from reestr rt, documents d
    where rt.document_id = d.document_id AND Rt.data between :dat1 and :dat2
    into :re_num, :re_dat, :re_use, :d_dok_num, :d_dok_sum, :CLIENT_IDS
   DO begin
    select cl.name from clients cl where cl.clients_id = :client_ids
    into :d_cli;
  suspend;
   end

end^


ALTER PROCEDURE PS_SCALE_INS (
    IIP VARCHAR(16),
    INAME VARCHAR(60),
    ITYPE_SCALE INTEGER)
RETURNS (
    OID INTEGER)
AS
begin
  oid = gen_id(gen_t_scales_id, 1);
  insert into t_scales(id, ip, name, type_scale)
               values(:oid, :iip, :iname, :itype_scale);
  suspend;
end^


ALTER PROCEDURE PS_SCALES_VIEW (
    IID_LIST VARCHAR(1000))
RETURNS (
    OID INTEGER,
    OIP VARCHAR(16),
    ONAME VARCHAR(60),
    OTYPE_SCALE SMALLINT)
AS
begin
  for select s.id, s.ip, s.name, s.type_scale
        from t_scales s
       where ISINLISTSTR(:iid_list, s.id) = 1
        into oid, oip, oname, otype_scale
  do begin
    suspend;
  end
end^


ALTER PROCEDURE PS_SLIV_MINUSOV (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
declare variable pmgoods_id integer;
declare variable ppgoods_id integer;
declare variable pdocgoods_id integer;
declare variable pmrest double precision;
declare variable pprest double precision;
declare variable pkilk double precision;
declare variable tmarker varchar(64);
declare variable pdelta double precision;
declare variable pdocrec_id integer;
begin
/*Не використовується, так як не пройшов затвердження!!!!*/
/*$$IBE$$ 
  vobject_id = 1;
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module = 'store_general'
    into tmarker;

  if (:tmarker = 'yes') then
  begin
    for select g.goods_id, g.goods_rest from goods g
         where g.nomen_id   = :vnomen_id  and
               g.objects_id = :vobject_id and
               g.goods_rest < 0
          into pmgoods_id, pmrest
    do begin
      for select g.goods_id, g.goods_rest from goods g
           where g.nomen_id   = :vnomen_id  and
                 g.objects_id = :vobject_id and
                 g.goods_rest > 0
        order by goods_id
            into ppgoods_id, pprest
      do begin
        for select dg.docgoods_id, dg.kilk, dg.docrec_id
              from docgoods dg
                   left join docrec dr on (dg.docrec_id = dr.docrec_id)
                   left join documents d on (dr.document_id = d.document_id)
             where dg.goods_id    = :pmgoods_id   and
                   d.typedoc_id not in(10, 12, 17) and
                   d.objects_id   = :vobject_id
              into pdocgoods_id, pkilk, pdocrec_id
        do begin
          if ((:pprest > 0.0)and(:pmrest < 0.0)) then
          begin
            pdelta = :pkilk - :pprest;
            if (pdelta <= 0.0) then
            begin
              update goods g
                 set g.goods_rest = g.goods_rest - :pkilk
               where g.goods_id = :ppgoods_id;

              update goods g
                 set g.goods_rest = g.goods_rest + :pkilk
               where g.goods_id = :pmgoods_id;

              pprest = pprest - :pkilk;
              pmrest = pmrest + :pkilk;

              update docgoods dg
                 set dg.goods_id = :ppgoods_id
               where dg.docgoods_id = :pdocgoods_id;
            end else
            if (pdelta > 0.0) then
            begin
              update goods g
                 set g.goods_rest = g.goods_rest - :pprest
               where g.goods_id = :ppgoods_id;

              update goods g
                 set g.goods_rest = g.goods_rest + :pprest
               where g.goods_id = :pmgoods_id;

              pprest = pprest - :pprest;
              pmrest = pmrest + :pprest;

              update docgoods dg
                 set dg.kilk = :pdelta
               where dg.docgoods_id = :pdocgoods_id;

              insert into docgoods (goods_id, docrec_id, kilk)
                values(:ppgoods_id, :pdocrec_id, :pprest);
            end
          end
        end
      end
    end
  end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE PS_SW_HEADER_VIEW (
    IDOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30),
    N_NAME_S VARCHAR(40),
    N_NAME_D VARCHAR(40),
    DIRECTOR_S VARCHAR(40),
    DIRECTOR_D VARCHAR(40),
    OTOKEN VARCHAR(14),
    ODATE_BEGIN DATE,
    ODATE_END DATE,
    OMONTH_SUM DOUBLE PRECISION,
    OIS_MONTH_PERCENT SMALLINT,
    OACCOUNT_NUM_D VARCHAR(20),
    OACCOUNT_NUM_S VARCHAR(20),
    OBANK_NAME_D VARCHAR(40),
    OBANK_NAME_S VARCHAR(40),
    OMFO_D VARCHAR(20),
    OMFO_S VARCHAR(20),
    OTM VARCHAR(1000))
AS
DECLARE VARIABLE TCLIENT_ID INTEGER;
DECLARE VARIABLE TOBJECT_ID INTEGER;
DECLARE VARIABLE TAUTH_ID INTEGER;
DECLARE VARIABLE P_SUM_IN DOUBLE PRECISION;
DECLARE VARIABLE TPAY_TYPE_ID INTEGER;
DECLARE VARIABLE TT INTEGER;
DECLARE VARIABLE TTM VARCHAR(40);
begin
 SELECT D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.OBJECTS_ID, D.CLIENTS_ID, D.STAFF_ID,
             D.lock_date, D.OPLATA_TYPE, d.auth_id
       FROM DOCUMENTS D
       WHERE D.DOCUMENT_ID=:idocument_id
       INTO :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :tobject_id, :tclient_id, :STAFF_ID,
            :LOCK_DATE, :TPAY_TYPE_ID, :tauth_id;

 if (:TPAY_TYPE_ID = 1) then OPLATA_TYPE='Готівка';
 if (:TPAY_TYPE_ID = 2) then OPLATA_TYPE='Перерахунок';
 if (:TPAY_TYPE_ID = 1) then DOC_TIP = 'готівка';
 if (:TPAY_TYPE_ID = 2) then DOC_TIP = 'з розрахункового рахунку';

 SELECT TD.TYPEDOC_NAME
      FROM TYPEDOC TD
      WHERE TD.TYPEDOC_ID=:TYPEDOC_ID
    INTO :TYPEDOC_NAME;

 SELECT SUM(DV.SUM_OUT), SUM(DV.SUM_OUT_PDV), SUM(DV.P_SUM_IN)
     FROM S_DOCREC_VIEW(:IDOCUMENT_ID) DV
     INTO :DOC_SUM, :DOC_SUMPDV, :P_SUM_IN;

 IF (P_SUM_IN IS NULL) THEN P_SUM_IN=0.000;
 IF (DOC_SUM IS NULL) THEN DOC_SUM=0.000;
 IF (DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
 if (NOT(/*around(*/P_SUM_IN/*)*/=0.000)) THEN
 DOC_PDV=0.000;
 DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
 DES_SUMDOC = decpart(around(:doc_sumpdv));
 OUT_SUMPDV = around(:doc_sumpdv);
 
 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director
      from clients
      where CLIENTS_ID = :tobject_id
   into name_s, zkpo_s, ispdv_s, ipn_s, numpdv_s, adress_s, phone_s, SHORTNAME_S, tt, director_s;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tobject_id
   into :oaccount_num_s, :obank_name_s, :omfo_s;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_s;

 select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME, typeprop_id, director
       from clients
       where CLIENTS_ID = :tclient_id
      into name_d, zkpo_d, ispdv_d, ipn_d, numpdv_d, adress_d, phone_d, SHORTNAME_D, tt, director_d;

 select first(1) ca.account_num, b.name, b.mfo
      from banks b, clientaccount ca
    where b.banks_id = ca.banks_id and
         ca.clients_id = :tclient_id
   into :oaccount_num_d, :obank_name_d, :omfo_d;

 select tp.name  from typeprop tp
    where  tp.typeprop_id = :tt
    into  :n_name_d;

 suspend;

end^


ALTER PROCEDURE PS_TD10_CORRECT
AS
declare variable pmarker varchar(64);
declare variable pkilk_day integer;
declare variable pdoc_lock smallint;
declare variable pdocument_id integer;
begin
  select marker from t_configs c
   where c.module = 'store_documents' and
         c.config_id = 2
    into pmarker;
 if (:pmarker != 'no') then
 begin
/*$$IBEC$$    begin
     pkilk_day = cast(:pmarker as integer);
     when any do
     begin
       pkilk_day = 1;
     end
   end $$IBEC$$*/

   for select d.document_id, d.doc_lock from documents d
        where d.typedoc_id = 10 and
              d.doc_lock > 0 and
              d.doc_date <= (cast('today' as date) - d.reserving_time/*:pkilk*/)
         into pdocument_id, pdoc_lock
   do begin
     if (:pdoc_lock > 1) then
       update documents
          set doc_lock = 1
        where document_id = :pdocument_id;
     execute procedure ps_document_fix(:pdocument_id);
   end
 end
end^


ALTER PROCEDURE PS_TMP_BARCODE_INS (
    IBARCODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
RETURNS (
    OBARCODE_ID INTEGER)
AS
begin
  /* Procedure Text */
  select max(b.barcode_id) from barcode b
      where b.code = :ibarcode
  into :obarcode_id;

  if (obarcode_id is null) then
  begin
    obarcode_id = GEN_ID(GEN_BARCODE_ID,1);
    insert into barcode(barcode_id, code)
      values(:obarcode_id, :ibarcode);
  end

  insert into t_tmp_nom_bar(nomen_id, barcode_id, barcode_type_id, out_price)
    values (:inomen_id, :obarcode_id, :ibarcode_type_id, :iout_price);

  suspend;
end^


ALTER PROCEDURE PS_TMP_BARCODE_UPD (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IBARCODE_TYPE_ID INTEGER,
    IOUT_PRICE DOUBLE PRECISION)
AS
begin
  /* Procedure Text */

  update t_tmp_nom_bar nb
    set nb.out_price = :iout_price,
        nb.barcode_type_id = :ibarcode_type_id
   where nb.nomen_id = :inomen_id and
         nb.barcode_id = :ibarcode_id;
end^


ALTER PROCEDURE PS_TMP_BARCODES_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    OBARCODE_ID INTEGER,
    OBARCODE VARCHAR(27),
    OOUT_PRICE DOUBLE PRECISION,
    OBARCODE_TYPE_ID INTEGER,
    OTYPE_NAME VARCHAR(20))
AS
begin
  for select b.barcode_id, b.code, nb.barcode_type_id, nb.out_price from t_tmp_nom_bar nb, barcode b
      where nb.nomen_id = :inomen_id and
            b.barcode_id = nb.barcode_id
    into :obarcode_id, :obarcode, :obarcode_type_id, :oout_price
  do begin
    if (:obarcode_type_id is null) then
      obarcode_type_id = 0;

    select bt.type_name from t_barcode_types bt
        where bt.barcode_type_id = :obarcode_type_id
      into :otype_name;

    suspend;

    obarcode_type_id = null;
  end
end^


ALTER PROCEDURE PS_TMP_NOMEN_DEL (
    INOMEN_ID INTEGER)
RETURNS (
    OCOUNT INTEGER,
    OCAPTION VARCHAR(100))
AS
declare variable tsuma integer;
begin
  tsuma = 0;

  ocaption = '';
  ocount = 0;
  suspend;

  if (:tsuma = 0) then
  begin
    delete from t_tmp_nom_bar nb
     where nb.nomen_id = :inomen_id;

    delete from t_tmp_nomens tn
     where tn.nomen_id = :inomen_id;
  end
end^


ALTER PROCEDURE PS_TMP_NOMEN_INS (
    ISHORT_NAME VARCHAR(24),
    IFULL_NAME VARCHAR(40),
    IDESCRIPTION VARCHAR(255),
    IMAKER_NAME VARCHAR(80),
    ITRADEMARK VARCHAR(80),
    ICODE VARCHAR(6),
    IIS_DEVIDED SMALLINT,
    IGROUP_ID INTEGER,
    ISG_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISI_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
begin
  onomen_id = gen_id(gen_t_tmp_nomens_id, 1);

  insert into t_tmp_nomens(nomen_id, short_name, full_name, description,
    maker_name, trademark, code, is_devided, group_id, sg_id, typepdv_id, si_id)
  values(:onomen_id, :ishort_name, :ifull_name, :idescription, :imaker_name,
    :itrademark, :icode, :iis_devided, :igroup_id, :isg_id, :itypepdv_id, :isi_id);
  suspend;
end^


ALTER PROCEDURE PS_TMP_NOMEN_LIKE_INS (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
declare variable tcode varchar(7);
declare variable tshort_name varchar(24);
declare variable tfull_name varchar(40);
declare variable tdescription varchar(255);
declare variable tmaker_name varchar(80);
declare variable ttrademark varchar(80);
declare variable tis_divided smallint;
declare variable tgroup_id integer;
declare variable tsg_id integer;
declare variable ttypepdv_id integer;
declare variable tsi_id integer;
declare variable tmarker varchar(64);
begin
  select c.marker from t_configs c
      where c.config_id = 3 and
          c.module = 'store_nomen'
    into :tmarker;

 /* select max(cast(n.nomen_code as integer)) from nomen n
    into :tnew_code;   */
  tcode = '000000'; /*tosix(:tnew_code + 1);   */
  onomen_id = GEN_ID(gen_t_tmp_nomens_id, 1);

  select n.short_name, n.full_name, n.description, n.maker_name,
         n.trademark, n.is_devided, n.group_id, n.sg_id,
         n.typepdv_id, n.si_id
    from t_tmp_nomens n
   where n.nomen_id = :inomen_id
    into :tshort_name, :tfull_name, :tdescription, :tmaker_name,
         :ttrademark, :tis_divided, :tgroup_id, :tsg_id,
         :ttypepdv_id, :tsi_id;

  if (:tmarker = 'no') then
  begin
    tshort_name = '';
    tfull_name  = '';
  end

  insert into t_tmp_nomens (nomen_id, short_name, full_name, description, maker_name,
              trademark, code, is_devided, group_id, sg_id, typepdv_id, si_id)
    values (:onomen_id, :tshort_name, :tfull_name, :tdescription, :tmaker_name,
        :ttrademark, :tcode, :tis_divided, :tgroup_id, :tsg_id, :ttypepdv_id, :tsi_id);

  suspend;
end^


ALTER PROCEDURE PS_TMP_NOMEN_UPD (
    INOMEN_ID INTEGER,
    ISHORT_NAME VARCHAR(24),
    IFULL_NAME VARCHAR(40),
    IDESCRIPTION VARCHAR(255),
    IMAKER_NAME VARCHAR(80),
    ITRADEMARK VARCHAR(80),
    ICODE VARCHAR(6),
    IIS_DEVIDED SMALLINT,
    IGROUP_ID INTEGER,
    ISG_ID INTEGER,
    ITYPEPDV_ID INTEGER,
    ISI_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER)
AS
begin
  onomen_id = inomen_id;

  update t_tmp_nomens tn set
    tn.short_name = :ishort_name,
    tn.full_name = :ifull_name,
    tn.description = :idescription,
    tn.maker_name = :imaker_name,
    tn.trademark = :itrademark,
    tn.code = :icode,
    tn.is_devided = :iis_devided,
    tn.group_id = :igroup_id,
    tn.sg_id = :isg_id,
    tn.typepdv_id = :itypepdv_id,
    tn.si_id = :isi_id
  where tn.nomen_id = :inomen_id;

  suspend;
end^


ALTER PROCEDURE PS_TMP_NOMEN_VIEW (
    INOMEN_ID INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OBARCODE_COUNT INTEGER,
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OGROUP_NAME VARCHAR(50),
    OSG_ID INTEGER,
    OSG_NAME VARCHAR(30),
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_NAME VARCHAR(40),
    OSI_ID INTEGER,
    OSI_NAME VARCHAR(12))
AS
begin
  select
    tm.nomen_id,
    tm.short_name,
    tm.full_name,
    tm.description,
    tm.maker_name,
    tm.trademark,
    tm.code,
    tm.is_devided,
    tm.group_id,
    tm.sg_id,
    tm.typepdv_id,
    tm.si_id
  from t_tmp_nomens tm where tm.nomen_id = :inomen_id
  into
    :onomen_id,
    :oshort_name,
    :ofull_name,
    :odescription,
    :omaker_name,
    :otrademark,
    :ocode,
    :ois_devided,
    :ogroup_id,
    :osg_id,
    :otypepdv_id,
    :osi_id;

    select name from t_tmp_nomen_groups where nomen_group_id = :ogroup_id into :ogroup_name;

    select sg_name from specials_groups where sg_id = :osg_id into :osg_name;

    select typepdv_name from typepdv where typepdv_id = :otypepdv_id into :otypepdv_name;

    select si_name from si where si_id = :osi_id into :osi_name;

    select count(tnb.barcode_id) from t_tmp_nom_bar tnb where tnb.nomen_id = :onomen_id into :obarcode_count;

    suspend;
end^


ALTER PROCEDURE PS_TMP_NOMENS_VIEW
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OBARCODE_COUNT INTEGER,
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OGROUP_NAME VARCHAR(50),
    OSG_ID INTEGER,
    OSG_NAME VARCHAR(30),
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_NAME VARCHAR(40),
    OSI_ID INTEGER,
    OSI_NAME VARCHAR(12))
AS
begin
  for select
    tm.nomen_id,
    tm.short_name,
    tm.full_name,
    tm.description,
    tm.maker_name,
    tm.trademark,
    tm.code,
    tm.is_devided,
    tm.group_id,
    tm.sg_id,
    tm.typepdv_id,
    tm.si_id
  from t_tmp_nomens tm
  into
    :onomen_id,
    :oshort_name,
    :ofull_name,
    :odescription,
    :omaker_name,
    :otrademark,
    :ocode,
    :ois_devided,
    :ogroup_id,
    :osg_id,
    :otypepdv_id,
    :osi_id
  do begin
    select name from t_tmp_nomen_groups where nomen_group_id = :ogroup_id into :ogroup_name;

    select sg_name from specials_groups where sg_id = :osg_id into :osg_name;

    select typepdv_name from typepdv where typepdv_id = :otypepdv_id into :otypepdv_name;

    select si_name from si where si_id = :osi_id into :osi_name;

    select count(tnb.barcode_id) from t_tmp_nom_bar tnb where tnb.nomen_id = :onomen_id into :obarcode_count;

    suspend;
  end
end^


ALTER PROCEDURE PS_TRAFFIC (
    IDATE_0 DATE,
    IDATE_1 DATE,
    IWEEK_DAYS VARCHAR(1000))
RETURNS (
    ODAY_ID DATE,
    OWEEK_DAY INTEGER,
    OHOUR INTEGER,
    OCNT INTEGER,
    OSUM DOUBLE PRECISION)
AS
begin
--  EXTRACT (WEEKDAY FROM aTime)    HOUR

  oday_id = :idate_0;
  while (:oday_id <= :idate_1) do
  begin
    oweek_day = EXTRACT (WEEKDAY FROM :oday_id);
    if (isinliststr(:iweek_days, :oweek_day) <> 0) then
    begin
      for select EXTRACT (HOUR FROM d.time_cr), count(d.document_id)
                     from documents d
         where  d.doc_date = :oday_id and
                d.typedoc_id = 11
          group by EXTRACT (HOUR FROM d.time_cr)
         order by EXTRACT (HOUR FROM d.time_cr)
        into ohour, ocnt
      do begin
        select sum(calcpricepdv((dr.kilk * dr.price), dr.disc_persent, d.disc_persent, 6))
                     from docrec dr, documents d
           where  d.document_id = dr.document_id and
                  EXTRACT (HOUR FROM d.time_cr) = :ohour and
                  d.doc_date = :oday_id and
                  d.typedoc_id = 11
          into osum;
        suspend;
      end
    end
    oday_id = :oday_id + 1;
  end
end^


ALTER PROCEDURE PS_TRAFFIC_DIM (
    IDATE_0 DATE,
    IDATE_1 DATE,
    IWEEK_DAYS VARCHAR(1000))
RETURNS (
    ODAY_ID DATE,
    OWEEK_DAY INTEGER)
AS
begin
--  EXTRACT (WEEKDAY FROM aTime)    HOUR

  oday_id = :idate_0;
  while (:oday_id <= :idate_1) do
  begin
    oweek_day = EXTRACT (WEEKDAY FROM :oday_id);
    if (isinliststr(:iweek_days, :oweek_day) <> 0) then
    begin
      suspend;
    end
    oday_id = :oday_id + 1;
  end
end^


ALTER PROCEDURE PW_RALASE (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin /*$$IBE$$ 
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r on n.nomen_id=r.nomen_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  e_s_in=calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k=:e_k;
  b_s_in=:e_s_in;
  p_k   =0.000;
  p_s_in=0.000;
  r_k   =0.000;
  r_s_in=0.000;
  r_s_vat=0.000;
  r_s_out=0.000;
  suspend;
 end
 select max(d.doc_date)
  from documents d
  into :p_date_out;
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name, gch.rshelf, dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id, dr.insum, dr.insum_pdv, calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6)
      from (t_grp_childs_shelfs(:grp_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
           join
           (documents d left join docrec dr on d.document_id=dr.document_id)
           on n.nomen_id=dr.nomen_id
      where d.doc_date between :date_in and :p_date_out and
            d.typedoc_id != 10 and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0))) and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
      into :p_doc_date, :nomen_id, :nomen_code, :nomen_name, :grp_name, :shelf, :p_kilk,
           :p_src_id, :p_dst_id, :p_tvat_id, :s_in, :s_in_vat, :p_price
 do begin
  if (:s_in is null) then s_in=0.000;

  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_price is null) then p_price=0.000;
  if (:p_kilk is null) then p_kilk=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date>:date_out) then begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =-:p_kilk;
     e_s_in=-:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =:p_kilk;
     e_s_in=:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
   end
  else begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =:p_kilk;
     p_s_in=:s_in;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =:p_kilk;
     r_s_in=:s_in;
     r_s_out=calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat=(:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k=:e_k+:r_k-:p_k;
  b_s_in=:e_s_in+:r_s_in-:p_s_in;
  suspend;
 end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE R_CLIENT_DOC_LIST (
    VDATE1 DATE,
    VDATE2 DATE,
    VCLIENT_ID INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER,
    RTYPE INTEGER,
    RSUMA_PDV DOUBLE PRECISION,
    RPERCENT VARCHAR(7),
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RSUMA DOUBLE PRECISION,
    RTYPE_PROPL INTEGER,
    RDOC_LOCK SMALLINT,
    RDOC_DATE DATE,
    RIN_SUM_PDV DOUBLE PRECISION,
    RDOC_MARK VARCHAR(14),
    RCLIENTS_ID INTEGER)
AS
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PCLIENTS_ID INTEGER;
DECLARE VARIABLE PPERCENT DOUBLE PRECISION;
DECLARE VARIABLE PPERCENT1 NUMERIC(3,2);
begin
  for select d.doc_lock, d.document_id, d.doc_num, d.doc_mark, d.objects_id, d.clients_id, d.disc_persent, d.oplata_state, d.doc_date from documents d
    where ((d.objects_id = :vclient_id) or ( d.clients_id = :vclient_id)) and
          d.doc_date between :vdate1 and :vdate2
  into :rdoc_lock, :rdocument_id, :rdoc_num, :rdoc_mark, :pobject_id, :pclients_id, :ppercent, :rtype_propl, :rdoc_date
  do begin
    select drs.sum_out, drs.sum_out_pdv, drs.sum_in, drs.sum_in_pdv, around(drs.avg_disc_persent*100)
        from S_DOCREC_SUM(:rdocument_id, :ppercent) drs
      into :rsuma, :rsuma_pdv, :rin_sum, :rin_sum_pdv, :ppercent1;
    if (:vclient_id = :pobject_id) then
      rtype = 1;
    if (:vclient_id = :pclients_id) then
      rtype = 0;
    rnacinka = :rsuma - :rin_sum;
    rpercent = cast(ppercent1 as varchar(6)) || '%';
    suspend;
  end
end^


ALTER PROCEDURE R_DOC (
    DOCUMENT_ID INTEGER)
RETURNS (
    DATE_CR DATE,
    DOC_NUM VARCHAR(14))
AS
begin
 select doc_num, date_cr from documents
   where DOCUMENT_ID=:DOCUMENT_ID into doc_num, date_cr;
  suspend;
end^


ALTER PROCEDURE R_DOCSUM (
    DOCUMENT_ID INTEGER)
RETURNS (
    SUM_P_IN DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    NAME VARCHAR(30),
    SUM_OUT DOUBLE PRECISION)
AS
begin
 for select sum(P_SUM_IN), SUM(EXTRA_SUM), SUM(SUM_OUT) from S_DOCREC_VIEW(:document_id) into sum_p_in, EXTRA_SUM, SUM_OUT
 do begin
 /* select name from users where users = :users into name;*/
   suspend;
 end
end^


ALTER PROCEDURE R_NAKL_N (
    DOCUMENT_ID INTEGER)
RETURNS (
    ADRESS_S VARCHAR(50),
    NUMPDV_S VARCHAR(20),
    IPN_S VARCHAR(20),
    ISPDV_S INTEGER,
    ZKPO_S VARCHAR(20),
    NAME_S VARCHAR(50),
    PHONE_S VARCHAR(24),
    ADRESS_D VARCHAR(50),
    NUMPDV_D VARCHAR(20),
    IPN_D VARCHAR(20),
    ISPDV_D INTEGER,
    ZKPO_D VARCHAR(20),
    NAME_D VARCHAR(50),
    PHONE_D VARCHAR(24),
    NOMER_P INTEGER,
    AUTH_NAME VARCHAR(80),
    SHORTNAME_S VARCHAR(30),
    SHORTNAME_D VARCHAR(30),
    BORG DOUBLE PRECISION)
AS
DECLARE VARIABLE DST_ID INTEGER;
DECLARE VARIABLE SRC_ID INTEGER;
DECLARE VARIABLE AUTH_ID INTEGER;
DECLARE VARIABLE COUNTS INTEGER;
begin
 select objects_id, clients_id, AUTH_ID from documents where document_id = :DOCUMENT_ID
 into :src_id, :dst_id, :auth_id;
 
  select max(re.reestr_id)  from reestr re where re.document_id=:document_id into :counts;
 
   if (counts is null) then
  select max(rr.reestr_id) from reestr rr into :nomer_p;
   else
    nomer_p=:counts;
     if (counts is null) then
      nomer_p= :nomer_p+1;
 for select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME
      from clients
      where CLIENTS_ID = :src_id
     into name_s, zkpo_s, ispdv_s, ipn_s, numpdv_s, adress_s, phone_s, SHORTNAME_S
     do begin
     select name, zkpo, ispdv, ipn, numpdv, adress, phone, SHORTNAME
      from clients
      where CLIENTS_ID = :dst_id
     into name_d, zkpo_d, ispdv_d, ipn_d, numpdv_d, adress_d, phone_d, SHORTNAME_D;
 
 SELECT '№ '||A.AUTH_NUM||' від '||CAST(A.AUTH_DATE AS VARCHAR(11))||'р. через '||A.AUTH_NAME
    FROM AUTH A
    WHERE A.AUTH_ID=:AUTH_ID
    INTO :AUTH_NAME;
   IF (:AUTH_ID IS NULL) THEN AUTH_NAME='';
/*    select DOC_BORG from rc_debitorka_y(:src_id) where CLIENT_ID=:dst_id  into :BORG; */
    IF (:BORG IS NULL) THEN BORG=0;
     BORG = around(:borg);
  suspend;
    end
end^


ALTER PROCEDURE R_TOVARINDOC (
    DATE_START DATE,
    DATE_END DATE,
    NOMENID INTEGER)
RETURNS (
    KODTOVARA VARCHAR(7),
    KILK DOUBLE PRECISION,
    TVARNAME VARCHAR(40),
    MAKERS VARCHAR(40),
    PRICES DOUBLE PRECISION,
    DATE_CR DATE,
    USER_CR VARCHAR(12),
    TIME_CR TIME,
    OBJECTS_ID INTEGER,
    DOCREC_ID INTEGER,
    DOC_NUM VARCHAR(15),
    TYPE_DOC INTEGER,
    DOCUMENT_ID INTEGER,
    SUMA DOUBLE PRECISION)
AS
DECLARE VARIABLE PCLIENTS_ID INTEGER;
begin
SELECT n.nomen_code, n.nomen_name/*, m.maker_name*/
 from nomen n/*, maker m*/
  where n.nomen_id= :NOMENID /*and n.maker_id=m.maker_id*/
  into kodtovara, tvarname/*, makers*/;

 for SELECT d.docrec_id, d.kilk, d.price, d.date_cr, d.user_cr, d.time_cr, dd.typedoc_id, dd.objects_id, dd.clients_id, dd.doc_num, dd.document_id
     from docrec d, documents dd
      where d.date_cr between :date_start and :date_end and d.nomen_id= :NOMENID and dd.document_id = d.document_id
      into docrec_id, kilk, prices, date_cr, user_cr, time_cr, type_doc, objects_id, :pclients_id, doc_num, document_id
 do begin
    suma = :kilk * :prices;
    if (:pclients_id = 1) then
      select c.shortname from clients c
         where c.clients_id = :objects_id
       into :makers;
    else
      select c.shortname from clients c
         where c.clients_id = :pclients_id
       into :makers;
    suspend;
 end
end^


ALTER PROCEDURE R_ZVITPROP_DETAL_K (
    S_DATA DATE,
    E_DATE DATE,
    TYPP_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    POKIPEC VARCHAR(40),
    VIDPOVIDAL VARCHAR(40),
    DOC_SUM_PDV DOUBLE PRECISION,
    PROPLATA DOUBLE PRECISION,
    DATA_S DATE,
    DATA_E DATE,
    PEYNAME VARCHAR(30))
AS
BEGIN
  EXIT;
END^


ALTER PROCEDURE RC_RALASE (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
begin
  rprihod_k = 0.0;
  rprihod_s = 0.0;

  for select dg.goods_id, dr.nomen_id, n.typepdv_id, t.pdv, n.grp_id, d.clients_id, sum(dg.kilk),
             sum(gs.osum_pdv), sum(dg.kilk*g.goods_inprice)
        from documents d
             left join docrec dr on (d.document_id  = dr.document_id)
             left join docgoods dg on (dr.docrec_id = dg.docrec_id)
             join goods g on (g.goods_id      = dg.goods_id)
             join nomen n on (n.nomen_id      = g.nomen_id)
             join typepdv t on (n.typepdv_id    = t.typepdv_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.objects_id    = :vsklad_id            and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10
    group by dg.goods_id, dr.nomen_id, n.typepdv_id, t.pdv, n.grp_id, d.clients_id
        into rgoods_id, rnomen_id, ptypepdv, ppdv, rgrp_id, rclients_id, rrashod_k,
             rrashod_s_pdv, rin_sum
  do begin
    rnacinka = :rrashod_s_pdv - :rin_sum;
    rrashod_s = calcsum(:rrashod_s_pdv, :rnacinka, :ppdv, :ptypepdv, 6);
    rpdv = :rrashod_s_pdv - :rrashod_s;
    suspend;
  end

  rrashod_k = 0.0;
  rrashod_s_pdv = 0.0;
  rrashod_s = 0.0;
  rpdv = 0.0;
  rnacinka = 0.0;
  for select dg.goods_id, dr.nomen_id, n.grp_id, d.objects_id, sum(dg.kilk), sum(aroundin(dr.price, 3)*dg.kilk)
        from documents d, docrec dr, docgoods dg, nomen n
       where d.clients_id    = :vsklad_id            and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10                    and
             d.document_id   = dr.document_id        and
             dr.docrec_id    = dg.docrec_id          and
             dr.nomen_id     = n.nomen_id
    group by dg.goods_id, dr.nomen_id, n.grp_id, d.objects_id
        into rgoods_id, rnomen_id, rgrp_id, rclients_id, rprihod_k, rprihod_s
  do begin
    rin_sum = :rprihod_s;
    suspend;
  end
end^


ALTER PROCEDURE RC_RALASE_DR (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER,
    RMAKER_ID INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
declare variable pclients_id integer;
declare variable pobjects_id integer;
declare variable psum_s_pdv double precision;
declare variable pkilk double precision;
declare variable pdocrec_id integer;
declare variable pnacinka double precision;
declare variable perm_nacinka integer;
declare variable pinsum double precision;
declare variable pinsum_pdv double precision;
begin
  perm_nacinka = 1;

  for select d.document_id, d.clients_id, d.objects_id, d.staff_id, dr.nomen_id,
             dr.typepdv_id, dr.typepdv_pdv, gs.osum_pdv,
             dr.docrec_id, dr.kilk, dr.insum, dr.insum_pdv, gr.rgrp_id,
             gr.rgrp_name, dr.typepdv_id, n.maker_id
        from (t_grp_childs(:vgrp_id) gr
              left join nomen n on gr.rgrp_id = n.grp_id)
                  join
             (documents d
              left join docrec dr on (d.document_id = dr.document_id)
              left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                  on dr.nomen_id = n.nomen_id
       where d.doc_date between :vdate1 and :vdate2 and
             d.typedoc_id  != 10                    and
             ((d.clients_id = :vsklad_id) or (d.objects_id = :vsklad_id))
        into rdocument_id, pclients_id, pobjects_id, rstaff_id, rnomen_id,
             ptypepdv, ppdv, psum_s_pdv,
             pdocrec_id, pkilk, pinsum, pinsum_pdv, rgrp_id,
             rgrp_name, rtype_pdv, rmaker_id
  do begin
        if (:pobjects_id = :vsklad_id) then
        begin
          rprihod_k     = 0.0;
          rprihod_s     = 0.0;
          rprihod_s_pdv = 0.0;
          rrashod_s_pdv = :psum_s_pdv;
          pnacinka      = :psum_s_pdv - :pinsum_pdv;
          rrashod_s     = calcsum(:rrashod_s_pdv, :pnacinka, :ppdv, :ptypepdv, 6);
          rin_sum       = :pinsum;
          if (:perm_nacinka = 1) then
            rnacinka = :rrashod_s - :rin_sum;
          else
            rnacinka = 0.0;
          rpdv = :rrashod_s_pdv - :rrashod_s;
          rrashod_k    = :pkilk;
          rclients_id  = :pclients_id;
          if (:rin_sum = 0.0) then
            rper_nac = 0.0;
          else
            rper_nac = (:rnacinka/:rin_sum) * 100.0;
          suspend;
          rmaker_id = null;
        end

    /* ?????? */
        if (:pclients_id = :vsklad_id) then
        begin
          rin_sum       = 0.0;
          rnacinka      = 0.0;
          rrashod_s     = 0.0;
          rpdv          = 0.0;
          rrashod_k     = 0.0;
          rrashod_s_pdv = 0.0;

          rprihod_k     = :pkilk;
          rprihod_s_pdv = :psum_s_pdv;
          rprihod_s     = :pinsum;
          rclients_id   = :pobjects_id;
          suspend;
          rmaker_id = null;
        end
      end
end^


ALTER PROCEDURE RC_RALASE_DR_MANAGER (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VMANAGER_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RCLIENTS_ID INTEGER,
    RSTAFF_ID INTEGER,
    RPRIHOD_S_PDV DOUBLE PRECISION,
    RDOCUMENT_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPER_NAC DOUBLE PRECISION,
    RTYPE_PDV INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
declare variable pclients_id integer;
declare variable pobjects_id integer;
declare variable psum_s_pdv double precision;
declare variable pkilk double precision;
declare variable pdocrec_id integer;
declare variable pnacinka double precision;
declare variable perm_nacinka integer;
declare variable pinsum double precision;
declare variable pinsum_pdv double precision;
begin
   perm_nacinka = 1;

  for select d.document_id, d.clients_id, d.objects_id, d.staff_id, dr.nomen_id,
             dr.typepdv_id, dr.typepdv_pdv, gs.osum_pdv, dr.docrec_id, dr.kilk,
             dr.insum, dr.insum_pdv, gr.rgrp_id, gr.rgrp_name, n.typepdv_id
        from (t_grp_manager(:vmanager_id) gr left join nomen n on gr.rgrp_id=n.grp_id)
                    join
             (documents d
              left join docrec dr on (d.document_id = dr.document_id)
              left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                    on dr.nomen_id=n.nomen_id
      where  d.doc_date between :vdate1 and :vdate2  and
             ((d.clients_id = :vsklad_id) or (d.objects_id   = :vsklad_id)) and
             d.typedoc_id not in (12, 10)
        into rdocument_id, pclients_id, pobjects_id, rstaff_id, rnomen_id,
             ptypepdv, ppdv, psum_s_pdv, pdocrec_id, pkilk,
             pinsum, pinsum_pdv, rgrp_id, rgrp_name, rtype_pdv
  do begin
    /* ?????? */
        if (:pobjects_id = :vsklad_id) then
        begin
          rprihod_k     = 0.0;
          rprihod_s     = 0.0;
          rprihod_s_pdv = 0.0;
          rrashod_s_pdv = :psum_s_pdv;
          pnacinka  = :psum_s_pdv - :pinsum_pdv;
          rrashod_s = calcsum(:rrashod_s_pdv, :pnacinka, :ppdv, :ptypepdv, 6);
          rin_sum   = :pinsum;
          if (:perm_nacinka = 1) then
            rnacinka = :rrashod_s - :rin_sum;
          else
            rnacinka = 0.0;
          rpdv        = :rrashod_s_pdv - :rrashod_s;
          rrashod_k   = :pkilk;
          rclients_id = :pclients_id;
          if (:rin_sum = 0.0) then
            rper_nac = 0.0;
          else
            rper_nac = (:rnacinka/:rin_sum) * 100.0;
          suspend;
        end

    /* ?????? */
        if (:pclients_id = :vsklad_id) then
        begin
          rin_sum   = 0.0;
          rnacinka  = 0.0;
          rrashod_s = 0.0;
          rpdv      = 0.0;
          rrashod_k = 0.0;
          rrashod_s_pdv = 0.0;

          rprihod_k     = :pkilk;
          rprihod_s_pdv = :psum_s_pdv;
          rprihod_s     = :pinsum;
          rclients_id   = :pobjects_id;
          suspend;
        end
      end
end^


ALTER PROCEDURE RC_RALASE_INMINUS (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RNOMEN_NAME VARCHAR(40),
    RNOMEN_CODE VARCHAR(7))
AS
begin
  for select rnomen_id, sum(rin_sum), sum(rrashod_k), sum(rrashod_s),
                sum(rpdv), sum(rnacinka) from rc_ralase_dr(:vdate1, :vdate2, :vsklad_id, :vgrp_id)
      where rnacinka < 0.00 and
            rin_sum > 0.00
    group by rnomen_id
  into :rnomen_id, :rin_sum, :rrashod_k, :rrashod_s, :rpdv, :rnacinka
  do begin
    select n.nomen_code, n.nomen_name
      from nomen n
        where n.nomen_id=:rnomen_id
    into :rnomen_code, :rnomen_name;

    suspend;
    rnomen_code = null;
    rnomen_name = null;
  end
end^


ALTER PROCEDURE RC_RALASE_VIDPOV (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER,
    RSTAFF_NAME VARCHAR(30),
    RPRIHOD_S_PDV DOUBLE PRECISION)
AS
begin
  for select rstaff_id, rgrp_id, rnomen_id, sum(rprihod_k), sum(rprihod_s), sum(rprihod_s_pdv), sum(rin_sum),
             sum(rrashod_k), sum(rrashod_s), sum(rrashod_s_pdv), sum(rpdv), sum(rnacinka) from rc_ralase_dr(:vdate1, :vdate2, :vsklad_id, :vgrp_id)
    group by rstaff_id, rgrp_id, rnomen_id
  into :rstaff_id, :rgrp_id, :rnomen_id, :rprihod_k, :rprihod_s, rprihod_s_pdv, :rin_sum, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka
  do begin
    select s.surname||' '||firstchar(s.name)||'.'||firstchar(s.patronymic)||'.'
      from staff s
        where s.staff_id=:rstaff_id
    into :rstaff_name;

    if (:rstaff_id is null) then rstaff_name = null;
    suspend;
  end
end^


ALTER PROCEDURE RP_PRICE_GRP (
    VGRP_ID INTEGER,
    VDATE_TIME TIMESTAMP)
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40))
AS
declare variable ppricejournal_id integer;
begin
  rgrp_id = :vgrp_id;
  select g.grp_name from grp g
   where g.grp_id = :vgrp_id
    into rgrp_name;
      
  if (:vdate_time is null) then
  begin
    for select n.nomen_id, n.nomen_code, n.nomen_name, n.out_price
          from nomen n
         where n.grp_id = :vgrp_id and
               ((n.is_exist = 1)or(n.is_exist is null))
      into rnomen_id, rnomen_code, rnomen_name, rout_price
    do begin
        if (:rout_price is not null) then
        suspend;
    end
  end
  else
  begin
    for select n.nomen_id, n.nomen_code, n.nomen_name from nomen n
         where n.grp_id = :vgrp_id and
               ((n.is_exist = 1)or(n.is_exist is null)) 
    into rnomen_id, rnomen_code, rnomen_name
    do begin
      select max(pj.pricejournal_id) from pricejournal pj
        where pj.nomen_id = :rnomen_id and
              pj.date_time <= :vdate_time
      into :ppricejournal_id;
      select pj.out_price from pricejournal pj
       where pj.pricejournal_id = :ppricejournal_id
        into rout_price;
      if (:rout_price is not null) then
         suspend;
    end
  end
end^


ALTER PROCEDURE RP_PRICE_INGRP (
    VGRP_ID INTEGER,
    VDATE_TIME TIMESTAMP,
    VWITH_0 INTEGER,
    VSKLAD_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_NAME VARCHAR(40),
    ROUT_PRICE DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RREST DOUBLE PRECISION)
AS
DECLARE VARIABLE PGRP_ID INTEGER;
begin
  rgrp_id = :vgrp_id;

  for select rgrp_id from t_grp_childs(:vgrp_id)
    into :pgrp_id
  do begin
    for select rgrp_name, rnomen_id, rnomen_code, rnomen_name, rout_price, rgrp_id from rp_price_grp(:pgrp_id, :vdate_time)
      into :rgrp_name, :rnomen_id, :rnomen_code, :rnomen_name, :rout_price, rgrp_id
    do begin
        select rt.rest from rst rt
          where rt.nomen_id = :rnomen_id and
                rt.objects_id = :vsklad_id
        into :rrest;
        if (:rrest > 0.0) then
          suspend;
        else if (:rrest <= 0.0) then
          if (:vwith_0 = 1) then
            suspend;
    end
  end
end^


ALTER PROCEDURE RP_PRICE_JOURNAL (
    VDATE1 DATE,
    VDATE2 DATE,
    VNOMEN_ID INTEGER)
RETURNS (
    RDATE_TIME TIMESTAMP,
    ROUT_PRICE DOUBLE PRECISION,
    RUSER_NAME VARCHAR(12),
    RNAME VARCHAR(30))
AS
begin
  vdate2 = :vdate2 + 1;
  for select p.date_time, around(p.out_price), p.user_name from pricejournal p
    where p.date_time between :vdate1 and :vdate2 and
          p.nomen_id = :vnomen_id
  into :rdate_time, :rout_price, :ruser_name
  do begin
    select u.user_surname||' '||firstchar(u.user_first_name)||'.'||firstchar(u.user_second_name)||'.'
     from t_users u
       where u.user_login = :ruser_name
     into :rname;
    suspend;
  end
end^


ALTER PROCEDURE RR_RALASE (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
begin
  rprihod_k = 0.0;
  rprihod_s = 0.0;

  for select dg.goods_id, dr.nomen_id, n.typepdv_id, n.grp_id, sum(dg.kilk),
             sum(gs.osum_pdv), sum(dg.kilk*g.goods_inprice)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join docgoods dg on (dr.docrec_id = dg.docrec_id)
             left join goods g on (g.goods_id = dg.goods_id)
             join nomen n on (n.nomen_id = g.nomen_id)
             join typepdv t on (n.typepdv_id = t.typepdv_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.objects_id    = :vsklad_id            and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10
    group by dg.goods_id, dr.nomen_id, n.typepdv_id, t.pdv, n.grp_id
        into rgoods_id, rnomen_id, ptypepdv, rgrp_id, rrashod_k,
             rrashod_s_pdv, rin_sum
  do begin
    rnacinka  = :rrashod_s_pdv - :rin_sum;
    rrashod_s = calcsum(:rrashod_s_pdv, :rnacinka, 0.00, :ptypepdv, 6);
    rpdv      = :rrashod_s_pdv - :rrashod_s;
    suspend;
  end

  rrashod_k     = 0.0;
  rrashod_s_pdv = 0.0;
  rrashod_s     = 0.0;
  rpdv     = 0.0;
  rnacinka = 0.0;
  for select dg.goods_id, dr.nomen_id, n.grp_id, sum(dg.kilk), sum(aroundin(dr.price, 3) * dg.kilk)
        from documents d, docrec dr, docgoods dg, nomen n
      where d.clients_id    = :vsklad_id            and
            d.doc_date between :vdate1 and :vdate2  and
            d.typedoc_id   != 10                    and
            d.document_id   = dr.document_id        and
            dr.docrec_id    = dg.docrec_id          and
            dr.nomen_id     = n.nomen_id
        group by dg.goods_id, dr.nomen_id, n.grp_id
    into :rgoods_id, :rnomen_id, :rgrp_id, :rprihod_k, :rprihod_s
  do begin
    rin_sum = :rprihod_s;
    suspend;
  end
end^


ALTER PROCEDURE RR_RALASE_GOOD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGOODS_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
declare variable pkilk double precision;
declare variable pprice double precision;
declare variable pdisc1 double precision;
declare variable pdisc2 double precision;
declare variable pobject_id double precision;
declare variable pclient_id integer;
declare variable pinprice double precision;
declare variable pnacinka double precision;
declare variable psum double precision;
declare variable pin_sum double precision;
declare variable pdocrec_id integer;
begin
  rgoods_id = :vgoods_id;
  rprihod_k = 0.0;
  rprihod_s = 0.0;
  rrashod_k = 0.0;
  rrashod_s_pdv = 0.0;
  rrashod_s = 0.0;
  rpdv      = 0.0;
  rnacinka  = 0.0;
  rin_sum   = 0.0;

  select n.nomen_id, n.typepdv_id, t.pdv, g.goods_inprice
    from goods g, nomen n, typepdv t
   where g.goods_id = :vgoods_id and
         n.nomen_id = g.nomen_id and
         n.typepdv_id = t.typepdv_id
    into rnomen_id, ptypepdv, ppdv, pinprice;

  for select dr.price, dg.kilk, d.disc_persent, d.clients_id, d.objects_id, dr.docrec_id
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             join docgoods dg on (dr.docrec_id    = dg.docrec_id)
       where ((d.objects_id  = :vsklad_id) or (d.clients_id  = :vsklad_id)) and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10                    and
             dg.goods_id     = :vgoods_id
        into pprice, pkilk, pdisc1, pclient_id, pobject_id, pdocrec_id 
  do begin
    if (:pobject_id = :vsklad_id) then  /* ?????? */
    begin
      select gs.osum_pdv, gs.oprice_pdv from ps_get_sum(:pdocrec_id, :pdisc1, 0.0) gs
        into psum, pprice;

      pin_sum = :pinprice * :pkilk;
      pnacinka = :psum - :pin_sum;

      rin_sum = :rin_sum + :pin_sum;
      rrashod_s_pdv = :rrashod_s_pdv + :psum;
      rrashod_s = rrashod_s + calcsum(:psum, :pnacinka, 0.00, :ptypepdv, 6);
      rnacinka  = :rnacinka + :pnacinka;
      rpdv = :rrashod_s_pdv - :rrashod_s;
      rrashod_k = :rrashod_k + :pkilk;
    end

    if (:pclient_id = :vsklad_id) then  /* ?????? */
    begin
      rprihod_k = :rprihod_k + :pkilk;
      rprihod_s = :rprihod_s + aroundin(pprice, 3) * :pkilk;
    end
  end
  suspend;
end^


ALTER PROCEDURE RR_RALASE_GRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
begin
  rgrp_id = :vgrp_id;
  for select n.nomen_id from nomen n
      where n.grp_id = :vgrp_id
    into :rnomen_id
  do begin
    select rprihod_k, rprihod_s, rrashod_k, rrashod_s, rrashod_s_pdv, rpdv, rnacinka, rin_sum
              from rr_ralase_nomen(:vdate1, :vdate2, :vsklad_id, :rnomen_id)
    into :rprihod_k, :rprihod_s, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka, :rin_sum;

/*    if ((:rprihod_k <> 0.0) or (:rrashod_k <> 0.0)) then*/
    if (:rprihod_k <> 0.0) then
      suspend;
  end
end^


ALTER PROCEDURE RR_RALASE_INGRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
DECLARE VARIABLE PGRP_ID INTEGER;
begin
  rgrp_id = :vgrp_id;
  for select rgrp_id from t_grp_childs(:vgrp_id)
    into :pgrp_id
  do begin
    for select rnomen_id, rprihod_k, rprihod_s, rrashod_k, rrashod_s, rrashod_s_pdv, rpdv, rnacinka, rin_sum, rgrp_id
        from rr_ralase_grp(:vdate1, :vdate2, :vsklad_id, :pgrp_id)
      into :rnomen_id, :rprihod_k, :rprihod_s, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka, :rin_sum, :rgrp_id
    do begin
      suspend;
    end
  end
end^


ALTER PROCEDURE RR_RALASE_NOMEN (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RPRIHOD_K DOUBLE PRECISION,
    RRASHOD_K DOUBLE PRECISION,
    RPRIHOD_S DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER)
AS
DECLARE VARIABLE PPDV DOUBLE PRECISION;
DECLARE VARIABLE PNACINKA DOUBLE PRECISION;
DECLARE VARIABLE PPRIHOD_S DOUBLE PRECISION;
DECLARE VARIABLE PIN_SUM DOUBLE PRECISION;
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PPRIHOD_K DOUBLE PRECISION;
DECLARE VARIABLE PRASHOD_K DOUBLE PRECISION;
DECLARE VARIABLE PRASHOD_S DOUBLE PRECISION;
DECLARE VARIABLE PRASHOD_S_PDV DOUBLE PRECISION;
begin
  rprihod_k = 0.0;
  rprihod_s = 0.0;
  rrashod_k = 0.0;
  rrashod_s_pdv = 0.0;
  rrashod_s = 0.0;
  rpdv = 0.0;
  rnacinka = 0.0;
  rin_sum = 0.0;

  select n.grp_id from nomen n
    where n.nomen_id = :vnomen_id
  into :rgrp_id;

  for select g.goods_id from goods g
      where g.nomen_id = :vnomen_id
    into :pgoods_id
  do begin
    select rprihod_k, rprihod_s, rrashod_k, rrashod_s, rrashod_s_pdv, rpdv, rnacinka, rin_sum
              from rr_ralase_good(:vdate1, :vdate2, :vsklad_id, :pgoods_id)
    into :pprihod_k, :pprihod_s, :prashod_k, :prashod_s, :prashod_s_pdv, :ppdv, :pnacinka, :pin_sum;

    rin_sum = :rin_sum + :pin_sum;
    rrashod_s_pdv = :rrashod_s_pdv + :prashod_s_pdv;
    rrashod_s = :rrashod_s + :prashod_s;
    rnacinka = :rnacinka + :pnacinka;
    rpdv = :rpdv + :ppdv;
    rrashod_k = :rrashod_k + :prashod_k;
    rprihod_k = :rprihod_k + :pprihod_k;
    rprihod_s = :rprihod_s + :pprihod_s;
  end
  suspend;
end^


ALTER PROCEDURE RR_REST_PERIOD (
    DATE_IN DATE,
    DATE_OUT DATE,
    OBJECT_ID INTEGER)
RETURNS (
    BEGIN_S_PDV DOUBLE PRECISION,
    END_S_PDV DOUBLE PRECISION)
AS
BEGIN
/* SELECT SUM(RN.B_S_IN_PDV), SUM(RN.E_S_IN_PDV)
  FROM RS_RALASE_NOMEN(:OBJECT_ID, :DATE_IN, :DATE_OUT) RN
  INTO :BEGIN_S_PDV, :END_S_PDV;*/
 IF (:BEGIN_S_PDV IS NULL) THEN BEGIN_S_PDV=0.000;
 IF (:END_S_PDV IS NULL) THEN END_S_PDV=0.000;
 SUSPEND;
END^


ALTER PROCEDURE RS_ACTION_RALASE (
    IACTION_ID INTEGER,
    IDATE0 DATE,
    IDATE1 DATE,
    IBEFOREDATE0 DATE,
    IBEFOREDATE1 DATE)
RETURNS (
    OW3_NOMEN_ID INTEGER,
    ONOMEN_CODE VARCHAR(7),
    ONOMEN_NAME VARCHAR(40),
    OB_K DOUBLE PRECISION,
    OR_K DOUBLE PRECISION,
    OR_S_MAR DOUBLE PRECISION,
    OR_S_OUT DOUBLE PRECISION,
    OE_K DOUBLE PRECISION,
    OB_K1 DOUBLE PRECISION,
    OR_K1 DOUBLE PRECISION,
    OR_S_MAR1 DOUBLE PRECISION,
    OR_S_OUT1 DOUBLE PRECISION,
    OE_K1 DOUBLE PRECISION,
    OD_K DOUBLE PRECISION,
    OD_S_MAR DOUBLE PRECISION,
    OD_S_OUT DOUBLE PRECISION)
AS
begin
  if ((:ibeforedate0 = cast('today' as date))and
      (:ibeforedate1 = cast('today' as date))or
      (:ibeforedate0 is null)) then
    begin
      ibeforedate1 = :idate0 - 1;
      ibeforedate0 = :ibeforedate1 - (:idate1 - :idate0);
    end

   for select n.w3_nomen_id, n.nomen_code, n.nomen_name,
              around3(sum(rs.b_k)) b_k, around3(sum(rs.r_k)) r_k,
              around3(sum(rs.r_s_out) - sum(rs.r_s_in)) r_s_mar,
              around3(sum(rs.r_s_out)) r_s_out,
              around3(sum(rs.e_k)) e_k,
              around3(sum(rs.b_k1)) b_k1, around3(sum(rs.r_k1)) r_k1,
              around3(sum(rs.r_s_out1) - sum(rs.r_s_in1)) r_s_mar1,
              around3(sum(rs.r_s_out1)) r_s_out1,
              around3(sum(rs.e_k1)) e_k1
         from pr_ralase_nomen_action(:ibeforedate0, :ibeforedate1, :idate0, :idate1, :iaction_id, 0) rs
              left join nomen n on n.nomen_id = rs.nomen_id
        where n.action_id = :iaction_id
        group by n.w3_nomen_id, n.nomen_code, n.nomen_name
         into ow3_nomen_id, onomen_code, onomen_name,
              ob_k, or_k, or_s_mar, or_s_out, oe_k,
              ob_k1, or_k1, or_s_mar1, or_s_out1, oe_k1
  do begin
    od_k = around3((:or_k1 - :or_k)/(:or_k + 0.000001) * 100);
    od_s_mar = around3((:or_s_mar1 - :or_s_mar)/(:or_s_mar + 0.000001) * 100);
    od_s_out = around3((:or_s_out1 - :or_s_out)/(:or_s_mar + 0.000001) * 100);
    suspend;
  end
end^


ALTER PROCEDURE RS_DOCUMENTS (
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    DOCUMENT_ID INTEGER,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(40),
    DOC_DATE DATE,
    DOC_NUM VARCHAR(14),
    CLIENT_NAME VARCHAR(50),
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION)
AS
declare variable p_disc_persent double precision;
declare variable p_kilk double precision;
declare variable p_price double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable pdocrec_id integer;
begin
  for select d.document_id, d.typedoc_id, td.typedoc_name, d.doc_date, d.doc_num,
             d.objects_id, d.clients_id, dr.typepdv_id, dr.typepdv_pdv,
             d.disc_persent, dr.kilk, dr.price, dr.insum, dr.insum_pdv, dr.docrec_id
        from documents d,
             typedoc td,
             docrec dr
       where ((d.objects_id = 1) or (d.clients_id = 1)) and
             d.doc_date between :date_in and :date_out  and
             d.typedoc_id   = td.typedoc_id             and
             d.document_id  = dr.document_id
        into document_id, typedoc_id, typedoc_name, doc_date, doc_num,
             p_src_id, p_dst_id, p_typepdv_id, p_typepdv_pdv,
             p_disc_persent, p_kilk, p_price, sum_in, sum_in_pdv, pdocrec_id
  do begin
    if (:p_src_id = 1) then begin
      select c.name
       from clients c
       where c.clients_id = :p_dst_id
       into :client_name;
    end
    if (:p_dst_id = 1) then begin
      select c.name
       from clients c
       where c.clients_id = :p_src_id
       into :client_name;
    end
    if (:typedoc_id = 14) then begin
      if (:p_src_id = 1) then typedoc_name = :typedoc_name || ' (на розхід)';
      if (:p_dst_id = 1) then typedoc_name = :typedoc_name || ' (на прихід)';
    end
    if (:p_disc_persent is NULL) then p_disc_persent = 0.000;
    if (:typedoc_id = 11) then begin
      p_kilk = around3(:p_kilk);
      p_price = around(:p_price * (1 - :p_disc_persent));
      sum_out_pdv = around(:p_kilk * :p_price);
    end
    else begin
      select osum_pdv from ps_get_sum(:pdocrec_id, :p_disc_persent, 0.000)
        into sum_out_pdv;
    end
    sum_out = calcsum(:sum_out_pdv, (:sum_out_pdv - :sum_in_pdv), :p_typepdv_pdv, :p_typepdv_id, 6);
   suspend;
  end

end^


ALTER PROCEDURE RS_PROFITABILITY_REST (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
begin
/* ---------------------------------------------------------------------------*/
/*              коефіцієнт рентабельності залишків (крз/krz)                  */
/* формула розрахунків:                                                       */
/* крз = <% націнки за період>/<сума залишку>                                 */
/*                                                                            */
/*----------------------------------------------------------------------------*/

 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id
       from t_grp_childs(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r on n.nomen_id=r.nomen_id
      where r.objects_id=:objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id, dr.insum, dr.insum_pdv,
            gs.oprice_pdv
       from (t_grp_childs(:grp_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
                   join
            (documents d
             left join docrec dr on d.document_id=dr.document_id
             left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                   on n.nomen_id=dr.nomen_id
      where d.doc_date between :date_in and 'today'     and
            d.typedoc_id != 10                          and
            ((d.objects_id = :objects_id) or (d.clients_id = :objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, p_kilk,
            p_src_id, p_dst_id, p_tvat_id, s_in, s_in_vat,
            p_price
 do begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_doc_date > :date_out) then begin
    if (:p_dst_id = :objects_id) then begin
     e_k     = -:p_kilk;
     e_s_in  = -:s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then begin
     e_k     = :p_kilk;
     e_s_in  = :s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_out = 0.000;
    end
   end
  else begin
    if (:p_src_id = :objects_id) then begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     r_k     = :p_kilk;
     r_s_in  = :s_in;
     r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
    end
   end
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r on n.nomen_id = r.nomen_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value = 0.0; end
  e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k     = :e_k;
  b_s_in  = :e_s_in;
  p_k     = 0.000;
  p_s_in  = 0.000;
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_vat = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 select max(d.doc_date) from documents d
  into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv
       from (t_grp_childs_shelfs(:grp_id) gch
             left join nomen n on gch.rgrp_id=n.grp_id)
                join
            (documents d
             left join docrec dr on d.document_id=dr.document_id
             left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                on n.nomen_id=dr.nomen_id
      where d.doc_date between :date_in and :p_date_out             and
            d.typedoc_id   != 10                                    and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))  and
            ((d.objects_id = :objects_id) or (d.clients_id = :objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price
 do begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then
    p_tvat_value = 0.2;
  else
    p_tvat_value = 0.0;
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
    begin
      e_k     = -:p_kilk;
      e_s_in  = -:s_in;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
      e_k     = :p_kilk;
      e_s_in  = :s_in;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
   end
  else begin
    if (:p_dst_id = :objects_id) then
    begin
      e_k     = 0.000;
      e_s_in  = 0.000;
      p_k     = :p_kilk;
      p_s_in  = :s_in;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
      e_k     = 0.000;
      e_s_in  = 0.000;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = :p_kilk;
      r_s_in  = :s_in;
      r_s_out = calcsum((:p_kilk * :p_price), (:p_kilk * :p_price) - :s_in_vat, :p_tvat_value, :p_tvat_id, 0);
      r_s_vat = (:p_kilk * :p_price) - :r_s_out;
    end
   end
  b_k    = :e_k + :r_k - :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE_1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id
       from t_grp_childs(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r on n.nomen_id=r.nomen_id
      where r.objects_id=:objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  e_s_in = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k     = :e_k;
  b_s_in  = :e_s_in;
  p_k     = 0.000;
  p_s_in  = 0.000;
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_vat = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id, dr.insum, dr.insum_pdv,
            gs.oprice_pdv
       from (T_GRP_CHILDS(:GRP_ID) GCH
             left join NOMEN N on GCH.RGRP_ID=N.GRP_ID)
                join
            (DOCUMENTS D
             left join DOCREC DR on D.DOCUMENT_ID=DR.DOCUMENT_ID
             left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                on N.NOMEN_ID=DR.NOMEN_ID
      where d.doc_date between :date_in and 'today'     and
            d.typedoc_id   != 10                        and
            ((d.objects_id = :objects_id) or (d.clients_id = :objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, p_kilk,
            p_src_id, p_dst_id, p_tvat_id, s_in, s_in_vat,
            p_price
 do begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date > :date_out) then begin
    if (:p_dst_id = :objects_id) then begin
     e_k     = -:p_kilk;
     e_s_in  = -:s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then begin
     e_k     = :p_kilk;
     e_s_in  = :s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
   end
  else begin
    if (:p_dst_id = :objects_id) then begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = :p_kilk;
     p_s_in  = :s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = :p_kilk;
     r_s_in  = :s_in;
     r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat = (:p_kilk * :p_price) - :r_s_out;
    end
   end
  b_k    = :e_k + :r_k - :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE_ABC (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10),
    OGRP_ID INTEGER)
AS
declare variable pall_kilk double precision;
declare variable pa_kilk double precision;
declare variable pb_kilk double precision;
declare variable pcurent_kilk integer;
declare variable plitera_kilk integer;
declare variable pold_litera varchar(1);
begin
  if (:abc_prm is null) then abc_prm = 0;
  if (:type_prm is null) then type_prm = 0;
  /*
    abc_prm = 0 - Не показувати
    abc_prm = 1 - Кінцева к-сть
    abc_prm = 2 - Розхідна к-сть
    abc_prm = 3 - Кінцева сума
    abc_prm = 4 - Розхідна сума

    type_prm = 0 - RS_RALASE_V1
    type_prm = 1 - RS_RALASE_MANAGER_V1
    type_prm = 2 - RS_RALASE_LIST_V1
  */
  /*Всі блоки for select однакові. Різниця лише в назві процедури. Щоб оптимізнути не хватає
    функціоналу Фіребірд 1.5 (exec не катить), або знань*/
  pcurent_kilk = 0;
  plitera_kilk = -1;
  pold_litera  = 'A';
if (:type_prm = 0) then  begin
/*RS_RALASE_V1*/
  select count(distinct n.nomen_id)
    from t_grp_childs_shelfs(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for SELECT rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name,         
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             rs.ogrp_id
        from rs_ralase_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name, rs.ogrp_id
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into nomen_id, nomen_code, nomen_name, shelf, grp_name,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, ogrp_id
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end   else
if (:type_prm = 1) then  begin
/*RS_RALASE_MANAGER_V1*/
  select count(distinct n.nomen_id)
    from t_grp_manager(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for SELECT rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name,         
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             rs.ogrp_id
        from RS_RALASE_MANAGER_V1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name, rs.ogrp_id
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into nomen_id, nomen_code, nomen_name, shelf, grp_name,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, ogrp_id
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end else
if (:type_prm = 2) then  begin
/*RS_RALASE_LIST_V1*/
  select count(distinct n.nomen_id)
    from t_grp_childs_list(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for SELECT rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name,         
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             rs.ogrp_id
        from RS_RALASE_LIST_V1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.nomen_id, rs.nomen_code, rs.nomen_name, rs.shelf, rs.ogrp_name, rs.ogrp_id
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into nomen_id, nomen_code, nomen_name, shelf, grp_name,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, ogrp_id
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end
end^


ALTER PROCEDURE RS_RALASE_ABC_1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
declare variable pall_kilk double precision;
declare variable pa_kilk double precision;
declare variable pb_kilk double precision;
declare variable pcurent_kilk integer;
declare variable plitera_kilk integer;
declare variable pold_litera varchar(1);
begin
  if (:abc_prm is null) then abc_prm = 0;
  if (:type_prm is null) then type_prm = 0;
  /*
    abc_prm = 0 - Не показувати
    abc_prm = 1 - Кінцева к-сть
    abc_prm = 2 - Розхідна к-сть
    abc_prm = 3 - Кінцева сума
    abc_prm = 4 - Розхідна сума

    type_prm = 0 - RS_RALASE_V1
    type_prm = 1 - RS_RALASE_MANAGER_V1
    type_prm = 2 - RS_RALASE_LIST_V1
  */
  /*Всі блоки for select однакові. Різниця лише в назві процедури. Щоб оптимізнути не хватає
    функціоналу Фіребірд 1.5 (exec не катить), або знань*/
  select count(distinct gch.rgrp_id)
    from t_grp_childs_shelfs(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;
  pcurent_kilk = 0;
  plitera_kilk = -1;
  pold_litera  = 'A';
if (:type_prm = 0) then  begin
/*RS_RALASE_V1*/
  for select rs.grp_name, rs.shelf,                                        
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in
        from rs_ralase_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into grp_name, shelf,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end   else
if (:type_prm = 1) then  begin
/*RS_RALASE_MANAGER_V1*/
  select count(distinct gch.rgrp_id)
    from t_grp_manager(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for select rs.grp_name, rs.shelf,                                        
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in
        from rs_ralase_manager_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into grp_name, shelf,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end else
if (:type_prm = 2) then  begin
/*RS_RALASE_LIST_V1*/
  select count(distinct gch.rgrp_id)
    from t_grp_childs_list(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;

  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for select rs.grp_name, rs.shelf,                                        
             sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in
        from rs_ralase_list_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into grp_name, shelf,
             b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end
end^


ALTER PROCEDURE RS_RALASE_ABC_2 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
declare variable pall_kilk double precision;
declare variable pa_kilk double precision;
declare variable pb_kilk double precision;
declare variable pcurent_kilk integer;
declare variable plitera_kilk integer;
declare variable pold_litera varchar(1);
begin
  if (:abc_prm is null) then abc_prm = 0;
  if (:type_prm is null) then type_prm = 0;
  /*
    abc_prm = 0 - Не показувати
    abc_prm = 1 - Кінцева к-сть
    abc_prm = 2 - Розхідна к-сть
    abc_prm = 3 - Кінцева сума
    abc_prm = 4 - Розхідна сума

    type_prm = 0 - RS_RALASE_V1
    type_prm = 1 - RS_RALASE_MANAGER_V1
    type_prm = 2 - RS_RALASE_LIST_V1
  */
  /*Всі блоки for select однакові. Різниця лише в назві процедури. Щоб оптимізнути не хватає
    функціоналу Фіребірд 1.5 (exec не катить), або знань*/

  pcurent_kilk = 0;
  plitera_kilk = -1;
  pold_litera  = 'A';
if (:type_prm = 0) then  begin
/*RS_RALASE_V1*/
  select count(distinct gch.rgrp_id)
    from t_grp_childs_shelfs(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;
    
  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for select sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             sum(rs.shelf) as shelf
        from rs_ralase_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, shelf
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end   else
if (:type_prm = 1) then  begin
/*RS_RALASE_MANAGER_V1*/
  select count(distinct gch.rgrp_id)
    from t_grp_manager(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;
    
  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for select sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             sum(rs.shelf) as shelf
        from rs_ralase_manager_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, shelf
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end else
if (:type_prm = 2) then  begin
/*RS_RALASE_LIST_V1*/
  select count(distinct gch.rgrp_id)
    from t_grp_childs_list(:ingrp_id) gch
         join nomen n on gch.rgrp_id = n.grp_id
    into pall_kilk;
    
  pa_kilk = :pall_kilk / 100 * 50;
  pb_kilk = :pall_kilk / 100 * 30;

  for select sum(rs.b_k) as b_k, sum(rs.b_s_in) b_s_in,
             sum(rs.p_k) as p_k, sum(rs.p_s_in) p_s_in,
             sum(rs.r_k) as r_k, sum(rs.r_s_out) as r_s_out,
             sum(rs.r_s_vat) as r_s_vat, sum(rs.r_s_in) as r_s_in,
             sum(rs.e_k) as e_k, sum(rs.e_s_in) as e_s_in,
             sum(rs.shelf) as shelf
        from rs_ralase_list_v1(:objects_id, :date_in, :date_out, :ingrp_id, :flag0) rs
    group by rs.grp_name, rs.shelf
    order by case :abc_prm
                when 1 then sum(rs.e_k)
                when 2 then sum(rs.r_k)
                when 3 then sum(rs.e_s_in)
                when 4 then sum(rs.r_s_out)
                else null
             end desc
        into b_k, b_s_in, p_k, p_s_in,
             r_k, r_s_out, r_s_vat, r_s_in,
             e_k, e_s_in, shelf
  do begin
    if (:abc_prm > 0) then
    begin
      pcurent_kilk = :pcurent_kilk + 1;
      plitera_kilk = :plitera_kilk + 1;
      if (:pcurent_kilk <= :pa_kilk) then
        abc = 'A'; else
      if (:pcurent_kilk <= :pa_kilk + :pb_kilk) then
        abc = 'B'; else
        abc = 'C';
      if (:pold_litera != :abc) then
      begin
        plitera_kilk = 0;
        pold_litera = :abc;
      end

      abc = :abc || cast(:plitera_kilk as varchar(9));
    end
    suspend;
  end
end
end^


ALTER PROCEDURE RS_RALASE_ABC_3 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    INGRP_ID VARCHAR(1000),
    FLAG0 SMALLINT,
    ABC_PRM SMALLINT,
    TYPE_PRM SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    ABC VARCHAR(10))
AS
declare variable pall_kilk double precision;
declare variable pa_kilk double precision;
declare variable pb_kilk double precision;
declare variable pcurent_kilk integer;
declare variable plitera_kilk integer;
declare variable pold_litera varchar(1);
declare variable pgrp_name varchar(40);
begin
  for select g.grp_id, g.grp_name from grp g
       where g.prew_grp_id is null
        into ingrp_id, pgrp_name
  do begin
     select grp_name, sum(b_k), sum(b_s_in), sum(p_k),
               sum(p_s_in), sum(r_k), sum(r_s_in), sum(r_s_vat), sum(r_s_out), sum(e_k), sum(e_s_in)
          from RS_RALASE_ABC_2(:objects_id, :date_in, :date_out, :ingrp_id, :flag0, :abc_prm, :type_prm)
      group by grp_name
          into grp_name, b_k, b_s_in, p_k,
               p_s_in, r_k, r_s_in, r_s_vat, r_s_out, e_k, e_s_in;
    grp_name = :pgrp_name;
    if (b_k     is null) then b_k     = 0;
    if (b_s_in  is null) then b_s_in  = 0;
    if (p_k     is null) then p_k     = 0;
    if (p_s_in  is null) then p_s_in  = 0;
    if (r_k     is null) then r_k     = 0;
    if (r_s_in  is null) then r_s_in  = 0;
    if (r_s_vat is null) then r_s_vat = 0;
    if (r_s_out is null) then r_s_out = 0;
    if (e_k     is null) then e_k     = 0;
    if (e_s_in  is null) then e_s_in  = 0;
    suspend;
    b_k     = null;
    b_s_in  = null;
    p_k     = null;
    p_s_in  = null;
    r_k     = null;
    r_s_in  = null;
    r_s_vat = null;
    r_s_out = null;
    e_k     = null;
    e_s_in  = null;
  end
end^


ALTER PROCEDURE RS_RALASE_COPY (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    RGRP_ID VARCHAR(200))
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
BEGIN
 FOR SELECT N.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, R.REST, R.REST_SUM,
            N.TYPEPDV_ID, GCH.RGRP_NAME
      FROM T_GRP_CHILDS_CHILDS(:GRP_ID) GCH
           LEFT JOIN NOMEN N ON GCH.RGRP_ID=N.GRP_ID
           LEFT JOIN RST R ON N.NOMEN_ID=R.NOMEN_ID
      WHERE R.OBJECTS_ID=:OBJECTS_ID
      INTO :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME, :E_K, :S_IN_VAT,
           :P_TVAT_ID, :RGRP_ID
 DO BEGIN
  IF (:S_IN_VAT IS NULL) THEN S_IN_VAT=0.000;
  IF (:P_TVAT_ID IN (2, 3)) THEN BEGIN P_TVAT_VALUE=0.2; END
   ELSE BEGIN P_TVAT_VALUE=0.0; END
  E_S_IN=CALCSUM(:S_IN_VAT, 0.000, 0.0, :P_TVAT_ID, 0);
  B_K=:E_K;
  B_S_IN=:E_S_IN;
  P_K   =0.000;
  P_S_IN=0.000;
  R_K   =0.000;
  R_S_IN=0.000;
  R_S_VAT=0.000;
  R_S_OUT=0.000;
  SUSPEND;
 END
 FOR SELECT D.DOC_DATE, N.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, DR.KILK, GCH.RGRP_NAME,
            D.OBJECTS_ID, D.CLIENTS_ID, DR.TYPEPDV_ID, DR.INSUM, DR.INSUM_PDV, CALCPRICEPDV(DR.PRICE, D.DISC_PERSENT, DR.DISC_PERSENT, 6)
      FROM (T_GRP_CHILDS_CHILDS(:GRP_ID) GCH LEFT JOIN NOMEN N ON GCH.RGRP_ID=N.GRP_ID)
           JOIN
           (DOCUMENTS D LEFT JOIN DOCREC DR ON D.DOCUMENT_ID=DR.DOCUMENT_ID)
           ON N.NOMEN_ID=DR.NOMEN_ID
      WHERE D.DOC_DATE BETWEEN :DATE_IN AND 'TODAY' AND
            d.typedoc_id   != 10                    and
            ((D.OBJECTS_ID=:OBJECTS_ID) OR (D.CLIENTS_ID=:OBJECTS_ID))
      INTO :P_DOC_DATE, :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME, :P_KILK, :RGRP_ID,
           :P_SRC_ID, :P_DST_ID, :P_TVAT_ID, :S_IN, :S_IN_VAT, :P_PRICE
 DO BEGIN
  IF (:S_IN IS NULL) THEN S_IN=0.000;
  IF (:S_IN_VAT IS NULL) THEN S_IN_VAT=0.000;
  IF (:P_PRICE IS NULL) THEN P_PRICE=0.000;
  IF (:P_KILK IS NULL) THEN P_KILK=0.000;
  IF (:P_TVAT_ID IN (2, 3)) THEN BEGIN P_TVAT_VALUE=0.2; END
   ELSE BEGIN P_TVAT_VALUE=0.0; END
  IF (:P_DOC_DATE>:DATE_OUT) THEN BEGIN
    IF (:P_DST_ID=:OBJECTS_ID) THEN BEGIN
     E_K   =-:P_KILK;
     E_S_IN=-:S_IN;
     P_K   =0.000;
     P_S_IN=0.000;
     R_K   =0.000;
     R_S_IN=0.000;
     R_S_VAT=0.000;
     R_S_OUT=0.000;
    END
    IF (:P_SRC_ID=:OBJECTS_ID) THEN BEGIN
     E_K   =:P_KILK;
     E_S_IN=:S_IN;
     P_K   =0.000;
     P_S_IN=0.000;
     R_K   =0.000;
     R_S_IN=0.000;
     R_S_VAT=0.000;
     R_S_OUT=0.000;
    END
   END
  ELSE BEGIN
    IF (:P_DST_ID=:OBJECTS_ID) THEN BEGIN
     E_K   =0.000;
     E_S_IN=0.000;
     P_K   =:P_KILK;
     P_S_IN=:S_IN;
     R_K   =0.000;
     R_S_IN=0.000;
     R_S_VAT=0.000;
     R_S_OUT=0.000;
    END
    IF (:P_SRC_ID=:OBJECTS_ID) THEN BEGIN
     E_K   =0.000;
     E_S_IN=0.000;
     P_K   =0.000;
     P_S_IN=0.000;
     R_K   =:P_KILK;
     R_S_IN=:S_IN;
     R_S_OUT=CALCSUM((:P_KILK*:P_PRICE), (:P_KILK*:P_PRICE)-:S_IN_VAT, :P_TVAT_VALUE, :P_TVAT_ID, 0);
     R_S_VAT=(:P_KILK*:P_PRICE)-:R_S_OUT;
    END
   END
  B_K=:E_K+:R_K-:P_K;
  B_S_IN=:E_S_IN+:R_S_IN-:P_S_IN;
  SUSPEND;
 END
END^


ALTER PROCEDURE RS_RALASE_LIST (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID VARCHAR(10000))
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf
       from t_grp_childs_list(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r on n.nomen_id=r.nomen_id
      where r.objects_id=:objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  e_s_in=calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k     = :e_k;
  b_s_in  = :e_s_in;
  p_k     = 0.000;
  p_s_in  = 0.000;
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_vat = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 select max(d.doc_date)
  from documents d
  into :p_date_out;
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv
       from (t_grp_childs_list(:grp_id) gch
             left join nomen n on gch.rgrp_id=n.grp_id)
                join
            (documents d left join docrec dr on d.document_id=dr.document_id
             left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs on 1=1)
                on n.nomen_id = dr.nomen_id
      where d.doc_date between :date_in and :p_date_out     and
            d.typedoc_id   != 10                            and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0))) and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price
 do begin
  if (:s_in      is null)   then s_in     = 0.000;
  if (:s_in_vat  is null)   then s_in_vat = 0.000;
  if (:p_price   is null)   then p_price  = 0.000;
  if (:p_kilk    is null)   then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
    else begin p_tvat_value=0.0; end
  if (:p_doc_date>:date_out) then
  begin
    if (:p_dst_id=:objects_id) then
    begin
     e_k     = -:p_kilk;
     e_s_in  = -:s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id=:objects_id) then
    begin
     e_k    = :p_kilk;
     e_s_in = :s_in;
     p_k    = 0.000;
     p_s_in = 0.000;
     r_k    = 0.000;
     r_s_in = 0.000;
     r_s_vat= 0.000;
     r_s_out= 0.000;
    end
  end
  else
  begin
    if (:p_dst_id = :objects_id) then
    begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = :p_kilk;
     p_s_in  = :s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = :p_kilk;
     r_s_in  = :s_in;
     r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat,:p_tvat_value, :p_tvat_id, 0);
     r_s_vat = (:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k    = :e_k + :r_k -  :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE_LIST_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID VARCHAR(10000),
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            g.grp_id
       from t_grp_childs_list(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
     if (:s_in_vat is null)    then s_in_vat=0.000;
     if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
       else begin p_tvat_value = 0.0; end
     e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
     b_k     = :e_k;
     b_s_in  = :e_s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv,
            n.is_visible, g.grp_name, g.grp_id
       from (t_grp_childs_list(:grp_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id)
                join
            (documents d left join docrec dr on d.document_id = dr.document_id
             left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs on 1=1)
                on n.nomen_id = dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out and
            d.typedoc_id   != 10                        and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0))) and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
      into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name, shelf,
           p_kilk, p_src_id, p_dst_id, p_tvat_id, s_in, s_in_vat, p_price,
           pis_visible, ogrp_name, ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value = 0.2; end
    else begin p_tvat_value=0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
    begin
     e_k     = -:p_kilk;
     e_s_in  = -:s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
     e_k     = :p_kilk;
     e_s_in  = :s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
  end
  else
  begin
    if (:p_dst_id = :objects_id) then
    begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = :p_kilk;
     p_s_in  = :s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = :p_kilk;
     r_s_in  = :s_in;
     r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat,:p_tvat_value, :p_tvat_id, 0);
     r_s_vat = (:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k    = :e_k    + :r_k - :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
  end
 end
end^


ALTER PROCEDURE RS_RALASE_MANAGER (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    MANAGER_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf
       from t_grp_manager(:manager_id) gch
            left join nomen n on gch.rgrp_id=n.grp_id
            left join rst r on n.nomen_id=r.nomen_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  e_s_in=calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k=:e_k;
  b_s_in=:e_s_in;
  p_k   =0.000;
  p_s_in=0.000;
  r_k   =0.000;
  r_s_in=0.000;
  r_s_vat=0.000;
  r_s_out=0.000;
  suspend;
 end
 select max(d.doc_date)
  from documents d
  into :p_date_out;
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv
      from (t_grp_manager(:manager_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
               join
           (documents d left join docrec dr on d.document_id=dr.document_id
            left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
               on n.nomen_id=dr.nomen_id
      where d.doc_date between :date_in and :p_date_out and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0))) and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price
 do begin
  if (:s_in is null) then s_in=0.000;
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_price is null) then p_price=0.000;
  if (:p_kilk is null) then p_kilk=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date>:date_out) then begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =-:p_kilk;
     e_s_in=-:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =:p_kilk;
     e_s_in=:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
   end
  else begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =:p_kilk;
     p_s_in=:s_in;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =:p_kilk;
     r_s_in=:s_in;
     r_s_out=calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat=(:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k=:e_k+:r_k-:p_k;
  b_s_in=:e_s_in+:r_s_in-:p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE_MANAGER_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    MANAGER_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            g.grp_id
       from t_grp_manager(:manager_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id    = gch.rgrp_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then begin p_tvat_value = 0.2; end
       else begin p_tvat_value = 0.0; end
     e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
     b_k     = :e_k;
     b_s_in  = :e_s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            g.grp_id
       from (t_grp_manager(:manager_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
                join
            (documents d left join docrec dr on d.document_id=dr.document_id
             left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0))) and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date > :date_out) then begin
    if (:p_dst_id = :objects_id) then begin
     e_k     = -:p_kilk;
     e_s_in  = -:s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k     = :p_kilk;
     e_s_in  = :s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
   end
  else begin
    if (:p_dst_id=:objects_id) then begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = :p_kilk;
     p_s_in  = :s_in;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k     = 0.000;
     e_s_in  = 0.000;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = :p_kilk;
     r_s_in  = :s_in;
     r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat = (:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k    = :e_k + :r_k - :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
  end
 end
end^


ALTER PROCEDURE RS_RALASE_SG (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    SG_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id
       from nomen n left join rst r on n.nomen_id=r.nomen_id
      where n.sg_id=:sg_id and
            r.objects_id=:objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id
 do begin
  if (:s_in_vat is null) then s_in_vat=0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
  b_k     = :e_k;
  b_s_in  = :e_s_in;
  p_k     = 0.000;
  p_s_in  = 0.000;
  r_k     = 0.000;
  r_s_in  = 0.000;
  r_s_vat = 0.000;
  r_s_out = 0.000;
  suspend;
 end
 select max(d.doc_date)
  from documents d
  into :p_date_out;
 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id, dr.insum, dr.insum_pdv,
            gs.oprice_pdv
       from nomen n
            join docrec dr on (n.nomen_id = dr.nomen_id)
            left join documents d on (d.document_id = dr.document_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where n.sg_id         =  :sg_id                   and
            d.typedoc_id   !=  10                       and
            d.doc_date between :date_in and :p_date_out and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, p_kilk,
            p_src_id, p_dst_id, p_tvat_id, s_in, s_in_vat,
            p_price
 do begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date>:date_out) then begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =-:p_kilk;
     e_s_in=-:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =:p_kilk;
     e_s_in=:s_in;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
   end
  else begin
    if (:p_dst_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =:p_kilk;
     p_s_in=:s_in;
     r_k   =0.000;
     r_s_in=0.000;
     r_s_vat=0.000;
     r_s_out=0.000;
    end
    if (:p_src_id=:objects_id) then begin
     e_k   =0.000;
     e_s_in=0.000;
     p_k   =0.000;
     p_s_in=0.000;
     r_k   =:p_kilk;
     r_s_in=:s_in;
     r_s_out=calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
     r_s_vat=(:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k=:e_k+:r_k-:p_k;
  b_s_in=:e_s_in+:r_s_in-:p_s_in;
  suspend;
 end
end^


ALTER PROCEDURE RS_RALASE_SG_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    SG_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40))
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
begin
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, n.is_visible, g.grp_name
       from nomen n
            left join rst r on n.nomen_id = r.nomen_id
            left join grp g on n.grp_id   = g.grp_id
      where n.sg_id      = :sg_id and
            r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, pis_visible, ogrp_name
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
     if (:s_in_vat is null)    then s_in_vat=0.000;
     if (:p_tvat_id in (2, 3)) then begin p_tvat_value = 0.2; end
       else begin p_tvat_value=0.0; end
     e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
     b_k     = :e_k;
     b_s_in  = :e_s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, dr.kilk,
            d.objects_id, d.clients_id, dr.typepdv_id, dr.insum, dr.insum_pdv,
            gs.oprice_pdv, n.is_visible, g.grp_name
       from nomen n
            join docrec dr on (n.nomen_id = dr.nomen_id)
            left join documents d on (d.document_id = dr.document_id)
            join grp g on (n.grp_id = g.grp_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
      where n.sg_id         =  :sg_id                   and
            d.typedoc_id   !=  10                       and
            d.doc_date between :date_in and :p_date_out and
            ((d.objects_id = :objects_id) or (d.clients_id = :objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, p_kilk,
            p_src_id, p_dst_id, p_tvat_id, s_in, s_in_vat,
            p_price, pis_visible, ogrp_name
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
     if (:s_in     is null) then s_in     = 0.000;
     if (:s_in_vat is null) then s_in_vat = 0.000;
     if (:p_price  is null) then p_price  = 0.000;
     if (:p_kilk   is null) then p_kilk   = 0.000;
     if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
       else begin p_tvat_value = 0.0; end
     if (:p_doc_date > :date_out) then
     begin
       if (:p_dst_id = :objects_id) then begin
         e_k     = -:p_kilk;
         e_s_in  = -:s_in;
         p_k     = 0.000;
         p_s_in  = 0.000;
         r_k     = 0.000;
         r_s_in  = 0.000;
         r_s_vat = 0.000;
         r_s_out = 0.000;
       end
       if (:p_src_id = :objects_id) then begin
         e_k     = :p_kilk;
         e_s_in  = :s_in;
         p_k     = 0.000;
         p_s_in  = 0.000;
         r_k     = 0.000;
         r_s_in  = 0.000;
         r_s_vat = 0.000;
         r_s_out = 0.000;
       end
     end
     else begin
       if (:p_dst_id = :objects_id) then begin
         e_k     = 0.000;
         e_s_in  = 0.000;
         p_k     = :p_kilk;
         p_s_in  = :s_in;
         r_k     = 0.000;
         r_s_in  = 0.000;
         r_s_vat = 0.000;
         r_s_out = 0.000;
       end
       if (:p_src_id = :objects_id) then begin
         e_k     = 0.000;
         e_s_in  = 0.000;
         p_k     = 0.000;
         p_s_in  = 0.000;
         r_k     = :p_kilk;
         r_s_in  = :s_in;
         r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
         r_s_vat = (:p_kilk*:p_price)-:r_s_out;
       end
     end
     b_k    = :e_k    + :r_k - :p_k;
     b_s_in = :e_s_in + :r_s_in - :p_s_in;
     suspend;
   end
 end
end^


ALTER PROCEDURE RS_RALASE_V1 (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    GRP_ID INTEGER,
    FLAG0 SMALLINT)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    GRP_NAME VARCHAR(40),
    B_K DOUBLE PRECISION,
    B_S_IN DOUBLE PRECISION,
    P_K DOUBLE PRECISION,
    P_S_IN DOUBLE PRECISION,
    R_K DOUBLE PRECISION,
    R_S_IN DOUBLE PRECISION,
    R_S_VAT DOUBLE PRECISION,
    R_S_OUT DOUBLE PRECISION,
    E_K DOUBLE PRECISION,
    E_S_IN DOUBLE PRECISION,
    SHELF DOUBLE PRECISION,
    OGRP_NAME VARCHAR(40),
    OGRP_ID INTEGER)
AS
declare variable p_doc_date date;
declare variable p_kilk double precision;
declare variable p_dst_id integer;
declare variable p_src_id integer;
declare variable s_in double precision;
declare variable s_in_vat double precision;
declare variable p_tvat_id integer;
declare variable p_tvat_value double precision;
declare variable p_price double precision;
declare variable p_date_out date;
declare variable pis_visible smallint;
begin
/* flag0 = 1 - лише видимі товари */
 for select n.nomen_id, n.nomen_code, n.nomen_name, r.rest, r.rest_sum,
            n.typepdv_id, gch.rgrp_name, gch.rshelf, n.is_visible, g.grp_name,
            g.grp_id
       from t_grp_childs_shelfs(:grp_id) gch
            left join nomen n on gch.rgrp_id = n.grp_id
            left join rst r   on n.nomen_id  = r.nomen_id
            inner join grp g  on g.grp_id = gch.rgrp_id
      where r.objects_id = :objects_id
       into nomen_id, nomen_code, nomen_name, e_k, s_in_vat,
            p_tvat_id, grp_name, shelf, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
     if (:s_in_vat is null)    then s_in_vat = 0.000;
     if (:p_tvat_id in (2, 3)) then begin p_tvat_value = 0.2; end
       else begin p_tvat_value = 0.0; end
     e_s_in  = calcsum(:s_in_vat, 0.000, 0.0, :p_tvat_id, 0);
     b_k     = :e_k;
     b_s_in  = :e_s_in;
     p_k     = 0.000;
     p_s_in  = 0.000;
     r_k     = 0.000;
     r_s_in  = 0.000;
     r_s_vat = 0.000;
     r_s_out = 0.000;
     suspend;
   end
 end

 select max(d.doc_date) from documents d
   into p_date_out;

 for select d.doc_date, n.nomen_id, n.nomen_code, n.nomen_name, gch.rgrp_name,
            gch.rshelf, dr.kilk, d.objects_id, d.clients_id, dr.typepdv_id,
            dr.insum, dr.insum_pdv, gs.oprice_pdv, n.is_visible, g.grp_name,
            g.grp_id
       from (t_grp_childs_shelfs(:grp_id) gch left join nomen n on gch.rgrp_id=n.grp_id)
                join
            (documents d left join docrec dr on d.document_id=dr.document_id
             left join ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs on 1=1)
                on n.nomen_id=dr.nomen_id
            inner join grp g on g.grp_id = gch.rgrp_id
      where d.doc_date between :date_in and :p_date_out             and
            d.typedoc_id   != 10                                    and
            (not ((d.typedoc_id in (4, 11)) and (d.doc_lock = 0)))  and
            ((d.objects_id=:objects_id) or (d.clients_id=:objects_id))
       into p_doc_date, nomen_id, nomen_code, nomen_name, grp_name,
            shelf, p_kilk, p_src_id, p_dst_id, p_tvat_id,
            s_in, s_in_vat, p_price, pis_visible, ogrp_name,
            ogrp_id
 do begin
   if (((:flag0  = 1)and(:pis_visible = 1))or
       ((:flag0 != 1)or(:flag0 is null))) then
   begin
  if (:s_in     is null) then s_in     = 0.000;
  if (:s_in_vat is null) then s_in_vat = 0.000;
  if (:p_price  is null) then p_price  = 0.000;
  if (:p_kilk   is null) then p_kilk   = 0.000;
  if (:p_tvat_id in (2, 3)) then begin p_tvat_value=0.2; end
   else begin p_tvat_value=0.0; end
  if (:p_doc_date > :date_out) then
  begin
    if (:p_dst_id = :objects_id) then
    begin
      e_k     = -:p_kilk;
      e_s_in  = -:s_in;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then
    begin
      e_k     = :p_kilk;
      e_s_in  = :s_in;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
  end
  else begin
    if (:p_dst_id = :objects_id) then begin
      e_k     = 0.000;
      e_s_in  = 0.000;
      p_k     = :p_kilk;
      p_s_in  = :s_in;
      r_k     = 0.000;
      r_s_in  = 0.000;
      r_s_vat = 0.000;
      r_s_out = 0.000;
    end
    if (:p_src_id = :objects_id) then begin
      e_k     = 0.000;
      e_s_in  = 0.000;
      p_k     = 0.000;
      p_s_in  = 0.000;
      r_k     = :p_kilk;
      r_s_in  = :s_in;
      r_s_out = calcsum((:p_kilk*:p_price), (:p_kilk*:p_price)-:s_in_vat, :p_tvat_value, :p_tvat_id, 0);
      r_s_vat = (:p_kilk*:p_price)-:r_s_out;
    end
   end
  b_k    = :e_k + :r_k - :p_k;
  b_s_in = :e_s_in + :r_s_in - :p_s_in;
  suspend;
  end
 end
end^


ALTER PROCEDURE RV_RALASE_GOOD (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGOODS_ID INTEGER)
RETURNS (
    RGOODS_ID INTEGER,
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RSTAFF_ID INTEGER)
AS
declare variable ppdv double precision;
declare variable ptypepdv integer;
declare variable pkilk double precision;
declare variable pprice double precision;
declare variable pdisc1 double precision;
declare variable pobject_id double precision;
declare variable pstaff_id integer;
declare variable pinprice double precision;
declare variable pnacinka double precision;
declare variable psum double precision;
declare variable pin_sum double precision;
declare variable pdocrec_id integer;
begin

  select n.nomen_id, n.typepdv_id, t.pdv, g.goods_inprice  from goods g, nomen n, typepdv t
   where g.goods_id = :vgoods_id and
         n.nomen_id = g.nomen_id and
         n.typepdv_id = t.typepdv_id
    into rnomen_id, ptypepdv, ppdv, pinprice;

  for select dr.price, dg.kilk, d.disc_persent, d.staff_id, d.objects_id, dr.docrec_id
        from documents d, docrec dr, docgoods dg
       where (d.objects_id   = :vsklad_id)           and
             d.doc_date between :vdate1 and :vdate2  and
             d.typedoc_id   != 10                    and
             dg.goods_id     = :vgoods_id            and
             d.document_id   = dr.document_id        and
             dr.docrec_id    = dg.docrec_id
        into pprice, pkilk, pdisc1, pstaff_id, pobject_id, pdocrec_id
  do begin
    rgoods_id = :vgoods_id;
    rrashod_k = 0.0;
    rrashod_s_pdv = 0.0;
    rrashod_s = 0.0;
    rpdv = 0.0;
    rnacinka = 0.0;
    rin_sum = 0.0;

    rstaff_id = :pstaff_id;
    select oprice_pdv from ps_get_sum(:pdocrec_id, :pdisc1, 0)
      into pprice;
    psum = :pprice * :pkilk;
    pin_sum = :pinprice * :pkilk;
    pnacinka = :psum - :pin_sum;

    rin_sum = :rin_sum + :pin_sum;
    rrashod_s_pdv = :rrashod_s_pdv + :psum;
    rrashod_s = rrashod_s + calcsum(:psum, :pnacinka, :ppdv, :ptypepdv, 6);
    rnacinka = :rnacinka + :pnacinka;
    rpdv = :rrashod_s_pdv - :rrashod_s;
    rrashod_k = :rrashod_k + :pkilk;
    suspend;
  end
end^


ALTER PROCEDURE RV_RALASE_GRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
begin
  rgrp_id = :vgrp_id;
  for select n.nomen_id from nomen n
      where n.grp_id = :vgrp_id
    into :rnomen_id
  do begin
    for select rstaff_id, sum(rrashod_k), sum(rrashod_s),
             sum(rrashod_s_pdv), sum(rpdv), sum(rnacinka), sum(rin_sum)
              from rv_ralase_nomen(:vdate1, :vdate2, :vsklad_id, :rnomen_id)
      group by rstaff_id
    into :rstaff_id, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka, :rin_sum
    do begin
      suspend;
    end
  end
end^


ALTER PROCEDURE RV_RALASE_INGRP (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VGRP_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
DECLARE VARIABLE PGRP_ID INTEGER;
begin
  rgrp_id = :vgrp_id;
  for select rgrp_id from t_grp_childs(:vgrp_id)
    into :pgrp_id
  do begin
    for select rnomen_id, rrashod_k, rrashod_s, rrashod_s_pdv, rpdv, rnacinka, rin_sum, rgrp_id, rstaff_id
        from rv_ralase_grp(:vdate1, :vdate2, :vsklad_id, :pgrp_id)
      into :rnomen_id, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka, :rin_sum, :rgrp_id, :rstaff_id
    do begin
      suspend;
    end
  end
end^


ALTER PROCEDURE RV_RALASE_NOMEN (
    VDATE1 DATE,
    VDATE2 DATE,
    VSKLAD_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RNOMEN_ID INTEGER,
    RRASHOD_K DOUBLE PRECISION,
    RRASHOD_S_PDV DOUBLE PRECISION,
    RIN_SUM DOUBLE PRECISION,
    RNACINKA DOUBLE PRECISION,
    RPDV DOUBLE PRECISION,
    RRASHOD_S DOUBLE PRECISION,
    RGRP_ID INTEGER,
    RSTAFF_ID INTEGER)
AS
DECLARE VARIABLE PPDV DOUBLE PRECISION;
DECLARE VARIABLE PNACINKA DOUBLE PRECISION;
DECLARE VARIABLE PIN_SUM DOUBLE PRECISION;
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PRASHOD_K DOUBLE PRECISION;
DECLARE VARIABLE PRASHOD_S DOUBLE PRECISION;
DECLARE VARIABLE PRASHOD_S_PDV DOUBLE PRECISION;
begin

  select n.grp_id from nomen n
    where n.nomen_id = :vnomen_id
  into :rgrp_id;

  for select g.goods_id from goods g
      where g.nomen_id = :vnomen_id
    into :pgoods_id
  do begin
    rnomen_id = :vnomen_id;
    rrashod_k = 0.0;
    rrashod_s_pdv = 0.0;
    rrashod_s = 0.0;
    rpdv = 0.0;
    rnacinka = 0.0;
    rin_sum = 0.0;
    for select rstaff_id, sum(rrashod_k),
                  sum(rrashod_s), sum(rrashod_s_pdv), sum(rpdv), sum(rnacinka), sum(rin_sum)
              from rv_ralase_good(:vdate1, :vdate2, :vsklad_id, :pgoods_id)
      group by rstaff_id
      into :rstaff_id, :rrashod_k, :rrashod_s, :rrashod_s_pdv, :rpdv, :rnacinka, :rin_sum
    do begin
      suspend;
    end
  end
end^


ALTER PROCEDURE S_AUTH_CREATE (
    V_AUTH_DATE DATE,
    V_AUTH_NUM VARCHAR(12),
    V_AUTH_NAME VARCHAR(40))
RETURNS (
    R_AUTH_ID INTEGER)
AS
BEGIN
 R_AUTH_ID=GEN_ID(GEN_AUTH_ID, 1);
 INSERT INTO AUTH (AUTH_ID, AUTH_DATE, AUTH_NUM, AUTH_NAME)
  VALUES(:R_AUTH_ID, :V_AUTH_DATE, :V_AUTH_NUM, :V_AUTH_NAME);
 SUSPEND;
END^


ALTER PROCEDURE S_BARCODE_ATTACH (
    VBARCODE_ID INTEGER,
    VNOMEN_ID INTEGER)
RETURNS (
    RIS_EXIST INTEGER)
AS
DECLARE VARIABLE PNOM_BAR_ID INTEGER;
begin
  /* Procedure Text */
  select nb.nom_bar_id from nom_bar nb
    where nb.nomen_id = :vnomen_id and
          nb.barcode_id = :vbarcode_id
  into :pnom_bar_id;
  if (:pnom_bar_id is not null) then
  begin
    ris_exist = 1;
    suspend;
  end
  else
  begin
    insert into nom_bar(nomen_id, barcode_id)
      values(:vnomen_id, :vbarcode_id);
    ris_exist = 0;
    suspend;
  end
end^


ALTER PROCEDURE S_BARCODE_CREATE (
    VCODE VARCHAR(27))
RETURNS (
    RBARCODE_ID INTEGER)
AS
begin
  /* Procedure Text */
  select max(b.barcode_id) from barcode b
      where     b.code = :vcode
  into :rbarcode_id;

  if (rbarcode_id is null) then
  begin
      rbarcode_id = GEN_ID(GEN_BARCODE_ID,1);
      insert into barcode(barcode_id, code)
        values(:rbarcode_id, :vcode);
  end
  suspend;
end^


ALTER PROCEDURE S_BARCODE_DELETE (
    VCODE VARCHAR(27),
    VNOMEN_ID INTEGER)
AS
DECLARE VARIABLE PBARCODE_ID INTEGER;
begin
  select b.barcode_id from barcode b
    where b.code = :vcode
  into :pbarcode_id;

  delete from nom_bar nb
    where nb.barcode_id = :pbarcode_id and
          nb.nomen_id = :vnomen_id;
end^


ALTER PROCEDURE S_CINNIK (
    VLIST VARCHAR(10000))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RINTP INTEGER,
    RDECP VARCHAR(4),
    RNOMEN_CODE VARCHAR(7),
    RSI_NAME VARCHAR(12),
    RBARCODE VARCHAR(27),
    ROUTPRICE DOUBLE PRECISION,
    RDATEX_NAME VARCHAR(26))
AS
declare variable pbarcode_id integer;
begin
  for SELECT n.nomen_id, n.nomen_name, around(n.out_price), intpart(around(n.out_price)),
             decpart(around(n.out_price) + 0.001), n.nomen_code, s.si_name, n.datex_name
        from nomen n, si s
       where n.si_id = s.si_id and
             isinliststr(:vlist, n.nomen_id) = 1
  into rnomen_id, rnomen_name, routprice, rintp,
       rdecp, rnomen_code, rsi_name, rdatex_name
  do begin
    rbarcode = null;
    select max(nb.barcode_id) from nom_bar nb
     where nb.nomen_id = :rnomen_id
      into pbarcode_id;

    select b.code from barcode b
     where b.barcode_id = :pbarcode_id
      into rbarcode;
    suspend;
  end
end^


ALTER PROCEDURE S_CINNIK_PEREOCINKA (
    VLIST VARCHAR(10000))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RINTP0 INTEGER,
    RDECP0 VARCHAR(4),
    RINTP INTEGER,
    RDECP VARCHAR(4),
    RNOMEN_CODE VARCHAR(7),
    RDATEX_NAME VARCHAR(26))
AS
declare variable ppricejournal0_id integer;
declare variable ppricejournal_id integer;
begin
  for SELECT n.nomen_id, n.nomen_name, n.nomen_code, n.datex_name
        from nomen n
       where isinliststr(:vlist, n.nomen_id) = 1
        into rnomen_id, rnomen_name, rnomen_code, rdatex_name
  do begin
    ppricejournal0_id = null;

    select max(pj.pricejournal_id) from pricejournal pj
     where pj.nomen_id = :rnomen_id
      into ppricejournal_id;

    select intpart(around(pj.out_price)), decpart(around(pj.out_price) + 0.001) from pricejournal pj
     where pj.pricejournal_id = :ppricejournal_id
      into  rintp, rdecp;

    select max(pj.pricejournal_id) from pricejournal pj
      where pj.nomen_id = :rnomen_id and
            pj.pricejournal_id < :ppricejournal_id
       into ppricejournal0_id;
    if(:ppricejournal0_id is null) then
      ppricejournal0_id = :ppricejournal_id;
    select intpart(around(pj.out_price)), decpart(around(pj.out_price) + 0.001) from pricejournal pj
      where pj.pricejournal_id = :ppricejournal0_id
     into  :rintp0, :rdecp0;
    suspend;
  end
end^


ALTER PROCEDURE S_CLIENT_UNIT (
    VCLIENT0_ID INTEGER,
    VCLIENT1_ID INTEGER)
AS
declare variable PTYPE0_ID integer;
declare variable PTYPE1_ID integer;
begin
  if ((:vclient1_id > 110) and (:vclient0_id >= 99)) then
  begin
    select c.typeclient_id from clients c
      where c.clients_id = :vclient0_id
     into :ptype0_id;

    select c.typeclient_id from clients c
      where c.clients_id = :vclient1_id
     into :ptype1_id;

    if ((:ptype0_id <> 1) and (:ptype1_id <> 1)) then
    begin
      update goods g
          set g.clients_id = :vclient0_id
        where g.clients_id = :vclient1_id;

      update documents d
          set d.clients_id = :vclient0_id
        where d.clients_id = :vclient1_id;

      update documents d
          set d.objects_id = :vclient0_id
        where d.objects_id = :vclient1_id;

      update kards k
          set k.clients_id = :vclient0_id
        where k.clients_id = :vclient1_id;

      update clientaccount ca
          set ca.clients_id = :vclient0_id
        where ca.clients_id = :vclient1_id;

      delete from clients c
        where c.clients_id = :vclient1_id;
    end
  end
end^


ALTER PROCEDURE S_DOC_CINNIK (
    DOCUMENT_ID INTEGER)
RETURNS (
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    OUT_PRICE NUMERIC(15,2),
    IS_CHECK INTEGER)
AS
DECLARE VARIABLE P_LAST_DATE_UPD DATE;
DECLARE VARIABLE P_DOC_DATE DATE;
BEGIN
 SELECT D.DOC_DATE
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOCUMENT_ID
  INTO :P_DOC_DATE;
 FOR SELECT DR.NOMEN_ID
      FROM DOCREC DR
      WHERE DR.DOCUMENT_ID=:DOCUMENT_ID
      INTO :NOMEN_ID
 DO BEGIN
  SELECT N.NOMEN_CODE, N.NOMEN_NAME, N.OUT_PRICE
   FROM NOMEN N
   WHERE N.NOMEN_ID=:NOMEN_ID
   INTO :NOMEN_CODE, :NOMEN_NAME, :OUT_PRICE;

  SELECT CAST(MAX(PJ.DATE_TIME) AS DATE)
   FROM PRICEJOURNAL PJ
   WHERE PJ.NOMEN_ID=:NOMEN_ID
   INTO :P_LAST_DATE_UPD;
  IF (:P_LAST_DATE_UPD IS NULL) THEN P_LAST_DATE_UPD='04.04.4004';
  IS_CHECK=1;
  IF (:P_DOC_DATE > :P_LAST_DATE_UPD) THEN IS_CHECK=0;
  SUSPEND;
 END
END^


ALTER PROCEDURE S_DOC_CLOSE (
    FLAG SMALLINT,
    DOCUMENT_ID INTEGER)
AS
declare variable pkilk double precision;
declare variable pnomen_id integer;
declare variable pdocrec_id integer;
declare variable pnom_rest double precision;
declare variable pprice double precision;
declare variable pgoods_id integer;
declare variable prest double precision;
declare variable pobjects_id integer;
declare variable pclients_id integer;
declare variable pstaff_id integer;
declare variable kilk double precision;
declare variable docrec_id integer;
declare variable p_goods_id integer;
declare variable p_docgoods_id integer;
declare variable in_kilk double precision;
declare variable p_typedoc_id integer;
BEGIN
  SELECT D.TYPEDOC_ID, d.objects_id, d.clients_id, d.staff_id
   FROM DOCUMENTS D
   WHERE D.DOCUMENT_ID=:DOCUMENT_ID
   INTO :P_TYPEDOC_ID, :pclients_id, :pobjects_id, :pstaff_id;

  IF (FLAG IN (0, 1)) THEN BEGIN
   IF (:P_TYPEDOC_ID NOT IN (4, 11)) THEN BEGIN
/*    if ((:P_TYPEDOC_ID = 2) and (:FLAG = 1)) then
     if (:pstaff_id is null) then
      flag = 0;*/
    UPDATE DOCUMENTS D
      SET D.DOC_LOCK=:FLAG
     WHERE D.DOCUMENT_ID=:DOCUMENT_ID;
   END
  END

  if ((P_TYPEDOC_ID = 1) and ((:flag = 1) or (:flag = 2))) then
  begin
    for select dr.docrec_id, dr.kilk, dr.nomen_id from docrec dr
        where dr.document_id = :document_id
      into :docrec_id, :kilk, :pnomen_id
    do begin
      SELECT DG.Goods_Id, DG.DocGoods_Id, dg.kilk FROM DOCGOODS DG
        WHERE DG.DocRec_Id=:DocRec_Id
       INTO :P_Goods_Id, :P_DocGoods_Id, :in_kilk;

      Kilk=:Kilk-:In_Kilk;

      UPDATE GOODS G
        SET G.Goods_Rest=G.Goods_Rest+:Kilk
       WHERE G.Goods_Id=:P_Goods_Id;

      UPDATE DOCGOODS DG
        SET DG.Kilk=DG.Kilk+:Kilk
       WHERE DG.DocGoods_Id=:P_DocGoods_Id;

      execute procedure s_sliv_minusov(1, :pnomen_id);
    end
    execute procedure ps_document_ins_or_upd_td16(:document_id);
  end


  if ((P_TYPEDOC_ID = 12) and (:flag = 1)) then
  begin
    for select dr.docrec_id, dr.nomen_id, dr.kilk, dr.price from docrec dr
        where dr.document_id = :document_id
      into :pdocrec_id, :pnomen_id, :pkilk, :pprice
    do begin
      pnom_rest = 0.0;
      for select g.goods_id, g.goods_rest from goods g
          where g.nomen_id = :pnomen_id and
                g.objects_id = :pobjects_id and
                g.clients_id = :pclients_id and
                g.goods_rest <> 0.0
        into :pgoods_id, :prest
      do begin
        pnom_rest = :pnom_rest + :prest;

        insert into docgoods(docrec_id, goods_id, kilk)
            values (:pdocrec_id, :pgoods_id, :prest);
        update goods g
         set g.goods_rest=0
         where g.goods_id=:pgoods_id;
      end

      delete from docgoods dg
        where dg.docrec_id = :pdocrec_id;

      update goods g
          set g.goods_rest = 0.0
        where g.nomen_id = :pnomen_id and
              g.objects_id = :pclients_id and
              g.clients_id = :pobjects_id;

      pgoods_id = null;
      select max(g.goods_id) from goods g
          where g.goods_inprice = :pprice and
                g.objects_id = :pobjects_id and
                g.clients_id = :pclients_id
        into :pgoods_id;
      if (:pgoods_id is null) then
        insert into goods(objects_id, clients_id, goods_rest, nomen_id, goods_inprice)
            values (:pobjects_id, :pclients_id, :pnom_rest, :pnomen_id, :pprice);
      else
        update goods g
          set g.goods_rest = :pnom_rest
        where g.goods_id = :pgoods_id;
      update docrec dr
       set dr.KILK=:PNOM_REST
       where dr.DOCREC_ID=:PDOCREC_ID;
    end
  end
END^


ALTER PROCEDURE S_DOC_CREATE (
    VTYPEDOC INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
DECLARE VARIABLE PDOCNUM INTEGER;
BEGIN
  RDOCUMENT_ID=GEN_ID(GEN_DOCUMENTS_ID, 1);

  SELECT U.NICK, U.LAST_doc
   FROM t_USERS U
   WHERE UPPER(U.user_login)=USER
   INTO :PUSER_NIK, :PDOCNUM;

  IF (:PUSER_NIK IS NULL) THEN BEGIN
   PUSER_NIK='Sys';
   SELECT COUNT(D.DOCUMENT_ID)
    FROM DOCUMENTS D
    WHERE D.USER_NAME=USER
    INTO :PDOCNUM;
  END

  IF (:PUSER_NIK IS NOT NULL) THEN BEGIN
   UPDATE t_USERS U
    SET U.LAST_doc=:PDOCNUM+1
    WHERE UPPER(U.user_login)=USER;
  END

  RDOC_NUM=GENDOCNUM(:PUSER_NIK, :PDOCNUM);

  INSERT INTO DOCUMENTS(DOCUMENT_ID, DOC_NUM, TYPEDOC_ID, DOC_LOCK, USER_NAME, BLOK)
   VALUES (:RDOCUMENT_ID, :RDOC_NUM, :VTYPEDOC, 0, USER, 1);

  SUSPEND;

END^


ALTER PROCEDURE S_DOC_DELETE (
    DOC_ID INTEGER)
AS
DECLARE VARIABLE PDOCREC_ID INTEGER;
BEGIN
 for select dr.docrec_id from docrec dr
   where dr.document_id = :doc_id and
         dr.kilk = 0.00
 into :pdocrec_id
 do begin
  EXECUTE PROCEDURE S_DOCREC_DEL(:PDOCREC_ID);
 end
 DELETE FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOC_ID;
END^


ALTER PROCEDURE S_DOC_LOCK_PREPARE (
    DOCID INTEGER)
RETURNS (
    FLAG INTEGER)
AS
DECLARE VARIABLE P_DOCREC_ID INTEGER;
DECLARE VARIABLE P_DOCREC_COUNT DOUBLE PRECISION;
DECLARE VARIABLE PP_DOCREC_COUNT DOUBLE PRECISION;
DECLARE VARIABLE P_DOCGOODS_COUNT DOUBLE PRECISION;
DECLARE VARIABLE PP_DOCGOODS_COUNT DOUBLE PRECISION;
BEGIN
 P_DOCREC_COUNT=0.000;
 P_DOCGOODS_COUNT=0.000;
 FOR SELECT DR.DOCREC_ID, DR.KILK
      FROM DOCREC DR
      WHERE DR.DOCUMENT_ID=:DOCID
      INTO :P_DOCREC_ID, :PP_DOCREC_COUNT
 DO BEGIN
  P_DOCREC_COUNT=:P_DOCREC_COUNT+:PP_DOCREC_COUNT;
  SELECT SUM(DG.KILK)
   FROM DOCGOODS DG
   WHERE DG.DOCGOODS_ID=:P_DOCREC_ID
   INTO :PP_DOCGOODS_COUNT;
  P_DOCGOODS_COUNT=:P_DOCGOODS_COUNT+PP_DOCGOODS_COUNT;
 END
 IF (P_DOCREC_COUNT=P_DOCGOODS_COUNT) THEN FLAG=0;
 IF (P_DOCREC_COUNT<P_DOCGOODS_COUNT) THEN FLAG=1;
 IF (P_DOCREC_COUNT>P_DOCGOODS_COUNT) THEN FLAG=2;
 SUSPEND;
END^


ALTER PROCEDURE S_DOC_SET_EXTRA (
    DOCUMENT_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
AS
begin
  /* Procedure Text */
 SUSPEND;
end^


ALTER PROCEDURE S_DOC_VIEW (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPES VARCHAR(10000),
    PAYS VARCHAR(10000),
    ISPAYS VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    DOC_SUM_OUT DOUBLE PRECISION,
    DOC_SUM_OUT_PDV DOUBLE PRECISION,
    DOC_SUM_IN DOUBLE PRECISION,
    DOC_SUM_IN_PDV DOUBLE PRECISION,
    DOC_LOCK SMALLINT,
    STAFF_NAME VARCHAR(30),
    DISC_PERSENT DOUBLE PRECISION,
    LOCK_DATE DATE,
    OPLATA_STATE INTEGER,
    OPLATA_TYPE VARCHAR(30),
    BLOK INTEGER,
    TIME_CR TIME,
    NOTARIZATION VARCHAR(12),
    KARDS_ID INTEGER)
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_STAFF_ID INTEGER;
DECLARE VARIABLE P_OPLATA_TYPE INTEGER;
BEGIN
  PAYS = :PAYS||'3 ';
  FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             TP.TYPEDOC_NAME, D.CLIENTS_ID, D.OBJECTS_ID, D.DOC_LOCK, D.STAFF_ID,
             D.DISC_PERSENT, D.LOCK_DATE, D.OPLATA_STATE, D.OPLATA_TYPE, D.BLOK, D.time_cr,
             D.notarization, D.kards_id
       FROM DOCUMENTS D,
            TYPEDOC TP
       WHERE ((D.OBJECTS_ID=:OBJECTS_ID) OR (D.CLIENTS_ID=:OBJECTS_ID)) AND
             D.DOC_DATE BETWEEN :DATE_IN AND :DATE_OUT AND
             ISINLISTSTR(:TYPES, D.TYPEDOC_ID) = 1 AND
             ISINLISTSTR(:PAYS, D.OPLATA_TYPE) = 1 AND
             ISINLISTSTR(:ISPAYS, D.OPLATA_STATE) = 1 AND
             TP.TYPEDOC_ID=D.TYPEDOC_ID
       INTO :DOCUMENT_ID, :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :TYPEDOC_NAME, :P_CLIENTS_ID, :P_OBJECTS_ID, :DOC_LOCK, :P_STAFF_ID,
            :P_DISC_PERSENT, :LOCK_DATE, :OPLATA_STATE, :P_OPLATA_TYPE, :BLOK, :time_cr,
            :notarization, :kards_id
  DO BEGIN
   SELECT P.TYPEPAY_NAME
    FROM TYPEPAY P
    WHERE P.TYPEPAY_ID=:P_OPLATA_TYPE
    INTO :OPLATA_TYPE;

   IF (:P_OPLATA_TYPE IS NULL) THEN OPLATA_TYPE=NULL;

/*   SELECT S.SURNAME||' '||FIRSTCHAR(S.NAME)||'.'||FIRSTCHAR(S.PATRONYMIC)||'.'
    FROM STAFF S
    WHERE S.STAFF_ID=:P_STAFF_ID
    INTO :STAFF_NAME;
   IF (:P_STAFF_ID IS NULL) THEN STAFF_NAME=NULL;*/

   SELECT C.SHORTNAME, C.NAME
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:P_OBJECTS_ID
    INTO :SRC_NAME, :SRC_FULLNAME;
   SELECT C.SHORTNAME, C.NAME
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:P_CLIENTS_ID
    INTO :DST_NAME, :DST_FULLNAME;
   IF (:P_CLIENTS_ID IS NULL) THEN BEGIN
    DST_NAME=NULL;
    DST_FULLNAME=NULL;
   END
   IF (:P_OBJECTS_ID IS NULL) THEN BEGIN
    SRC_NAME=NULL;
    SRC_FULLNAME=NULL;
   END

/*   DISC_PERSENT=:P_DISC_PERSENT*100;*/

   SELECT DRS.SUM_OUT, DRS.SUM_OUT_PDV, DRS.SUM_IN, DRS.SUM_IN_PDV, (DRS.AVG_DISC_PERSENT*100)
    FROM S_DOCREC_SUM(:DOCUMENT_ID, :P_DISC_PERSENT) DRS
    INTO :DOC_SUM_OUT, :DOC_SUM_OUT_PDV, :DOC_SUM_IN, :DOC_SUM_IN_PDV, :DISC_PERSENT;

   SUSPEND;
   notarization = NULL;
   kards_id = NULL;
  END
END^


ALTER PROCEDURE S_DOC_VIEW_G (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    CLIENTS_ID INTEGER,
    OBJECT_ID INTEGER,
    SRC_NAME VARCHAR(30),
    DST_NAME VARCHAR(30),
    DOC_SUMIN_PDV DOUBLE PRECISION,
    DOC_SUMIN DOUBLE PRECISION,
    DOC_IN_PDV DOUBLE PRECISION,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_SUM_PDV DOUBLE PRECISION,
    OPLATA_TYPE INTEGER,
    DOC_MARK VARCHAR(14))
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
BEGIN
  FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_DATE, D.TYPEDOC_ID,
             D.CLIENTS_ID, D.OBJECTS_ID,
             D.DISC_PERSENT, D.oplata_type, D.doc_mark
       FROM DOCUMENTS D
       WHERE ((D.OBJECTS_ID=:OBJECTS_ID) OR (D.CLIENTS_ID=:OBJECTS_ID)) AND
             D.DOC_DATE BETWEEN :DATE_IN AND :DATE_OUT
       ORDER BY D.DOCUMENT_ID
       INTO :DOCUMENT_ID, :DOC_NUM, :DOC_DATE, :TYPEDOC_ID,
            :CLIENTS_ID, :OBJECT_ID,
            :P_DISC_PERSENT, :oplata_type, :doc_mark
  DO BEGIN
   SELECT C.SHORTNAME
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:OBJECT_ID
    INTO :SRC_NAME;
   SELECT C.SHORTNAME
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:CLIENTS_ID
    INTO :DST_NAME;
   IF (:CLIENTS_ID IS NULL) THEN DST_NAME=NULL;
   IF (:OBJECTS_ID IS NULL) THEN SRC_NAME=NULL;

   SELECT SUM(DV.SUM_OUT), SUM(DV.SUM_OUT_PDV), SUM(DV.EXTRA_SUM), SUM(DV.SUM_IN_PDV),
          SUM(DV.SUM_IN), SUM(DV.SUM_PDV_IN)
    FROM S_DOCREC_VIEW_G(:DOCUMENT_ID, :TYPEDOC_ID, :P_DISC_PERSENT) DV
    INTO :DOC_SUM, :DOC_SUMPDV, :EXTRA_SUM_PDV, :DOC_SUMIN_PDV,
         :DOC_SUMIN, :DOC_IN_PDV;

   IF (:DOC_SUMIN_PDV IS NULL) THEN DOC_SUMIN_PDV=0.000;
   IF (:DOC_SUM IS NULL) THEN DOC_SUM=0.000;
   IF (:DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
   IF (:EXTRA_SUM_PDV IS NULL) THEN EXTRA_SUM_PDV=0.000;
   IF (:DOC_SUMIN_PDV IS NULL) THEN DOC_SUMIN_PDV=0.000;
   IF (:DOC_SUMIN IS NULL) THEN DOC_SUMIN=0.000;
   IF (:DOC_IN_PDV IS NULL) THEN DOC_IN_PDV=0.000;
   DOC_PDV=0.000;
   DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
   EXTRA_SUM=:DOC_SUM-:DOC_SUMIN;
   SUSPEND;
  END
END^


ALTER PROCEDURE S_DOC_VIEW_ID (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER,
    SRC_NAME VARCHAR(30),
    SRC_ISPDV INTEGER,
    DST_NAME VARCHAR(30),
    DST_ISPDV INTEGER,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P VARCHAR(10),
    DOC_LOCK SMALLINT,
    AUTH_ID INTEGER,
    AUTH_NAME VARCHAR(80),
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    DISC_PERSENT DOUBLE PRECISION,
    TYPEDISCOUNT VARCHAR(20),
    LOCK_DATE DATE,
    DISCOUNT_ID INTEGER,
    DES_SUMDOC VARCHAR(4),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DELAY_PAY INTEGER)
AS
DECLARE VARIABLE P_SUM_IN DOUBLE PRECISION;
DECLARE VARIABLE OPLATA_T INTEGER;
BEGIN
  FOR SELECT D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.OBJECTS_ID, D.CLIENTS_ID, D.DOC_LOCK, D.AUTH_ID, D.STAFF_ID,
             D.DISCONT_ID, D.DISC_PERSENT*100, D.lock_date, D.OPLATA_TYPE,
             D.DELAY_PAY
       FROM DOCUMENTS D
       WHERE D.DOCUMENT_ID=:DOCUMENT_ID
       INTO :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :OBJECTS_ID, :CLIENTS_ID, :DOC_LOCK, :AUTH_ID, :STAFF_ID,
            :DISCOUNT_ID, :DISC_PERSENT, :LOCK_DATE, :OPLATA_T,
            :DELAY_PAY
  DO BEGIN
   if (:delay_pay is null) then delay_pay=0;
   IF (OPLATA_T = 1) THEN OPLATA_TYPE='Готівка';
   IF (OPLATA_T = 2) THEN OPLATA_TYPE='Перерахунок';
   SELECT TD.TYPEDOC_NAME
    FROM TYPEDOC TD
    WHERE TD.TYPEDOC_ID=:TYPEDOC_ID
    INTO :TYPEDOC_NAME;

   SELECT DS.TIPDISCONT
    FROM DISCONT DS
    WHERE DS.DISCONT_ID=:DISCOUNT_ID
    INTO :TYPEDISCOUNT;
   IF (:DISCOUNT_ID IS NULL) THEN TYPEDISCOUNT=NULL;

   SELECT '№ '||A.AUTH_NUM||' від '||CAST(A.AUTH_DATE AS VARCHAR(11))||'р. через '||A.AUTH_NAME
    FROM AUTH A
    WHERE A.AUTH_ID=:AUTH_ID
    INTO :AUTH_NAME;
   IF (:AUTH_ID IS NULL) THEN AUTH_NAME=NULL;

   SELECT S.SURNAME||' '||FIRSTCHAR(S.NAME)||'.'||FIRSTCHAR(S.PATRONYMIC)||'.'
    FROM STAFF S
    WHERE S.STAFF_ID=:STAFF_ID
    INTO :STAFF_NAME;
   IF (STAFF_ID IS NULL) THEN STAFF_NAME=NULL;

   SELECT C.SHORTNAME, C.ISPDV
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:OBJECTS_ID
    INTO :SRC_NAME, :SRC_ISPDV;
   SELECT C.SHORTNAME, C.ISPDV
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:CLIENTS_ID
    INTO :DST_NAME, :DST_ISPDV;
   IF (:CLIENTS_ID IS NULL) THEN DST_NAME=NULL;
   IF (:OBJECTS_ID IS NULL) THEN SRC_NAME=NULL;

   SELECT DRS.SUM_OUT, DRS.SUM_OUT_PDV, DRS.SUM_IN, DRS.AVG_DISC_PERSENT
    FROM S_DOCREC_SUM(:DOCUMENT_ID, :DISC_PERSENT) DRS
    INTO :DOC_SUM, :DOC_SUMPDV, :P_SUM_IN, :DISC_PERSENT;

   EXTRA_SUM=:DOC_SUM-:P_SUM_IN;

   IF (P_SUM_IN IS NULL) THEN P_SUM_IN=0.000;
   IF (DOC_SUM IS NULL) THEN DOC_SUM=0.000;
   IF (DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
   IF (EXTRA_SUM IS NULL) THEN EXTRA_SUM=0.000;
   EXTRA_P=NULL;
   IF (NOT(P_SUM_IN=0.000)) THEN
    EXTRA_P=CAST(CAST((:EXTRA_SUM*100)/:P_SUM_IN AS NUMERIC(7,3)) AS VARCHAR(10))||'%';
   IF (EXTRA_P IS NULL) THEN EXTRA_P='0%';
   DOC_PDV=0.000;
   DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
   DES_SUMDOC = decpart(:doc_sumpdv);
   OUT_SUMPDV=AROUND(:DOC_SUMPDV);
   SUSPEND;
  END
END^


ALTER PROCEDURE S_DOC_VIEW_ID_N (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_MARK VARCHAR(14),
    DOC_DATE DATE,
    TYPEDOC_ID INTEGER,
    TYPEDOC_NAME VARCHAR(30),
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER,
    DOC_SUM DOUBLE PRECISION,
    DOC_SUMPDV DOUBLE PRECISION,
    DOC_PDV DOUBLE PRECISION,
    STAFF_ID INTEGER,
    STAFF_NAME VARCHAR(30),
    LOCK_DATE DATE,
    DES_SUMDOC VARCHAR(3),
    OPLATA_TYPE VARCHAR(12),
    OUT_SUMPDV DOUBLE PRECISION,
    DOC_TIP VARCHAR(30))
AS
DECLARE VARIABLE P_SUM_IN DOUBLE PRECISION;
DECLARE VARIABLE OPLATA_T INTEGER;
BEGIN
  FOR SELECT D.DOC_NUM, D.DOC_MARK, D.DOC_DATE, D.TYPEDOC_ID,
             D.OBJECTS_ID, D.CLIENTS_ID, D.STAFF_ID,
             D.lock_date, D.OPLATA_TYPE
       FROM DOCUMENTS D
       WHERE D.DOCUMENT_ID=:DOCUMENT_ID
       INTO :DOC_NUM, :DOC_MARK, :DOC_DATE, :TYPEDOC_ID,
            :OBJECTS_ID, :CLIENTS_ID, :STAFF_ID,
            :LOCK_DATE, :OPLATA_T
  DO BEGIN
      if (OPLATA_T = 1) then OPLATA_TYPE='Готівка';
      if (OPLATA_T = 2) then OPLATA_TYPE='Перерахунок';
       if (OPLATA_T = 1) then DOC_TIP = 'готівка';
       if (OPLATA_T = 2) then DOC_TIP = 'з розрахункового рахунку';
   SELECT TD.TYPEDOC_NAME
    FROM TYPEDOC TD
    WHERE TD.TYPEDOC_ID=:TYPEDOC_ID
    INTO :TYPEDOC_NAME;
 
   SELECT S.SURNAME||' '||FIRSTCHAR(S.NAME)||'.'||FIRSTCHAR(S.PATRONYMIC)||'.'
    FROM STAFF S
    WHERE S.STAFF_ID=:STAFF_ID
    INTO :STAFF_NAME;
   IF (STAFF_ID IS NULL) THEN STAFF_NAME=NULL;
                                                    
 
   SELECT SUM(DV.SUM_OUT), SUM(DV.SUM_OUT_PDV), SUM(DV.P_SUM_IN)
    FROM S_DOCREC_VIEW(:DOCUMENT_ID) DV
    INTO :DOC_SUM, :DOC_SUMPDV, :P_SUM_IN;
 
   IF (P_SUM_IN IS NULL) THEN P_SUM_IN=0.000;
   IF (DOC_SUM IS NULL) THEN DOC_SUM=0.000;
   IF (DOC_SUMPDV IS NULL) THEN DOC_SUMPDV=0.000;
   IF (NOT(/*around(*/P_SUM_IN/*)*/=0.000)) THEN
   DOC_PDV=0.000;
   DOC_PDV=:DOC_SUMPDV-:DOC_SUM;
     DES_SUMDOC = decpart(around(:doc_sumpdv));
     OUT_SUMPDV = around(:doc_sumpdv);
 
   SUSPEND;
  END
END^


ALTER PROCEDURE S_DOCGOODS_CREATE (
    DOCGOODS_ID INTEGER,
    GOODS_ID INTEGER,
    DOCREC_ID INTEGER,
    KILK DOUBLE PRECISION)
RETURNS (
    R_DOCGOODS_ID INTEGER)
AS
BEGIN
 IF ((:DOCGOODS_ID=0) OR (:DOCGOODS_ID IS NULL)) THEN
  DOCGOODS_ID=GEN_ID(GEN_DOCGOODS_ID,1);

 UPDATE GOODS GG
  SET GG.GOODS_REST=GG.GOODS_REST-:KILK
  WHERE GG.GOODS_ID=:GOODS_ID;

 INSERT INTO DOCGOODS (DOCGOODS_ID, DOCREC_ID, GOODS_ID, KILK)
  VALUES (:DOCGOODS_ID, :DOCREC_ID, :GOODS_ID, :KILK);

 R_DOCGOODS_ID=:DOCGOODS_ID;

 SUSPEND;
END^


ALTER PROCEDURE S_DOCGOODS_VIEW_ID (
    DOCREC_ID INTEGER)
RETURNS (
    GOODS_ID INTEGER,
    REST DOUBLE PRECISION,
    KILK DOUBLE PRECISION)
AS
BEGIN
 FOR SELECT DG.GOODS_ID, AROUND3(DG.KILK)
      FROM DOCGOODS DG
      WHERE DG.DOCREC_ID=:DOCREC_ID
      INTO :GOODS_ID, :KILK
 DO BEGIN
  SELECT AROUND3(G.GOODS_REST)
   FROM GOODS G
   WHERE G.GOODS_ID=:GOODS_ID
   INTO :REST;
  SUSPEND;
 END
END^


ALTER PROCEDURE S_DOCREC_CLIUPD (
    DOCUMENT_ID INTEGER,
    CLIENT_ID INTEGER,
    TYPEDOC_ID INTEGER)
AS
DECLARE VARIABLE P_GOODS_ID INTEGER;
BEGIN
 IF (:TYPEDOC_ID=1) THEN BEGIN

  UPDATE DOCUMENTS D
   SET D.OBJECTS_ID=:CLIENT_ID
   WHERE D.DOCUMENT_ID=:DOCUMENT_ID;

  FOR SELECT DG.GOODS_ID
       FROM DOCREC DR,
            DOCGOODS DG
       WHERE DR.DOCUMENT_ID=:DOCUMENT_ID AND
             DG.DOCREC_ID=DR.DOCREC_ID
       INTO :P_GOODS_ID
  DO BEGIN
   UPDATE GOODS G
    SET G.CLIENTS_ID=:CLIENT_ID
    WHERE G.GOODS_ID=:P_GOODS_ID;
  END
 END
END^


ALTER PROCEDURE S_DOCREC_CREATE (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION,
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION)
RETURNS (
    DOCREC_ID INTEGER,
    VKILK DOUBLE PRECISION)
AS
declare variable p_typedoc_id integer;
declare variable p_goods_id integer;
declare variable p_goods_id2 integer;
declare variable p_rest double precision;
declare variable p_min_kilk double precision;
declare variable p_objects_id integer;
declare variable p_max_goods_id integer;
declare variable p_max_inprice double precision;
declare variable p_inprice double precision;
declare variable p_client_id integer;
declare variable p_client_id2 integer;
declare variable p_typepdv_id integer;
declare variable p_nomen_id integer;
declare variable p_m_sale varchar(1);
declare variable p_all_rest double precision;
declare variable p_price integer;
declare variable p_ispdv integer;
declare variable p_disc_persent double precision;
begin
 vkilk=:kilk;

 select d.typedoc_id, d.objects_id, d.clients_id, d.disc_persent
   from documents d
  where d.document_id=:document_id
   into p_typedoc_id, p_objects_id, p_client_id, p_disc_persent;

 select o.m_sale
   from objects o
  where o.objects_id = :p_objects_id
   into p_m_sale;

/* прихідна накладна ---------------------------------------------------------*/

 if (:p_typedoc_id = 1) then begin

  docrec_id = gen_id(gen_docrec_id, 1);
  insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
     values(:docrec_id, :document_id, :nomen_id, :kilk, :price, :typepdv_id, :typepdv_pdv);

  select c.ispdv from clients c
   where c.clients_id = :p_objects_id
    into p_ispdv;
  if (:p_ispdv is null) then p_ispdv = 1;
  if (:p_ispdv=0) then
  begin
   select n.typepdv_id from nomen n
    where n.nomen_id = :nomen_id
     into p_typepdv_id;
   price = calcsumpdv(:price, 0.000, 0.000, :p_typepdv_id, 0);
  end
  price = calcpricepdv(:price, :p_disc_persent, 0.000, 6);
  p_goods_id = gen_id(gen_goods_id, 1);
  insert into goods (goods_id, nomen_id, objects_id, goods_rest, goods_inprice, clients_id)
      values (:p_goods_id, :nomen_id, :p_client_id, 0, :price, :p_objects_id);

  insert into docgoods (docrec_id, goods_id, kilk)
      values (:docrec_id, :p_goods_id, 0);

  suspend;

 end /*if (:p_typedoc_id=1)*/

/* розхідна накладна ---------------------------------------------------------*/

 if (:p_typedoc_id = 2) then begin
  p_all_rest = 0.000;
  select sum(g.goods_rest) from goods g
   where g.nomen_id=:nomen_id and
         g.objects_id=:p_objects_id
    into p_all_rest;
  if ((:kilk > :p_all_rest) and (:p_m_sale = 'n')) then kilk = :p_all_rest;
  vkilk = :kilk;
  docrec_id = gen_id(gen_docrec_id, 1);
  insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
   values(:docrec_id, :document_id, :nomen_id, :kilk, :price, :typepdv_id, :typepdv_pdv);

  for select g.goods_id, g.goods_rest from goods g
       where g.nomen_id   = :nomen_id and
             g.objects_id = :p_objects_id
        into p_goods_id, p_rest
  do begin
   p_min_kilk = min2(:kilk, :p_rest);
   if (:p_min_kilk > 0.000) then
   begin
     kilk   = :kilk-:p_min_kilk;
     p_rest = :p_rest-:p_min_kilk;
     update goods gg
        set gg.goods_rest = :p_rest
      where gg.goods_id   = :p_goods_id;

     insert into docgoods (docrec_id, goods_id, kilk)
      values (:docrec_id, :p_goods_id, :p_min_kilk);
   end
  end

  if (:kilk > 0.000) then begin
   p_max_inprice=0.000;
   p_max_goods_id=null;
   for select gg.goods_id, gg.goods_inprice, gg.goods_rest
         from goods gg
        where gg.nomen_id=:nomen_id and
              gg.goods_rest<=0.000 and
              gg.objects_id=:p_objects_id and
              gg.goods_inprice<:price
         into p_goods_id, p_inprice, p_rest
   do begin
    if (:p_max_inprice < :p_inprice) then begin
     p_max_goods_id = :p_goods_id;
     p_max_inprice  = :p_inprice;
    end
   end

   if (:p_max_goods_id is null) then begin
    for select gg.goods_id, gg.goods_inprice, gg.goods_rest
         from goods gg
         where gg.nomen_id   = :nomen_id and
               gg.objects_id = :p_objects_id
          into p_goods_id, p_inprice, p_rest
    do begin
      p_max_goods_id = :p_goods_id;
      p_max_inprice  = :p_inprice;
    end
   end

   if (:p_max_goods_id is null) then exception none_goods;

   update goods gg
      set gg.goods_rest = gg.goods_rest - :kilk
    where gg.goods_id   = :p_goods_id;

   insert into docgoods (docrec_id, goods_id, kilk)
    values (:docrec_id, :p_goods_id, :kilk);

  end

  suspend;

 end /*if (:p_typedoc_id=2)*/

/* акт переоцінки вхідних цін ------------------------------------------------*/

 if (:p_typedoc_id = 12) then
 begin
   docrec_id = gen_id(gen_docrec_id, 1);
   insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
     values(:docrec_id, :document_id, :nomen_id, 0, :price, :typepdv_id, :typepdv_pdv);
   suspend;
 end /*if (:p_typedoc_id=12)*/

/* внутрішнє переміщення -----------------------------------------------------*/

 if (:p_typedoc_id = 6) then begin

  select g.nomen_id, g.goods_inprice
    from goods g
   where g.goods_id = :nomen_id
    into p_nomen_id, price;

  price = calcsum(:price, 0.000, 0.000, :typepdv_id, 0);

  docrec_id = gen_id(gen_docrec_id, 1);
  insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
   values(:docrec_id, :document_id, :p_nomen_id, :kilk, :price, 1, 0.000);

  update goods gg
     set gg.goods_rest = gg.goods_rest - :kilk
   where gg.goods_id = :nomen_id;

  insert into docgoods (docrec_id, goods_id, kilk)
   values (:docrec_id, :nomen_id, :kilk);

  suspend;
 end /*if (:p_typedoc_id = 6)*/

/* акт списання --------------------------------------------------------------*/
/* повернення постачальникові ------------------------------------------------*/

 if (:p_typedoc_id in (15,17)) then
 begin
  select g.nomen_id, g.goods_inprice
    from goods g
   where g.goods_id = :nomen_id
    into p_nomen_id, price;

  docrec_id = gen_id(gen_docrec_id, 1);
  insert into docrec (docrec_id, document_id, nomen_id, kilk, price, typepdv_id, typepdv_pdv)
    values(:docrec_id, :document_id, :p_nomen_id, :kilk, :price, :typepdv_id, :typepdv_pdv);

  update goods gg
     set gg.goods_rest = gg.goods_rest - :kilk
   where gg.goods_id = :nomen_id;

  insert into docgoods (docrec_id, goods_id, kilk)
   values (:docrec_id, :nomen_id, :kilk);

  suspend;
 end /*if (:p_typedoc_id in (15,17))*/

end^


ALTER PROCEDURE S_DOCREC_DEL (
    DOCREC_ID INTEGER)
AS
DECLARE VARIABLE P_DOCUMENT_ID INTEGER;
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
DECLARE VARIABLE P_GOODS_ID INTEGER;
DECLARE VARIABLE P_KILK DOUBLE PRECISION;
DECLARE VARIABLE P_DOCGOODS_ID INTEGER;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_INPRICE DOUBLE PRECISION;
BEGIN

 SELECT DR.DOCUMENT_ID
  FROM DOCREC DR
  WHERE DR.DOCREC_ID=:DOCREC_ID
  INTO :P_DOCUMENT_ID;

 SELECT D.TYPEDOC_ID, D.CLIENTS_ID
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:P_DOCUMENT_ID
  INTO :P_TYPEDOC_ID, :P_OBJECTS_ID;

/* SELECT DR.
  FROM DOCREC DR
  WHERE DR.DOCREC_ID=:DOCREC_ID*/

 /*???????? ????????*/
 IF (:P_TYPEDOC_ID=1) THEN BEGIN

  FOR SELECT DG.DOCGOODS_ID, DG.GOODS_ID, DG.KILK
       FROM DOCGOODS DG
       WHERE DG.DOCREC_ID=:DOCREC_ID
       INTO :P_DOCGOODS_ID, :P_GOODS_ID, :P_KILK
  DO BEGIN

   UPDATE GOODS G
    SET G.GOODS_REST=G.GOODS_REST-:P_KILK
    WHERE G.GOODS_ID=:P_GOODS_ID;

   DELETE FROM DOCGOODS DG1
    WHERE DG1.DOCGOODS_ID=:P_DOCGOODS_ID;

   DELETE FROM GOODS G
    WHERE G.GOODS_ID=:P_GOODS_ID;

  END

  DELETE FROM DOCREC DR
   WHERE DR.DOCREC_ID=:DOCREC_ID;

  SUSPEND;

 END

 /*???????? ????????*/
 IF (:P_TYPEDOC_ID=2) THEN BEGIN

  FOR SELECT DG.DOCGOODS_ID, DG.GOODS_ID, DG.KILK
       FROM DOCGOODS DG
       WHERE DG.DOCREC_ID=:DOCREC_ID
       INTO :P_DOCGOODS_ID, :P_GOODS_ID, :P_KILK
  DO BEGIN

   UPDATE GOODS G
    SET G.GOODS_REST=G.GOODS_REST+:P_KILK
    WHERE G.GOODS_ID=:P_GOODS_ID;

   DELETE FROM DOCGOODS DG1
    WHERE DG1.DOCGOODS_ID=:P_DOCGOODS_ID;
  END

  DELETE FROM DOCREC DR
   WHERE DR.DOCREC_ID=:DOCREC_ID;

  SUSPEND;

 END

 IF (:P_TYPEDOC_ID IN (6,15,17)) THEN BEGIN

  FOR SELECT DG.DOCGOODS_ID, DG.GOODS_ID, DG.KILK
       FROM DOCGOODS DG
       WHERE DG.DOCREC_ID=:DOCREC_ID
       INTO :P_DOCGOODS_ID, :P_GOODS_ID, :P_KILK
  DO BEGIN

   UPDATE GOODS G
    SET G.GOODS_REST=G.GOODS_REST+:P_KILK
    WHERE G.GOODS_ID=:P_GOODS_ID;

   DELETE FROM DOCGOODS DG1
    WHERE DG1.DOCGOODS_ID=:P_DOCGOODS_ID;

  END

  DELETE FROM DOCREC DR
   WHERE DR.DOCREC_ID=:DOCREC_ID;

  SUSPEND;

 END

END^


ALTER PROCEDURE S_DOCREC_KILKUPD (
    VDOCREC_ID INTEGER,
    VNOMEN_ID INTEGER,
    OBJECT_ID INTEGER,
    CLIENTS_ID INTEGER,
    OUT_PRICE DOUBLE PRECISION,
    VKILK NUMERIC(9,3),
    IN_KILK NUMERIC(9,3),
    VTYPE_DOC INTEGER)
AS
DECLARE VARIABLE PGOODS_REST DOUBLE PRECISION;
DECLARE VARIABLE PMIN_KILK DOUBLE PRECISION;
DECLARE VARIABLE PKILK DOUBLE PRECISION;
DECLARE VARIABLE PDOCGOODS_ID INTEGER;
DECLARE VARIABLE PIN_KILK DOUBLE PRECISION;
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PCNT INTEGER;
BEGIN
  pobject_id = 1;
  select sum(d.kilk) from docgoods d
    where d.docrec_id = :vdocrec_id
  into :pkilk;

  update docrec dr
    set dr.kilk=:vkilk
   where dr.docrec_id=:vdocrec_id;

  if (:pkilk is null) then
    pkilk = 0.0;

  pin_kilk = :vkilk;

/*------------ Aey ?ico?aieo oa ?ae?a -----------------------------*/
  if (:vtype_doc in (2, 11)) then
  begin
    if (:pkilk < :vkilk) then
    begin
      vkilk = :vkilk - :pkilk;

      for select d.docgoods_id, g.goods_id, g.goods_rest from docgoods d, goods g
        where d.docrec_id = :vdocrec_id and
              g.goods_id = d.goods_id and
              g.goods_rest > 0.0
      into  :pdocgoods_id, :pgoods_id, :pgoods_rest
      do begin

        pmin_kilk = Min2(:vkilk, :pgoods_rest);

        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest - :pmin_kilk
            where g.goods_id = :pgoods_id;

          update docgoods
              set kilk = kilk + :pmin_kilk
            where docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0) then
      begin
     /* ????????? ????? ?? ??????? ?????? */
        for select gg.goods_id, gg.goods_rest from goods gg
          where    gg.nomen_id = :vnomen_id and
                   gg.objects_id = :pobject_id and
                   gg.goods_rest > 0.0
            order by gg.goods_id
        into :pgoods_id, :pgoods_rest
        do begin

          pmin_kilk = Min2(:vkilk, :pgoods_rest);

          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest - :pmin_kilk
              where g.goods_id = :pgoods_id;

            insert into docgoods (goods_id, docrec_id, kilk)
              values  (:pgoods_id, :vdocrec_id, :pmin_kilk);
          end
        end
      end

      if (:vkilk > 0) then
      begin
   /* ????????? ?? ??????? ?????? ? ??????????? ????? */

        pgoods_id = null;
        select max(goods_id) from goods g
            where g.nomen_id = :vnomen_id and
                  g.objects_id = :pobject_id
          into :pgoods_id;
        update goods g
            set g.goods_rest = g.goods_rest - :vkilk
          where g.goods_id = :pgoods_id;
        insert into docgoods (goods_id, docrec_id, kilk)
          values(:pgoods_id, :vdocrec_id, :vkilk);
      end
    end
/* ------------------------------------------- */
    else if (:pkilk > :vkilk) then
    begin
      vkilk = :pkilk - :vkilk;
      for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
        where    d.docrec_id = :vdocrec_id and
                 d.goods_id = g.goods_id and
                 g.goods_rest < 0.0
      into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
      do begin
        pmin_kilk = Min2(:vkilk, -:pgoods_rest);
        pmin_kilk = Min2(:pkilk, :pmin_kilk);
        if (:pmin_kilk > 0.0) then
        begin
          vkilk = :vkilk - :pmin_kilk;

          update goods g
              set g.goods_rest = g.goods_rest + :pmin_kilk
            where g.goods_id = :pgoods_id;
          update docgoods d
              set d.kilk = d.kilk - :pmin_kilk
            where d.docgoods_id = :pdocgoods_id;
        end
      end

      if (:vkilk > 0.0) then
      begin
        for select d.docgoods_id, d.kilk, g.goods_id, g.goods_rest from docgoods d, goods g
          where    d.docrec_id = :vdocrec_id and
                   d.goods_id = g.goods_id and
                   g.goods_rest >= 0.0
        into :pdocgoods_id, :pkilk, :pgoods_id, :pgoods_rest
        do begin
          pmin_kilk = Min2(:vkilk, :pkilk);
          if (:pmin_kilk > 0.0) then
          begin
            vkilk = :vkilk - :pmin_kilk;

            update goods g
                set g.goods_rest = g.goods_rest + :pmin_kilk
              where g.goods_id = :pgoods_id;
            update docgoods d
                set d.kilk = d.kilk - :pmin_kilk
              where d.docgoods_id = :pdocgoods_id;
          end
        end
      end
    end
  end
  else if (:vtype_doc in (6,15,17)) then
  begin
    SELECT DG.DocGoods_Id, DG.Goods_Id
        FROM DOCGOODS DG
      WHERE DG.DocRec_Id=:vdocrec_Id
    INTO :pdocgoods_id, :pgoods_id;
    pmin_kilk=:vkilk-:In_Kilk;
    UPDATE GOODS G
        SET G.Goods_Rest=G.Goods_Rest-:pmin_kilk
      WHERE G.Goods_Id=:pgoods_id;
    UPDATE DOCGOODS DG
        SET DG.Kilk=:vkilk
      WHERE DG.DocGoods_Id=:pdocgoods_id;
 end /* if (:typedoc_id in (6,15,17)) */
END^


ALTER PROCEDURE S_DOCREC_PRICEUPD (
    DOCREC_ID INTEGER,
    PRICE DOUBLE PRECISION,
    TYPEDOC_ID INTEGER,
    OBJECTS_ID INTEGER,
    CLIENTS_ID INTEGER)
AS
DECLARE VARIABLE P_PRICE DOUBLE PRECISION;
DECLARE VARIABLE P_GOODS_ID INTEGER;
DECLARE VARIABLE P_GOODS_ID1 INTEGER;
DECLARE VARIABLE P_KILK NUMERIC(9,3);
DECLARE VARIABLE P_NOMEN_ID INTEGER;
DECLARE VARIABLE P_ISPDV INTEGER;
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
BEGIN
  /* ================= ????? !!!!!!!!!!!! ====================================

     ???? ????????? ???? ???????? ????????? ?????? ? ???? ??????? ???? ?
       ????????? ?????? (OBJECTS_ID ? ? ??????? ???????????? ???????????
       CLIENTS_ID) ????????? ??????? ? ????? ??????, ?????????.
       ? ?????? ???? ?????? "??????"
 */

 SELECT AROUNDIN(DR.Price, 6), DR.Nomen_Id
  FROM DOCREC DR
  WHERE DR.DocRec_Id=:DocRec_Id
  INTO :P_Price, :P_Nomen_Id;

/* ======================= ???????? ???????? ================================ */
 IF (:TypeDoc_Id=1) THEN BEGIN

  SELECT DG.Goods_Id
       FROM DOCGOODS DG
       WHERE DG.DocRec_Id=:DocRec_Id
       INTO :P_Goods_Id;

  Price = AROUNDIN(:Price, 6);

  UPDATE DOCREC DR
   SET DR.Price = :Price
   WHERE DR.DocRec_Id=:DocRec_Id;

  SELECT C.ISPDV
   FROM CLIENTS C
   WHERE C.CLIENTS_ID=:OBJECTS_ID
   INTO :P_ISPDV;
  IF (:P_ISPDV IS NULL) THEN P_ISPDV=1;
  IF (:P_ISPDV=0) THEN BEGIN
   SELECT N.TYPEPDV_ID
    FROM NOMEN N
    WHERE N.NOMEN_ID=:P_NOMEN_ID
    INTO :P_TYPEPDV_ID;
   PRICE=CALCSUMPDV(:PRICE, 0.000, 0.000, :P_TYPEPDV_ID, 0);
  END

  UPDATE goods g
    SET g.goods_inprice = :price
   WHERE g.goods_id = :P_Goods_Id;

 END /*  if (:typedoc_id=1) */

/* ======================= ???????? ???????? ================================ */
 IF (:TypeDoc_Id=2) THEN BEGIN
  UPDATE DOCREC DR
   SET DR.Price=AROUNDIN(:Price, 6)
   WHERE DR.DocRec_Id=:DocRec_Id;
 END /*  if (:typedoc_id=2) */

END^


ALTER PROCEDURE S_DOCREC_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    AVG_DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_docrec_id integer;
declare variable p_kilk double precision;
declare variable p_main_price double precision;
declare variable p_price_out_pdv double precision;
declare variable p_sum_out_pdv double precision;
declare variable p_sum_in_pdv double precision;
declare variable p_sum_in double precision;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_disc_persent double precision;
declare variable p_sum_disc_persent double precision;
declare variable p_count_rec integer;
begin
  /* procedure text */
 sum_out_pdv = 0.000;
 sum_out     = 0.000;
 sum_in_pdv  = 0.000;
 sum_in      = 0.000;
 if (:disc_persent is null) then disc_persent = 0.000;
 p_sum_disc_persent = 0.000;
 p_count_rec        = 0;
 for select dr.docrec_id, dr.kilk, dr.price, dr.typepdv_id, dr.typepdv_pdv,
            dr.disc_persent, dr.insum_pdv, dr.insum
       from docrec dr
      where dr.document_id = :documents_id
       into p_docrec_id, p_kilk, p_main_price, p_typepdv_id, p_typepdv_pdv,
            p_disc_persent, p_sum_in_pdv, p_sum_in
 do begin
  if ((:p_disc_persent is null) or (:p_disc_persent=0.000)) then begin
    p_sum_disc_persent = :p_sum_disc_persent + :disc_persent;
   end
  else begin
    p_sum_disc_persent = :p_sum_disc_persent + :p_disc_persent;
   end

  p_count_rec = :p_count_rec + 1;
  select oprice_pdv, osum_pdv from ps_get_sum(:p_docrec_id, :disc_persent, :p_disc_persent)
    into p_price_out_pdv, p_sum_out_pdv;

  sum_in_pdv  = :sum_in_pdv  + :p_sum_in_pdv;
  sum_out_pdv = :sum_out_pdv + :p_sum_out_pdv;

  sum_in  = :sum_in + :p_sum_in;
  sum_out = :sum_out + calcsum(:p_sum_out_pdv, :p_sum_out_pdv-:p_sum_in_pdv, :p_typepdv_pdv, :p_typepdv_id, 0);

 end
 if (:p_count_rec <> 0) then begin
   avg_disc_persent = (:p_sum_disc_persent/:p_count_rec);
  end
 else begin
  avg_disc_persent = :disc_persent;
 end
 suspend;
end^


ALTER PROCEDURE S_DOCREC_UPDATE (
    DOCREC_ID INTEGER,
    KILK NUMERIC(9,3),
    OUT_PRICE DOUBLE PRECISION)
RETURNS (
    VKILK DOUBLE PRECISION)
AS
DECLARE VARIABLE P_DOCUMENT_ID INTEGER;
DECLARE VARIABLE P_PRICE DOUBLE PRECISION;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
DECLARE VARIABLE P_NOMEN_ID INTEGER;
DECLARE VARIABLE P_KILK NUMERIC(9,3);
DECLARE VARIABLE REST NUMERIC(9,3);
DECLARE VARIABLE RIZN NUMERIC(9,3);
BEGIN

 SELECT AROUNDIN(DR.Price, 6), DR.Nomen_Id, DR.Kilk, DR.Document_Id
  FROM DOCREC DR
  WHERE DR.DocRec_Id=:Docrec_Id
  INTO :P_Price, :P_Nomen_Id, :P_Kilk, :P_Document_Id;

 SELECT D.Objects_Id, D.Clients_Id, D.TypeDoc_Id
  FROM DOCUMENTS D
  WHERE D.Document_Id=:P_Document_Id
  INTO :P_Objects_Id, :P_Clients_Id, :P_TypeDoc_Id;

 IF ((:Out_Price>0.000) AND (AROUNDIN(:Out_Price, 6)<>AROUNDIN(:P_Price, 6))) THEN
   EXECUTE PROCEDURE S_DOCREC_PRICEUPD(:DocRec_Id, :Out_Price, :P_TypeDoc_Id, :P_Objects_Id, :P_Clients_Id);

 IF (:Kilk<>:P_Kilk) THEN
 begin
  if (P_TypeDoc_Id = 2) then
  begin
    rizn = :P_Kilk - :Kilk;
    if ((rizn < 0) and (can_minus() = 0)) then
    begin
      select sum(g.goods_rest) from goods g
          where g.nomen_id = :p_nomen_id
        into :rest;
      rest = max2(0, rest);
      rest = min2(:kilk - :p_kilk, rest);
      kilk = :p_kilk + rest;
    end
  end
  EXECUTE PROCEDURE S_DOCREC_KILKUPD(:DocRec_Id, :P_Nomen_Id, :P_Objects_Id, :P_Clients_Id, :Out_Price, :Kilk, :P_Kilk, :P_TypeDoc_Id);
 end
 VKILK=:KILK;
 SUSPEND;
END^


ALTER PROCEDURE S_DOCREC_VIEW (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable p_disc_persent double precision;
declare variable p_typedoc_id integer;
declare variable p_maker_id integer;
declare variable p_tara_id integer;
declare variable p_objects_id integer;
declare variable p_ispdv integer;
declare variable p_nomen_pdv integer;
declare variable p_in_sum double precision;
declare variable p_in_sum_vat double precision;
begin
 select d.disc_persent, d.typedoc_id, d.objects_id
  from documents d
  where d.document_id=:document_id
  into :p_disc_persent, :p_typedoc_id, :p_objects_id;

 for select dr.docrec_id, dr.nomen_id, n.nomen_code, n.nomen_name, dr.price, dr.kilk, tp.typepdv_id, tp.pdv,
            '('||cast(cast(dr.typepdv_pdv*100 as integer) as varchar(5))||'%) '||tp.typepdv_name, '', 1.00,
            s.si_name, dr.typepdv_id, dr.typepdv_pdv, n.is_weight, 1, 0, n.out_price,
            dr.disc_persent, n.typepdv_id, dr.insum_pdv, dr.insum
      from docrec dr 
           join nomen n on (dr.nomen_id = n.nomen_id)
           join typepdv tp on (n.typepdv_id = tp.typepdv_id)
           join si s  on (n.si_id = s.si_id)
     where dr.document_id = :document_id
  order by dr.docrec_id
      into docrec_id, nomen_id, nomen_code, nomen_name, general_price, kilk,
           p_typepdv_id, p_typepdv_pdv, type_pdv, packs, in_pack,
           si_name, typepdv_id, typepdv_pdv, is_weight, p_tara_id, p_maker_id, nomen_price,
           disc_persent, p_nomen_pdv, p_in_sum_vat, p_in_sum
 do begin
  p_sum_in=:p_in_sum_vat;
  sum_pdv=0.000;
  sum_out=0.000;
  out_price=0.000;
  extra_sum=0.000;
  extra_p=0.000;
  maker_name=null;
  p_in_sum_vat=absrizn(0, :p_in_sum_vat);
  p_in_sum=absrizn(0, :p_in_sum);

  if (disc_persent is null) then begin
    disc_persent=:p_disc_persent;
   end

  select osum_pdv, oprice_pdv from ps_get_sum(:docrec_id, :p_disc_persent, :disc_persent)
    into sum_out_pdv, out_price_pdv;

  if (kilk <> 0) then
  begin
   p_in_price = :p_in_sum / :kilk;
   extra_sum  = :sum_out_pdv - :p_in_sum_vat;

   sum_out = calcsum(:sum_out_pdv, :extra_sum, :p_typepdv_pdv, :p_typepdv_id, 0);

   extra_sum = :sum_out - :p_in_sum;
   if (:extra_sum <> 0.000) then extra_p = (:extra_sum / :sum_out) * 100;

   out_price = :sum_out / :kilk;

  if (:p_typedoc_id=1) then begin
   if (:sum_out_pdv <> 0.000) then
   begin
      extra_sum = (:kilk*:nomen_price) - :sum_out_pdv;
      extra_p   = (((:kilk*:nomen_price)*100)/:sum_out_pdv)-100;
   end
   else begin
     extra_sum = 0.000;
     extra_p   = 0.000;
   end
  end

  sum_pdv = :sum_out_pdv - :sum_out;

  end /* if (kilk<>0) then */
  else begin
   out_price   = null;
   sum_out     = null;
   type_pdv    = null;
   sum_pdv     = null;
   sum_out_pdv = null;
   extra_sum   = null;
   extra_p     = null;
  end /* if (kilk<>0) else */
  disc_persent = :disc_persent*100;
  suspend;
 end
end^


ALTER PROCEDURE S_DOCREC_VIEW_1 (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    NOMEN_PRICE DOUBLE PRECISION,
    DISC_PERSENT DOUBLE PRECISION)
AS
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_in_price double precision;
declare variable p_disc_persent double precision;
declare variable p_typedoc_id integer;
declare variable p_maker_id integer;
declare variable p_tara_id integer;
declare variable p_objects_id integer;
declare variable p_ispdv integer;
declare variable p_nomen_pdv integer;
declare variable p_in_sum double precision;
declare variable p_in_sum_vat double precision;
BEGIN /*$$IBE$$  !!!!!!УЖЕ НЕ ВИКОРИСТОВУЄТЬСЯ!!!!!
 SELECT D.DISC_PERSENT, D.TYPEDOC_ID, D.OBJECTS_ID
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOCUMENT_ID
  INTO :P_DISC_PERSENT, :P_TYPEDOC_ID, :P_OBJECTS_ID;

 FOR SELECT DR.DOCREC_ID, DR.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, DR.PRICE, DR.KILK, TP.TYPEPDV_ID, TP.PDV,
            '('||CAST(CAST(DR.TYPEPDV_PDV*100 AS INTEGER) AS VARCHAR(5))||'%) '||TP.TYPEPDV_NAME, '', 1.00,
            S.SI_NAME, DR.TYPEPDV_ID, DR.TYPEPDV_PDV, N.IS_WEIGHT, 1, 0, N.OUT_PRICE,
            DR.DISC_PERSENT, N.TYPEPDV_ID, DR.INSUM_PDV, DR.INSUM
      FROM DOCREC DR,
           NOMEN N,
           TYPEPDV TP,
           SI S
      WHERE DR.DOCUMENT_ID=:DOCUMENT_ID AND
            DR.NOMEN_ID=N.NOMEN_ID AND
            TP.TYPEPDV_ID=DR.TYPEPDV_ID AND
            S.SI_ID=N.SI_ID
      order by DR.DOCREC_ID
      INTO :DOCREC_ID, :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME, :GENERAL_PRICE, :KILK,
           :P_TYPEPDV_ID, :P_TYPEPDV_PDV, :TYPE_PDV, :PACKS, :IN_PACK,
           :SI_NAME, :TYPEPDV_ID, :TYPEPDV_PDV, :IS_WEIGHT, :P_TARA_ID, :P_MAKER_ID, :NOMEN_PRICE,
           :DISC_PERSENT, :P_NOMEN_PDV, :P_IN_SUM_VAT, :P_IN_SUM
 DO BEGIN
  P_SUM_IN=:P_IN_SUM_VAT;
  SUM_PDV=0.000;
  SUM_OUT=0.000;
  OUT_PRICE=0.000;
  EXTRA_SUM=0.000;
  EXTRA_P=0.000;
  MAKER_NAME=NULL;
  P_IN_SUM_VAT=ABSRIZN(0, :P_IN_SUM_VAT);
  P_IN_SUM=ABSRIZN(0, :P_IN_SUM);

  IF (DISC_PERSENT IS NULL) THEN BEGIN
    DISC_PERSENT=:P_DISC_PERSENT;
   END

  OUT_PRICE_PDV=CALCPRICEPDV(:GENERAL_PRICE, :P_DISC_PERSENT, :DISC_PERSENT, 0);

  SUM_OUT_PDV=:OUT_PRICE_PDV*:KILK;

  IF (KILK<>0) THEN BEGIN
   P_IN_PRICE=:P_IN_SUM/:KILK;
   EXTRA_SUM=:SUM_OUT_PDV-:P_IN_SUM_VAT;

   SUM_OUT=CALCSUM(:SUM_OUT_PDV, :EXTRA_SUM, :P_TYPEPDV_PDV, :P_TYPEPDV_ID, 0);

   EXTRA_SUM=:SUM_OUT-:P_IN_SUM;
 $$IBE$$*/ /*   IF (:P_SUM_IN<>0.000) THEN EXTRA_P=(:SUM_OUT*100/:P_IN_SUM)-100;*/ /*$$IBE$$ 

   IF (:SUM_OUT <> 0.000) THEN
   BEGIN
     EXTRA_P = (EXTRA_SUM / :SUM_OUT) * 100;
   END
   ELSE
   BEGIN
     EXTRA_P = 0.000;
   END

   OUT_PRICE=:SUM_OUT/:KILK;

  IF (:P_TYPEDOC_ID=1) THEN BEGIN
   SELECT C.ISPDV
    FROM CLIENTS C
    WHERE C.CLIENTS_ID=:P_OBJECTS_ID
    INTO :P_ISPDV;
   IF ((:P_ISPDV=0) AND (:P_NOMEN_PDV=3)) THEN BEGIN
      EXTRA_SUM=(:KILK*:NOMEN_PRICE) - (:SUM_OUT_PDV*1.2);
      EXTRA_P=(((:KILK*:NOMEN_PRICE)*100)/(:SUM_OUT_PDV*1.2))-100;
     END
    ELSE BEGIN
      EXTRA_SUM=(:KILK*:NOMEN_PRICE) - :SUM_OUT_PDV;
      EXTRA_P=(((:KILK*:NOMEN_PRICE)*100)/:SUM_OUT_PDV)-100;
     END
  END

  SUM_PDV=:SUM_OUT_PDV-:SUM_OUT;

  END  $$IBE$$*/ /* IF (KILK<>0) THEN */ /*$$IBE$$ 
  ELSE BEGIN
   OUT_PRICE=NULL;
   SUM_OUT=NULL;
   TYPE_PDV=NULL;
   SUM_PDV=NULL;
   SUM_OUT_PDV=NULL;
   EXTRA_SUM=NULL;
   EXTRA_P=NULL;
  END  $$IBE$$*/ /* IF (KILK<>0) ELSE */ /*$$IBE$$ 
  DISC_PERSENT=:DISC_PERSENT*100;
  SUSPEND;
 END
 $$IBE$$*/ EXIT;
END^


ALTER PROCEDURE S_DOCREC_VIEW_G (
    DOCUMENT_ID INTEGER,
    TYPEDOC_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    SUM_PDV_IN DOUBLE PRECISION,
    GENERAL_PRICE DOUBLE PRECISION)
AS
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_TYPEPDV_PDV DOUBLE PRECISION;
DECLARE VARIABLE P_IN_PRICE DOUBLE PRECISION;
BEGIN
 FOR SELECT DR.DOCREC_ID, DR.NOMEN_ID, DR.PRICE, DR.KILK, TP.TYPEPDV_ID,
            TP.PDV, DR.INSUM_PDV
      FROM DOCREC DR,
           NOMEN N,
           TYPEPDV TP
      WHERE DR.DOCUMENT_ID=:DOCUMENT_ID AND
            DR.NOMEN_ID=N.NOMEN_ID AND
            TP.TYPEPDV_ID=N.TYPEPDV_ID
      INTO :DOCREC_ID, :NOMEN_ID, :GENERAL_PRICE, :KILK, :P_TYPEPDV_ID,
           :P_TYPEPDV_PDV, :SUM_IN_PDV
 DO BEGIN

  SUM_PDV=0.000;
  SUM_OUT=0.000;
  OUT_PRICE=0.000;

  IF (DISC_PERSENT IS NULL) THEN BEGIN
    OUT_PRICE_PDV=:GENERAL_PRICE;
   END
  ELSE BEGIN
    OUT_PRICE_PDV=:GENERAL_PRICE*(1-:DISC_PERSENT);
   END

  SUM_OUT_PDV=:OUT_PRICE_PDV*:KILK;

  IF (KILK<>0) THEN BEGIN

/*   SELECT SUM(G.GOODS_INPRICE*DG.KILK)
    FROM DOCGOODS DG,
         GOODS G
    WHERE DG.DOCREC_ID=:DOCREC_ID AND
          G.GOODS_ID=DG.GOODS_ID
    INTO :SUM_IN_PDV;*/

   IF ((:SUM_IN_PDV IS NULL) OR (:SUM_IN_PDV=0.000)) THEN BEGIN
     SUM_IN_PDV=0.000;
     P_IN_PRICE=0.000;
     EXTRA_SUM=0.000;
     EXTRA_P=0.000;
    END
   ELSE BEGIN
     P_IN_PRICE=:SUM_IN_PDV/:KILK;
     EXTRA_SUM=:SUM_OUT_PDV-:SUM_IN_PDV;

     EXTRA_P=(:SUM_OUT_PDV*100/:SUM_IN_PDV)-100;
    END

  IF (P_TYPEPDV_ID=1) THEN BEGIN
   SUM_IN=:SUM_IN_PDV;
   OUT_PRICE=:OUT_PRICE_PDV;
  END
  IF (P_TYPEPDV_ID=2) THEN BEGIN
   SUM_IN=:SUM_IN_PDV;
   OUT_PRICE=:P_IN_PRICE + ((:OUT_PRICE_PDV-:P_IN_PRICE)/(1+:P_TYPEPDV_PDV));
  END
  IF (P_TYPEPDV_ID=3) THEN BEGIN
   SUM_IN=:SUM_IN_PDV/(1+:P_TYPEPDV_PDV);
   OUT_PRICE=:OUT_PRICE_PDV/(1+:P_TYPEPDV_PDV);
  END

  SUM_OUT=:OUT_PRICE*:KILK;

  IF ((EXTRA_SUM IS NULL) OR (:TYPEDOC_ID=1) ) THEN EXTRA_SUM=0.000;
  IF ((EXTRA_P IS NULL) OR (:TYPEDOC_ID=1) ) THEN EXTRA_P=0.000;

  SUM_PDV=:SUM_OUT_PDV-:SUM_OUT;
  SUM_PDV_IN=:SUM_IN_PDV-:SUM_IN;

  END /* IF (KILK<>0) THEN */
  ELSE BEGIN
   OUT_PRICE=NULL;
   SUM_OUT=NULL;
   TYPE_PDV=NULL;
   SUM_PDV=NULL;
   SUM_OUT_PDV=NULL;
   OUT_PRICE_PDV=NULL;
   EXTRA_SUM=NULL;
   EXTRA_P=NULL;
  END /* IF (KILK<>0) ELSE */

  SUSPEND;
 END
END^


ALTER PROCEDURE S_DOCREC_VIEW_ID (
    DOCREC_ID INTEGER)
RETURNS (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    EXTRA_SUM DOUBLE PRECISION,
    EXTRA_P DOUBLE PRECISION,
    IN_PRICE DOUBLE PRECISION,
    IN_PRICE_PDV DOUBLE PRECISION,
    PACKS VARCHAR(12),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT)
AS
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_TYPEPDV_PDV DOUBLE PRECISION;
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
DECLARE VARIABLE P_OBJETCS_ID INTEGER;
DECLARE VARIABLE P_AROUND_PRICE_PDV INTEGER;
BEGIN
  SELECT D.DISC_PERSENT, D.TYPEDOC_ID, D.OBJECTS_ID
   FROM DOCUMENTS D
   WHERE D.DOCUMENT_ID=:DOCUMENT_ID
   INTO :P_DISC_PERSENT, :P_TYPEDOC_ID, :P_OBJETCS_ID;
  SELECT O.AROUND_PRICE_PDV
   FROM OBJECTS O
   WHERE O.OBJECTS_ID=:P_OBJETCS_ID
   INTO :P_AROUND_PRICE_PDV;
 FOR SELECT DR.DOCUMENT_ID, DR.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, DR.PRICE, DR.KILK, TP.TYPEPDV_ID, TP.PDV,
            '('||CAST(CAST(TP.PDV*100 AS INTEGER) AS VARCHAR(5))||'%) '||TP.TYPEPDV_NAME, '', 1.00,
            S.SI_NAME, TP.TYPEPDV_ID, TP.PDV, N.IS_WEIGHT, DR.INSUM_PDV
      FROM DOCREC DR,
           NOMEN N,
           TYPEPDV TP,
           SI S
      WHERE DR.DOCREC_ID=:DOCREC_ID AND
            DR.NOMEN_ID=N.NOMEN_ID AND
            TP.TYPEPDV_ID=N.TYPEPDV_ID AND
            S.SI_ID=N.SI_ID
      INTO :DOCUMENT_ID, :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME, :OUT_PRICE_PDV, :KILK,:P_TYPEPDV_ID, :TYPEPDV_PDV, 
           :TYPE_PDV, :PACKS, :IN_PACK,
           :SI_NAME, :TYPEPDV_ID, :TYPEPDV_PDV, :IS_WEIGHT, :IN_PRICE
 DO BEGIN

  SUM_PDV=0.000;
  SUM_OUT=0.000;
  OUT_PRICE=0.000;
  /* ????????????? ?????? ?? ????????? */
/*  IF ( NOT (P_DISC_PERSENT IS NULL)) THEN BEGIN
   OUT_PRICE_PDV=AROUNDN((:OUT_PRICE_PDV-:OUT_PRICE_PDV*:P_DISC_PERSENT), :P_AROUND_PRICE_PDV);
  END*/

  SUM_OUT_PDV=:OUT_PRICE_PDV*:KILK;

  IF (KILK<>0) THEN BEGIN

/*   SELECT SUM(G.GOODS_INPRICE*DG.KILK)
    FROM DOCGOODS DG,
         GOODS G
    WHERE DG.DOCREC_ID=:DOCREC_ID AND
          G.GOODS_ID=DG.GOODS_ID
    INTO :IN_PRICE;*/
   IN_PRICE = :IN_PRICE/:KILK;

   IN_PRICE_PDV=IN_PRICE;
   IF (P_TYPEPDV_ID=3) THEN IN_PRICE_PDV=(:IN_PRICE*(1+:P_TYPEPDV_PDV));

   IF ((:IN_PRICE IS NULL) OR (:IN_PRICE=0)) THEN BEGIN
     IN_PRICE=0.000;
     EXTRA_SUM=0.000;
     EXTRA_P=0.000;
    END
   ELSE BEGIN
     EXTRA_SUM=:SUM_OUT-(:IN_PRICE*:KILK);
     EXTRA_P=(:EXTRA_SUM*100)/(:IN_PRICE*:KILK);
    END
   IF ((EXTRA_SUM IS NULL) OR (:P_TYPEDOC_ID=1) ) THEN EXTRA_SUM=0.000;
   IF ((EXTRA_P IS NULL) OR (:P_TYPEDOC_ID=1) ) THEN EXTRA_P=0.000;

   IF (P_TYPEPDV_ID=1) THEN SUM_OUT=:SUM_OUT_PDV;
   IF (P_TYPEPDV_ID=2) THEN SUM_OUT=(:SUM_OUT_PDV-:EXTRA_SUM)+(:EXTRA_SUM/(1+:P_TYPEPDV_PDV));
   IF (P_TYPEPDV_ID=3) THEN SUM_OUT=(:SUM_OUT_PDV/(1+:P_TYPEPDV_PDV));

/*   SUM_OUT=AROUNDN(:SUM_OUT, :P_AROUND_PRICE_PDV);*/
   SUM_PDV=:SUM_OUT_PDV-:SUM_OUT;

   OUT_PRICE=AROUNDIN(:SUM_OUT/:KILK, 6);

  END /* IF (KILK<>0) THEN */
  ELSE BEGIN
   OUT_PRICE_PDV=NULL;
   SUM_OUT_PDV=NULL;
   TYPE_PDV=NULL;
   SUM_PDV=NULL;
   SUM_OUT=NULL;
   OUT_PRICE=NULL;
   EXTRA_SUM=NULL;
   EXTRA_P=NULL;
  END

  SUSPEND;
 END
END^


ALTER PROCEDURE S_DOCREC_VIEW_NAKL1 (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOCREC_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK DOUBLE PRECISION,
    OUT_PRICE_PDV DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION,
    SUM_PDV DOUBLE PRECISION,
    TYPE_PDV VARCHAR(45),
    OUT_PRICE DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    P_SUM_IN DOUBLE PRECISION,
    PACKS VARCHAR(60),
    IN_PACK NUMERIC(9,3),
    SI_NAME VARCHAR(12),
    TARA_NAME VARCHAR(12),
    TYPEPDV_ID INTEGER,
    TYPEPDV_PDV DOUBLE PRECISION,
    IS_WEIGHT SMALLINT,
    MAKER_NAME VARCHAR(40),
    GENERAL_PRICE DOUBLE PRECISION,
    SUMTOV_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_TYPEPDV_PDV DOUBLE PRECISION;
DECLARE VARIABLE P_IN_PRICE DOUBLE PRECISION;
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
DECLARE VARIABLE P_MAKER_ID INTEGER;
DECLARE VARIABLE P_TARA_ID INTEGER;
DECLARE VARIABLE N_PACK_ID INTEGER;
DECLARE VARIABLE BRUTTO DOUBLE PRECISION;
DECLARE VARIABLE IN_PROM_TARA DOUBLE PRECISION;
DECLARE VARIABLE PROM_TARA_ID INTEGER;
DECLARE VARIABLE TYP_PDV INTEGER;
BEGIN
 FOR SELECT DR.DOCREC_ID, DR.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME, 1, n.typepdv_id, DR.PRICE, AROUND3(DR.KILK), TP.TYPEPDV_ID, TP.PDV,
            '('||CAST(CAST(TP.PDV*100 AS INTEGER) AS VARCHAR(5))||'%) '||TP.TYPEPDV_NAME, /*P.PACK_NAME,*/ 1.0,
            '', TP.TYPEPDV_ID, TP.PDV, N.IS_WEIGHT, 1, 0, N.brutto,
            1.00, 1
      FROM DOCREC DR,
           NOMEN N,
           TYPEPDV TP
      WHERE DR.DOCUMENT_ID=:DOCUMENT_ID AND
            DR.NOMEN_ID=N.NOMEN_ID AND
            TP.TYPEPDV_ID=N.TYPEPDV_ID
      INTO :DOCREC_ID, :NOMEN_ID,  :NOMEN_CODE, :NOMEN_NAME, :N_PACK_ID, :typ_pdv, :GENERAL_PRICE, :KILK,
           :P_TYPEPDV_ID, :P_TYPEPDV_PDV, :TYPE_PDV, :IN_PACK,
           :SI_NAME, :TYPEPDV_ID, :TYPEPDV_PDV, :IS_WEIGHT, :P_TARA_ID, :P_MAKER_ID, :brutto,
           :IN_PROM_TARA, :prom_tara_id
 DO BEGIN
  P_SUM_IN= :GENERAL_PRICE*:kilk;
  SUM_PDV=0.000;
  SUM_OUT=0.000;
  OUT_PRICE=0.000;
 

  MAKER_NAME = '';
  PACKS='';
 
  SELECT D.DISC_PERSENT, D.TYPEDOC_ID
   FROM DOCUMENTS D
   WHERE D.DOCUMENT_ID=:DOCUMENT_ID
   INTO :P_DISC_PERSENT, :P_TYPEDOC_ID;
 
  IF (P_DISC_PERSENT IS NULL) THEN BEGIN
    OUT_PRICE_PDV=:GENERAL_PRICE;
   END
  ELSE BEGIN
    OUT_PRICE_PDV=:GENERAL_PRICE*(1-:P_DISC_PERSENT);
   END
 
  SUM_OUT_PDV=:OUT_PRICE_PDV*:KILK;
 
  IF (KILK<>0) THEN BEGIN
                     /*
   SELECT SUM(G.GOODS_INPRICE*DG.KILK)
    FROM DOCGOODS DG,
         GOODS G
    WHERE DG.DOCREC_ID=:DOCREC_ID AND
          G.GOODS_ID=DG.GOODS_ID
    INTO :P_SUM_IN;*/
 
   IF ((:P_SUM_IN IS NULL) OR (:P_SUM_IN=0.000)) THEN BEGIN
     P_SUM_IN=0.000;
     P_IN_PRICE=0.000;
/*     EXTRA_SUM=0.000;*/
/*     EXTRA_P=0.000;*/
    END
   ELSE BEGIN
     P_IN_PRICE=:P_SUM_IN/:KILK;
/*     EXTRA_SUM=:SUM_OUT_PDV-:P_SUM_IN;*/
 
  /*   EXTRA_P=(:SUM_OUT_PDV*100/:P_SUM_IN)-100;*/
    END
 
  IF (P_TYPEPDV_ID=1) THEN OUT_PRICE=:OUT_PRICE_PDV;
  IF (P_TYPEPDV_ID=2) THEN OUT_PRICE=:P_IN_PRICE + ((:OUT_PRICE_PDV-:P_IN_PRICE)/(1+:P_TYPEPDV_PDV));
  IF (P_TYPEPDV_ID=3) THEN OUT_PRICE=:OUT_PRICE_PDV/(1+:P_TYPEPDV_PDV);
 
/*  SUM_OUT=AROUND6(:OUT_PRICE*:KILK);*/
  SUM_OUT=:OUT_PRICE*:KILK;
 
/*  IF ((EXTRA_SUM IS NULL) OR (:P_TYPEDOC_ID=1) ) THEN EXTRA_SUM=0.000;*/
/*  IF ((EXTRA_P IS NULL) OR (:P_TYPEDOC_ID=1) ) THEN EXTRA_P=0.000;*/
 
  SUM_PDV=:SUM_OUT_PDV-:SUM_OUT;
 
  END /* IF (KILK<>0) THEN */
  ELSE BEGIN
   OUT_PRICE=NULL;
   SUM_OUT=NULL;
   TYPE_PDV=NULL;
   SUM_PDV=NULL;
   SUM_OUT_PDV=NULL;
   OUT_PRICE_PDV=NULL;
/*   EXTRA_SUM=NULL;*/
/*   EXTRA_P=NULL;*/
  END /* IF (KILK<>0) ELSE */
  SUMTOV_PDV = null;
  if (:typ_pdv = 1) then
   begin
   SUMTOV_PDV =:sum_out;
   sum_out = null;
   end
   typ_pdv = -1;
 
  SUSPEND;
 END
END^


ALTER PROCEDURE S_FAKTURA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RCLIENT_NAME VARCHAR(50),
    ROBJECT_NAME VARCHAR(50),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24),
    RZKPO VARCHAR(20),
    RNUMPDV VARCHAR(20),
    RIPN VARCHAR(20),
    RDOC_NUM VARCHAR(14),
    RACCOUNT VARCHAR(20),
    RNAME VARCHAR(40),
    RMFO VARCHAR(20),
    RDOC_DATE DATE,
    OTYPEPROP_NAME VARCHAR(40))
AS
DECLARE VARIABLE PCLIENT_ID INTEGER;
DECLARE VARIABLE TTYPEPROP_ID INTEGER;
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PACCOUNT_ID INTEGER;
begin
  select d.doc_num, d.doc_date, d.clients_id, d.objects_id from documents d
    where d.document_id = :vdocument_id
  into :rdoc_num, :rdoc_date, :pobject_id, :pclient_id;

  select c.name, c.adress, c.phone, c.zkpo, c.numpdv, c.ipn, c.typeprop_id from clients c
    where c.clients_id = :pclient_id
  into :rclient_name, :radress, :rphone, :rzkpo, :rnumpdv, :ripn, :ttypeprop_id;

  select c.name from clients c
    where c.clients_id = :pobject_id
  into :robject_name;

  select max(ca.account_id) from clientaccount ca
    where ca.clients_id = :pclient_id
  into :paccount_id;

  if (:paccount_id is not null) then
  begin
    select ca.account_num, b.name, b.mfo from clientaccount ca, banks b
      where ca.account_id = :paccount_id and
            ca.banks_id = b.banks_id
    into :raccount, :rname, :rmfo;
  end
  select tp.name from typeprop tp
    where tp.typeprop_id = :ttypeprop_id
  into :otypeprop_name;
  suspend;
end^


ALTER PROCEDURE S_GET_NOMCODE (
    GROUP_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7))
AS
declare variable p_cnt integer;
declare variable pnom_id integer;
declare variable pgrp_code integer;
declare variable tnew_code integer;
declare variable tcode varchar(7);
BEGIN
  tcode = '';
  while (:tcode is not null)
  do begin
    tnew_code = GEN_ID(GEN_LAST_NOMEN_CODE, 1);

    tcode = null;
    select n.nomen_code from nomen n
        where n.nomen_code = tosix(:tnew_code) and
      ((n.is_exist = 1)or(n.is_exist is null))
      into :tcode;
  end
  nomen_code = tosix(:tnew_code);

/*  NOMEN_CODE = tosix(:pnew_code + 1);*/
  SUSPEND;
END^


ALTER PROCEDURE S_GRP_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RPREWGRP_ID INTEGER)
AS
BEGIN
   FOR SELECT G.GRP_ID, G.PREW_GRP_ID
        FROM GRP G
        WHERE G.PREW_GRP_ID=:VGRP_ID
        INTO :RGRP_ID, :RPREWGRP_ID
   DO BEGIN
    SELECT GC.RGRP_ID, GC.RPREWGRP_ID
     FROM S_GRP_CHILDS(:RPREWGRP_ID) GC
     INTO :RGRP_ID, :RPREWGRP_ID;
    SUSPEND;
   END
END^


ALTER PROCEDURE S_KILL_MINEX (
    OBJECTS_ID INTEGER)
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    D_PRICE DOUBLE PRECISION,
    G_PRICE DOUBLE PRECISION,
    TYPEDOC_NAME VARCHAR(30))
AS
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
BEGIN
 FOR SELECT D.DOCUMENT_ID, D.DOC_NUM, D.DOC_DATE, DR.PRICE, G.GOODS_INPRICE,
            D.TYPEDOC_ID
      FROM DOCUMENTS D,
           DOCREC DR,
           DOCGOODS DG,
           GOODS G
      WHERE D.TYPEDOC_ID=2 AND
            D.OBJECTS_ID=:OBJECTS_ID AND
            DR.DOCUMENT_ID=D.DOCUMENT_ID AND
            DG.DOCREC_ID=DR.DOCREC_ID AND
            G.GOODS_ID=DG.GOODS_ID AND
            AROUND3(G.GOODS_INPRICE)>AROUND3(DR.PRICE)
      INTO :DOCUMENT_ID, :DOC_NUM, :DOC_DATE, :D_PRICE, :G_PRICE,
           :P_TYPEDOC_ID
 DO BEGIN
  SELECT TD.TYPEDOC_NAME
   FROM TYPEDOC TD
   WHERE TD.TYPEDOC_ID=:P_TYPEDOC_ID
   INTO :TYPEDOC_NAME;
  SUSPEND;
 END
END^


ALTER PROCEDURE S_KILLER_MINUSOV (
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
AS
DECLARE VARIABLE P_GOODS_ID0 INTEGER;
DECLARE VARIABLE P_GOODS_REST0 DOUBLE PRECISION;
DECLARE VARIABLE P_GOODS_ID1 INTEGER;
DECLARE VARIABLE P_GOODS_REST1 DOUBLE PRECISION;
DECLARE VARIABLE P_DOCGOODS_ID INTEGER;
DECLARE VARIABLE P_DOCGOODS_KILK DOUBLE PRECISION;
DECLARE VARIABLE P_MIN_KILK DOUBLE PRECISION;
DECLARE VARIABLE P_MIN_KILK1 DOUBLE PRECISION;
DECLARE VARIABLE P_MIN_KILK2 DOUBLE PRECISION;
DECLARE VARIABLE P_DOCREC_ID INTEGER;
BEGIN

 SELECT KS.GOODS_ID, KS.GOODS_REST
  FROM S_KILLER_SELECT(0, :NOMEN_ID, :OBJECTS_ID) KS
  INTO :P_GOODS_ID0, :P_GOODS_REST0;
 SELECT KS.GOODS_ID, KS.GOODS_REST
  FROM S_KILLER_SELECT(1, :NOMEN_ID, :OBJECTS_ID) KS
  INTO :P_GOODS_ID1, :P_GOODS_REST1;

 WHILE ((:P_GOODS_REST1>0.000) AND (:P_GOODS_REST0<0.000)) DO BEGIN
  P_MIN_KILK=MIN2(-:P_GOODS_REST0, :P_GOODS_REST1);
  SELECT MAX(DG.DOCGOODS_ID)
   FROM DOCUMENTS D,
        DOCREC DR,
        DOCGOODS DG
   WHERE D.TYPEDOC_ID IN (2, 11, 6, 14) AND
         D.OBJECTS_ID=:OBJECTS_ID AND
         DR.DOCUMENT_ID=D.DOCUMENT_ID AND
         DG.DOCREC_ID=DR.DOCREC_ID AND
         DG.GOODS_ID=:P_GOODS_ID0
   INTO :P_DOCGOODS_ID;
  SELECT DG.KILK, DG.DOCREC_ID
   FROM DOCGOODS DG
   WHERE DG.DOCGOODS_ID=:P_DOCGOODS_ID
   INTO P_DOCGOODS_KILK, :P_DOCREC_ID;
  P_MIN_KILK1=MIN2(-:P_GOODS_REST0, :P_DOCGOODS_KILK);
  P_MIN_KILK2=MIN2(P_MIN_KILK1, :P_GOODS_REST1);
  UPDATE GOODS G
   SET G.GOODS_REST=G.GOODS_REST+:P_MIN_KILK2
   WHERE G.GOODS_ID=:P_GOODS_ID0;
  UPDATE GOODS G
   SET G.GOODS_REST=G.GOODS_REST-:P_MIN_KILK2
   WHERE G.GOODS_ID=:P_GOODS_ID1;
  IF (:P_MIN_KILK2<:P_DOCGOODS_KILK) THEN BEGIN
    UPDATE DOCGOODS DG
     SET DG.KILK=DG.KILK-:P_MIN_KILK2
     WHERE DG.DOCGOODS_ID=:P_DOCGOODS_ID;
    INSERT INTO DOCGOODS (GOODS_ID, DOCREC_ID, KILK)
     VALUES (:P_GOODS_ID1, :P_DOCREC_ID, :P_MIN_KILK2);
   END
  ELSE BEGIN
   UPDATE DOCGOODS DG
    SET DG.GOODS_ID=:P_GOODS_ID1
    WHERE DG.DOCGOODS_ID=:P_DOCGOODS_ID;
  END
  SELECT KS.GOODS_ID, KS.GOODS_REST
   FROM S_KILLER_SELECT(0, :NOMEN_ID, :OBJECTS_ID) KS
   INTO :P_GOODS_ID0, :P_GOODS_REST0;
  SELECT KS.GOODS_ID, KS.GOODS_REST
   FROM S_KILLER_SELECT(1, :NOMEN_ID, :OBJECTS_ID) KS
   INTO :P_GOODS_ID1, :P_GOODS_REST1;
 END
END^


ALTER PROCEDURE S_KILLER_SELECT (
    FLAG INTEGER,
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    GOODS_ID INTEGER,
    GOODS_REST DOUBLE PRECISION)
AS
BEGIN
  /* Текст процедури */
 IF (FLAG=0) THEN BEGIN
  SELECT MAX(G.GOODS_ID)
   FROM GOODS G
   WHERE G.OBJECTS_ID=:OBJECTS_ID AND
         G.NOMEN_ID=:NOMEN_ID AND
         G.GOODS_REST<0.000
   INTO :GOODS_ID;
 END
 IF (FLAG=1) THEN BEGIN
  SELECT MAX(G.GOODS_ID)
   FROM GOODS G
   WHERE G.OBJECTS_ID=:OBJECTS_ID AND
         G.NOMEN_ID=:NOMEN_ID AND
         G.GOODS_REST>0.000
   INTO :GOODS_ID;
 END
 SELECT G.GOODS_REST
  FROM GOODS G
  WHERE G.GOODS_ID=:GOODS_ID
  INTO GOODS_REST;
 SUSPEND;
END^


ALTER PROCEDURE S_MAKER_CREATE (
    MAKER_NAME VARCHAR(40))
RETURNS (
    MAKER_ID INTEGER)
AS
BEGIN
 MAKER_ID=GEN_ID(GEN_MAKER_ID, 1);
 INSERT INTO MAKER(MAKER_ID, MAKER_NAME)
  VALUES (:MAKER_ID, :MAKER_NAME);
 SUSPEND;
END^


ALTER PROCEDURE S_MAKER_UPDATE (
    MAKER_ID INTEGER,
    MAKER_NAME VARCHAR(40))
AS
BEGIN
 UPDATE MAKER M
  SET M.MAKER_NAME=:MAKER_NAME
  WHERE M.MAKER_ID=:MAKER_ID;
 SUSPEND;
END^


ALTER PROCEDURE S_NAC_DOC (
    VDOCUMENT_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
AS
DECLARE VARIABLE PTYPEDOC_ID INTEGER;
DECLARE VARIABLE PPRICE DOUBLE PRECISION;
DECLARE VARIABLE PNOMEN_ID INTEGER;
begin
  vpercent = 1.0 + (:vpercent/100.0);
  select d.typedoc_id from documents d
      where d.document_id = :vdocument_id
    into :ptypedoc_id;
  if (:ptypedoc_id = 1) then
  begin
    for select dr.price, dr.nomen_id from docrec dr
      where dr.document_id = :vdocument_id
    into :pprice, :pnomen_id
    do begin
      update nomen n
          set n.out_price = :pprice * :vpercent
        where n.nomen_id = :pnomen_id;
    end
  end
end^


ALTER PROCEDURE S_NAC_DOCREC (
    VDOCREC_ID INTEGER,
    VPERCENT DOUBLE PRECISION)
AS
declare variable ptypedoc_id integer;
declare variable pprice double precision;
declare variable pnomen_id integer;
begin
  vpercent = 1.0 + (:vpercent/100.0);
  select d.typedoc_id from documents d, docrec dr
      where dr.docrec_id = :vdocrec_id and
            d.document_id = dr.document_id
    into ptypedoc_id;
  select dr.price, dr.nomen_id from docrec dr
    where dr.docrec_id = :vdocrec_id
    into pprice, pnomen_id;
  update nomen n
    set n.out_price = :pprice * :vpercent
    where n.nomen_id = :pnomen_id;
end^


ALTER PROCEDURE S_PAYMENT_SUMMA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RDOC_NUM VARCHAR(14),
    RDOC_SUMMA DOUBLE PRECISION,
    RPAY_SUMMA DOUBLE PRECISION,
    RTYPEDOC_ID INTEGER)
AS
declare variable pdisc_persent double precision;
begin
 select d.doc_num, d.typedoc_id, sum(gs.osum_pdv)
   from documents d
        left join docrec dr on (d.document_id = dr.document_id),
        ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs
  where dr.document_id = :vdocument_id
  group by d.doc_num, d.typedoc_id, d.disc_persent
   into rdoc_num, rtypedoc_id, rdoc_summa;

  select sum(p.summa) from payment p
   where p.document_id = :vdocument_id
    into rpay_summa;

  rdoc_summa = around(:rdoc_summa);
  rpay_summa = around(:rpay_summa);
  suspend;
end^


ALTER PROCEDURE S_PAYMENT_VIEW (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RPAYMENT_ID INTEGER,
    RSUMMA DOUBLE PRECISION,
    RPAY_DATE DATE,
    RTYPEPAY_ID INTEGER,
    RTYPEPAY_NAME VARCHAR(30))
AS
begin
  for select p.payment_id, p.summa, p.pay_date, p.typepay_id, tp.typepay_name from payment p, typepay tp
    where p.document_id = :vdocument_id and
          p.typepay_id = tp.typepay_id
   into :rpayment_id, :rsumma, :rpay_date, :rtypepay_id, :rtypepay_name
  do begin
    suspend;
  end
end^


ALTER PROCEDURE S_PRICE_EDIT (
    NOMEN_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7),
    GRP_FULLNAME VARCHAR(200),
    NOMEN_NAME VARCHAR(40),
    TYPEVAT_NAME VARCHAR(48),
    REST DOUBLE PRECISION,
    PRICE_IN_VAT DOUBLE PRECISION,
    PRICE_OUT_VAT DOUBLE PRECISION,
    TYPEVAT_ID INTEGER,
    TYPEVAT_VAT DOUBLE PRECISION)
AS
DECLARE VARIABLE P_GRP_ID INTEGER;
DECLARE VARIABLE P_SUM_IN_VAT DOUBLE PRECISION;
BEGIN
 SELECT N.NOMEN_CODE, N.NOMEN_NAME, N.TYPEPDV_ID, N.OUT_PRICE, N.GRP_ID
  FROM NOMEN N
  WHERE N.NOMEN_ID=:NOMEN_ID
  INTO :NOMEN_CODE, NOMEN_NAME, :TYPEVAT_ID, :PRICE_OUT_VAT, :P_GRP_ID;

 SELECT GFN.RGRP_FULLNAME
  FROM T_GRP_FULLNAME(:P_GRP_ID) GFN
  INTO :GRP_FULLNAME;

 SELECT SUM(G.GOODS_REST), SUM(G.GOODS_REST*G.GOODS_INPRICE)
  FROM GOODS G
  WHERE G.NOMEN_ID=:NOMEN_ID AND
        G.OBJECTS_ID=:OBJECTS_ID
  INTO :REST, :P_SUM_IN_VAT;

 SELECT TP.TYPEPDV_NAME||' ('||CAST(TP.PDV*100 AS VARCHAR(4))||'%)', TP.PDV
  FROM TYPEPDV TP
  WHERE TP.TYPEPDV_ID=:TYPEVAT_ID
  INTO :TYPEVAT_NAME, :TYPEVAT_VAT;

 IF (:REST<>0.000) THEN BEGIN
   PRICE_IN_VAT=:P_SUM_IN_VAT/:REST;
  END
 ELSE BEGIN
   PRICE_IN_VAT=0.000;
  END

 SUSPEND;
END^


ALTER PROCEDURE S_PRN_FAKTURA (
    VDOCUMENT_ID INTEGER)
RETURNS (
    RCLIENT_NAME VARCHAR(50),
    ROBJECT_NAME VARCHAR(50),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24),
    RZKPO VARCHAR(20),
    RNUMPDV VARCHAR(20),
    RIPN VARCHAR(20),
    RDOC_NUM VARCHAR(14),
    RACCOUNT VARCHAR(20),
    RNAME VARCHAR(40),
    RMFO VARCHAR(20),
    RDOC_DATE DATE)
AS
DECLARE VARIABLE PCLIENT_ID INTEGER;
DECLARE VARIABLE POBJECT_ID INTEGER;
DECLARE VARIABLE PACCOUNT_ID INTEGER;
begin
  select d.doc_num, d.doc_date, d.clients_id, d.objects_id from documents d
    where d.document_id = :vdocument_id
  into :rdoc_num, :rdoc_date, :pobject_id, :pclient_id;

  select c.name, c.adress, c.phone, c.zkpo, c.numpdv, c.ipn from clients c
    where c.clients_id = :pclient_id
  into :rclient_name, :radress, :rphone, :rzkpo, :rnumpdv, :ripn;

  select c.name from clients c
    where c.clients_id = :pobject_id
  into :robject_name;

  select max(ca.account_id) from clientaccount ca
    where ca.clients_id = :pclient_id
  into :paccount_id;

  if (:paccount_id is not null) then
  begin
    select ca.account_num, b.name, b.mfo from clientaccount ca, banks b
      where ca.account_id = :paccount_id and
            ca.banks_id = b.banks_id
    into :raccount, :rname, :rmfo;
  end

  suspend;
end^


ALTER PROCEDURE S_PRN_RECEIPT (
    DOCUMENT_ID INTEGER)
RETURNS (
    DOC_NUM VARCHAR(14),
    DOC_DATE DATE,
    SRC_NAME VARCHAR(30),
    SRC_FULLNAME VARCHAR(50),
    DST_NAME VARCHAR(30),
    DST_FULLNAME VARCHAR(50),
    AUTH_NAME VARCHAR(80),
    DOC_MARK VARCHAR(14))
AS
declare variable p_src_id integer;
declare variable p_dst_id integer;
declare variable p_auth_id integer;
BEGIN
 SELECT D.DOC_NUM, D.DOC_DATE, D.OBJECTS_ID, D.CLIENTS_ID, D.DOC_MARK, D.AUTH_ID
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOCUMENT_ID
  INTO :DOC_NUM, :DOC_DATE, :P_SRC_ID, :P_DST_ID, :DOC_MARK, :P_AUTH_ID;

 SELECT C.SHORTNAME, C.NAME
  FROM CLIENTS C
  WHERE C.CLIENTS_ID=:P_SRC_ID
  INTO :SRC_NAME, :SRC_FULLNAME;

 SELECT C.SHORTNAME, C.NAME
  FROM CLIENTS C
  WHERE C.CLIENTS_ID=:P_DST_ID
  INTO :DST_NAME, :DST_FULLNAME;

 SELECT '№ '||A.AUTH_NUM||' від '||CAST(A.AUTH_DATE AS VARCHAR(11))||'р. через '||A.AUTH_NAME
  FROM AUTH A
  WHERE A.AUTH_ID=:P_AUTH_ID
  INTO :AUTH_NAME;
 IF (:P_AUTH_ID IS NULL) THEN AUTH_NAME=NULL;

 SUSPEND;
END^


ALTER PROCEDURE S_PRN_RECEIPT_DTL (
    DOCUMENT_ID INTEGER,
    OBJECTS_ID INTEGER)
RETURNS (
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    TARA_NAME VARCHAR(12),
    KILK DOUBLE PRECISION,
    PRICE_IN DOUBLE PRECISION,
    PRICE_IN_VAT DOUBLE PRECISION,
    PRICE_OUT DOUBLE PRECISION,
    PRICE_OUT_VAT DOUBLE PRECISION,
    BAR_CODE VARCHAR(30),
    ODATEX_NAME VARCHAR(26))
AS
declare variable p_d_disc_persent double precision;
declare variable p_dr_disc_persent double precision;
declare variable p_nomen_id integer;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_tara_id integer;
declare variable p_rest double precision;
declare variable p_sum_in double precision;
declare variable p_sum_in_vat double precision;
declare variable p_sum_out double precision;
declare variable p_sum_out_vat double precision;
declare variable p_nom_bar_id integer;
declare variable p_nom_bar_count integer;
declare variable pdocrec_id integer;
declare variable pin_sum_pdv double precision;
begin
 select d.disc_persent from documents d
  where d.document_id = :document_id
   into p_d_disc_persent;
 if (:p_d_disc_persent is null) then p_d_disc_persent = 0.000;
 for select n.nomen_id, n.nomen_code, n.nomen_name, dr.kilk, n.out_price,
            dr.typepdv_id, 1, dr.disc_persent, dr.price, n.datex_name,
            dr.docrec_id
       from docrec dr
            join nomen n on (n.nomen_id = dr.nomen_id)
      where dr.document_id = :document_id
       into p_nomen_id, nomen_code, nomen_name, kilk, price_out_vat,
            p_typepdv_id, p_tara_id, p_dr_disc_persent, price_in_vat, odatex_name,
            pdocrec_id
 do begin
  if (:price_out_vat is null) then price_out_vat=0.000;

   select sum(g.goods_rest * g.goods_inprice), sum(g.goods_rest)
     from goods g
    where g.nomen_id   = :p_nomen_id and
          g.objects_id = :objects_id
     into p_sum_in_vat, p_rest;
  if (:p_sum_in_vat is null) then p_sum_in_vat = 0.000;
  if (:p_rest is null) then p_rest = 0.000;
  select tp.pdv from typepdv tp
   where tp.typepdv_id = :p_typepdv_id
    into p_typepdv_pdv;
  select oprice_pdv from ps_get_sum(:pdocrec_id, :p_d_disc_persent, :p_dr_disc_persent)
    into price_in_vat;
  price_in      = calcsum(:price_in_vat, 0.000, :p_typepdv_pdv, :p_typepdv_id, 0);
  p_sum_out_vat = :price_out_vat * :p_rest;
  p_sum_out     = calcsum(:p_sum_out_vat, :p_sum_out_vat-:p_sum_in_vat, :p_typepdv_pdv, :p_typepdv_id, 0);
  if (:p_rest<>0.000) then begin
     price_out=:p_sum_out/:p_rest;
    end
   else begin
     price_out=0.000;
    end
  select count(nb.nom_bar_id)
    from nom_bar nb
   where nb.nomen_id=:p_nomen_id
    into p_nom_bar_count;
  if (:p_nom_bar_count is null) then p_nom_bar_count=0;
  if (:p_nom_bar_count>0) then begin
    select max(nb.nom_bar_id)
     from nom_bar nb
     where nb.nomen_id=:p_nomen_id
     into :p_nom_bar_id;
    select b.code
     from nom_bar nb,
          barcode b
     where nb.nom_bar_id=:p_nom_bar_id and
           b.barcode_id=nb.barcode_id
     into :bar_code;
    if (:p_nom_bar_count>1) then bar_code=:bar_code||'/'||cast(:p_nom_bar_count as varchar(2));
   end
  else begin
   bar_code='';
  end
  suspend;
 end
end^


ALTER PROCEDURE S_RECALC_MINUSOV
AS
DECLARE VARIABLE NOMEN_ID INTEGER;
begin
 for select r.nomen_id
      from rst r
      where around3(r.rest) = 0.000 and
            around3(r.rest_sum) <> 0.000
      into :nomen_id
 do begin
  execute procedure s_sliv_minusov(1, :nomen_id);
 end
end^


ALTER PROCEDURE S_RECEIPT_CLIENT (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE)
RETURNS (
    SHORTNAME VARCHAR(30),
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_PDV_IN DOUBLE PRECISION)
AS
DECLARE VARIABLE P_DOCUMENT_ID INTEGER;
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
BEGIN
 FOR SELECT C.SHORTNAME, D.DOCUMENT_ID, D.DISC_PERSENT
      FROM DOCUMENTS D,
           CLIENTS C
      WHERE D.TYPEDOC_ID=1 AND
            D.DOC_DATE BETWEEN :DATE_IN AND :DATE_OUT AND
            D.CLIENTS_ID=:OBJECTS_ID AND
            C.CLIENTS_ID=D.OBJECTS_ID
      INTO :SHORTNAME, :P_DOCUMENT_ID, :P_DISC_PERSENT
 DO BEGIN
  IF (:P_DISC_PERSENT IS NULL) THEN P_DISC_PERSENT=0.000;
  SELECT SUM(DRS.SUM_IN), SUM(DRS.SUM_IN_PDV)
   FROM S_DOCREC_SUM(:P_DOCUMENT_ID, :P_DISC_PERSENT) DRS
   INTO :SUM_IN, :SUM_IN_PDV;
  SUM_PDV_IN=:SUM_IN_PDV-:SUM_IN;
  SUSPEND;
 END
END^


ALTER PROCEDURE S_REV_RECORDS_VIEW (
    VREVISION_ID INTEGER)
RETURNS (
    REV_RECORDS_ID INTEGER,
    NOMEN_ID INTEGER,
    NOMEN_CODE VARCHAR(7),
    NOMEN_NAME VARCHAR(40),
    KILK_OLD DOUBLE PRECISION,
    KILK_NEW DOUBLE PRECISION,
    PRICE_IN DOUBLE PRECISION,
    PRICE_IN_PDV DOUBLE PRECISION,
    PRICE_OUT DOUBLE PRECISION,
    PRICE_OUT_PDV DOUBLE PRECISION,
    SUM_IN_OLD DOUBLE PRECISION,
    SUM_IN_PDV_OLD DOUBLE PRECISION,
    SUM_IN_NEW DOUBLE PRECISION,
    SUM_IN_PDV_NEW DOUBLE PRECISION,
    SUM_OUT_OLD DOUBLE PRECISION,
    SUM_OUT_PDV_OLD DOUBLE PRECISION,
    SUM_OUT_NEW DOUBLE PRECISION,
    SUM_OUT_PDV_NEW DOUBLE PRECISION,
    KILK DOUBLE PRECISION,
    SUM_IN DOUBLE PRECISION,
    SUM_IN_PDV DOUBLE PRECISION,
    SUM_OUT DOUBLE PRECISION,
    SUM_OUT_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_TYPEPDV_PDV DOUBLE PRECISION;
BEGIN
 FOR SELECT RR.REV_RECORDS_ID, RR.NOMEN_ID, N.NOMEN_CODE, N.NOMEN_NAME,
            RR.KILK_OLD, RR.KILK_NEW, RR.PRICE_IN_PDV, RR.PRICE_OUT_PDV,
            N.TYPEPDV_ID, TP.PDV
      FROM REV_RECORDS RR,
           NOMEN N,
           TYPEPDV TP
      WHERE RR.REVISION_ID=:VREVISION_ID AND
            RR.NOMEN_ID=N.NOMEN_ID AND
            N.TYPEPDV_ID=TP.TYPEPDV_ID
      INTO :REV_RECORDS_ID, :NOMEN_ID, :NOMEN_CODE, :NOMEN_NAME,
           :KILK_OLD, :KILK_NEW, :PRICE_IN_PDV, :PRICE_OUT_PDV,
           :P_TYPEPDV_ID, :P_TYPEPDV_PDV
 DO BEGIN
  SUM_IN_PDV_OLD=:KILK_OLD*:PRICE_IN_PDV;
  SUM_IN_PDV_NEW=:KILK_NEW*:PRICE_IN_PDV;
  SUM_OUT_PDV_OLD=:KILK_OLD*:PRICE_OUT_PDV;
  SUM_OUT_PDV_NEW=:KILK_NEW*:PRICE_OUT_PDV;
  KILK=:KILK_NEW-:KILK_OLD;
  SUM_IN_PDV=:SUM_IN_PDV_NEW-:SUM_IN_PDV_OLD;
  SUM_OUT_PDV=:SUM_OUT_PDV_NEW-:SUM_OUT_PDV_OLD;
  IF (P_TYPEPDV_ID=1) THEN BEGIN
   PRICE_IN=:PRICE_IN_PDV;
   PRICE_OUT=:PRICE_OUT_PDV;
  END
  IF (P_TYPEPDV_ID=2) THEN BEGIN
   PRICE_IN=:PRICE_IN_PDV;
   PRICE_OUT=:PRICE_IN_PDV + ((:PRICE_OUT_PDV-:PRICE_IN_PDV)/(1+:P_TYPEPDV_PDV));
  END
  IF (P_TYPEPDV_ID=3) THEN BEGIN
   PRICE_IN=:PRICE_IN_PDV/(1+:P_TYPEPDV_PDV);
   PRICE_OUT=:PRICE_OUT_PDV/(1+:P_TYPEPDV_PDV);
  END
  SUM_IN_OLD=:KILK_OLD*:PRICE_IN;
  SUM_IN_NEW=:KILK_NEW*:PRICE_IN;
  SUM_OUT_OLD=:KILK_OLD*:PRICE_OUT;
  SUM_OUT_NEW=:KILK_NEW*:PRICE_OUT;
  KILK=:KILK_NEW-:KILK_OLD;
  SUM_IN=:SUM_IN_NEW-:SUM_IN_OLD;
  SUM_OUT=:SUM_OUT_NEW-:SUM_OUT_OLD;
  SUSPEND;
 END
END^


ALTER PROCEDURE S_RT_DOCREC_SUM (
    DOCUMENTS_ID INTEGER,
    DISC_PERSENT DOUBLE PRECISION,
    ISPDV INTEGER)
RETURNS (
    SUM_OUT_VAT_6 DOUBLE PRECISION,
    SUM_OUT_VAT_7 DOUBLE PRECISION,
    SUM_OUT_8 DOUBLE PRECISION,
    SUM_OUT_11 DOUBLE PRECISION,
    SUM_OUT_VAT_15 DOUBLE PRECISION,
    SUM_OUT_16 DOUBLE PRECISION,
    SUM_VAT_17 DOUBLE PRECISION,
    SUM_OUT_18 DOUBLE PRECISION,
    SUM_VAT_19 DOUBLE PRECISION)
AS
declare variable p_kilk double precision;
declare variable p_main_price double precision;
declare variable p_sum_out_vat double precision;
declare variable p_sum_in_pdv double precision;
declare variable p_sum_out double precision;
declare variable p_typepdv_id integer;
declare variable p_typepdv_pdv double precision;
declare variable p_disc_persent double precision;
declare variable pdocrec_id integer;
begin
 sum_out_vat_6=0.000;
 sum_out_vat_7=0.000;
 sum_out_8=0.000;
 sum_out_11=0.000;
 sum_out_vat_15=0.000;
 sum_out_16=0.000;
 sum_out_18=0.000;
 sum_vat_17=0.000;
 sum_vat_19=0.000;
 if (:ispdv is null) then ispdv=0;
 if (:disc_persent is null) then disc_persent=0.000;
 for select dr.kilk, dr.price, dr.typepdv_id, dr.typepdv_pdv,
            dr.disc_persent, dr.insum_pdv, dr.docrec_id
       from docrec dr
      where dr.document_id = :documents_id
       into p_kilk, p_main_price, p_typepdv_id, p_typepdv_pdv,
            p_disc_persent, p_sum_in_pdv, pdocrec_id
 do begin
   select gs.osum_pdv from ps_get_sum(:pdocrec_id, :disc_persent, :p_disc_persent) gs
     into p_sum_out_vat;
   p_sum_out = calcsum(:p_sum_out_vat, :p_sum_out_vat-:p_sum_in_pdv, :p_typepdv_pdv, :p_typepdv_id, 0);

  sum_out_vat_6 = :sum_out_vat_6+p_sum_out_vat;
  if (:p_typepdv_id=1) then begin
    sum_out_vat_7 = :sum_out_vat_7+:p_sum_out_vat;
    if (:ispdv=1) then begin sum_out_8=:sum_out_8+:p_sum_out; end
    else begin sum_out_11=:sum_out_11+:p_sum_out; end
   end
  else begin
    sum_out_vat_15=:sum_out_vat_15+:p_sum_out_vat;
    if (:ispdv=1) then begin
      sum_out_16=:sum_out_16+:p_sum_out;
      sum_vat_17=:sum_vat_17+(:p_sum_out_vat-:p_sum_out);
     end
    else begin
      sum_out_18=:sum_out_18+:p_sum_out;
      sum_vat_19=:sum_vat_19+(:p_sum_out_vat-:p_sum_out);
     end
   end
 end
 suspend;
end^


ALTER PROCEDURE S_RT_DOCS (
    OBJECTS_ID INTEGER,
    DATE_IN DATE,
    DATE_OUT DATE,
    TYPESPAY VARCHAR(10000))
RETURNS (
    DOCUMENT_ID INTEGER,
    DOC_NUM VARCHAR(14),
    TAX_NUM INTEGER,
    DOC_DATE DATE,
    DST_NAME VARCHAR(50),
    IPN VARCHAR(20),
    SUM_OUT_VAT_6 DOUBLE PRECISION,
    SUM_OUT_VAT_7 DOUBLE PRECISION,
    SUM_OUT_8 DOUBLE PRECISION,
    SUM_OUT_11 DOUBLE PRECISION,
    SUM_OUT_VAT_15 DOUBLE PRECISION,
    SUM_OUT_16 DOUBLE PRECISION,
    SUM_VAT_17 DOUBLE PRECISION,
    SUM_OUT_18 DOUBLE PRECISION,
    SUM_VAT_19 DOUBLE PRECISION,
    OPLATA_TYPE VARCHAR(30))
AS
DECLARE VARIABLE P_DISC_PERSENT DOUBLE PRECISION;
DECLARE VARIABLE P_DST_ID INTEGER;
DECLARE VARIABLE P_ISPDV INTEGER;
BEGIN
 FOR SELECT D.DOCUMENT_ID, D.DOC_DATE, D.DOC_NUM, Rt.reestr_id,
            D.DISC_PERSENT, D.CLIENTS_ID, TP.TYPEPAY_NAME
      FROM DOCUMENTS D,
           TYPEPAY TP,
           reestr Rt
      WHERE D.OBJECTS_ID=:OBJECTS_ID AND
            D.DOC_DATE BETWEEN :DATE_IN AND :DATE_OUT AND
            ISINLISTSTR(:TYPESPAY, D.OPLATA_TYPE)=1 AND
            TP.TYPEPAY_ID=D.OPLATA_TYPE AND
            Rt.DOCUMENT_ID=D.DOCUMENT_ID
      INTO :DOCUMENT_ID, :DOC_DATE, :DOC_NUM, :TAX_NUM,
           :P_DISC_PERSENT, :P_DST_ID, :OPLATA_TYPE
 DO BEGIN

  SELECT C.NAME, C.IPN, C.ISPDV
   FROM CLIENTS C
   WHERE C.CLIENTS_ID=:P_DST_ID
   INTO :DST_NAME, :IPN, :P_ISPDV;

  SELECT DS.SUM_OUT_VAT_6, DS.SUM_OUT_VAT_7, DS.SUM_OUT_8, DS.SUM_OUT_11,
         DS.SUM_OUT_VAT_15, DS.SUM_OUT_16, DS.SUM_VAT_17, DS.SUM_OUT_18, DS.SUM_VAT_19
   FROM S_RT_DOCREC_SUM(:DOCUMENT_ID, :P_DISC_PERSENT, :P_ISPDV) DS
   INTO :SUM_OUT_VAT_6, :SUM_OUT_VAT_7, :SUM_OUT_8, :SUM_OUT_11,
        :SUM_OUT_VAT_15, :SUM_OUT_16, :SUM_VAT_17, :SUM_OUT_18, :SUM_VAT_19;

  SUSPEND;
 END
END^


ALTER PROCEDURE S_RT_UPDATE (
    DOCUMENT_ID INTEGER,
    TD_NUMBER VARCHAR(30),
    TD_DATE DATE,
    TD_SUM DOUBLE PRECISION,
    TD_SUM_VAT DOUBLE PRECISION,
    TD_SUM_WITH_VAT DOUBLE PRECISION)
RETURNS (
    REESTR_ID INTEGER,
    EVENT_SP INTEGER)
AS
DECLARE VARIABLE COUNT_RT_DOCS INTEGER;
begin
  event_sp = 0;
  reestr_id = 0;
  count_rt_docs = 0;
  select count(rt.reestr_id)
   from reestr rt
   where rt.document_id = :document_id
   into :count_rt_docs;
  if (:count_rt_docs is null) then count_rt_docs = 0;
  if (:count_rt_docs = 0) then
  begin
    reestr_id = gen_id(reestr_gen_id, 1);
    insert into reestr (reestr_id, document_id, td_number, td_date, td_sum, td_sum_vat, td_sum_with_vat)
     values (:reestr_id, :document_id, :td_number, :td_date, :td_sum, :td_sum_vat, :td_sum_with_vat);
    event_sp = 1;
  end
  else begin
   select max(r.reestr_id)
    from reestr r
    where r.document_id = :document_id
    into :reestr_id;
   update reestr r
    set r.td_number = :td_number,
        r.td_date = :td_date,
        r.td_sum = :td_sum,
        r.td_sum_vat = :td_sum_vat,
        r.td_sum_with_vat = :td_sum_with_vat
    where r.reestr_id = :reestr_id;
   event_sp = 2;
  end
  suspend;
end^


ALTER PROCEDURE S_SEL_TOVAR_BY_CODE (
    VINP_FILTER VARCHAR(27))
RETURNS (
    RNOMEN_ID INTEGER,
    RNOMEN_NAME VARCHAR(40),
    RNOMEN_CODE VARCHAR(7),
    RNOMEN_BARC VARCHAR(27))
AS
declare variable pcont integer;
declare variable pobj_id integer;
declare variable piscode integer;
declare variable pcode integer;
declare variable pweight_code_id integer;
declare variable pcode_int bigint;
begin
  pobj_id= object();
  piscode = wiscode(:vinp_filter);
  pcode = wcode(:vinp_filter);
  if (:piscode=1) then
  begin
    pweight_code_id=null;
  select wc.weight_code_id from weight_code wc
      where wc.code = :pcode
    into :pweight_code_id;
    if (:pweight_code_id is not null) then
    begin
      vinp_filter = wincode(:vinp_filter);
    end
  end

  for select n.nomen_id, n.nomen_name, n.nomen_code from nomen n
      where n.nomen_code = :VINP_FILTER
    into :rnomen_id, :rnomen_name, :rnomen_code
  do begin
    select count(g.goods_id) from goods g
        where g.nomen_id = :rnomen_id and
              g.objects_id = :pobj_id
      into :pcont;
    if (:pcont > 0) then
      suspend;
  end

  begin
    pcode_int = cast(:vinp_filter as bigint);
    vinp_filter = cast(:pcode_int as varchar(27));
  when any do
  begin

  end
  end

  for select n.nomen_id, n.nomen_name, n.nomen_code, b.code from nomen n, barcode b, nom_bar nb
      where (b.code like '0'||'%'||:VINP_FILTER or
             b.code = :VINP_FILTER) and
            b.barcode_id = nb.barcode_id and
            n.nomen_id = nb.nomen_id  and
            ((n.is_exist = 1)or(n.is_exist is null))
    into :rnomen_id, :rnomen_name, :rnomen_code, :rnomen_barc
  do begin
    select count(g.goods_id) from goods g
        where g.nomen_id = :rnomen_id and
              g.objects_id = :pobj_id
      into :pcont;
    if (:pcont > 0) then
      suspend;
  end
end^


ALTER PROCEDURE S_SLIV_MINUSOV (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
declare variable pmgoods_id integer;
declare variable ppgoods_id integer;
declare variable pdocgoods_id integer;
declare variable pmrest double precision;
declare variable pprest double precision;
declare variable pkilk double precision;
declare variable tmarker varchar(64);
begin
  select c.marker from t_configs c
      where c.config_id = 5 and
            c.module = 'store_general'
    into :tmarker;

  if (:tmarker = 'yes') then
  begin
    for select g.goods_id, g.goods_rest from goods g
      where g.nomen_id   = :vnomen_id  and
            g.objects_id = :vobject_id and
            g.goods_rest < 0
       into pmgoods_id, pmrest
    do begin
      for select g.goods_id, g.goods_rest from goods g
        where g.nomen_id   = :vnomen_id  and
              g.objects_id = :vobject_id and
              g.goods_rest > 0
        order by goods_id
         into ppgoods_id, pprest
      do begin
        for select dg.docgoods_id, dg.kilk
              from docgoods dg
                   left join docrec dr on (dg.docrec_id   = dr.docrec_id)
                   left join documents d on (dr.document_id = d.document_id)
             where dg.goods_id    = :pmgoods_id   and
                   d.typedoc_id not in(12, 17) and
                   d.objects_id   = :vobject_id
              into pdocgoods_id, pkilk
        do begin
          if ((:pprest >= :pkilk)and(:pmrest < 0)) then
          begin
            update goods g
               set g.goods_rest = g.goods_rest - :pkilk
             where g.goods_id = :ppgoods_id;
            update goods g
               set g.goods_rest = g.goods_rest + :pkilk
             where g.goods_id = :pmgoods_id;
            pprest = pprest - :pkilk;
            pmrest = pmrest + :pkilk;
            update docgoods dg
               set dg.goods_id = :ppgoods_id
             where dg.docgoods_id = :pdocgoods_id;
          end
        end
      end
    end
  end
end^


ALTER PROCEDURE S_SLIV_MINUSOV_1 (
    VOBJECT_ID INTEGER,
    VNOMEN_ID INTEGER)
AS
declare variable pmgoods_id integer;
declare variable ppgoods_id integer;
declare variable pdocgoods_id integer;
declare variable pmrest double precision;
declare variable pprest double precision;
declare variable pkilk double precision;
begin
  /* Procedure Text */
  for select g.goods_id, g.goods_rest from goods g
    where g.nomen_id = :vnomen_id and
          g.objects_id = :vobject_id and
          g.goods_rest < 0
  into :pmgoods_id, :pmrest
  do begin
    for select g.goods_id, g.goods_rest from goods g
      where g.nomen_id = :vnomen_id and
            g.objects_id = :vobject_id and
            g.goods_rest > 0
      order by goods_id
    into :ppgoods_id, :pprest
    do begin
      for select dg.docgoods_id, dg.kilk from docgoods dg, docrec dr, documents d
        where dg.goods_id = :pmgoods_id and
              dg.docrec_id = dr.docrec_id and
              dr.document_id = d.document_id and
              d.typedoc_id not in (10, 12) and
              d.objects_id = :vobject_id
      into :pdocgoods_id, :pkilk
      do begin
        if ((:pprest >= :pkilk) and (:pmrest < 0)) then
        begin
          update goods g
            set g.goods_rest = g.goods_rest - :pkilk
           where g.goods_id = :ppgoods_id;
          update goods g
            set g.goods_rest = g.goods_rest + :pkilk
           where g.goods_id = :pmgoods_id;
          pprest = pprest - :pkilk;
          pmrest = pmrest + :pkilk;
          update docgoods dg
            set dg.goods_id = :ppgoods_id
           where dg.docgoods_id = :pdocgoods_id;
        end
      end
    end
  end
end^


ALTER PROCEDURE S_SLIV_MINUSOV_FULL (
    VNOMEN_ID_0 INTEGER,
    VNOMEN_ID_1 INTEGER)
AS
DECLARE VARIABLE TNOMEN_ID INTEGER;
begin
  for select nomen_id from nomen n where nomen_id
      between :vnomen_id_0 and :vnomen_id_1
    into :tnomen_id
  do begin
    execute procedure s_sliv_minusov_1(1, :tnomen_id);
  end
end^


ALTER PROCEDURE S_STAFF_VIEW
RETURNS (
    STAFF_ID INTEGER,
    STAFF_NUM VARCHAR(7),
    FULL_NAME VARCHAR(30),
    JOBS_NAME VARCHAR(30))
AS
DECLARE VARIABLE SURNAME VARCHAR(20);
DECLARE VARIABLE NAME VARCHAR(20);
DECLARE VARIABLE PATRONYMIC VARCHAR(20);
DECLARE VARIABLE JOBS_ID INTEGER;
DECLARE VARIABLE RESPONSIBLE SMALLINT;
BEGIN
 FOR SELECT S.STAFF_ID, S.STAFF_NUM, S.SURNAME, S.NAME, S.PATRONYMIC,
            S.JOBS_ID, S.RESPONSIBLE
      FROM STAFF S
      WHERE S.RESPONSIBLE=1 AND
            S.JOB_END>='TODAY' AND
            S.JOB_START<='TODAY'
      INTO :STAFF_ID, :STAFF_NUM, :SURNAME, :NAME, :PATRONYMIC,
           :JOBS_ID, :RESPONSIBLE
 DO BEGIN
  FULL_NAME=:SURNAME||' '||FIRSTCHAR(:NAME)||'.'||FIRSTCHAR(:PATRONYMIC)||'.';
  SELECT J.JOBS_NAME
   FROM JOBS J
   WHERE J.JOBS_ID=:JOBS_ID
   INTO :JOBS_NAME;
  SUSPEND;
 END
END^


ALTER PROCEDURE SP_CINA (
    OBJEKTS INTEGER,
    NOMENSID INTEGER)
RETURNS (
    INPRISES DOUBLE PRECISION,
    NOMENCODE VARCHAR(7),
    NOMENNAME VARCHAR(40),
    OUTPRISES DOUBLE PRECISION,
    NACINKA DOUBLE PRECISION,
    PROCANTNAC DOUBLE PRECISION,
    GOODSID INTEGER)
AS
begin
 for select g.goods_id, g.goods_inprice, n.nomen_code, n.nomen_name, n.out_price
       from goods g, nomen n
      where g.objects_id = :objekts  and
            g.nomen_id   = :nomensid and
            g.nomen_id   = n.nomen_id
       into goodsid, inprises, nomencode, nomenname, outprises
 do begin
   nacinka = :outprises-:inprises;
   procantnac = ((:outprises-:inprises)*100)/:outprises;
  suspend;
 end
end^


ALTER PROCEDURE T_DOC_CREATE (
    VDOC_MARK VARCHAR(14))
RETURNS (
    RDOCUMENT_ID INTEGER)
AS
DECLARE VARIABLE PDOC_NUM VARCHAR(14);
DECLARE VARIABLE PUSER_NIK VARCHAR(4);
DECLARE VARIABLE PDOCNUM INTEGER;
BEGIN
  RDOCUMENT_ID=GEN_ID(GEN_DOCUMENTS_ID, 1);

  SELECT U.NICK, U.last_doc
   FROM T_USERS U
   WHERE UPPER(U.user_login)=USER
   INTO :PUSER_NIK, :PDOCNUM;

  IF (:PUSER_NIK IS NULL) THEN BEGIN
   PUSER_NIK='Sys';
   SELECT COUNT(D.DOCUMENT_ID)
    FROM DOCUMENTS D
    WHERE D.USER_NAME=USER
    INTO :PDOCNUM;
  END

  IF (:PUSER_NIK IS NOT NULL) THEN BEGIN
   UPDATE T_USERS U
    SET U.last_doc=:PDOCNUM+1
    WHERE UPPER(U.user_login)=USER;
  END

  PDOC_NUM=GENDOCNUM(:PUSER_NIK, :PDOCNUM);

  INSERT INTO DOCUMENTS(DOCUMENT_ID, DOC_NUM, TYPEDOC_ID, DOC_LOCK, USER_NAME, BLOK, DOC_MARK, DOC_DATE, OBJECTS_ID, CLIENTS_ID)
   VALUES (:RDOCUMENT_ID, :PDOC_NUM, 1, 0, USER, 1, :VDOC_MARK, '09.08.2002', 108, 1);

  SUSPEND;

END^


ALTER PROCEDURE T_DOCREC_CREATE (
    DOCUMENT_ID INTEGER,
    NOMEN_ID INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION)
AS
DECLARE VARIABLE P_TYPEDOC_ID INTEGER;
DECLARE VARIABLE P_GOODS_ID INTEGER;
DECLARE VARIABLE P_GOODS_ID2 INTEGER;
DECLARE VARIABLE P_REST DOUBLE PRECISION;
DECLARE VARIABLE P_MIN_KILK DOUBLE PRECISION;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_MAX_GOODS_ID INTEGER;
DECLARE VARIABLE P_MAX_INPRICE DOUBLE PRECISION;
DECLARE VARIABLE P_INPRICE DOUBLE PRECISION;
DECLARE VARIABLE P_CLIENT_ID INTEGER;
DECLARE VARIABLE P_CLIENT_ID2 INTEGER;
DECLARE VARIABLE P_TYPEPDV_ID INTEGER;
DECLARE VARIABLE P_NOMEN_ID INTEGER;
DECLARE VARIABLE DOCREC_ID INTEGER;
BEGIN

 SELECT D.TYPEDOC_ID, D.OBJECTS_ID, D.CLIENTS_ID
  FROM DOCUMENTS D
  WHERE D.DOCUMENT_ID=:DOCUMENT_ID
  INTO :P_TYPEDOC_ID, :P_OBJECTS_ID, :P_CLIENT_ID;

/* ????????? ???????? --------------------------------------------------------*/

 IF (:P_TYPEDOC_ID=1) THEN BEGIN

  DOCREC_ID=GEN_ID(GEN_DOCREC_ID, 1);
  INSERT INTO DOCREC (DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE)
   VALUES(:DOCREC_ID, :DOCUMENT_ID, :NOMEN_ID, :KILK, AROUNDIN(:PRICE, 6));

  SELECT G.GOODS_ID, G.GOODS_REST
   FROM GOODS G
   WHERE G.NOMEN_ID=:NOMEN_ID AND
         G.OBJECTS_ID=:P_CLIENT_ID AND
         G.CLIENTS_ID=:P_OBJECTS_ID AND
         AROUNDIN(G.GOODS_INPRICE, 6)=AROUNDIN(:PRICE, 6)
   INTO :P_GOODS_ID, :P_REST;

  IF (:P_GOODS_ID IS NULL) THEN BEGIN
    P_GOODS_ID=GEN_ID(GEN_GOODS_ID, 1);
    INSERT INTO GOODS (GOODS_ID, NOMEN_ID, OBJECTS_ID, GOODS_REST, GOODS_INPRICE, CLIENTS_ID)
     VALUES (:P_GOODS_ID, :NOMEN_ID, :P_CLIENT_ID, :KILK, AROUNDIN(:PRICE, 6), :P_OBJECTS_ID);
   END
  ELSE BEGIN
    UPDATE GOODS GG
     SET GG.GOODS_REST=:P_REST+:KILK
     WHERE GG.GOODS_ID=:P_GOODS_ID;
   END
  INSERT INTO DOCGOODS (DOCREC_ID, GOODS_ID, KILK)
   VALUES (:DOCREC_ID, :P_GOODS_ID, :KILK);

  SUSPEND;

 END /*if (:P_TypeDoc_Id=1)*/

/* ????????? ???????? --------------------------------------------------------*/

 IF (:P_TYPEDOC_ID=2) THEN BEGIN

  DOCREC_ID=GEN_ID(GEN_DOCREC_ID, 1);
  INSERT INTO DOCREC (DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE)
   VALUES(:DOCREC_ID, :DOCUMENT_ID, :NOMEN_ID, :KILK, :PRICE);

  FOR SELECT G.GOODS_ID, G.GOODS_REST
       FROM GOODS G
       WHERE G.NOMEN_ID=:NOMEN_ID AND
             G.OBJECTS_ID=:P_OBJECTS_ID
       INTO :P_GOODS_ID, :P_REST
  DO BEGIN
   P_MIN_KILK=MIN2(:KILK, :P_REST);
   IF (:P_MIN_KILK>0.000) THEN
    BEGIN
     KILK=:KILK-:P_MIN_KILK;
     P_REST=:P_REST-:P_MIN_KILK;
     UPDATE GOODS GG
      SET GG.GOODS_REST=:P_REST
      WHERE GG.GOODS_ID=:P_GOODS_ID;
     INSERT INTO DOCGOODS (DOCREC_ID, GOODS_ID, KILK)
      VALUES (:DOCREC_ID, :P_GOODS_ID, :P_MIN_KILK);
    END
  END

  IF (:KILK>0.000) THEN BEGIN
   P_MAX_INPRICE=0.000;
   P_MAX_GOODS_ID=NULL;
   FOR SELECT GG.GOODS_ID, GG.GOODS_INPRICE, GG.GOODS_REST
        FROM GOODS GG
        WHERE GG.NOMEN_ID=:NOMEN_ID AND
              GG.GOODS_REST<=0.000 AND
              GG.OBJECTS_ID=:P_OBJECTS_ID AND
              GG.GOODS_INPRICE<:PRICE
        INTO :P_GOODS_ID, :P_INPRICE, :P_REST
   DO BEGIN
    IF (:P_MAX_INPRICE<:P_INPRICE) THEN BEGIN
     P_MAX_GOODS_ID=:P_GOODS_ID;
     P_MAX_INPRICE=:P_INPRICE;
    END
   END

   IF (:P_MAX_GOODS_ID IS NULL) THEN BEGIN
    FOR SELECT GG.GOODS_ID, GG.GOODS_INPRICE, GG.GOODS_REST
         FROM GOODS GG
         WHERE GG.NOMEN_ID=:NOMEN_ID AND
               GG.OBJECTS_ID=:P_OBJECTS_ID
         INTO :P_GOODS_ID, :P_INPRICE, :P_REST
    DO BEGIN
      P_MAX_GOODS_ID=:P_GOODS_ID;
      P_MAX_INPRICE=:P_INPRICE;
    END
   END

   IF (:P_MAX_GOODS_ID IS NULL) THEN EXCEPTION NONE_GOODS;

   UPDATE GOODS GG
    SET GG.GOODS_REST=GG.GOODS_REST-:KILK
    WHERE GG.GOODS_ID=:P_GOODS_ID;

   INSERT INTO DOCGOODS (DOCREC_ID, GOODS_ID, KILK)
    VALUES (:DOCREC_ID, :P_GOODS_ID, :KILK);

  END

  SUSPEND;

 END /*if (:P_TypeDoc_Id=2)*/

/* ????????? ??????????? -----------------------------------------------------*/

 IF (:P_TYPEDOC_ID=6) THEN BEGIN

  SELECT G.NOMEN_ID
   FROM GOODS G
   WHERE G.GOODS_ID=:NOMEN_ID
   INTO :P_NOMEN_ID;

  DOCREC_ID=GEN_ID(GEN_DOCREC_ID, 1);
  INSERT INTO DOCREC (DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE)
   VALUES(:DOCREC_ID, :DOCUMENT_ID, :P_NOMEN_ID, :KILK, AROUNDIN(:PRICE, 6));

  UPDATE GOODS GG
   SET GG.GOODS_REST=GG.GOODS_REST-:KILK
   WHERE GG.GOODS_ID=:NOMEN_ID;

  SELECT G.GOODS_ID, G.GOODS_REST
   FROM GOODS G
   WHERE G.NOMEN_ID=:P_NOMEN_ID AND
         G.OBJECTS_ID=:P_CLIENT_ID AND
         G.CLIENTS_ID=:P_OBJECTS_ID AND
         AROUNDIN(G.GOODS_INPRICE, 6)=AROUNDIN(:PRICE, 6)
   INTO :P_GOODS_ID, :P_REST;

  IF (:P_GOODS_ID IS NULL) THEN BEGIN
    P_GOODS_ID=GEN_ID(GEN_GOODS_ID, 1);
    INSERT INTO GOODS (GOODS_ID, NOMEN_ID, OBJECTS_ID, GOODS_REST, GOODS_INPRICE, CLIENTS_ID)
     VALUES (:P_GOODS_ID, :P_NOMEN_ID, :P_CLIENT_ID, :KILK, AROUNDIN(:PRICE, 6), :P_OBJECTS_ID);
   END
  ELSE BEGIN
    UPDATE GOODS GG
     SET GG.GOODS_REST=:P_REST+:KILK
     WHERE GG.GOODS_ID=:P_GOODS_ID;
   END
  INSERT INTO DOCGOODS (DOCREC_ID, GOODS_ID, KILK)
   VALUES (:DOCREC_ID, :NOMEN_ID, :KILK);
 END    

/* ??? ?????????? ??????? ???? -----------------------------------------------*/

 IF (:P_TYPEDOC_ID=12) THEN BEGIN
  DOCREC_ID=GEN_ID(GEN_DOCREC_ID, 1);
  INSERT INTO DOCREC (DOCREC_ID, DOCUMENT_ID, NOMEN_ID, KILK, PRICE)
   VALUES(:DOCREC_ID, :DOCUMENT_ID, :NOMEN_ID, 0, :PRICE);
  SUSPEND;
 END /*if (:P_TypeDoc_Id=12)*/


/* ??? ?????????????? --------------------------------------------------------*/

/* IF (:P_TYPEDOC_ID=8) THEN BEGIN

  SUSPEND;

 END*/

END^


ALTER PROCEDURE T_GRP_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RGRP_FULL_NAME VARCHAR(250),
    OMAKER_ID INTEGER)
AS
declare variable pgrp_full_name varchar(250);
begin
  /* Procedure Text */
  if ((:vgrp_id is null) or (:vgrp_id <= 0)) then
  begin
    pgrp_full_name = '';
    for select g.grp_id, g.grp_name, g.prew_grp_id from grp g
      where g.prew_grp_id is null
      plan (g index(FK_GRP_PREW_GRP))
    into :rgrp_id, :rgrp_name, :rprew_grp_id
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id, rgrp_full_name, omaker_id from t_grp_childs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rgrp_full_name, :omaker_id
      do begin
        rgrp_full_name = :pgrp_full_name || :rgrp_full_name;
        suspend;
        omaker_id = null;
      end
    end
  end
  else
  begin
    select g.grp_id, g.grp_name, g.prew_grp_id, g.maker_id from grp g
      where g.grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name, :rprew_grp_id, :omaker_id;
    pgrp_full_name = '\' || :rgrp_name;
    rgrp_full_name = :pgrp_full_name;
    suspend;
    omaker_id = null;

    for select g.grp_id, g.grp_name from grp g
      where g.prew_grp_id = :vgrp_id
      plan (g index(FK_GRP_PREW_GRP))
    into :rgrp_id, :rgrp_name
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id, rgrp_full_name, omaker_id from t_grp_childs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rgrp_full_name, :omaker_id
      do begin
        rgrp_full_name = pgrp_full_name || :rgrp_full_name;
        suspend;
        omaker_id = null;
      end
    end
  end
end^


ALTER PROCEDURE T_GRP_CHILDS_CHILDS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(200),
    RPREW_GRP_ID INTEGER)
AS
begin
  /* Procedure Text */
  if ((:vgrp_id is null) or (:vgrp_id <= 0)) then
  begin
    for select g.grp_id, g.GRP_FULLNAME, g.prew_grp_id from grp g
      where g.prew_grp_id is null
    into :rgrp_id, :rgrp_name, :rprew_grp_id
    do begin
        for select rgrp_id, rgrp_name, rprew_grp_id from t_grp_childs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id
      do begin
        suspend;
      end
    end
  end
  else
  begin
    select g.grp_id, g.GRP_FULLNAME, g.prew_grp_id from grp g
      where g.grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name, :rprew_grp_id;
    suspend;

    for select g.grp_id, g.GRP_FULLNAME from grp g
      where g.prew_grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id from t_grp_childs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id
      do begin
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE T_GRP_CHILDS_LINK (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RGRP_FULL_NAME VARCHAR(250))
AS
declare variable pgrp_full_name varchar(250);
begin
  /* Procedure Text */
  if ((:vgrp_id is null) or (:vgrp_id <= 0)) then
  begin
    pgrp_full_name = '';
    for select g.grp_id, g.grp_name, g.prew_grp_id from t_grps_sync g
      where g.prew_grp_id is null
      plan (g index(FK_T_GRPS_SYNC_PREW_GRP))
    into :rgrp_id, :rgrp_name, :rprew_grp_id
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id, rgrp_full_name from t_grp_childs_link(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rgrp_full_name
      do begin
        rgrp_full_name = :pgrp_full_name || :rgrp_full_name;
        suspend;
      end
    end
  end
  else
  begin
    select g.grp_id, g.grp_name, g.prew_grp_id from t_grps_sync g
      where g.grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name, :rprew_grp_id;
    pgrp_full_name = '\' || :rgrp_name;
    rgrp_full_name = :pgrp_full_name;
    suspend;

    for select g.grp_id, g.grp_name from t_grps_sync g
      where g.prew_grp_id = :vgrp_id
      plan (g index(FK_T_GRPS_SYNC_PREW_GRP))
    into :rgrp_id, :rgrp_name
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id, rgrp_full_name from t_grp_childs_link(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rgrp_full_name
      do begin
        rgrp_full_name = pgrp_full_name || :rgrp_full_name;
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE T_GRP_CHILDS_LIST (
    VGRP_ID VARCHAR(10000))
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RSHELF DOUBLE PRECISION)
AS
DECLARE VARIABLE PGRP_ID INTEGER;
BEGIN
 FOR SELECT G.GRP_ID
      FROM GRP G
      WHERE ISINLISTSTR (:VGRP_ID, G.GRP_ID) = 1
      INTO :PGRP_ID
 DO
 FOR SELECT TG.RGRP_ID, TG.RGRP_NAME, TG.RPREW_GRP_ID, TG.RSHELF
       FROM t_grp_childs_shelfs (:PGRP_ID) TG
       INTO :RGRP_ID, :RGRP_NAME, :RPREW_GRP_ID, :RSHELF
 DO
  SUSPEND;
END^


ALTER PROCEDURE T_GRP_CHILDS_SHELFS (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RPREW_GRP_ID INTEGER,
    RSHELF DOUBLE PRECISION)
AS
begin
  /* Procedure Text */
  if ((:vgrp_id is null) or (:vgrp_id <= 0)) then
  begin
    for select g.grp_id, g.grp_name, g.prew_grp_id, g.shelf from grp g
      where g.prew_grp_id is null
    into :rgrp_id, :rgrp_name, :rprew_grp_id, :rshelf
    do begin
        for select rgrp_id, rgrp_name, rprew_grp_id, rshelf from t_grp_childs_shelfs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rshelf
      do begin
        if (:rshelf is null) then rshelf=0.000;
        suspend;
      end
    end
  end
  else
  begin
    select g.grp_id, g.grp_name, g.prew_grp_id, g.shelf from grp g
      where g.grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name, :rprew_grp_id, :rshelf;
    if (:rshelf is null) then rshelf=0.000;
    suspend;

    for select g.grp_id, g.grp_name, g.shelf from grp g
      where g.prew_grp_id = :vgrp_id
    into :rgrp_id, :rgrp_name, rshelf
    do begin
      for select rgrp_id, rgrp_name, rprew_grp_id, rshelf from t_grp_childs_shelfs(:rgrp_id)
            into :rgrp_id, :rgrp_name, :rprew_grp_id, :rshelf
      do begin
        if (:rshelf is null) then rshelf=0.000;
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE T_GRP_CREATE_CHILD (
    VGRP_ID INTEGER,
    VNAME VARCHAR(40),
    VCODE INTEGER,
    VSHELF DOUBLE PRECISION)
RETURNS (
    RGRP_ID INTEGER)
AS
begin
  /* Procedure Text */
  if ((:vgrp_id is null) or (:vgrp_id <= 0)) then
  begin
    rgrp_id = gen_id(GEN_GRP_ID,1);
    insert into grp(grp_id, grp_name, prew_grp_id, grp_code, shelf)
      values (:rgrp_id, :vname, null, :vcode, :vshelf);
  end
  else
  begin
    rgrp_id = gen_id(GEN_GRP_ID,1);
    insert into grp(grp_id, grp_name, prew_grp_id, grp_code, shelf)
      values (:rgrp_id, :vname, :vgrp_id, :vcode, :vshelf);
  end
  suspend;
end^


ALTER PROCEDURE T_GRP_CREATE_CHILD_V1 (
    IPREW_GRP_ID INTEGER,
    INAME VARCHAR(40),
    ICODE INTEGER,
    IMAKER_ID INTEGER)
RETURNS (
    OGRP_ID INTEGER)
AS
begin
  /* Procedure Text */
  if ((:iprew_grp_id is null) or (:iprew_grp_id <= 0)) then
  begin
    ogrp_id = gen_id(GEN_GRP_ID, 1);
    insert into grp(grp_id, grp_name, prew_grp_id, grp_code, maker_id)
      values (:ogrp_id, :iname, null, :icode, :imaker_id);
  end
  else
  begin
    update grp g
        set g.maker_id = null
      where g.prew_grp_id = :iprew_grp_id;

    ogrp_id = gen_id(GEN_GRP_ID, 1);
    insert into grp(grp_id, grp_name, prew_grp_id, grp_code, maker_id)
      values (:ogrp_id, :iname, :iprew_grp_id, :icode, :imaker_id);
  end

  suspend;
end^


ALTER PROCEDURE T_GRP_DELETE (
    VGRP_ID INTEGER)
RETURNS (
    RSUCS INTEGER)
AS
DECLARE VARIABLE ID_N INTEGER;
DECLARE VARIABLE ID_G INTEGER;
begin
  /* Procedure Text */
  rsucs = 1;
  select max(n.nomen_id) from nomen n
      where n.grp_id = :vgrp_id
    into :id_n;
  select max(g.grp_id) from grp g
      where g.prew_grp_id = :vgrp_id
   into :id_g;

  if ((id_n is null) and (id_g is null)) then
  begin
    delete from grp g
      where g.grp_id = :vgrp_id;
  end
  else
    rsucs = 0;
  suspend;
end^


ALTER PROCEDURE T_GRP_FULLNAME (
    VGRP_ID INTEGER)
RETURNS (
    RGRP_FULLNAME VARCHAR(200))
AS
DECLARE VARIABLE P_PREWGRP_ID INTEGER;
DECLARE VARIABLE P_GRP_NAME VARCHAR(40);
DECLARE VARIABLE P_GRP_ID INTEGER;
BEGIN
 RGRP_FULLNAME='';
 WHILE (NOT (:VGRP_ID IS NULL)) DO BEGIN
  SELECT G.PREW_GRP_ID, G.GRP_NAME
   FROM GRP G
   WHERE G.GRP_ID=:VGRP_ID
   INTO :P_PREWGRP_ID, :P_GRP_NAME;
  RGRP_FULLNAME=:P_GRP_NAME||' \ '||:RGRP_FULLNAME;
  VGRP_ID=:P_PREWGRP_ID;
 END
 SUSPEND;
END^


ALTER PROCEDURE T_GRP_IS_LAST_LEVEL (
    IGRP_ID INTEGER)
RETURNS (
    OIS_LAST_LEVEL SMALLINT)
AS
DECLARE VARIABLE TCNT INTEGER;
begin
  select count(g.grp_id) from grp g
      where g.prew_grp_id = :igrp_id
    into :tcnt;

  if (:tcnt = 0) then
    ois_last_level = 1;
  else
    ois_last_level = 0;

  suspend;
end^


ALTER PROCEDURE T_GRP_MANAGER (
    VMANAGER_ID INTEGER)
RETURNS (
    RGRP_ID INTEGER,
    RGRP_NAME VARCHAR(40),
    RSHELF DOUBLE PRECISION)
AS
DECLARE VARIABLE PGRP_ID INTEGER;
begin
  for select g.grp_id from grp g
    where g.prew_grp_id is null and
          g.manager_id = :vmanager_id
  into :pgrp_id
  do begin
    for select rgrp_id, rgrp_name, rshelf from t_grp_childs_shelfs(:pgrp_id)
            into :rgrp_id, :rgrp_name, :rshelf
     do begin
        suspend;
    end
  end
end^


ALTER PROCEDURE T_GRP_RECALC
AS
begin

  suspend;
end^


ALTER PROCEDURE T_GRPC_CHILDS (
    VGRPC_ID INTEGER)
RETURNS (
    RGRPC_ID INTEGER,
    RGRPC_NAME VARCHAR(40),
    RPREW_GRPC_ID INTEGER)
AS
begin
  /* Procedure Text */
  if ((:vgrpc_id is null) or (:vgrpc_id <= 0)) then
  begin
    for select g.grpc_id, g.grpc_name, g.prew_grpc_id from grpc g
      where g.prew_grpc_id is null
    into :rgrpc_id, :rgrpc_name, :rprew_grpc_id
    do begin
        for select rgrpc_id, rgrpc_name, rprew_grpc_id from t_grpc_childs(:rgrpc_id)
            into :rgrpc_id, :rgrpc_name, :rprew_grpc_id
      do begin
        suspend;
      end
    end
  end
  else
  begin
    select g.grpc_id, g.grpc_name, g.prew_grpc_id from grpc g
      where g.grpc_id = :vgrpc_id
    into :rgrpc_id, :rgrpc_name, :rprew_grpc_id;
    suspend;

    for select g.grpc_id, g.grpc_name from grpc g
      where g.prew_grpc_id = :vgrpc_id
    into :rgrpc_id, :rgrpc_name
    do begin
      for select rgrpc_id, rgrpc_name, rprew_grpc_id from t_grpc_childs(:rgrpc_id)
            into :rgrpc_id, :rgrpc_name, :rprew_grpc_id
      do begin
        suspend;
      end
    end
  end
end^


ALTER PROCEDURE T_GRPC_CREATE_CHILD (
    VGRPC_ID INTEGER,
    VNAME VARCHAR(40))
RETURNS (
    RGRPC_ID INTEGER)
AS
begin
  /* Procedure Text */
  if ((:vgrpc_id is null) or (:vgrpc_id <= 0)) then
  begin
    rgrpc_id = gen_id(GEN_GRPC_ID,1);
    insert into grpc(grpc_id, grpc_name, prew_grpc_id)
      values (:rgrpc_id, :vname, null);
  end
  else
  begin
    rgrpc_id = gen_id(GEN_GRPC_ID,1);
    insert into grpc(grpc_id, grpc_name, prew_grpc_id)
      values (:rgrpc_id, :vname, :vgrpc_id);
  end
  suspend;
end^


ALTER PROCEDURE T_GRPC_DELETE (
    VGRPC_ID INTEGER)
RETURNS (
    RSUCS INTEGER)
AS
DECLARE VARIABLE ID_C INTEGER;
DECLARE VARIABLE ID_G INTEGER;
begin
  /* Procedure Text */
  rsucs = 1;
  select max(c.clients_id) from clients c
      where c.grpc_id = :vgrpc_id
    into :id_c;
  select max(g.grpc_id) from grpc g
      where g.prew_grpc_id = :vgrpc_id
   into :id_g;

  if ((id_c is null) and (id_g is null)) then
  begin
    delete from grpc g
      where g.grpc_id = :vgrpc_id;
  end
  else
    rsucs = 0;
  suspend;
end^


ALTER PROCEDURE T_GRPC_FULLNAME (
    VGRPC_ID INTEGER)
RETURNS (
    RGRPC_FULLNAME VARCHAR(200))
AS
DECLARE VARIABLE P_PREWGRPC_ID INTEGER;
DECLARE VARIABLE P_GRPC_NAME VARCHAR(40);
BEGIN
 RGRPC_FULLNAME='';
 WHILE (NOT (:VGRPC_ID IS NULL)) DO BEGIN
  SELECT G.PREW_GRPC_ID, G.GRPC_NAME
   FROM GRPC G
   WHERE G.GRPC_ID=:VGRPC_ID
   INTO :P_PREWGRPC_ID, :P_GRPC_NAME;
  RGRPC_FULLNAME=:P_GRPC_NAME||' \ '||:RGRPC_FULLNAME;
  VGRPC_ID=:P_PREWGRPC_ID;
 END
 SUSPEND;
END^


ALTER PROCEDURE T_IMPORT_GOODS_VOL (
    DOCUMENT_ID INTEGER,
    NOMEN_CODE INTEGER,
    KILK DOUBLE PRECISION,
    PRICE DOUBLE PRECISION)
AS
declare variable p_nomen_id integer;
declare variable docrec_id integer;
declare variable p_typedoc_id integer;
declare variable ptype_pdv_id integer;
declare variable ppdv double precision;
begin
 select n.nomen_id, n.typepdv_id, tp.pdv
   from nomen n, typepdv tp
   where n.nomen_code=:nomen_code
         and n.typepdv_id = tp.typepdv_id
   into :p_nomen_id, :ptype_pdv_id, :ppdv;

  if (:p_nomen_id is not null) then begin
   /*select dc.docrec_id
    from s_docrec_create(:document_id, :p_nomen_id, :kilk, :price, :ptype_pdv_id, :ppdv) dc
    into :docrec_id;*/

    select kid.rdocrec_id from kas_ins_docrec(:document_id, :p_nomen_id, :kilk, :price, 11) kid
      into :docrec_id;
  end

  suspend;
end^


ALTER PROCEDURE TMP_FIX_DR6 (
    IDOCREC_ID INTEGER)
AS
DECLARE VARIABLE PDR_KILK DOUBLE PRECISION;
DECLARE VARIABLE PDG_KILK DOUBLE PRECISION;
DECLARE VARIABLE PDOCGOODS_ID INTEGER;
DECLARE VARIABLE PGOODS_ID INTEGER;
DECLARE VARIABLE PSUMDG_KILK DOUBLE PRECISION;
DECLARE VARIABLE PDG_PRICE DOUBLE PRECISION;
DECLARE VARIABLE PDG_SUM DOUBLE PRECISION;
begin
  select dr.kilk, sum(dg.kilk)
    from docrec dr
         left join docgoods dg on dr.docrec_id = dg.docrec_id
   where dr.docrec_id = :idocrec_id
   group by dr.kilk
    into pdr_kilk, pdg_kilk;
  if (:pdg_kilk is null) then pdg_kilk = 0;

  if (:pdr_kilk > :pdg_kilk + 0.000001) then
  begin
    select max(docgoods_id) from docgoods dg
     where dg.docrec_id = :idocrec_id
      into pdocgoods_id;

    select sum(dg.kilk) from docgoods dg
     where dg.docrec_id = :idocrec_id and
           dg.docgoods_id != :pdocgoods_id
      into psumdg_kilk;
    if (:psumdg_kilk is null) then psumdg_kilk = 0;

    select dg.goods_id, dg.kilk, dg.inprice, dg.insum from docgoods dg
     where dg.docgoods_id = :pdocgoods_id
      into pgoods_id, pdg_kilk, pdg_price, pdg_sum;
    if (:pdg_kilk is null) then
    begin
      pdg_kilk = :pdg_sum / pdg_price;
      update docgoods dg
         set dg.kilk = :pdg_kilk
       where dg.docgoods_id = :pdocgoods_id;
    end
    if (:pdg_kilk is null) then pdg_kilk = 0;

    update goods g
       set g.goods_rest = g.goods_rest - (:pdr_kilk - :psumdg_kilk - :pdg_kilk)
     where g.goods_id = :pgoods_id;
    update docgoods dg
       set dg.kilk = (:pdr_kilk - :psumdg_kilk)
     where dg.docgoods_id = :pdocgoods_id;
  end
end^


ALTER PROCEDURE TOOLS_DEL_BAD_CLIENTS
RETURNS (
    OCLIENT_ID INTEGER,
    OCLIENT_NAME VARCHAR(50))
AS
begin
  for select cl.clients_id, cl.name
        from clients cl
       where cl.clients_id > 100
        into oclient_id, oclient_name
  do begin
    if (not(exists(select * from documents d
                    where ((d.clients_id = :oclient_id) or
                          (d.objects_id  = :oclient_id))))                  and
       not(exists(select * from goods g where g.clients_id = :oclient_id))  and
       not(exists(select * from kards k where k.clients_id = :oclient_id))) then
    begin
      delete from clientaccount ca
       where ca.clients_id = :oclient_id;
      delete from clients c
       where c.clients_id = :oclient_id;
      suspend;
    end
  end
end^


ALTER PROCEDURE TOOLS_INIT_PJ
AS
DECLARE VARIABLE NOMEN_ID INTEGER;
DECLARE VARIABLE OUT_PRICE DOUBLE PRECISION;
DECLARE VARIABLE COUNT_PJ INTEGER;
begin
 for select n.nomen_id, n.out_price, count(pj.pricejournal_id)
      from nomen n left join pricejournal pj on n.nomen_id=pj.nomen_id
      group by n.nomen_id, n.out_price
      into :nomen_id, :out_price, :count_pj
 do begin
  if (:count_pj=0) then begin
   insert into pricejournal(nomen_id, out_price, date_time)
    values(:nomen_id, :out_price, '14.03.2003 15:36:58');
  end
 end
end^


ALTER PROCEDURE TOOLS_MOVE_REST (
    GOODS_ID1 INTEGER,
    GOODS_ID2 INTEGER)
RETURNS (
    RESULT VARCHAR(120))
AS
DECLARE VARIABLE P_REST1 DOUBLE PRECISION;
DECLARE VARIABLE P_REST2 DOUBLE PRECISION;
DECLARE VARIABLE P_RELASE1 DOUBLE PRECISION;
DECLARE VARIABLE P_RELASE2 DOUBLE PRECISION;
DECLARE VARIABLE P_DOCGOODS_ID INTEGER;
DECLARE VARIABLE P_KILK DOUBLE PRECISION;
BEGIN
 SELECT G.GOODS_REST
  FROM GOODS G
  WHERE G.GOODS_ID=:GOODS_ID1
  INTO :P_REST1;
 IF (:P_REST1 IS NULL) THEN P_REST1=0.000;
 SELECT SUM(DG.KILK)
  FROM DOCGOODS DG,
       DOCREC DR,
       DOCUMENTS D
  WHERE DG.GOODS_ID=:GOODS_ID1 AND
        DR.DOCREC_ID=DG.DOCREC_ID AND
        D.DOCUMENT_ID=DR.DOCUMENT_ID AND
        D.OBJECTS_ID=1
  INTO :P_RELASE1;
 IF (:P_RELASE1 IS NULL) THEN P_RELASE1=0.000;
 SELECT G.GOODS_REST
  FROM GOODS G
  WHERE G.GOODS_ID=:GOODS_ID2
  INTO :P_REST2;
 IF (:P_REST2 IS NULL) THEN P_REST2=0.000;
 SELECT SUM(DG.KILK)
  FROM DOCGOODS DG,
       DOCREC DR,
       DOCUMENTS D
  WHERE DG.GOODS_ID=:GOODS_ID2 AND
        DR.DOCREC_ID=DG.DOCREC_ID AND
        D.DOCUMENT_ID=DR.DOCUMENT_ID AND
        D.OBJECTS_ID=1
  INTO :P_RELASE2;
 IF (:P_RELASE2 IS NULL) THEN P_RELASE2=0.000;
 IF (:P_RELASE1>=:P_REST2) THEN BEGIN
  FOR SELECT DG.DOCGOODS_ID, DG.KILK
       FROM DOCGOODS DG,
            DOCREC DR,
            DOCUMENTS D
       WHERE DG.GOODS_ID=:GOODS_ID1 AND
             DR.DOCREC_ID=DG.DOCREC_ID AND
             D.DOCUMENT_ID=DR.DOCUMENT_ID AND
             D.OBJECTS_ID=1
       INTO :P_DOCGOODS_ID, :P_KILK
  DO BEGIN
   IF ((:P_REST2>0) AND (:P_REST2 > :P_KILK)) THEN BEGIN
    UPDATE DOCGOODS DG
     SET DG.GOODS_ID=:GOODS_ID2
     WHERE DG.DOCGOODS_ID=:P_DOCGOODS_ID;
    UPDATE GOODS G
     SET G.GOODS_REST=G.GOODS_REST+:P_KILK
     WHERE G.GOODS_ID=:GOODS_ID1;
    UPDATE GOODS G
     SET G.GOODS_REST=G.GOODS_REST-:P_KILK
     WHERE G.GOODS_ID=:GOODS_ID2;
    P_REST2=:P_REST2-:P_KILK;
   END
  END
  RESULT='Залишок перенесено!';
 END
 ELSE BEGIN
   RESULT='Неможливо перенести заишок!';
 END
 SUSPEND;
END^


ALTER PROCEDURE TOOLS_NULL_DG
RETURNS (
    DOCREC_ID INTEGER,
    DOCGOODS_ID INTEGER)
AS
BEGIN
 FOR SELECT DR.DOCREC_ID, DG.DOCGOODS_ID
      FROM DOCREC DR RIGHT JOIN DOCGOODS DG ON DR.DOCREC_ID=DG.DOCREC_ID
      INTO :DOCREC_ID, :DOCGOODS_ID
 DO BEGIN
  IF (:DOCREC_ID IS NULL) THEN SUSPEND;
 END
END^


ALTER PROCEDURE TOOLS_NULL_DR (
    MIN_DR_ID INTEGER,
    MAX_DR_ID INTEGER)
RETURNS (
    DG_ID INTEGER,
    DR_ID INTEGER)
AS
DECLARE VARIABLE P_COUNT_DR INTEGER;
BEGIN
 FOR SELECT DG.DOCGOODS_ID, DG.DOCREC_ID
      FROM DOCGOODS DG
      WHERE DG.DOCREC_ID BETWEEN :MIN_DR_ID AND :MAX_DR_ID
      INTO :DG_ID, :DR_ID
 DO BEGIN
  P_COUNT_DR=0;
  SELECT COUNT(DR.DOCREC_ID)
   FROM DOCREC DR
   WHERE DR.DOCREC_ID=:DR_ID
   INTO :P_COUNT_DR;
  IF (:P_COUNT_DR IS NULL) THEN P_COUNT_DR=0;
  IF (:P_COUNT_DR=0) THEN SUSPEND;
  DR_ID=NULL;
 END
END^


ALTER PROCEDURE TOOLS_NULL_RST
RETURNS (
    RST_ID INTEGER,
    NOMEN_ID INTEGER)
AS
declare variable p_count_nid integer;
begin
 for select r.rst_id, r.nomen_id
      from rst r
      into rst_id, nomen_id
 do begin
  p_count_nid=0;
  select count(n.nomen_id)
   from nomen n
   where n.nomen_id=:nomen_id
   into :p_count_nid;
  if (:p_count_nid is null) then p_count_nid=0;
  if (:p_count_nid=0) then begin
   /*
   delete from rst r1
    where r1.rst_id=:rst_id;
   */
   suspend;
  end
  rst_id=null;
  nomen_id=null;
 end
end^


ALTER PROCEDURE TOOLS_RECALC_REST (
    NOMEN_CODE VARCHAR(7))
AS
DECLARE VARIABLE P_NOMEN_ID INTEGER;
DECLARE VARIABLE P_GOODS_ID INTEGER;
DECLARE VARIABLE P_REST_G DOUBLE PRECISION;
DECLARE VARIABLE P_REST_DG DOUBLE PRECISION;
DECLARE VARIABLE P_OBJECTS_ID INTEGER;
DECLARE VARIABLE P_CLIENTS_ID INTEGER;
DECLARE VARIABLE P_KILK DOUBLE PRECISION;
BEGIN
 P_NOMEN_ID=NULL;
 SELECT N.NOMEN_ID
  FROM NOMEN N
  WHERE N.NOMEN_CODE=:NOMEN_CODE
  INTO :P_NOMEN_ID;
 IF ( NOT (:P_NOMEN_ID IS NULL)) THEN BEGIN
  FOR SELECT G.GOODS_ID, G.GOODS_REST
       FROM GOODS G
       WHERE G.NOMEN_ID=:P_NOMEN_ID
       INTO :P_GOODS_ID, :P_REST_G
  DO BEGIN
   IF (:P_REST_G IS NULL) THEN P_REST_G = 0.000;
   P_REST_DG = 0.000;
   FOR SELECT D.OBJECTS_ID, D.CLIENTS_ID, DG.KILK
        FROM DOCGOODS DG,
             DOCREC DR,
             DOCUMENTS D
        WHERE DG.GOODS_ID=:P_GOODS_ID AND
              DR.DOCREC_ID=DG.DOCREC_ID AND
              D.DOCUMENT_ID=DR.DOCUMENT_ID
        INTO :P_OBJECTS_ID, :P_CLIENTS_ID, :P_KILK
   DO BEGIN
    IF (:P_KILK IS NULL) THEN P_KILK = 0.000;
    IF (:P_OBJECTS_ID = 1) THEN P_REST_DG = :P_REST_DG - :P_KILK;
    IF (:P_CLIENTS_ID = 1) THEN P_REST_DG = :P_REST_DG + :P_KILK;
   END
   IF (:P_REST_G <> :P_REST_DG) THEN BEGIN
    UPDATE GOODS GG
     SET GG.GOODS_REST=:P_REST_DG
     WHERE GG.GOODS_ID=:P_GOODS_ID;
   END
  END
 END
END^


ALTER PROCEDURE TOOLS_RECALC_RST (
    INOMEN_ID INTEGER)
AS
declare variable pnomen_id integer;
declare variable psum_rest double precision;
declare variable plast_inprice integer;
declare variable psum_rest_sum double precision;
BEGIN
for select g.nomen_id, sum(g.goods_rest), sum(g.goods_inprice * g.goods_rest)
      from goods g
     where g.nomen_id = :inomen_id
  group by g.nomen_id
      into pnomen_id, psum_rest, psum_rest_sum
do begin
                        /*
    if :psum_rest is null then
      psum_rest = 0;  */
  update rst
     set rest     = :psum_rest,
         rest_sum = :psum_rest_sum
   where nomen_id = :pnomen_id;
 end
END^


ALTER PROCEDURE TOOLS_SET_CURENT_CLIENTS_TYPE
AS
declare variable pclient_id integer;
declare variable ptype_client_id integer;
declare variable pzkpo varchar(20);
declare variable pnumber bigint;
begin
  for select cl.clients_id, cl.typeclient_id, cl.zkpo
        from clients cl
        into pclient_id, ptype_client_id, pzkpo
  do begin
    if (:ptype_client_id = 4) then
    begin
      if (:pzkpo is null) then
      begin
        update clients c
           set c.typeclient_id = 3   /*Покупець*/
         where c.clients_id = :pclient_id;
      end
      else /*if (:pzkpo is null) then*/
      begin
        begin
          pnumber = cast(:pzkpo as bigint);
          when any do /*pzkpo не число*/
          begin
            update clients c
               set c.typeclient_id = 3   /*Покупець*/
             where c.clients_id = :pclient_id;
          end
        end

        if (:pnumber > 10) then
        begin
          update clients c
             set c.typeclient_id = 2   /*Постачальник*/
           where c.clients_id = :pclient_id;
        end
        else
        begin
          update clients c
             set c.typeclient_id = 3   /*Покупець*/
           where c.clients_id = :pclient_id;
        end

      end
    end
  end

  delete from typeclient
   where typeclient_id = 4;

end^


ALTER PROCEDURE TOOLS_SET_TS
AS
declare variable pdocument_id integer;
declare variable pdocrec_id integer;
declare variable pdocdate date;
declare variable pmark integer;
declare variable pts timestamp;
begin
  pmark = 0;
  if (exists(select * from documents d where d.ts is not null)) then
    pmark = 1;
  for select d.document_id, dr.docrec_id, d.doc_date
        from documents d
             left join docrec dr on d.document_id = dr.document_id
       where d.doc_date > '30.05.2009'
        into pdocument_id, pdocrec_id, pdocdate
  do begin
    pts = cast(:pdocdate as timestamp);
    if (:pmark = 1) then
    begin
      pts = cast('now' as timestamp);
    end
    update documents d
       set d.ts = :pts
     where d.document_id = :pdocument_id and
           d.ts is null;
    update docgoods d
       set d.ts = :pts
     where d.docrec_id = :pdocrec_id and
           d.ts is null;
    update docrec d
       set d.ts = :pts
     where d.docrec_id = :pdocrec_id and
           d.ts is null;
  end

  for select g.goods_id, g.doc_date
        from goods g
       where g.doc_date > '30.05.2009'
        into pdocument_id, pdocdate
  do begin

    pts = cast(:pdocdate as timestamp);
    if (:pmark = 1) then
    begin
      pts = cast('now' as timestamp);
    end

    update goods g
       set g.ts = :pts
     where g.goods_id = :pdocrec_id and
           g.ts is null;
  end

  for select dg.goods_id
        from docgoods dg
       where dg.ts is not null
        into pdocument_id
  do begin
    update goods g
       set g.ts = cast('now' as timestamp)
     where g.goods_id = :pdocrec_id and
           ((g.ts is null) or
           (g.ts < '01.06.2009')) ;
  end

  update goods g
     set g.ts = 'now'
   where (g.goods_rest > 0.00001 or
         g.goods_rest < -0.00001)and
         g.ts is null;
end^


ALTER PROCEDURE TOOLS_SET_W3_CLIENTS_ID_BY_ZKPO
AS
declare variable pclient_id integer;
declare variable pw3_client_id integer;
declare variable pzkpo varchar(20);
begin
 if (exists(select * from t_clients_sync cs)) then
 begin
   if (exists(select conf.marker from t_configs conf
               where conf.config_id = 2 and
                     conf.module    = 'store_clients')) then
   begin
     update t_configs conf
        set conf.marker = 'yes'
      where conf.config_id = 2 and
            conf.module    = 'store_clients' and
            conf.marker   != 'yes';
   end else
   begin
     insert into t_configs (config_id, module, marker, descipt)
         values (2, 'store_clients', 'yes', 'повна синхронізація клієнтів (yes-табличка clients наповнюється даними)');
   end

 for select c.clients_id, c.zkpo
       from clients c
      where c.w3_client_id is null and
            c.typeclient_id = 2 and
            c.zkpo != '' and
            c.zkpo is not null
       into pclient_id, pzkpo
 do begin
   select first(1) cs.w3_client_id
     from t_clients_sync cs
    where cs.zkpo  = :pzkpo and
          cs.zkpo != '' and
          cs.zkpo is not null and
          cs.zkpo != 0
     into pw3_client_id;

   if (:pw3_client_id is not null) then
   begin
     update clients c
        set c.w3_client_id = :pw3_client_id
      where clients_id = :pclient_id;
   end
   pw3_client_id = null;
   pclient_id = null;
   pzkpo = null;
 end
 end
 update clients c
    set c.is_visible = 0
  where c.w3_client_id is null and
        c.typeclient_id =2;
end^


ALTER PROCEDURE TOOLS_SLIV_MINUSOV (
    INOMEN_ID INTEGER)
AS
declare variable pmgoods_id integer;
declare variable ppgoods_id integer;
declare variable pdocgoods_id integer;
declare variable pmrest double precision;
declare variable pprest double precision;
declare variable pkilk double precision;
declare variable tmarker varchar(64);
declare variable pdelta double precision;
declare variable pdocrec_id integer;
declare variable vobject_id integer;
begin
  vobject_id = 1;
/*Використовується в програмі*/
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module = 'store_general'
    into tmarker;

  if (:tmarker = 'yes') then
  begin
    for select g.goods_id, g.goods_rest from goods g
         where g.nomen_id   = :inomen_id  and
               g.objects_id = :vobject_id and
               g.goods_rest < 0
          into pmgoods_id, pmrest
    do begin
      for select g.goods_id, g.goods_rest from goods g
           where g.nomen_id   = :inomen_id  and
                 g.objects_id = :vobject_id and
                 g.goods_rest > 0
        order by goods_id
            into ppgoods_id, pprest
      do begin
        for select dg.docgoods_id, dg.kilk, dg.docrec_id
              from docgoods dg
                   left join docrec dr on (dg.docrec_id = dr.docrec_id)
                   left join documents d on (dr.document_id = d.document_id)
             where dg.goods_id    = :pmgoods_id   and
                   d.typedoc_id not in(10, 12, 17) and
                   d.objects_id   = :vobject_id
              into pdocgoods_id, pkilk, pdocrec_id
        do begin
          if ((:pprest > 0.0)and(:pmrest < 0.0)) then
          begin
            pdelta = :pkilk - :pprest;
            if (pdelta <= 0.0) then
            begin
              update goods g
                 set g.goods_rest = g.goods_rest - :pkilk
               where g.goods_id = :ppgoods_id;

              update goods g
                 set g.goods_rest = g.goods_rest + :pkilk
               where g.goods_id = :pmgoods_id;

              pprest = pprest - :pkilk;
              pmrest = pmrest + :pkilk;

              update docgoods dg
                 set dg.goods_id = :ppgoods_id
               where dg.docgoods_id = :pdocgoods_id;
            end else
            if (pdelta > 0.0) then
            begin
              update goods g
                 set g.goods_rest = g.goods_rest - :pprest
               where g.goods_id = :ppgoods_id;

              update goods g
                 set g.goods_rest = g.goods_rest + :pprest
               where g.goods_id = :pmgoods_id;

              pprest = pprest - :pprest;
              pmrest = pmrest + :pprest;

              update docgoods dg
                 set dg.kilk = :pdelta
               where dg.docgoods_id = :pdocgoods_id;

              insert into docgoods (goods_id, docrec_id, kilk)
                values(:ppgoods_id, :pdocrec_id, :pprest);
            end
          end
        end
      end
    end
  end
end^


ALTER PROCEDURE TOOLS_UNITE_CLIENTS_BY_ZKPO
RETURNS (
    OCLIENT_ID0 INTEGER,
    OCLIENT_ID1 INTEGER,
    OCLIENT_NAME0 VARCHAR(50),
    OCLIENT_NAME1 VARCHAR(50),
    OZKPO0 VARCHAR(20),
    OZKPO1 VARCHAR(20))
AS
declare variable pnumber0 bigint;
declare variable pnumber1 bigint;
declare variable penabled integer;
begin
  for select c.clients_id, c.name, c.zkpo from clients c
       where c.clients_id > 100
    order by c.clients_id
        into oclient_id0, oclient_name0, ozkpo0
  do begin
    if (:ozkpo0 is not null) then
    begin
    begin
      pnumber0 = cast(:ozkpo0 as bigint);
      when any do /*pozkpo0 не число*/
      begin
        pnumber0 = -1;
      end
    end
    if (:pnumber0 > 99999) then
    begin
    for select c.clients_id, c.name, c.zkpo from clients c
         where c.clients_id > :oclient_id0
          into oclient_id1, oclient_name1, ozkpo1
    do begin
      if (:ozkpo1 is not null) then
      begin
      begin
        pnumber1 = cast(:ozkpo1 as bigint);
        when any do /*pozkpo1 не число*/
        begin
          pnumber1 = -1;
        end
      end
      if (:pnumber0 = :pnumber1) then
      begin
        select ps.oenabled from ps_client_unite(:oclient_id0, :oclient_id1) ps
          into penabled;
        if (:penabled > 0) then
          suspend;
        when any do begin
        --  suspend;
        end
      end
      end
    end
    end
    end
  end
end^


ALTER PROCEDURE W_DISCONT_UPD (
    VDISCONT_ID INTEGER,
    VPERSENT DOUBLE PRECISION)
AS
declare variable ppersent double precision;
begin
  select d.procent from discont d
    where d.discont_id = :vdiscont_id and
          d.discont_id <> 0
   into :ppersent;

  if (:ppersent is null) then
  begin
    insert into discont (discont_id, procent, tipdiscont)
      values(:vdiscont_id, :vpersent, '');
    when any do
    begin
     update discont d
        set d.procent    = :vpersent
      where d.discont_id = :vdiscont_id;
    end
  end
  else
    if (:vpersent <> :ppersent) then
      update discont d
         set d.procent    = :vpersent
       where d.discont_id = :vdiscont_id;
end^


ALTER PROCEDURE W_GROUP_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RGRPCODE INTEGER,
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION,
    RINSUMMA DOUBLE PRECISION)
AS
BEGIN
  for select d.doc_date, g.grp_code, sum(dr.insum_pdv), sum(gs.osum_pdv)
        from grp g
             left join nomen n on (g.grp_id = n.grp_id)
             join docrec dr on (dr.nomen_id = n.nomen_id)
             left join documents d on (d.document_id = dr.document_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :vdate1 and :vdate2 and
             not(d.typedoc_id in (10)) and
             g.grp_code > 0 and
             d.typedoc_id = 11
    group by d.doc_date, g.grp_code
        into rdate_id, rgrpcode, rinsumma, rsumma
  do begin
    suspend;
  end
END^


ALTER PROCEDURE W_GROUP_ZVIT_V1 (
    IDATE1 DATE,
    IDATE2 DATE)
RETURNS (
    OGRPCODE INTEGER,
    ODATE_ID DATE,
    OO_INSUMMA DOUBLE PRECISION,
    OO_SUMMA DOUBLE PRECISION,
    OI_SUMMA DOUBLE PRECISION)
AS
BEGIN
  oi_summa = 0.00;
 for select d.doc_date, g.grp_code, sum(dr.insum_pdv), sum(gs.osum_pdv)
       from grp g
            left join nomen n on (g.grp_id = n.grp_id)
            join docrec dr on (dr.nomen_id = n.nomen_id)
            left join documents d on (d.document_id = dr.document_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
     where  d.doc_date between :idate1 and :idate2 and
            g.grp_code > 0 and
            d.typedoc_id = 11
   group by d.doc_date, g.grp_code
       into odate_id, ogrpcode, oo_insumma, oo_summa
  do begin
    suspend;
  end

  oo_insumma = 0.00;
  oo_summa = 0.00;
 for select d.doc_date, g.grp_code, sum(gs.osum_pdv)
       from grp g
            left join nomen n on (g.grp_id = n.grp_id)
            join docrec dr on (dr.nomen_id = n.nomen_id)
            left join documents d on (d.document_id = dr.document_id),
            ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
     where  d.doc_date between :idate1 and :idate2 and
            g.grp_code > 0 and
            d.typedoc_id = 1
   group by d.doc_date, g.grp_code
       into odate_id, ogrpcode, oi_summa
  do begin
    suspend;
  end
END^


ALTER PROCEDURE W_IMPORT_MAKER (
    IMAKER_ID INTEGER,
    INAME VARCHAR(40))
AS
DECLARE VARIABLE TMAKER_ID INTEGER;
begin
  select m.maker_id from maker m
     where m.maker_id = :imaker_id
   into :tmaker_id;

  if (:tmaker_id is null) then
    insert into maker (maker_id, maker_name)
      values(:imaker_id, :iname);
  else
    update maker m
        set m.maker_name = :iname
       where m.maker_id = :imaker_id;
end^


ALTER PROCEDURE W_KARDS_EXP
RETURNS (
    RKARDCODE VARCHAR(13),
    RDISCONT_ID INTEGER,
    RBLOCK SMALLINT,
    RNAME VARCHAR(50),
    RSURNAME VARCHAR(30),
    RADRESS VARCHAR(50),
    RPHONE VARCHAR(24))
AS
DECLARE VARIABLE PCLIENTS_ID INTEGER;
DECLARE VARIABLE PKARDS_ID INTEGER;
begin
 for select k.kardcode, k.discont_id, c.name, c.shortname, c.adress, c.phone
      from kards k, clients c
   where k.clients_id = c.clients_id and
         k.clients_id <> 99
    into :rkardcode, :rdiscont_id, :rname, :rsurname, :radress, :rphone
 do begin
   suspend;
 end
end^


ALTER PROCEDURE W_KARDS_UPD (
    VKARDCODE VARCHAR(13),
    VDISCONT_ID INTEGER,
    VBLOCK SMALLINT,
    VNAME VARCHAR(50))
AS
DECLARE VARIABLE PCLIENTS_ID INTEGER;
DECLARE VARIABLE PKARDS_ID INTEGER;
begin
  for select k.clients_id, k.kards_id from kards k
    where k.kardcode = :vkardcode
   into :pclients_id, :pkards_id
  do begin
    pclients_id = :pclients_id;
  end

  if (:pclients_id is null) then
  begin
    insert into kards (clients_id, name, discont_id, kardcode, pin, is_block)
      values (99, :vname, :vdiscont_id, :vkardcode, 1, :vblock);
  end
  else
  begin
     if (:pclients_id <> 99) then
     begin
       execute procedure s_client_unit(99, :pclients_id);
     end

     update kards k
       set k.discont_id = :vdiscont_id,
           k.name = :vname,
           k.is_block = :vblock
      where k.kards_id = :pkards_id;
  end
end^


ALTER PROCEDURE W_KARDS_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RKARDCODE VARCHAR(16),
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION)
AS
begin
  for select k.kardcode, d.doc_date, sum(gs.osum_pdv)
        from kards k
             join documents d on (d.kards_id = k.kards_id)
             left join docrec dr on (d.document_id = dr.document_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :vdate1 and :vdate2 and
             d.typedoc_id = 11
    group by k.kardcode, d.doc_date
        into rkardcode, rdate_id, rsumma
  do begin
    suspend;
  end
end^


ALTER PROCEDURE W_KARDS_ZVIT_V1
RETURNS (
    RKARDCODE VARCHAR(16),
    RDATE_ID DATE,
    RSUMMA DOUBLE PRECISION)
AS
declare variable pdate1 date;
declare variable pdate2 date;
begin
  select max(date_zvit)
    from t_kards_zvit_log
    into pdate1;

  if (:pdate1 is null) then
    pdate1 = cast('today' as date) - 14;

  pdate2 = cast('today' as date);

  for select k.kardcode, d.doc_date, sum(gs.osum_pdv)
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             left join kards k on (d.kards_id = k.kards_id),
             ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
       where d.doc_date between :pdate1 and :pdate2 and
             d.typedoc_id = 11
    group by k.kardcode, d.doc_date
        into rkardcode, rdate_id, rsumma
  do begin
    suspend;
  end

end^


ALTER PROCEDURE W_RALASE_ZVIT (
    VDATE1 DATE,
    VDATE2 DATE)
RETURNS (
    RCODE INTEGER,
    RDATE_ID DATE,
    RO_KILK DOUBLE PRECISION,
    RO_SUMMA DOUBLE PRECISION,
    RO_INSUMMA DOUBLE PRECISION)
AS
begin /*$$IBE$$ 
  rdate_id = :vdate1;
  ro_kilk = 0.00;
  ro_insumma = 0.00;
  ro_summa = 0.00;

  for select wn.code, d.doc_date, dr.kilk, dr.insum, calcpricepdv(dr.price, d.disc_persent, dr.disc_persent, 6) * dr.kilk
        from documents d
             left join docrec dr on (d.document_id = dr.document_id)
             left join w_nomen wn on (dr.nomen_id = wn.nomen_id)
       where d.doc_date between :vdate1 and :vdate2 and
             d.typedoc_id = 11
        into rcode, rdate_id, ro_kilk, ro_insumma, ro_summa
  do begin
    suspend;
  end
 $$IBE$$*/ EXIT;
end^


ALTER PROCEDURE WW_EXPORT_CHECK_MARKUP (
    IDAYS_CNT INTEGER)
RETURNS (
    OOBJ_NAME VARCHAR(50),
    ODOC_DATE DATE,
    OTIME_CR TIME,
    OCLT_NAME VARCHAR(50),
    OKARDCODE VARCHAR(13),
    OPROCENT DOUBLE PRECISION,
    OFIRST_GRP_NAME VARCHAR(40),
    OGRP_NAME VARCHAR(40),
    ONOMEN_NAME VARCHAR(40),
    OMAKER_NAME VARCHAR(40),
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OSUM_PDV DOUBLE PRECISION,
    OSUM DOUBLE PRECISION,
    OMARKUP DOUBLE PRECISION,
    OGRP_FULL_NAME VARCHAR(200),
    ODOCREC_ID INTEGER,
    OW3_NOMEN_ID INTEGER)
AS
declare variable pdate0 date;
declare variable pdate1 date;
begin
  pdate1 = cast('today' as date) -1;
  pdate0 = :pdate1 - :idays_cnt;

  for select o.name, d.doc_date, d.time_cr, c.name, k.kardcode, s.procent, slashparser(g.grp_fullname,1),
             g.grp_name, n.nomen_name, m.maker_name, dr.kilk, dr.price, (dr.kilk * dr.price),
             calcsum((dr.kilk * dr.price), (dr.kilk * dr.price) - dr.insum_pdv, dr.typepdv_pdv, dr.typepdv_id, 0),
             ((dr.kilk * dr.price)-dr.insum_pdv)/(dr.kilk * dr.price + 0.0000000001)*100, g.grp_fullname, dr.docrec_id,
             n.w3_nomen_id
        from documents d
             left join docrec dr
               left join nomen n
                 left join grp   g on g.grp_id = n.grp_id
                   left join maker m on n.maker_id = m.maker_id
                 on n.nomen_id = dr.nomen_id
               on d.document_id = dr.document_id
             left join clients o on d.objects_id = o.clients_id
             left join clients c on d.clients_id = c.clients_id
             left join kards   k
               left join discont s on s.discont_id = k.discont_id
               on d.kards_id   = k.kards_id
      where d.typedoc_id = 11 and
            d.doc_lock   > 0  and
            d.doc_date between :pdate0 and :pdate1
       into oobj_name, odoc_date, otime_cr, oclt_name, okardcode, oprocent, ofirst_grp_name,
            ogrp_name, onomen_name, omaker_name, okilk, oprice, osum_pdv,
            osum, omarkup, ogrp_full_name, odocrec_id,
            ow3_nomen_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_CLIENTS_TMP
RETURNS (
    OCLIENT_ID INTEGER,
    OTYPECLIENT_ID INTEGER,
    ONAME VARCHAR(50),
    OADRESS VARCHAR(100),
    OZKPO VARCHAR(20),
    OIS_PDV SMALLINT,
    OIS_ACTIVE SMALLINT,
    ONOTE VARCHAR(512))
AS
begin
  for select c.client_id, c.typeclient_id, c.name, c.adress, c.zkpo, c.is_pdv, c.is_active,
             c.note
        from t_clients_tmp c
       where c.date_last_modefication between (cast('today' as date) - 7) and 'today'
        into oclient_id, otypeclient_id, oname, oadress, ozkpo, ois_pdv, ois_active,
             onote
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_DEACTIVATE_CLIENTS
RETURNS (
    OW3_CLIENT_ID INTEGER,
    OSET_ACTIVE INTEGER)
AS
declare variable pclient_id integer;
begin
  for select cl.clients_id, cl.w3_client_id
        from clients cl
       where cl.clients_id > 100 and
             cl.w3_client_id is not null
        into pclient_id, ow3_client_id
  do begin
    oset_active = 1;
    if (not(exists(select * from documents d
                    where ((d.clients_id = :pclient_id) or
                          (d.objects_id  = :pclient_id))))                  and
       not(exists(select * from goods g where g.clients_id = :pclient_id))  and
       not(exists(select * from kards k where k.clients_id = :pclient_id))) then
    begin
      oset_active = 0;
    end
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TDATE_0 DATE;
DECLARE VARIABLE TDATE_1 DATE;
begin
    tdate_1 = 'today';
    tdate_0 = :tdate_1 - :idays_cnt;

    for select ed.onomen_id, ed.oday_id, sum(ed.oi_kilk), sum(ed.oi_sum), sum(ed.oi_sum_pdv),
                  sum(ed.oo_kilk), sum(ed.oo_sum), sum(ed.oo_insum), sum(ed.oo_sum_pdv)
            from ww_export_dinamics_dr(:tdate_0, :tdate_1) ed
        group by ed.onomen_id, ed.oday_id
      into :onomen_id, :oday_id, :oi_kilk, :oi_sum, :oi_sum_pdv,
                  :oo_kilk, :oo_sum, :oo_insum, :oo_sum_pdv
    do begin
      suspend;
    end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_DR (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OREAL_NOMEN_ID INTEGER,
    OO_INSUM_PDV DOUBLE PRECISION)
AS
declare variable tptypepdv integer;
declare variable tclients_id integer;
declare variable tobjects_id integer;
declare variable tnomen_id integer;
declare variable tmarkup double precision;
declare variable tsum_pdv double precision;
declare variable tkilk double precision;
declare variable to_sum double precision;
declare variable tinsum double precision;
declare variable tinsum_pdv double precision;
declare variable ttypepdv_id integer;
declare variable tclient_id integer;
declare variable tobject_id integer;
begin
  for select d.clients_id, d.objects_id, dr.typepdv_id,
             calcpricepdv(dr.price, d.disc_persent, dr.disc_persent * dr.is_in_discount, 6) * dr.kilk,
             d.doc_date, dr.kilk, dr.insum, dr.insum_pdv, dr.typepdv_id, n.w3_nomen_id,
             n.nomen_id
        from nomen n, documents d left join docrec dr on d.document_id=dr.document_id
       where d.doc_date between :idate_0 and :idate_1 and
             n.nomen_id = dr.nomen_id and
             n.w3_nomen_id is not null and
             d.doc_lock in (1, 2)  and
             d.typedoc_id not in (10)
        into tclients_id, tobjects_id, ttypepdv_id, tsum_pdv,
             oday_id, tkilk, tinsum, tinsum_pdv, ttypepdv_id, onomen_id,
             oreal_nomen_id
  do begin
  
    if (:tobjects_id = 1) then
    begin
      oi_kilk    = 0.0;
      oi_sum     = 0.0;
      oi_sum_pdv = 0.0;

      oo_sum_pdv    = :tsum_pdv;
      tmarkup       = :tsum_pdv - :tinsum_pdv;
      oo_insum_pdv  = :tinsum_pdv;
      oo_sum        = calcsum(:oo_sum_pdv, :tmarkup, 0, :ttypepdv_id, 6);
      oo_insum      = :tinsum;
      oo_kilk       = :tkilk;
      suspend;
    end  
    if (:tclients_id = 1) then
    begin
      oo_kilk    = 0.0;
      oo_sum     = 0.0;
      oo_sum_pdv = 0.0;
      oo_insum   = 0.0;
      
      oi_kilk    = :tkilk;
      oi_sum_pdv = :tsum_pdv;
      oi_sum     = :tinsum;
      suspend;
    end
  end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_DR_V1 (
    IDATE DATE,
    INOMEN_ID INTEGER)
RETURNS (
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TCLIENTS_ID INTEGER;
DECLARE VARIABLE TOBJECTS_ID INTEGER;
DECLARE VARIABLE TMARKUP DOUBLE PRECISION;
DECLARE VARIABLE TSUM_PDV DOUBLE PRECISION;
DECLARE VARIABLE TKILK DOUBLE PRECISION;
DECLARE VARIABLE TINSUM DOUBLE PRECISION;
DECLARE VARIABLE TINSUM_PDV DOUBLE PRECISION;
DECLARE VARIABLE TTYPEPDV_ID INTEGER;
begin
    oi_kilk = 0.0;
    oi_sum = 0.0;
    oi_sum_pdv = 0.0;
    oo_kilk = 0.0;
    oo_sum = 0.0;
    oo_sum_pdv = 0.0;
    oo_insum = 0.0;
    suspend;

    for select d.clients_id, d.objects_id, dr.typepdv_id, gs.osum_pdv,
               dr.kilk, dr.insum, dr.insum_pdv, dr.typepdv_id
          from documents d
               left join docrec dr on (d.document_id = dr.document_id)
               join nomen n on (dr.nomen_id = n.nomen_id),
               ps_get_sum(dr.docrec_id,  d.disc_persent, dr.disc_persent) gs
         where d.doc_date = :idate and
               n.is_visible = 1 and
               n.w3_nomen_id = :inomen_id and
               d.typedoc_id not in (10)
          into tclients_id, tobjects_id, ttypepdv_id, tsum_pdv,
               tkilk, tinsum, tinsum_pdv, ttypepdv_id
    do begin

        if (:tobjects_id = 1) then
        begin
          oi_kilk = 0.0;
          oi_sum = 0.0;
          oi_sum_pdv = 0.0;

          oo_sum_pdv = :tsum_pdv;
          tmarkup = :tsum_pdv - :tinsum_pdv;
          oo_sum = calcsum(:oo_sum_pdv, :tmarkup, 0, :ttypepdv_id, 6);
          oo_insum   = :tinsum;
          oo_kilk = :tkilk;
          suspend;
        end
        if (:tclients_id = 1) then
        begin
          oo_kilk = 0.0;
          oo_sum = 0.0;
          oo_sum_pdv = 0.0;
          oo_insum = 0.0;

          oi_kilk = :tkilk;
          oi_sum_pdv = :tsum_pdv;
          oi_sum = :tinsum;
          suspend;
        end
    end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_DR_V2 (
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OREAL_NOMEN_ID INTEGER,
    OO_INSUM_PDV DOUBLE PRECISION,
    OTYPEDOC_ID INTEGER,
    ODOCUMENT_ID INTEGER)
AS
declare variable tclients_id integer;
declare variable tobjects_id integer;
declare variable tmarkup double precision;
declare variable tsum_pdv double precision;
declare variable tkilk double precision;
declare variable tinsum double precision;
declare variable tinsum_pdv double precision;
declare variable ttypepdv_id integer;
begin
  for select d.clients_id, d.objects_id, dr.typepdv_id,
             calcpricepdv(dr.price, d.disc_persent, dr.disc_persent * dr.is_in_discount, 6) * dr.kilk,
             d.doc_date, dr.kilk, dr.insum, dr.insum_pdv, dr.typepdv_id, n.w3_nomen_id,
             n.nomen_id, d.typedoc_id, d.document_id
        from nomen n, documents d left join docrec dr on d.document_id=dr.document_id
       where d.doc_date between :idate_0 and :idate_1 and
             n.nomen_id = dr.nomen_id and
             n.w3_nomen_id is not null and
             d.doc_lock in (1, 2)  and
             d.typedoc_id not in (10)
        into tclients_id, tobjects_id, ttypepdv_id, tsum_pdv,
             oday_id, tkilk, tinsum, tinsum_pdv, ttypepdv_id, onomen_id,
             oreal_nomen_id, otypedoc_id, odocument_id
  do begin
  
    if (:tobjects_id = 1) then
    begin
      oi_kilk    = 0.0;
      oi_sum     = 0.0;
      oi_sum_pdv = 0.0;

      oo_sum_pdv    = :tsum_pdv;
      tmarkup       = :tsum_pdv - :tinsum_pdv;
      oo_insum_pdv  = :tinsum_pdv;
      oo_sum        = calcsum(:oo_sum_pdv, :tmarkup, 0, :ttypepdv_id, 6);
      oo_insum      = :tinsum;
      oo_kilk       = :tkilk;
      suspend;
    end  
    if (:tclients_id = 1) then
    begin
      oo_kilk    = 0.0;
      oo_sum     = 0.0;
      oo_sum_pdv = 0.0;
      oo_insum   = 0.0;
      
      oi_kilk    = :tkilk;
      oi_sum_pdv = :tsum_pdv;
      oi_sum     = :tinsum;
      suspend;
    end
  end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_RECURSION (
    INOMEN_ID INTEGER,
    IE_KILK DOUBLE PRECISION,
    IE_SUM DOUBLE PRECISION,
    IE_SUM_PDV DOUBLE PRECISION,
    IDATE_0 DATE,
    IDATE_1 DATE)
RETURNS (
    ODATE DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION)
AS
begin
   if (:idate_0 > :idate_1) then exit;

   odate = :idate_1;

   select sum(around3(oi_kilk)), sum(around(oi_sum)), sum(around(oi_sum_pdv)),
            sum(around3(oo_kilk)), sum(around(oo_sum)), sum(around(oo_insum)), sum(around(oo_sum_pdv))
        from WW_EXPORT_DINAMICS_DR_V1(:idate_1, :inomen_id)
     into :oi_kilk, :oi_sum, :oi_sum_pdv,
            :oo_kilk, :oo_sum, :oo_insum, :oo_sum_pdv;

   ob_kilk = :ie_kilk - :oi_kilk + :oo_kilk;
   ob_sum = :ie_sum - :oi_sum + :oo_sum;
   ob_sum_pdv = :ie_sum_pdv - :oi_sum_pdv + :oo_sum_pdv;

   oe_kilk = :ie_kilk;
   oe_sum = :ie_sum;
   oe_sum_pdv = :ie_sum_pdv;

   suspend;

   for select odate, oi_kilk, oi_sum, oi_sum_pdv, oo_kilk, oo_sum, oo_insum, oo_sum_pdv,
             oe_kilk, oe_sum, oe_sum_pdv, ob_kilk, ob_sum, ob_sum_pdv
        from WW_EXPORT_DINAMICS_RECURSION(:inomen_id, :ob_kilk, :ob_sum, :ob_sum_pdv, :idate_0, :odate - 1)
      into :odate, :oi_kilk, :oi_sum, :oi_sum_pdv, :oo_kilk, :oo_sum, :oo_insum, :oo_sum_pdv,
          :oe_kilk, :oe_sum, :oe_sum_pdv, :ob_kilk, :ob_sum, :ob_sum_pdv
   do begin
     suspend;
   end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_RST
RETURNS (
    ONOMEN_ID INTEGER,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OW3_NOMEN_ID INTEGER)
AS
begin
  for select r.nomen_id, n.w3_nomen_id, r.rest, r.rest_sum, calcsum(r.rest_sum, 0, 0, n.typepdv_id, 6) from rst r, nomen n
       where n.nomen_id = r.nomen_id and
             n.w3_nomen_id is not null
    into :onomen_id, :ow3_nomen_id, :oe_kilk, :oe_sum_pdv, :oe_sum
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_V1 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TDATE_0 DATE;
DECLARE VARIABLE TDATE_1 DATE;
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TE_KILK DOUBLE PRECISION;
DECLARE VARIABLE TE_SUM DOUBLE PRECISION;
DECLARE VARIABLE TE_SUM_PDV DOUBLE PRECISION;
begin
    tdate_1 = '02.04.2008';
    tdate_0 = :tdate_1 - :idays_cnt;

    for select dr.onomen_id, dr.ow3_nomen_id, dr.oe_kilk, dr.oe_sum, dr.oe_sum_pdv
            from ww_export_dinamics_rst dr
      into :tnomen_id, :onomen_id, :te_kilk, :te_sum, :te_sum_pdv
    do begin
      for select odate, oi_kilk, oi_sum, oi_sum_pdv, oo_kilk, oo_sum, oo_insum, oo_sum_pdv,
             oe_kilk, oe_sum, oe_sum_pdv, ob_kilk, ob_sum, ob_sum_pdv
            from ww_export_dinamics_recursion(:tnomen_id, :te_kilk, :te_sum, :te_sum_pdv, :tdate_0, :tdate_1)
         into :oday_id, :oi_kilk, :oi_sum, :oi_sum_pdv, :oo_kilk, :oo_sum, :oo_insum, :oo_sum_pdv,
            :oe_kilk, :oe_sum, :oe_sum_pdv, :ob_kilk, :ob_sum, :ob_sum_pdv
      do begin
        suspend;
      end
    end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_V2 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OI_KILK DOUBLE PRECISION,
    OI_SUM DOUBLE PRECISION,
    OI_SUM_PDV DOUBLE PRECISION,
    OO_KILK DOUBLE PRECISION,
    OO_SUM DOUBLE PRECISION,
    OO_INSUM_PDV DOUBLE PRECISION,
    OO_INSUM DOUBLE PRECISION,
    OO_SUM_PDV DOUBLE PRECISION,
    OE_KILK DOUBLE PRECISION,
    OE_SUM DOUBLE PRECISION,
    OE_SUM_PDV DOUBLE PRECISION,
    OB_KILK DOUBLE PRECISION,
    OB_SUM DOUBLE PRECISION,
    OB_SUM_PDV DOUBLE PRECISION)
AS
DECLARE VARIABLE TDATE_0 DATE;
DECLARE VARIABLE TDATE_1 DATE;
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TTYPE_PDV_ID INTEGER;
DECLARE VARIABLE TREAL_NOMEN_ID INTEGER;
DECLARE VARIABLE TPREW_NOMEN_ID INTEGER;
DECLARE VARIABLE TE_KILK DOUBLE PRECISION;
DECLARE VARIABLE TE_SUM DOUBLE PRECISION;
DECLARE VARIABLE TE_SUM_PDV DOUBLE PRECISION;
begin
    tdate_1 = 'today';
    tdate_0 = :tdate_1 - :idays_cnt;

    tprew_nomen_id = -1;
    for select ed.onomen_id, ed.oday_id, ed.oreal_nomen_id, around3(sum(ed.oi_kilk)), around3(sum(ed.oi_sum)),
             around3(sum(ed.oi_sum_pdv)), around3(sum(ed.oo_kilk)), around3(sum(ed.oo_sum)),
             around3(sum(ed.oo_insum)), around3(sum(ed.oo_sum_pdv)), around3(sum(ed.oo_insum_pdv))
            from ww_export_dinamics_dr(:tdate_0, :tdate_1) ed
          group by ed.onomen_id, ed.oday_id, ed.oreal_nomen_id
          order by ed.onomen_id, ed.oday_id desc 
      into onomen_id, oday_id, treal_nomen_id, oi_kilk, oi_sum, oi_sum_pdv,
                oo_kilk, oo_sum, oo_insum, oo_sum_pdv, oo_insum_pdv
    do begin
      if (:tprew_nomen_id <> :treal_nomen_id) then
      begin
        select first(1) r.rest, r.rest_sum, calcsum(r.rest_sum, 0, 0, n.typepdv_id, 6) from rst r, nomen n
              where r.nomen_id = :treal_nomen_id and
                    n.nomen_id = r.nomen_id and
                r.objects_id =1
          into :oe_kilk, :oe_sum_pdv, :oe_sum;
        tprew_nomen_id = :treal_nomen_id;
      end

      ob_kilk = :oe_kilk - :oi_kilk + :oo_kilk;
      ob_sum = :oe_sum - :oi_sum + :oo_insum;
      ob_sum_pdv = :oe_sum_pdv - :oi_sum_pdv + :oo_insum_pdv;

      suspend;

      oe_kilk = :ob_kilk;
      oe_sum = :ob_sum;
      oe_sum_pdv = :ob_sum_pdv;

    end
end^


ALTER PROCEDURE WW_EXPORT_DINAMICS_V3 (
    IDAYS_CNT INTEGER)
RETURNS (
    ONOMEN_ID INTEGER,
    ODAY_ID DATE,
    OTYPEDOC_ID INTEGER,
    ODOC_KILK DOUBLE PRECISION,
    ODOC_SUM DOUBLE PRECISION,
    ODOC_INSUM DOUBLE PRECISION,
    ODOC_SUM_PDV DOUBLE PRECISION,
    ODOC_CNT INTEGER,
    OOBJECT_ID INTEGER,
    OIS_PRIHID SMALLINT)
AS
declare variable tdate_0 date;
declare variable tdate_1 date;
declare variable tinsum_pdv double precision;
declare variable ttypepdv_id integer;
declare variable tobject_id integer;
begin
    tdate_1 = 'today';
    tdate_0 = :tdate_1 - :idays_cnt;

    for select d.doc_date, n.w3_nomen_id, d.typedoc_id, around(sum(gs.osum_pdv)),
              around(sum(dr.kilk)), around(sum(dr.insum)), around(sum(dr.insum_pdv)),
              count(d.document_id), dr.typepdv_id, ob.w3_client_id, d.objects_id
        from documents d
           left join docrec dr on d.document_id = dr.document_id
              left join nomen n on n.nomen_id = dr.nomen_id
                     left join clients ob on ob.clients_id = d.objects_id
               left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs on 1 = 1
         where d.doc_date between :tdate_0 and :tdate_1 and
               d.doc_lock in (1, 2)  and
               d.typedoc_id not in (10) and
               n.w3_nomen_id is not null
      group by d.doc_date, n.w3_nomen_id, d.typedoc_id, dr.typepdv_id, ob.w3_client_id, d.objects_id
      order by n.w3_nomen_id, d.doc_date desc
          into oday_id, onomen_id, otypedoc_id, odoc_sum_pdv,
               odoc_kilk, odoc_insum, tinsum_pdv,
               odoc_cnt, ttypepdv_id, oobject_id, tobject_id
    do begin
      odoc_sum  = calcsum(:odoc_sum_pdv, :odoc_sum_pdv - :tinsum_pdv, 0, :ttypepdv_id, 6);
      if (:tobject_id = 1) then
        ois_prihid = 0;
      else
        ois_prihid = 1;
      suspend;
    end
end^


ALTER PROCEDURE WW_EXPORT_DOC_HDR (
    IDAYS_CNT INTEGER)
RETURNS (
    ODOC_ID INTEGER,
    ODAY_ID DATE,
    OCLIENT_ID INTEGER,
    OOBJECT_ID INTEGER,
    OTYPEPAY_ID INTEGER,
    ODOC_MARK VARCHAR(14),
    ODOC_NUM VARCHAR(14),
    OW3CLIENT_ID INTEGER,
    OW3OBJECT_ID INTEGER)
AS
DECLARE VARIABLE TDATE_0 DATE;
DECLARE VARIABLE TDATE_1 DATE;
begin
  tdate_1 = 'today';
  tdate_0 = :tdate_1 - :idays_cnt;
  for select d.document_id, d.doc_date, d.clients_id, d.objects_id,
                 d.doc_mark, d.doc_num, d.oplata_type
             from documents d
      where d.doc_date between :TDATE_0 and :TDATE_1 and
            d.typedoc_id = 1 and
            d.doc_lock in (1, 2)
    into odoc_id, oday_id, oclient_id, oobject_id,
                 odoc_mark, odoc_num, otypepay_id
  do begin
    select c.w3_client_id from clients c
        where c.clients_id = :oclient_id
      into ow3client_id;
    if (ow3client_id is null) then ow3client_id = 0;

    select c.w3_client_id from clients c
        where c.clients_id = :oobject_id
      into ow3object_id;
    if (ow3object_id is null) then ow3object_id = 0;

    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_DOC_REC (
    IDAYS_CNT INTEGER)
RETURNS (
    ODOC_ID INTEGER,
    ONOMEN_ID INTEGER,
    OTYPEPDV_ID SMALLINT,
    OKILK DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION)
AS
declare variable tdate_0 date;
declare variable tdate_1 date;
begin
  tdate_1 = 'today';
  tdate_0 = :tdate_1 - :idays_cnt;

  for select d.document_id, n.w3_nomen_id, dr.typepdv_id, sum(dr.kilk), sum(dr.insum_pdv), sum(dr.insum)
       from documents d
            left join docrec dr on d.document_id = dr.document_id
            left join nomen n on dr.nomen_id = n.nomen_id
      where d.doc_date between :TDATE_0 and :TDATE_1 and
            d.typedoc_id = 1 and
            d.doc_lock in (1, 2)
   group by d.document_id, n.w3_nomen_id, dr.typepdv_id
       into odoc_id, onomen_id, otypepdv_id, okilk, oinsum_pdv, oinsum
  do begin

    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_DOCUMENTS (
    IDATE0 DATE,
    IDATE1 DATE)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODATE_DOC DATE,
    ODOC_NUM VARCHAR(14),
    OTYPEDOC_ID INTEGER,
    OZKPO VARCHAR(20),
    OIPN VARCHAR(20),
    ONAME VARCHAR(50),
    OKARDCODE VARCHAR(13),
    ONOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    OTYPEPDW_ID INTEGER,
    OIS_PRIHID SMALLINT)
AS
declare variable pkard_id integer;
declare variable pnomen_id integer;
declare variable pobject_id integer;
declare variable pclients_id integer;
begin
  for select d.document_id, d.doc_date, d.doc_num, d.typedoc_id, d.kards_id,
             dr.nomen_id, dr.kilk, dr.price, dr.typepdv_id, d.objects_id,
             d.clients_id
        from documents d, docrec dr, clients cl
       where d.document_id = dr.document_id and
             d.doc_date between :idate0 and :idate1
        into odocument_id, odate_doc, odoc_num, otypedoc_id, pkard_id,
             pnomen_id, okilk, oprice, otypepdw_id, pobject_id,
             pclients_id
  do begin
    ois_prihid = 0;
    if (:pclients_id = 1) then
    begin
      pclients_id = :pobject_id;
      ois_prihid  = 0;
    end

    select cl.zkpo, cl.ipn, cl.name
      from clients cl
     where cl.clients_id = :pclients_id
      into ozkpo, oipn, oname;

    select w3_nomen_id from nomen
     where nomen_id = :pnomen_id
      into onomen_id;

    select kardcode from kards
     where kards_id = :pkard_id
      into okardcode;

   if (:okardcode is null) then
   begin
     if (:pclients_id = 99)  then okardcode = '99';
     if (:pclients_id = 98) then okardcode = '98';
     if (:pclients_id = 100) then okardcode = '100';
   end

    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_STATICS
RETURNS (
    ONOMEN_ID INTEGER,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OCLIENT_NAME VARCHAR(50),
    OIN_DATE DATE)
AS
declare variable tnomen_id integer;
declare variable tgoods_id integer;
declare variable tclient_id integer;
declare variable pnomen_id integer;
begin
  for select n.nomen_id, around(n.out_price), around3(rt.rest), around3(n.minkilk), n.w3_nomen_id
  from nomen n, rst rt
    where n.nomen_id = rt.nomen_id
   into :pnomen_id, :oout_price, :orest, :omin_rest, :onomen_id
  do begin
    select max(g.goods_id) from goods g
       where g.nomen_id = :pnomen_id and
             g.clients_id > 100
      into :tgoods_id;

    if (:tgoods_id is not null) then
    begin
      select g.doc_date, g.goods_inprice, g.clients_id from goods g
          where g.goods_id = :tgoods_id
        into :oin_date, :oin_price, :tclient_id;

      select c.name from clients c
          where c.clients_id = :tclient_id
        into :oclient_name;

      if (:oin_date is null) then
        oin_date = '02.01.2000';
      suspend;
    end
    tgoods_id = null;
    oin_price = null;
    oin_date = null;
  end
end^


ALTER PROCEDURE WW_EXPORT_STATICS_V1
RETURNS (
    ONOMEN_ID INTEGER,
    OIN_PRICE DOUBLE PRECISION,
    OOUT_PRICE DOUBLE PRECISION,
    OREST DOUBLE PRECISION,
    OREST_SUM DOUBLE PRECISION,
    OMIN_REST DOUBLE PRECISION,
    OIN_DATE DATE)
AS
DECLARE VARIABLE TGOODS_ID INTEGER;
DECLARE VARIABLE PNOMEN_ID INTEGER;
begin
  for select n.nomen_id, around(n.out_price), around3(rt.rest), around3(rt.rest_sum), around3(n.minkilk), n.w3_nomen_id
  from nomen n, rst rt
    where n.nomen_id = rt.nomen_id and
          n.is_visible = 1 and
          n.w3_nomen_id is not null
   into :pnomen_id, :oout_price, :orest, :orest_sum, :omin_rest, :onomen_id
  do begin
    select max(g.goods_id) from goods g
       where g.nomen_id = :pnomen_id and
             g.clients_id > 100
      into :tgoods_id;

    if (:tgoods_id is not null) then
    begin
      select g.doc_date, g.goods_inprice from goods g
          where g.goods_id = :tgoods_id
        into :oin_date, :oin_price;

      suspend;
    end
    tgoods_id = null;
    oin_price = null;
    oin_date = null;
    orest = null;
    orest_sum = null;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_CHECKS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_NUM VARCHAR(14),
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_check as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;

  for select d.document_id, d.doc_num, cast(d.ts as date)
        from documents d
       where d.ts between (:pdocuments_ts- 0.0005) and :pts_hight and
             d.typedoc_id = 11
       order by d.ts
        into odocument_id, odoc_num, ots
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DEL_DOCGOODS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCGOODS_ID INTEGER,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_del_docgoods as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;
  for select dg.docgoods_id, cast(dg.ts as date)
        from t_del_docgoods dg
       where dg.ts between (:pdocuments_ts- 0.0005) and :pts_hight
        into odocgoods_id, ots
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DEL_DOCRECS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCREC_ID INTEGER,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_del_docrec as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;
  for select dr.docrec_id, cast(dr.ts as date)
        from t_del_docrecs dr
       where dr.ts between (:pdocuments_ts - 0.0005) and :pts_hight
        into odocrec_id, ots
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DEL_DOCUMENTS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_del_documents as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;
  for select d.document_id, cast(d.ts as date)
        from t_del_documents d
       where d.ts between (:pdocuments_ts - 0.0005) and :pts_hight
        into odocument_id, ots
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DEL_GOODS (
    IDELTA TIMESTAMP)
RETURNS (
    OGOODS_ID INTEGER,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_del_goods as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;
  for select g.goods_id, cast(g.ts as date)
        from t_del_goods g
       where g.ts between (:pdocuments_ts - 0.0005) and :pts_hight
        into ogoods_id, ots
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DOCGOODS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCGOODS_ID INTEGER,
    OGOODS_ID INTEGER,
    ODOCREC_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OINPRICE DOUBLE PRECISION,
    OINPRICE_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pmax_doc_id integer;
declare variable pmin_doc_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_docgoods as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;

/*$$IBEC$$   select max(dg.docgoods_id), min(dg.docgoods_id)
    from docgoods dg
   where dg.ts >= (:pdocuments_ts)
    into pmax_doc_id, pmin_doc_id; $$IBEC$$*/

  for select dg.docgoods_id, dg.goods_id, dg.docrec_id, dg.kilk, dg.inprice, dg.inprice_pdv,
             dg.insum, dg.insum_pdv, cast(dg.ts as date)
        from docgoods dg
       where dg.ts between (:pdocuments_ts- 0.0005) and :pts_hight
       order by dg.ts
        into odocgoods_id, ogoods_id, odocrec_id, okilk, oinprice, oinprice_pdv,
             oinsum, oinsum_pdv, ots
  do begin
    suspend;
  end
 /* update t_sync_ts t
     set t.docgoods_id_min = :pmin_doc_id,
         t.docgoods_id_max = :pmax_doc_id
   where t.sync_id = :psync_id;*/
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DOCRECS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCREC_ID INTEGER,
    ODOCUMENT_ID INTEGER,
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    OKILK DOUBLE PRECISION,
    OPRICE DOUBLE PRECISION,
    ODISC_PERSENT DOUBLE PRECISION,
    OTYPEPDV_ID INTEGER,
    OTYPEPDV_PDV DOUBLE PRECISION,
    OINSUM_PDV DOUBLE PRECISION,
    OINSUM DOUBLE PRECISION,
    OOUTSUM_PDV DOUBLE PRECISION,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pmax_doc_id integer;
declare variable pmin_doc_id integer;
declare variable pdoc_low timestamp;
declare variable pdoc_hight timestamp;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_docrec as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;

/*$$IBEC$$   select max(dr.docrec_id), min(dr.docrec_id), max(dr.ts), min(dr.ts)
    from docrec dr
   where dr.ts >= (:pdocuments_ts)
    into pmax_doc_id, pmin_doc_id, pdoc_hight, pdoc_low; $$IBEC$$*/

  for select dr.docrec_id, dr.document_id, dr.nomen_id, n.w3_nomen_id, dr.kilk,
             dr.price, dr.disc_persent, dr.typepdv_id, dr.typepdv_pdv, dr.insum_pdv,
             dr.insum, gs.osum_pdv, cast(dr.ts as date)
        from docrec dr
             left join nomen n on n.nomen_id = dr.nomen_id
             inner join documents d on d.document_id = dr.document_id
             left join ps_get_sum(dr.docrec_id, d.disc_persent, dr.disc_persent) gs on 1=1
       where dr.ts between (:pdocuments_ts- 0.0005) and :pts_hight
       order by dr.ts
        into odocrec_id, odocument_id, onomen_id, ow3_nomen_id, okilk,
             oprice, odisc_persent, otypepdv_id, otypepdv_pdv, oinsum_pdv,
             oinsum, ooutsum_pdv, ots
  do begin
    suspend;
  end
  /*update t_sync_ts t
     set t.docrec_id_min = :pmin_doc_id,
         t.docrec_id_max = :pmax_doc_id,
         t.ts_low        = :pdoc_low
   where t.sync_id = :psync_id;*/
end^


ALTER PROCEDURE WW_EXPORT_SYNC_DOCUMENTS (
    IDELTA TIMESTAMP)
RETURNS (
    ODOCUMENT_ID INTEGER,
    ODOC_DATE DATE,
    OTYPEDOC_ID INTEGER,
    OOBJECTS_ID INTEGER,
    OCLIENTS_ID INTEGER,
    OW3_OBJECTS_ID INTEGER,
    OW3_CLIENTS_ID INTEGER,
    ODOC_LOCK SMALLINT,
    ODISC_PERSENT DOUBLE PRECISION,
    OOPLATA_STATE SMALLINT,
    OOPLATA_TYPE SMALLINT,
    OKARDS_ID INTEGER,
    OTIME_FIX TIME,
    OKASSES_ID INTEGER,
    OMAKER_ID INTEGER,
    OTS DATE)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pmax_doc_id integer;
declare variable pmin_doc_id integer;
declare variable new_var integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_documents as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;

/*$$IBEC$$   select max(d.document_id), min(d.document_id)
    from documents d
   where d.ts >= (:pdocuments_ts)
    into pmax_doc_id, pmin_doc_id; $$IBEC$$*/

  for select d.document_id, d.doc_date, d.typedoc_id,
             d.objects_id, d.clients_id, ob.w3_client_id, cl.w3_client_id, d.doc_lock,
             d.disc_persent, d.oplata_state, d.oplata_type, d.kards_id, d.time_fix,
             d.kasses_id, d.maker_id, cast(d.ts as date)
        from documents d
             left join clients cl on cl.clients_id = d.clients_id
             left join clients ob on ob.clients_id = d.objects_id
       where d.ts between (:pdocuments_ts- 0.0005) and :pts_hight
       order by d.ts
        into odocument_id, odoc_date, otypedoc_id,
             oobjects_id, oclients_id, ow3_objects_id, ow3_clients_id, odoc_lock,
             odisc_persent, ooplata_state, ooplata_type, okards_id, otime_fix,
             okasses_id, omaker_id, ots
  do begin
    suspend;
  end
  /*update t_sync_ts t
     set t.document_id_min = :pmin_doc_id,
         t.document_id_max = :pmax_doc_id
   where t.sync_id = :psync_id;*/
end^


ALTER PROCEDURE WW_EXPORT_SYNC_GOODS (
    IDELTA TIMESTAMP)
RETURNS (
    OGOODS_ID INTEGER,
    ONOMEN_ID INTEGER,
    OW3_NOMEN_ID INTEGER,
    OGOODS_REST DOUBLE PRECISION,
    OGOODS_INPRICE DOUBLE PRECISION,
    OCLIENTS_ID INTEGER,
    OW3_CLIENTS_ID INTEGER,
    ODOC_DATE DATE,
    OTS DATE,
    OGOODS_INPRICE_WO_PDV DOUBLE PRECISION)
AS
declare variable pdocuments_ts date;
declare variable psync_id integer;
declare variable pmax_doc_id integer;
declare variable pmin_doc_id integer;
declare variable pts_hight timestamp;
begin
  select max(s.sync_id) from t_sync_ts s
    into psync_id;
  select cast(s.ts_goods as date), s.ts_hight from t_sync_ts s
   where s.sync_id = :psync_id
    into pdocuments_ts, pts_hight;

/*$$IBEC$$   select max(g.goods_id), min(g.goods_id)
    from goods g
   where g.ts >= (:pdocuments_ts)
    into pmax_doc_id, pmin_doc_id; $$IBEC$$*/

  for select g.goods_id, g.nomen_id, n.w3_nomen_id,
             g.goods_rest, g.goods_inprice, g.clients_id, cl.w3_client_id,
             g.doc_date, cast(g.ts as date)
        from goods g
             left join nomen n on n.nomen_id = g.nomen_id
             left join clients cl on g.clients_id = cl.clients_id
       where g.ts between (:pdocuments_ts- 0.0005) and :pts_hight
       order by g.ts
        into ogoods_id, onomen_id, ow3_nomen_id,
             ogoods_rest, ogoods_inprice, oclients_id, ow3_clients_id,
             odoc_date, ots
  do begin
    select max(dg.inprice) from docgoods dg
     where dg.goods_id = :ogoods_id
      into ogoods_inprice_wo_pdv;
    suspend;
  end
 /* update t_sync_ts t
     set t.goods_id_min = :pmin_doc_id,
         t.goods_id_max = :pmax_doc_id
   where t.sync_id = :psync_id;*/
end^


ALTER PROCEDURE WW_EXPORT_SYNC_LOG
RETURNS (
    OVISIBLE_CNT INTEGER,
    OSYNC_CNT INTEGER)
AS
begin
  select count(n.nomen_id) from nomen n
      where n.is_visible = 1
    into :ovisible_cnt;

  select count(n.nomen_id) from nomen n
      where n.is_visible = 1 and
            n.w3_nomen_id is not null
    into :osync_cnt;

  suspend;
end^


ALTER PROCEDURE WW_EXPORT_SYNC_LOG_DISC
RETURNS (
    OACTIVE INTEGER,
    OBLOCK INTEGER)
AS
begin
   select count(k.kards_id) from kards k
   where k.is_block = 0
    into oactive;

   select count(k.kards_id) from kards k
   where k.is_block = 1
    into oblock;
 suspend;
end^


ALTER PROCEDURE WW_EXPORT_SYNC_LOG_V1
RETURNS (
    OVISIBLE_CNT INTEGER,
    OSYNC_CNT INTEGER,
    OCLIENT_VISIBLE_CNT INTEGER,
    OCLIENT_SYNC_CNT INTEGER)
AS
begin
  select count(n.nomen_id) from nomen n
   where n.is_visible = 1
    into ovisible_cnt;

  select count(n.nomen_id) from nomen n
   where n.is_visible = 1 and
         n.w3_nomen_id is not null
    into osync_cnt;

  select count(cl.clients_id) from clients cl
   where cl.is_visible = 1 and
         cl.typeclient_id = 2
    into oclient_visible_cnt;

  select count(cl.clients_id) from clients cl
   where cl.is_visible = 1 and
         cl.typeclient_id = 2 and
         cl.w3_client_id is not null
    into oclient_sync_cnt;

  suspend;
end^


ALTER PROCEDURE WW_EXPORT_SYNC_SEANS
RETURNS (
    OSYNC_ID INTEGER,
    ODOCUMENT_ID_MIN INTEGER,
    ODOCUMENT_ID_MAX INTEGER,
    ODOCREC_ID_MIN INTEGER,
    ODOCREC_ID_MAX INTEGER,
    ODOCGOODS_ID_MIN INTEGER,
    ODOCGOODS_ID_MAX INTEGER,
    OGOODS_ID_MIN INTEGER,
    OGOODS_ID_MAX INTEGER,
    OTS_LOW DATE,
    OTS_HIGHT DATE)
AS
begin
  select max(s.sync_id) from t_sync_ts s
    into osync_id;
  select s.document_id_min, s.document_id_max, s.docrec_id_min, s.docrec_id_max,
         s.docgoods_id_min, s.docgoods_id_max, s.goods_id_min, s.goods_id_max,
         cast(s.ts_low as date), cast(s.ts_hight as date)
   from t_sync_ts s
   where s.sync_id = :osync_id
    into odocument_id_min, odocument_id_max, odocrec_id_min, odocrec_id_max,
         odocgoods_id_min, odocgoods_id_max, ogoods_id_min, ogoods_id_max,
         ots_low, ots_hight;
  suspend;
end^


ALTER PROCEDURE WW_EXPORT_TMP_NOM_BARS
RETURNS (
    ONOMEN_ID INTEGER,
    OCODE VARCHAR(27))
AS
begin
  for select nb.nomen_id, b.code
        from t_tmp_nom_bar nb, barcode b
        where nb.barcode_id = b.barcode_id
     into :onomen_id, :ocode
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_EXPORT_TMP_NOMENS
RETURNS (
    ONOMEN_ID INTEGER,
    OSHORT_NAME VARCHAR(24),
    OFULL_NAME VARCHAR(40),
    ODESCRIPTION VARCHAR(255),
    OMAKER_NAME VARCHAR(80),
    OTRADEMARK VARCHAR(80),
    OCODE VARCHAR(6),
    OIS_DEVIDED SMALLINT,
    OGROUP_ID INTEGER,
    OSG_ID INTEGER,
    OTYPEPDV_ID INTEGER,
    OSI_ID INTEGER)
AS
begin
  for select tn.nomen_id, tn.short_name, tn.full_name, tn.description, tn.maker_name,
      tn.trademark, tn.code, tn.is_devided, tn.group_id, tn.sg_id, tn.typepdv_id, tn.si_id
     from t_tmp_nomens tn
    where tn.date_last_modefication between (cast('today' as date) - 7) and 'today'
    into :onomen_id, :oshort_name, :ofull_name, :odescription, :omaker_name,
      :otrademark, :ocode, :ois_devided, :ogroup_id, :osg_id, :otypepdv_id, :osi_id
  do begin
    suspend;
  end
end^


ALTER PROCEDURE WW_IMPORT_AO_RECORDS (
    IAO_RECORD_ID INTEGER,
    IAUTOORDER_ID INTEGER,
    INOMEN_ID INTEGER,
    IAOR_BEGIN DOUBLE PRECISION,
    IAOR_ARRIVAL DOUBLE PRECISION,
    IAOR_CHARGE DOUBLE PRECISION,
    IAOR_END DOUBLE PRECISION,
    IAOR_MIN_REST DOUBLE PRECISION,
    IAOR_ORDERED DOUBLE PRECISION,
    IAOR_AVG_KILK DOUBLE PRECISION,
    IRECOM_ORDER DOUBLE PRECISION)
AS
declare variable PAUTOORDER_ID integer;
begin
  select au.autoorder_id from autoorders au where au.w3_autoorder_id = :iautoorder_id
    into :pautoorder_id;
  if (:pautoorder_id is null) then exit;
  select n.nomen_id from nomen n where n.w3_nomen_id = :inomen_id
    into inomen_id;
  if (:inomen_id is null) then exit;

  if (exists(select * from ao_records aor where aor.aor_autoorder_id = :pautoorder_id and aor.aor_nomen_id = :inomen_id)) then
  begin/*update*/
    update ao_records aor
       set AOR_BEGIN = :iaor_begin,
           AOR_ARRIVAL = :IAOR_ARRIVAL,
           AOR_CHARGE = :IAOR_CHARGE,
           AOR_END = :IAOR_END,
           AOR_MIN_REST = :IAOR_MIN_REST,
           AOR_ORDERED = :IAOR_ORDERED,
           AOR_MIDDLDAILY_SALES = :IAOR_AVG_KILK
     where aor_autoorder_id = :pautoorder_id and
           aor_nomen_id = :inomen_id and
           (AOR_BEGIN   != :iaor_begin or
           AOR_ARRIVAL  != :IAOR_ARRIVAL or
           AOR_CHARGE   != :IAOR_CHARGE or
           AOR_END      != :IAOR_END or
           AOR_MIN_REST != :IAOR_MIN_REST or
           AOR_ORDERED  != :IAOR_ORDERED or
           AOR_MIDDLDAILY_SALES != :IAOR_AVG_KILK);
  end else
  begin/*insert*/
    insert into ao_records(aor_autoorder_id, aor_NOMEN_ID, AOR_BEGIN, AOR_ARRIVAL, AOR_CHARGE, AOR_END, AOR_MIN_REST, AOR_ORDERED, AOR_MIDDLDAILY_SALES)
      values(:pautoorder_id, :INOMEN_ID, :IAOR_BEGIN, :IAOR_ARRIVAL, :IAOR_CHARGE, :IAOR_END, :IAOR_MIN_REST, :IAOR_ORDERED, :IAOR_AVG_KILK);
  end
end^


ALTER PROCEDURE WW_IMPORT_AUTOORDERS (
    IAUTOORDER_ID INTEGER,
    ICONDITIONS SMALLINT,
    IAO_DATE DATE,
    INOTE VARCHAR(30),
    ICLIENT_ID INTEGER,
    IANALYSED_DAYS SMALLINT,
    IORDERED_DAYS SMALLINT,
    IUSE_PERIOD SMALLINT,
    IDATE0 DATE,
    IDATE1 DATE,
    IDATE_INPUT DATE)
AS
begin
  select cl.clients_id from clients cl
   where cl.w3_client_id = :iclient_id
    into iclient_id;
  if (:iclient_id is null) then exit;
  if (exists(select * from autoorders ao where ao.w3_autoorder_id = :iautoorder_id)) then
  begin /*update*/
    update autoorders ao
       set AO_CONDITIONS = :iconditions,
           AO_DATE = :iao_date,
           AO_NOTE = :inote,
           AO_CLIENT_ID = :iclient_id,
           AO_ANALYSED_DAYS = :ianalysed_days,
           AO_ORDERED_DAYS= :iordered_days,
           AO_USE_PERIOD = :iuse_period,
           AO_DATE0 = :idate0,
           AO_DATE1 = :idate1,
           DATE_IN = :idate_input
     where w3_autoorder_id = :iautoorder_id and
           (AO_CONDITIONS != :iconditions or
           AO_DATE != :iao_date or
           AO_NOTE != :inote or
           AO_CLIENT_ID != :iclient_id or
           AO_ANALYSED_DAYS != :ianalysed_days or
           AO_ORDERED_DAYS != :iordered_days or
           AO_USE_PERIOD != :iuse_period or
           AO_DATE0 != :idate0 or
           AO_DATE1 != :idate1 or
           DATE_IN != :idate_input);
  end else
  begin /*insert*/
    insert into autoorders(AO_CONDITIONS, AO_DATE, AO_NOTE, AO_CLIENT_ID, AO_ANALYSED_DAYS, AO_ORDERED_DAYS, AO_USE_PERIOD, AO_DATE0, AO_DATE1,  DATE_IN, w3_AUTOORDER_ID)
     values(:ICONDITIONS, :IAO_DATE, :INOTE, :ICLIENT_ID, :IANALYSED_DAYS, :IORDERED_DAYS, :IUSE_PERIOD, :IDATE0,
                :IDATE1,  :IDATE_INPUT, :IAUTOORDER_ID);
  end
end^


ALTER PROCEDURE WW_IMPORT_BARCODES (
    IBARCODE_ID INTEGER,
    ICODE VARCHAR(27))
AS
declare variable tbarcode_id integer;
declare variable tcode varchar(27);
begin
  /* заміна або вставка штрихкодів*/

  select b.barcode_id, b.code
    from barcode b
   where b.barcode_id = :ibarcode_id
    into :tbarcode_id, :tcode;

  if (:tbarcode_id is null) then
  begin

    insert into barcode (barcode_id, code)
       values (:ibarcode_id, :icode);

    when any do
    begin

      for select b.barcode_id
            from barcode b
           where b.code       = :icode and
                 b.barcode_id <> :ibarcode_id
            into :tbarcode_id
       do update barcode
             set code       = tosix(:tbarcode_id)
           where barcode_id = :tbarcode_id;

       insert into barcode (barcode_id, code)
                    values (:ibarcode_id, :icode);
    end
  end
  else
  if (:tcode <> :icode) then
  begin
    update barcode
       set code       = :icode
     where barcode_id = :ibarcode_id;

    when any do
    begin
      for select b.barcode_id
            from barcode b
           where b.code       = :icode and
                 b.barcode_id <> :ibarcode_id
            into :tbarcode_id
       do update barcode
             set code       = tosix(:tbarcode_id)
           where barcode_id = :tbarcode_id;

     update barcode
        set code       = :icode
      where barcode_id = :ibarcode_id;
    end
  end
end^


ALTER PROCEDURE WW_IMPORT_CLIENTS (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER)
AS
declare variable tclient_id integer;
declare variable tw3_client_id integer;
declare variable tname varchar(50);
declare variable tur_address varchar(50);
declare variable tzkpo varchar(20);
declare variable tis_pdv smallint;
declare variable tis_visible smallint;
declare variable tis_active smallint;
declare variable tis_exist smallint;
declare variable ttypeprop_id integer;
declare variable tmarker varchar(64);
begin
/*  select c.marker from t_configs c
  where c.config_id = 5 and
        c.module    = 'store_nomen'
   into pmarker;
 */
 execute procedure WW_IMPORT_CLIENTS_SYNC(:iw3_client_id, 2, :iname, :iur_address, :izkpo, :iis_pdv, :iis_active, :iis_visible_lc);

 select conf.marker from t_configs conf
  where conf.config_id = 2 and
        conf.module = 'store_clients'
   into tmarker;
 if (:tmarker = 'yes') then
 begin
  if (not exists (select * from clients c where c.w3_client_id = :iw3_client_id)) then
  begin
     if (not exists (select g.grpc_id from grpc g where g.grpc_id = 23)) then
         insert into GRPC (GRPC_ID,GRPC_NAME,PREW_GRPC_ID) values (23, 'Постачальники', null);

    tclient_id = gen_id(GEN_CLIENTS_ID, 1);
    insert into clients (clients_id, name, shortname, adress, zkpo, ispdv, typeclient_id,
     /*   is_visible, is_active, is_exist, */ w3_client_id, typeprop_id, grpc_id, is_opt)
      values (:tclient_id, :iname, substring(:iname from 1 for 30), :iur_address, :izkpo, :iis_pdv, 2,
     /*   :iis_visible, :iis_active, :iis_exist,*/ :iw3_client_id, :itypeprop_id, 23, 1);
  end
  else
  begin
 -- if (:pmarker = 'yes') then
 -- begin
   for select clients_id, name, adress, zkpo, ispdv,
              /*$$IBEC$$ is_visible, is_active, is_exist, $$IBEC$$*/ typeprop_id
         from clients c
        where c.w3_client_id = :iw3_client_id
         into tclient_id, tname, tur_address, tzkpo, tis_pdv,
              /*$$IBEC$$ tis_visible, tis_active, tis_exist, $$IBEC$$*/ ttypeprop_id
      do begin
         if ((:tname         <> :iname)          or
             (:tur_address   <> :iur_address)    or
             (:tzkpo         <> :izkpo)  /*$$IBEC$$        or
             (:tis_pdv       <> :iis_pdv) (:tis_pdv       <      /*$$IBEC$$   or
            //*  (:tis_visible   <> :iis_visible)    or
             (:tis_active    <> :iis_active)     or
             (:tis_exist     <> :iis_exist)      or  *//*$$IBEC$$
             (:ttypeprop_id  <> :itypeprop_id) $$IBEC$$*/)  then
         begin
            update clients c
              set c.name        = :iname,
                  c.adress      = :iur_address,
                  c.zkpo        = :izkpo/*$$IBEC$$,
                  c.ispdv      = :iis_pdv,  c.ispdv
                  c.typeclient_id = 2/*$$IBEC$$ ,
                $$IBEC$$*//*   c.is_visible  = :iis_visible,
                  c.is_active   = :iis_active,
                  c.is_exist    = :iis_exist,   *//*$$IBEC$$
                  c.typeprop_id = :itypeprop_id $$IBEC$$*/
            where clients_id = :tclient_id;
         end
     end
  -- end
  end
 end
end^


ALTER PROCEDURE WW_IMPORT_CLIENTS_DEL (
    ICLIENT_ID INTEGER,
    IUNITED_CLIENT_ID INTEGER)
AS
begin
  update clients c
     set c.w3_client_id = :iunited_client_id
   where c.w3_client_id = :iclient_id;
end^


ALTER PROCEDURE WW_IMPORT_CLIENTS_SYNC (
    IW3_CLIENT_ID INTEGER,
    ITYPECLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IADRESS VARCHAR(100),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE_LC INTEGER)
AS
declare variable tw3_client_id integer;
declare variable ttypeclient_id integer;
declare variable tname varchar(50);
declare variable tadress varchar(100);
declare variable tzkpo varchar(20);
declare variable tis_pdv smallint;
declare variable tis_active smallint;
declare variable tis_visible integer;
begin
  select cs.w3_client_id, cs.typeclient_id, cs.name, cs.adress, cs.zkpo, cs.is_pdv, cs.is_active, cs.is_visible
    from t_clients_sync cs
   where cs.w3_client_id = :iw3_client_id
    into tw3_client_id, ttypeclient_id, tname, tadress, tzkpo, tis_pdv, tis_active, tis_visible;

  if (:tw3_client_id is null) then
  begin
    insert into t_clients_sync(W3_CLIENT_ID, TYPECLIENT_ID, NAME, ADRESS, ZKPO, IS_PDV, IS_ACTIVE, is_visible)
      values(:iw3_client_id, :itypeclient_id, :iname, :iadress, :izkpo, :iis_pdv, :iis_active, :iis_visible_lc);
  end else
  begin
    if ((:itypeclient_id != :ttypeclient_id)or
        (:iname         != :tname)or
        (:iadress       != :tadress)or
        (:izkpo         != :tzkpo)or
        (:iis_pdv       != :tis_pdv)or
        (:iis_active    != :tis_active)or
        (:iis_visible_lc!= :tis_visible)) then
    begin
      update t_clients_sync
         set typeclient_id = :itypeclient_id,
             name         = :iname,
             adress       = :iadress,
             zkpo         = :izkpo,
             is_pdv       = :iis_pdv,
             is_active    = :iis_active
       where w3_client_id = :iw3_client_id;
    end
  end
end^


ALTER PROCEDURE WW_IMPORT_CLIENTS_V1 (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER,
    IIS_MARKED INTEGER,
    IIPN VARCHAR(20),
    INUM_PDV VARCHAR(20))
AS
declare variable tclient_id integer;
declare variable tname varchar(50);
declare variable tur_address varchar(50);
declare variable tzkpo varchar(20);
declare variable tis_pdv smallint;
declare variable tis_visible smallint;
declare variable tis_active smallint;
declare variable tis_exist smallint;
declare variable ttypeprop_id integer;
declare variable tmarker varchar(64);
declare variable tipn varchar(20);
declare variable tnum_pdv varchar(20);
begin
/*  select c.marker from t_configs c
  where c.config_id = 5 and
        c.module    = 'store_nomen'
   into pmarker;
 */
 if (:iis_pdv is null) then iis_pdv = 1;
 if (:iis_marked is null) then iis_marked = 0;
 execute procedure WW_IMPORT_CLIENTS_SYNC(:iw3_client_id, 2, :iname, :iur_address, :izkpo, :iis_pdv, :iis_active, :iis_visible_lc);

 select conf.marker from t_configs conf
  where conf.config_id = 2 and
        conf.module = 'store_clients'
   into tmarker;
 if (:tmarker = 'yes') then
 begin
  if (not exists (select * from clients c where c.w3_client_id = :iw3_client_id)) then
  begin
     if (not exists (select g.grpc_id from grpc g where g.grpc_id = 23)) then
         insert into GRPC (GRPC_ID,GRPC_NAME,PREW_GRPC_ID) values (23, 'Постачальники', null);

    tclient_id = gen_id(GEN_CLIENTS_ID, 1);
    insert into clients (clients_id, name, shortname, adress, zkpo, ispdv, typeclient_id,
        is_visible, is_active, is_exist,  w3_client_id, typeprop_id, grpc_id, is_opt)
      values (:tclient_id, :iname, substring(:iname from 1 for 30), :iur_address, :izkpo, :iis_pdv, 2,
        :iis_visible, :iis_active, :iis_exist, :iw3_client_id, :itypeprop_id, 23, 1);
  end
  else
  begin

    begin
   for select clients_id, name, adress, zkpo, ispdv,
              is_visible, is_active, is_exist
         from clients c
        where c.w3_client_id = :iw3_client_id
         into tclient_id, tname, tur_address, tzkpo, tis_pdv,
              tis_visible, tis_active, tis_exist
      do begin
         if ((:tname         <> :iname)          or
             (:tur_address   <> :iur_address)    or
             (:tzkpo         <> :izkpo)          or
             (:tis_pdv       <> :iis_pdv)        or
             (:tis_visible   <> :iis_visible)    or
             (:tis_active    <> :iis_active)     or
             (:tis_exist     <> :iis_exist)        ) then
         begin
            update clients c
              set c.name        = :iname,
                  c.adress      = :iur_address,
                  c.zkpo        = :izkpo,
                  c.ispdv      = :iis_pdv,
                  c.typeclient_id = 2,
                  c.is_visible  = :iis_visible,
                  c.is_active   = :iis_active,
                  c.is_exist    = :iis_exist
            where clients_id = :tclient_id;
         end
     end
   end


  if (:iis_marked = 1) then
  begin
   for select c.typeprop_id, c.ipn, c.numpdv
         from clients c
        where c.w3_client_id = :iw3_client_id
         into ttypeprop_id, tipn, tnum_pdv
      do begin
         if ((:ttypeprop_id  <> :itypeprop_id) or
             (:tipn          <> :iipn)         or
             (:tnum_pdv      <> :inum_pdv)) then
         begin
            update clients c
               set c.typeprop_id = :itypeprop_id,
                   c.ipn         = :iipn,
                   c.numpdv      = :inum_pdv
             where clients_id    = :tclient_id;
         end
     end
   end
  end
 end
end^


ALTER PROCEDURE WW_IMPORT_CLIENTS_V2 (
    IW3_CLIENT_ID INTEGER,
    INAME VARCHAR(50),
    IUR_ADDRESS VARCHAR(50),
    IZKPO VARCHAR(20),
    IIS_PDV SMALLINT,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    ITYPEPROP_ID INTEGER,
    IIS_VISIBLE_LC INTEGER,
    IIS_MARKED INTEGER,
    IIPN VARCHAR(20),
    INUM_PDV VARCHAR(20),
    ICLIENT_TYPE_ID INTEGER)
AS
declare variable tclient_id integer;
declare variable tname varchar(50);
declare variable tur_address varchar(50);
declare variable tzkpo varchar(20);
declare variable tis_pdv smallint;
declare variable tis_visible smallint;
declare variable tis_active smallint;
declare variable tis_exist smallint;
declare variable ttypeprop_id integer;
declare variable tmarker varchar(64);
declare variable tipn varchar(20);
declare variable tnum_pdv varchar(20);
declare variable ttypeclient_id integer;
begin
/*  select c.marker from t_configs c
  where c.config_id = 5 and
        c.module    = 'store_nomen'
   into pmarker;
 */
 if (:iis_pdv is null) then iis_pdv = 1;
 if (:iis_marked is null) then iis_marked = 0;
 execute procedure WW_IMPORT_CLIENTS_SYNC(:iw3_client_id, :iclient_type_id, :iname, :iur_address, :izkpo, :iis_pdv, :iis_active, :iis_visible_lc);

 select conf.marker from t_configs conf
  where conf.config_id = 2 and
        conf.module = 'store_clients'
   into tmarker;
 if (:tmarker = 'yes') then
 begin
  if (not exists (select * from clients c where c.w3_client_id = :iw3_client_id)) then
  begin
     if (not exists (select g.grpc_id from grpc g where g.grpc_id = 23)) then
         insert into GRPC (GRPC_ID,GRPC_NAME,PREW_GRPC_ID) values (23, '?????????????', null);

    tclient_id = gen_id(GEN_CLIENTS_ID, 1);
    insert into clients (clients_id, name, shortname, adress, zkpo, ispdv, typeclient_id,
        is_visible, is_active, is_exist,  w3_client_id, typeprop_id, grpc_id, is_opt)
      values (:tclient_id, :iname, substring(:iname from 1 for 30), :iur_address, :izkpo, :iis_pdv, :iclient_type_id,
        :iis_visible, :iis_active, :iis_exist, :iw3_client_id, :itypeprop_id, 23, 1);
  end
  else
  begin

    begin
   for select clients_id, name, adress, zkpo, ispdv,
              is_visible, is_active, is_exist, typeclient_id
         from clients c
        where c.w3_client_id = :iw3_client_id
         into tclient_id, tname, tur_address, tzkpo, tis_pdv,
              tis_visible, tis_active, tis_exist, ttypeclient_id
      do begin
         if ((:tname         <> :iname)          or
             (:tur_address   <> :iur_address)    or
             (:tzkpo         <> :izkpo)          or
             (:tis_pdv       <> :iis_pdv)        or
             (:tis_visible   <> :iis_visible)    or
             (:tis_active    <> :iis_active)     or
             (:tis_exist     <> :iis_exist)      or
             (:ttypeclient_id<> :iclient_type_id) ) then
         begin
            update clients c
              set c.name        = :iname,
                  c.adress      = :iur_address,
                  c.zkpo        = :izkpo,
                  c.ispdv       = :iis_pdv,
                  c.is_visible  = :iis_visible,
                  c.is_active   = :iis_active,
                  c.is_exist    = :iis_exist,
                  c.typeclient_id = :iclient_type_id
            where clients_id = :tclient_id;
         end
     end
   end


  if (:iis_marked = 1) then
  begin
   for select c.typeprop_id, c.ipn, c.numpdv
         from clients c
        where c.w3_client_id = :iw3_client_id
         into ttypeprop_id, tipn, tnum_pdv
      do begin
         if ((:ttypeprop_id  <> :itypeprop_id) or
             (:tipn          <> :iipn)         or
             (:tnum_pdv      <> :inum_pdv)) then
         begin
            update clients c
               set c.typeprop_id = :itypeprop_id,
                   c.ipn         = :iipn,
                   c.numpdv      = :inum_pdv
             where clients_id    = :tclient_id;
         end
     end
   end
  end
 end
end^


ALTER PROCEDURE WW_IMPORT_GRPS (
    IGRP_ID INTEGER,
    IGRP_NAME VARCHAR(40),
    IPREW_GRP_ID INTEGER,
    IGRP_FULL_NAME VARCHAR(250))
AS
DECLARE VARIABLE TGRP_ID INTEGER;
begin
  select gs.grp_id from t_grps_sync gs
        where gs.grp_id = :igrp_id
    into :tgrp_id;
  if (:tgrp_id is null) then
  begin
    insert into t_grps_sync (grp_id, grp_name, prew_grp_id, grp_fullname)
       values (:igrp_id, :igrp_name, :iprew_grp_id, :igrp_full_name);
  end
  else
  begin
     update t_grps_sync gs
        set gs.grp_name = :igrp_name,
            gs.grp_fullname = :igrp_full_name
       where gs.grp_id = :igrp_id;
  end
end^


ALTER PROCEDURE WW_IMPORT_HAPPY_CHECK (
    OID INTEGER,
    OHAPPY_DATE DATE,
    OHAPPY_TIME TIME,
    OHAPPY_SUM0 DOUBLE PRECISION,
    OHAPPY_SUM1 DOUBLE PRECISION,
    OIS_USED INTEGER,
    OUSE_TIME TIMESTAMP)
AS
begin
  if (not(exists(select * from t_happy_check hc where hc.id = :oid))) then
  begin
    insert into t_happy_check(id, happy_date, happy_time, happy_sum0, happy_sum1, is_used)
             values(:oid, :ohappy_date, :ohappy_time, :ohappy_sum0, :ohappy_sum1, 0);
  end
end^


ALTER PROCEDURE WW_IMPORT_MAKERS (
    IMAKER_ID INTEGER,
    INAME VARCHAR(40))
AS
begin
  if (exists(select * from maker where maker_id = :imaker_id)) then
  begin
    update maker m
       set m.maker_name  = :iname
     where m.maker_id    = :imaker_id and
           m.maker_name != :iname;
  end else
  begin
    insert into maker (maker_id, maker_name, color)
                values (:imaker_id, :iname, null);
  end
end^


ALTER PROCEDURE WW_IMPORT_NOM_BARS (
    IBARCODE_ID INTEGER,
    INOMEN_ID INTEGER,
    IIS_DELETED INTEGER)
AS
declare variable tnom_bar_id integer;
declare variable tnomen_id integer;
begin
   select first(1) nb.nom_bar_id, n.nomen_id
      from nom_bar nb, nomen n
     where nb.barcode_id = :ibarcode_id and
           nb.nomen_id   = n.nomen_id   and
           n.w3_nomen_id = :inomen_id
      into :tnom_bar_id, :tnomen_id;

   if ((:tnom_bar_id is null)and
       (:iis_deleted = 0)) then
   begin
     select first(1) n.nomen_id
       from nomen n
      where n.w3_nomen_id = :inomen_id
       into :tnomen_id;
     if (:tnomen_id is not null) then
     begin
        insert into nom_bar(nomen_id, barcode_id)
       values (:tnomen_id, :ibarcode_id);
     end
   end
   else if ((:tnom_bar_id is not null) and
            (:iis_deleted = 1)) then
   begin
     delete from nom_bar
      where nom_bar_id = :tnom_bar_id;
   end
 end^


ALTER PROCEDURE WW_IMPORT_NOM_BARS_V1 (
    ICODE VARCHAR(27),
    INOMEN_ID INTEGER,
    IIS_DELETED INTEGER)
AS
declare variable tnom_bar_id integer;
declare variable tcode_int bigint;
declare variable tw3_nomen_id integer;
declare variable tnomen_id integer;
declare variable pmarker varchar(64);
declare variable tcount_nom_bar integer;
declare variable tbarcode_id integer;
begin
  begin
    tcode_int = cast(:icode as bigint);
    when any do
    begin
      exit;
    end
  end
/*--- Синхронізація номбарів для зведення ---------*/
   select ns.w3_nomen_id from t_nomens_sync ns
      where ns.w3_nomen_id = :inomen_id
    into tw3_nomen_id;

   if (:tw3_nomen_id is null) then exit;

   select first(1) nb.nom_bar_id
      from t_nom_bars_sync nb
     where nb.code_int = :tcode_int and
           nb.w3_nomen_id = :inomen_id
      into tnom_bar_id;

   if (:tnom_bar_id is null) then
   begin
     insert into t_nom_bars_sync(w3_nomen_id, code_int)
        values (:inomen_id, :tcode_int);
   end
/*--- Синхронізація номбарів ----------------------*/
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module    = 'store_nomen'
    into pmarker;

if ((:pmarker = 'yes')or
    (:pmarker = 'ins_only')or
    (:pmarker = 'upd_exc_name')) then
  begin

    select first(1) n.nomen_id
      from nomen n
     where n.w3_nomen_id = :inomen_id
      into tnomen_id;

    if (:tnomen_id is null) then exit;

    select count(nb.nom_bar_id)
      from nom_bar nb
     where nb.code_int = :tcode_int and
           nb.nomen_id = :tnomen_id
      into tcount_nom_bar;

    if (:tcount_nom_bar = 0) then
    begin
      begin
        select barcode_id
          from barcode
         where code_int = :tcode_int
          into tbarcode_id;
        when any do /*multiple rows*/
        begin
          select first(1) barcode_id
            from barcode
           where code = :icode
            into tbarcode_id;
        end
      end

      if (:tbarcode_id is null) then
      begin
        tbarcode_id = GEN_ID(GEN_BARCODE_ID,1);
        insert into barcode(barcode_id, code)
                 values(:tbarcode_id, :icode);
      end

      insert into nom_bar(nomen_id, barcode_id)
               values (:tnomen_id, :tbarcode_id);
    end
  end
end^


ALTER PROCEDURE WW_IMPORT_NOMEN_PRM (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION)
AS
declare variable pmarker varchar(10);
declare variable pis_in_discount smallint;
begin
  select first(1) c.marker from t_configs c
   where c.config_id = 6 and
         c.module = 'store_nomen'
    into pmarker;

  if (:iis_discount_blocked = 0) then
    pis_in_discount = 1;
  else
    pis_in_discount = 0;

  if (:pmarker = 'yes') then
  begin
    update nomen n
       set n.is_visible   = :iis_visible,
           n.is_active    = :iis_active,
           n.is_exist     = :iis_exist,
           n.is_in_discount = :pis_in_discount
     where n.w3_nomen_id  = :iw3_nomen_id and
           (n.is_visible != :iis_visible or
            n.is_active  != :iis_active  or
            n.is_exist   != :iis_exist   or
            n.is_in_discount != :pis_in_discount);

    if (:iis_out_price_blocked = 1) then
    begin
      update nomen n
         set n.out_price   = :iout_price
       where n.w3_nomen_id = :iw3_nomen_id and
             n.out_price  != :iout_price;
    end
  end
end^


ALTER PROCEDURE WW_IMPORT_NOMEN_PRM_V1 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT)
AS
declare variable pmarker varchar(10);
declare variable pis_in_discount smallint;
begin
  select first(1) c.marker from t_configs c
     where c.config_id = 6 and
          c.module = 'store_nomen'
          into pmarker;
                  
if (:iis_discount_blocked = 0) then
    pis_in_discount = 1;
 else
  pis_in_discount = 0;
                          
if (:pmarker = 'yes') then
  begin
  update nomen n
     set n.is_visible   = :iis_visible,
        n.is_active    = :iis_active,
       n.is_exist     = :iis_exist,
      n.is_in_discount = :pis_in_discount,
     n.category     = :icategory
  where n.w3_nomen_id  = :iw3_nomen_id and
                 (n.is_visible != :iis_visible or
             n.is_active  != :iis_active  or
         n.is_exist   != :iis_exist   or
n.is_in_discount != :pis_in_discount or
         n.category   != :icategory);
 if (:iis_out_price_blocked = 1) then
     begin
       update nomen n
        set n.out_price   = :iout_price
       where n.w3_nomen_id = :iw3_nomen_id and
            n.out_price  != :iout_price;
        end
  end
 end^


ALTER PROCEDURE WW_IMPORT_NOMEN_PRM_V2 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION)
AS
declare variable pmarker varchar(10);
declare variable pis_in_discount smallint;
begin
  select first(1) c.marker from t_configs c
   where c.config_id = 6 and
         c.module = 'store_nomen'
    into pmarker;

  if (:iis_discount_blocked = 0) then
    pis_in_discount = 1;
  else
    pis_in_discount = 0;

  if (:pmarker = 'yes') then
  begin
    update nomen n
       set n.is_visible   = :iis_visible,
           n.is_active    = :iis_active,
           n.is_exist     = :iis_exist,
           n.is_in_discount = :pis_in_discount,
           n.category       = :icategory,
           n.is_markup_block    = :iis_markup_block,
           n.recommended_markup = :irecommended_markup,
           n.is_outprice_block  = :iis_out_price_blocked
     where n.w3_nomen_id  = :iw3_nomen_id and
           (n.is_visible != :iis_visible or
            n.is_active  != :iis_active  or
            n.is_exist   != :iis_exist   or
            n.is_in_discount != :pis_in_discount or
            n.category       != :icategory or
            n.is_markup_block    != :iis_markup_block or
            n.recommended_markup != :irecommended_markup or
            n.is_outprice_block  != :iis_out_price_blocked);

    if (:iis_out_price_blocked = 1) then
    begin
      update nomen n
         set n.out_price   = :iout_price
       where n.w3_nomen_id = :iw3_nomen_id and
             n.out_price  != :iout_price;
    end
  end
end^


ALTER PROCEDURE WW_IMPORT_NOMEN_PRM_V3 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION,
    IACTION_ID SMALLINT,
    IOPT_REST DOUBLE PRECISION)
AS
declare variable pmarker varchar(10) character set win1251;
declare variable pis_in_discount smallint;
declare variable pmarkup_id integer;
declare variable precommended_markup double precision;
declare variable pout_price double precision;
declare variable pnomen_id integer;
declare variable pmarkup_rec_id integer;
declare variable pis_markup_block integer;
declare variable pis_out_price_blocked integer;
begin
  select first(1) c.marker from t_configs c
   where c.config_id = 6 and
         c.module = 'store_nomen'
    into pmarker;

  if ((:pmarker = 'yes')or
      (:pmarker = 'crt_markup')) then
  begin

  select first(1) n.recommended_markup, n.out_price, n.is_outprice_block, n.is_markup_block
    from nomen n
   where n.w3_nomen_id = :iw3_nomen_id
    into precommended_markup, pout_price, pis_out_price_blocked, pis_markup_block;

  if (:icategory is null) then icategory = 0;
  if (:irecommended_markup is null) then irecommended_markup = 0;
  if (:iaction_id is null) then iaction_id = 0;
  if (:iout_price is null) then iout_price = 0;


  if (:iis_discount_blocked = 0) then
    pis_in_discount = 1;
  else
    pis_in_discount = 0;

    update nomen n
       set n.is_visible   = :iis_visible,
           n.is_active    = :iis_active,
           n.is_exist     = :iis_exist,
           n.is_in_discount = :pis_in_discount,
           n.category       = :icategory,
           n.is_markup_block    = :iis_markup_block,
           n.recommended_markup = :irecommended_markup,
           n.is_outprice_block  = :iis_out_price_blocked,
           n.action_id    = :iaction_id,
           n.minkilk =: iopt_rest
     where n.w3_nomen_id  = :iw3_nomen_id and
           (n.is_visible != :iis_visible or
            n.is_active  != :iis_active  or
            n.is_exist   != :iis_exist   or
            n.is_in_discount != :pis_in_discount or
            n.category       != :icategory or
            n.is_markup_block    != :iis_markup_block or
            ((n.recommended_markup != :irecommended_markup)or(n.recommended_markup is null)) or
            n.is_outprice_block  != :iis_out_price_blocked or
            n.action_id  != :iaction_id);

  if (:pmarker = 'yes') then
  begin
    if (:iis_out_price_blocked = 1) then
    begin
      update nomen n
         set n.out_price   = :iout_price
       where n.w3_nomen_id = :iw3_nomen_id and
             n.out_price  != :iout_price;
    end
  end

  if  ((:pmarker = 'crt_markup')and
     (((:iis_out_price_blocked = 1)and(:pout_price != :iout_price)and(:iout_price != 0))or
      ((:iis_markup_block = 1)and(:precommended_markup != :irecommended_markup)and(:irecommended_markup != 0))or
      (:iis_out_price_blocked != :pis_out_price_blocked)or(:iis_markup_block != :pis_markup_block))) then
  begin
    select m.markup_id from t_markups m
     where m.token = 'AUTO'||cast('today' as date) and
           m.is_fixed = 0
      into pmarkup_id;
    if (:pmarkup_id is null) then
    begin
    /*Створення Акту переоцінки*/
      select m_ins.omarkup_id from ps_markup_ins('AUTO'||cast('today' as date)) m_ins
        into pmarkup_id;
    end

    for select n.nomen_id from nomen n join rst r on n.nomen_id = r.nomen_id
         where n.w3_nomen_id = :iw3_nomen_id and
               not(r.rest between -0.0001 and 0.0001)
          into pnomen_id
    do begin
      select mr.markup_record_id from t_markup_records mr
       where mr.nomen_id = :pnomen_id and
             mr.markup_id = :pmarkup_id
        into pmarkup_rec_id;

      if (:pmarkup_rec_id is null) then
      begin
       select mr_ins.omarkup_record_id from ps_markup_record_ins(:pmarkup_id, :pnomen_id, :irecommended_markup, 2) mr_ins
         into pmarkup_rec_id;
      end else
      if (:iis_markup_block = 1) then
      begin
        execute procedure ps_markup_record_around(:pmarkup_rec_id, 2, :irecommended_markup);
      end

      if (:iis_out_price_blocked = 1) then
      begin
       update t_markup_records mr
          set mr.out_price = :iout_price
        where mr.markup_record_id = :pmarkup_rec_id;
      end
    end
  end

  end
end^


ALTER PROCEDURE WW_IMPORT_NOMEN_PRM_V4 (
    IW3_NOMEN_ID INTEGER,
    IIS_VISIBLE SMALLINT,
    IIS_ACTIVE SMALLINT,
    IIS_EXIST SMALLINT,
    IIS_DISCOUNT_BLOCKED SMALLINT,
    IIS_OUT_PRICE_BLOCKED SMALLINT,
    IOUT_PRICE DOUBLE PRECISION,
    ICATEGORY SMALLINT,
    IIS_MARKUP_BLOCK SMALLINT,
    IRECOMMENDED_MARKUP DOUBLE PRECISION,
    IACTION_ID SMALLINT,
    IOPT_REST DOUBLE PRECISION)
AS
declare variable pmarker varchar(10) character set win1251;
declare variable pis_in_discount smallint;
declare variable pmarkup_id integer;
declare variable precommended_markup double precision;
declare variable pout_price double precision;
declare variable pnomen_id integer;
declare variable pmarkup_rec_id integer;
declare variable pis_markup_block integer;
declare variable pis_out_price_blocked integer;
begin
  select first(1) c.marker from t_configs c
   where c.config_id = 6 and
         c.module = 'store_nomen'
    into pmarker;

  if ((:pmarker = 'yes')or
      (:pmarker = 'crt_markup')) then
  begin

  select first(1) n.recommended_markup, n.out_price, n.is_outprice_block, n.is_markup_block
    from nomen n
   where n.w3_nomen_id = :iw3_nomen_id
    into precommended_markup, pout_price, pis_out_price_blocked, pis_markup_block;

  if (:icategory is null) then icategory = 0;
  if (:irecommended_markup is null) then irecommended_markup = 0;
  if (:iaction_id is null) then iaction_id = 0;
  if (:iout_price is null) then iout_price = 0;


  if (:iis_discount_blocked = 0) then
    pis_in_discount = 1;
  else
    pis_in_discount = 0;

    update nomen n
       set n.is_visible   = :iis_visible,
           n.is_active    = :iis_active,
           n.is_exist     = :iis_exist,
           n.is_in_discount = :pis_in_discount,
           n.category       = :icategory,
           n.is_markup_block    = :iis_markup_block,
           n.recommended_markup = :irecommended_markup,
           n.is_outprice_block  = :iis_out_price_blocked,
           n.action_id    = :iaction_id,
           n.minkilk =: iopt_rest
     where n.w3_nomen_id  = :iw3_nomen_id and
           (n.is_visible != :iis_visible or
            n.is_active  != :iis_active  or
            n.is_exist   != :iis_exist   or
            n.is_in_discount != :pis_in_discount or
            n.category       != :icategory or
            n.is_markup_block    != :iis_markup_block or
            ((n.recommended_markup != :irecommended_markup)or(n.recommended_markup is null)) or
            n.is_outprice_block  != :iis_out_price_blocked or
            n.action_id  != :iaction_id);

  if (:pmarker = 'yes') then
  begin
    if (:iis_out_price_blocked = 1) then
    begin
      update nomen n
         set n.out_price   = :iout_price
       where n.w3_nomen_id = :iw3_nomen_id and
             n.out_price  != :iout_price;
    end
  end

  if  ((:pmarker = 'crt_markup')and
     (((:iis_out_price_blocked = 1)and(:pout_price != :iout_price)and(:iout_price != 0))or
      ((:iis_markup_block = 1)and(:precommended_markup != :irecommended_markup)and(:irecommended_markup != 0))or
      (:iis_out_price_blocked != :pis_out_price_blocked)or(:iis_markup_block != :pis_markup_block))) then
  begin
    select m.markup_id from t_markups m
     where m.token = 'AUTO'||cast('today' as date) and
           m.is_fixed = 0
      into pmarkup_id;
    if (:pmarkup_id is null) then
    begin
    /*Створення Акту переоцінки*/
      select m_ins.omarkup_id from ps_markup_ins('AUTO'||cast('today' as date)) m_ins
        into pmarkup_id;
    end

    for select n.nomen_id from nomen n join rst r on n.nomen_id = r.nomen_id
         where n.w3_nomen_id = :iw3_nomen_id and
               not(r.rest between -0.0001 and 0.0001)
          into pnomen_id
    do begin
      select mr.markup_record_id from t_markup_records mr
       where mr.nomen_id = :pnomen_id and
             mr.markup_id = :pmarkup_id
        into pmarkup_rec_id;

      if (:pmarkup_rec_id is null) then
      begin
       select mr_ins.omarkup_record_id from ps_markup_record_ins(:pmarkup_id, :pnomen_id, :irecommended_markup, 2) mr_ins
         into pmarkup_rec_id;
      end else
      if (:iis_markup_block = 1) then
      begin
        execute procedure ps_markup_record_around(:pmarkup_rec_id, 2, :irecommended_markup);
      end

      if (:iis_out_price_blocked = 1) then
      begin
       update t_markup_records mr
          set mr.out_price = :iout_price
        where mr.markup_record_id = :pmarkup_rec_id;
      end
    end
  end

  end
end^


ALTER PROCEDURE WW_IMPORT_NOMENS (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER)
AS
declare variable tname varchar(40);
declare variable tekka_name varchar(26);
declare variable tis_visible smallint;
declare variable tnetto double precision;
declare variable tsi_id integer;
declare variable tsg_id integer;
declare variable ttypepdv_id integer;
declare variable tis_dividend integer;
declare variable tnomen_id integer;
declare variable tnomen_count integer;
declare variable tminkilk double precision;
declare variable tis_active smallint;
declare variable tdecrease_id integer;
declare variable pmarker varchar(64);
begin
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module    = 'store_nomen'
    into pmarker;

if ((:pmarker = 'yes')or
    (:pmarker = 'ins_only')or
    (:pmarker = 'upd_exc_name')) then
begin
 select count(n.nomen_id)
   from nomen n
  where n.w3_nomen_id = :iw3_nomen_id
   into :tnomen_count;

 if (:tnomen_count = 0) then
 begin
    tnomen_id = GEN_ID(GEN_NOMEN_ID, 1);
    insert into nomen (nomen_id, nomen_name, datex_name, typepdv_id, is_weight,
          brutto, si_id, out_price, grp_id, sg_id, minkilk, is_active,
          is_visible, decrease_id, w3_nomen_id)
      values (:tnomen_id, :iname, :iekka_name, :itypepdv_id, :iis_dividend,
          :inetto, :isi_id, 1.00, 1, :isg_id, :iminkilk, :iis_active,
          /*:iis_visible*/ 0, :idecrease_id, :iw3_nomen_id);
 end
 else /* if (:tnomen_count = 0)*/
 begin
   if (:pmarker = 'yes') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into :tname, :tekka_name, :ttypepdv_id, :tis_dividend,
              :tnetto, :tsi_id, :tsg_id, :tminkilk, :tis_active, :tis_visible,
            :tdecrease_id;

        if ((:tname        <> :iname)           or
            (:tekka_name    <> :iekka_name)     or
            (:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
        /* (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.nomen_name  = :iname,
                 n.datex_name  = :iekka_name,
                 n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end else
 if (:pmarker = 'upd_exc_name') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into :tname, :tekka_name, :ttypepdv_id, :tis_dividend,
              :tnetto, :tsi_id, :tsg_id, :tminkilk, :tis_active, :tis_visible,
            :tdecrease_id;

        if ((:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
        /*    (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end
 end
end
end^


ALTER PROCEDURE WW_IMPORT_NOMENS_1 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    IMAKER_ID INTEGER)
AS
declare variable tname varchar(40);
declare variable tekka_name varchar(26);
declare variable tis_visible smallint;
declare variable tnetto double precision;
declare variable tsi_id integer;
declare variable tsg_id integer;
declare variable ttypepdv_id integer;
declare variable tis_dividend integer;
declare variable tnomen_id integer;
declare variable tnomen_count integer;
declare variable tminkilk double precision;
declare variable tis_active smallint;
declare variable tdecrease_id integer;
declare variable pmarker varchar(64);
declare variable tmaker_id integer;
begin
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module    = 'store_nomen'
    into pmarker;

if ((:pmarker = 'yes')or
    (:pmarker = 'ins_only')or
    (:pmarker = 'upd_exc_name')) then
begin
 select count(n.nomen_id)
   from nomen n
  where n.w3_nomen_id = :iw3_nomen_id
   into :tnomen_count;

 if (:tnomen_count = 0) then
 begin
    tnomen_id = GEN_ID(GEN_NOMEN_ID, 1);
    insert into nomen (nomen_id, nomen_name, datex_name, typepdv_id, is_weight,
          brutto, si_id, out_price, grp_id, sg_id, minkilk, is_active,
          is_visible, decrease_id, w3_nomen_id, maker_id)
      values (:tnomen_id, :iname, :iekka_name, :itypepdv_id, :iis_dividend,
          :inetto, :isi_id, 1.00, 1, :isg_id, :iminkilk, :iis_active,
          /*:iis_visible*/ 0, :idecrease_id, :iw3_nomen_id, :imaker_id);
 end
 else /* if (:tnomen_count = 0)*/
 begin
   if (:pmarker = 'yes') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.maker_id
         from nomen n
        where n.w3_nomen_id = :iw3_nomen_id
         into tname, tekka_name, ttypepdv_id, tis_dividend,
              tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
              tdecrease_id, tmaker_id;

        if ((:tname         <> :iname)          or
            (:tekka_name    <> :iekka_name)     or
            (:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
            (:tmaker_id     <> :imaker_id)      or
        /* (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.nomen_name  = :iname,
                 n.datex_name  = :iekka_name,
                 n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
                 n.maker_id    = :imaker_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end else
 if (:pmarker = 'upd_exc_name') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.maker_id
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into tname, tekka_name, ttypepdv_id, tis_dividend,
             tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
             tdecrease_id, tmaker_id;

        if ((:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
            (:tmaker_id     <> :imaker_id)      or
        /*    (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
                 n.maker_id    = :imaker_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end
 end
end
end^


ALTER PROCEDURE WW_IMPORT_NOMENS_2 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    IMAKER_ID INTEGER,
    ICODE VARCHAR(7),
    IGRP_ID INTEGER)
AS
declare variable tname varchar(40);
declare variable tekka_name varchar(26);
declare variable tis_visible smallint;
declare variable tnetto double precision;
declare variable tsi_id integer;
declare variable tsg_id integer;
declare variable ttypepdv_id integer;
declare variable tis_dividend integer;
declare variable tnomen_id integer;
declare variable tnomen_count integer;
declare variable tminkilk double precision;
declare variable tis_active smallint;
declare variable tdecrease_id integer;
declare variable pmarker varchar(64);
declare variable tmaker_id integer;
begin
  execute procedure WW_IMPORT_NOMENS_V1 (iw3_nomen_id, iname, iekka_name, icode, igrp_id);
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module    = 'store_nomen'
    into pmarker;

if ((:pmarker = 'yes')or
    (:pmarker = 'ins_only')or
    (:pmarker = 'upd_exc_name')) then
begin
 select count(n.nomen_id)
   from nomen n
  where n.w3_nomen_id = :iw3_nomen_id
   into :tnomen_count;

 if (:tnomen_count = 0) then
 begin
    tnomen_id = GEN_ID(GEN_NOMEN_ID, 1);
    insert into nomen (nomen_id, nomen_name, datex_name, typepdv_id, is_weight,
          brutto, si_id, out_price, grp_id, sg_id, minkilk, is_active,
          is_visible, decrease_id, w3_nomen_id, maker_id)
      values (:tnomen_id, :iname, :iekka_name, :itypepdv_id, :iis_dividend,
          :inetto, :isi_id, 1.00, 1, :isg_id, :iminkilk, :iis_active,
          /*:iis_visible*/ 0, :idecrease_id, :iw3_nomen_id, :imaker_id);
 end
 else /* if (:tnomen_count = 0)*/
 
 
 begin
   if (:pmarker = 'yes') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.maker_id
         from nomen n
        where n.w3_nomen_id = :iw3_nomen_id
         into tname, tekka_name, ttypepdv_id, tis_dividend,
              tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
              tdecrease_id, tmaker_id;

        if ((:tname         <> :iname)          or
            (:tekka_name    <> :iekka_name)     or
            (:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
            (:tmaker_id     <> :imaker_id)      or
        /* (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.nomen_name  = :iname,
                 n.datex_name  = :iekka_name,
                 n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
                 n.maker_id    = :imaker_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end else
 if (:pmarker = 'upd_exc_name') then

    begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.maker_id
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into tname, tekka_name, ttypepdv_id, tis_dividend,
             tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
             tdecrease_id, tmaker_id;

        if ((:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
            (:tmaker_id     <> :imaker_id)      or
        /*    (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id))  then
        begin
           update nomen n
             set n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
                 n.maker_id    = :imaker_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id
           where w3_nomen_id = :iw3_nomen_id;
        end
 end
 end
end
end^


ALTER PROCEDURE WW_IMPORT_NOMENS_V1 (
    INOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ICODE VARCHAR(7),
    IGRP_ID INTEGER)
AS
DECLARE VARIABLE TW3_NOMEN_ID INTEGER;
DECLARE VARIABLE TNAME VARCHAR(40);
DECLARE VARIABLE TEKKA_NAME VARCHAR(26);
DECLARE VARIABLE TNOMEN_ID INTEGER;
DECLARE VARIABLE TCODE VARCHAR(7);
DECLARE VARIABLE TGRP_ID INTEGER;
DECLARE VARIABLE TGRP_ID_EX INTEGER;
begin
  select n.w3_nomen_id, n.name, n.ekka_name, n.code, n.grp_id
      from t_nomens_sync n
        where n.w3_nomen_id = :inomen_id
    into :tw3_nomen_id, :tname, :tekka_name, :tcode, :tgrp_id;

  select gs.grp_id from t_grps_sync gs
      where gs.grp_id = :igrp_id
    into :tgrp_id_ex;

  if (:tgrp_id_ex is null) then
    tgrp_id_ex = 12;

  if (:tw3_nomen_id is null) then
  begin
    insert into t_nomens_sync (w3_nomen_id, name, ekka_name, code, grp_id)
      values (:inomen_id, :iname, :iekka_name, :icode, :tgrp_id_ex);
  end
  else
  begin
    if ((:tname <> :iname) or
        (:tekka_name <> :iekka_name) or
        (:tcode <> :icode) or
        (:tgrp_id <> :igrp_id)) then
    begin
      update t_nomens_sync n
        set name = :iname,
            ekka_name = :iekka_name,
            grp_id = :tgrp_id_ex,
            code = :icode
        where w3_nomen_id = :inomen_id;
    end
  end

end^


ALTER PROCEDURE WW_IMPORT_NOMENS_V2 (
    IW3_NOMEN_ID INTEGER,
    INAME VARCHAR(40),
    IEKKA_NAME VARCHAR(26),
    ITYPEPDV_ID INTEGER,
    IIS_DIVIDEND INTEGER,
    INETTO DOUBLE PRECISION,
    ISI_ID INTEGER,
    ISG_ID INTEGER,
    IMINKILK DOUBLE PRECISION,
    IIS_ACTIVE SMALLINT,
    IIS_VISIBLE SMALLINT,
    IDECREASE_ID INTEGER,
    IFLAG_0 INTEGER,
    ICATEGORY SMALLINT)
AS
declare variable tname varchar(40);
declare variable tekka_name varchar(26);
declare variable tis_visible smallint;
declare variable tnetto double precision;
declare variable tsi_id integer;
declare variable tsg_id integer;
declare variable ttypepdv_id integer;
declare variable tis_dividend integer;
declare variable tnomen_id integer;
declare variable tnomen_count integer;
declare variable tminkilk double precision;
declare variable tis_active smallint;
declare variable tdecrease_id integer;
declare variable pmarker varchar(64);
declare variable tcategory smallint;
begin
  select c.marker from t_configs c
   where c.config_id = 5 and
         c.module    = 'store_nomen'
    into pmarker;

if ((:pmarker = 'yes')or
    (:pmarker = 'ins_only')or
    (:pmarker = 'upd_exc_name')) then
begin
 select count(n.nomen_id)
   from nomen n
  where n.w3_nomen_id = :iw3_nomen_id
   into :tnomen_count;

 if (:tnomen_count = 0) then
 begin
    tnomen_id = GEN_ID(GEN_NOMEN_ID, 1);
    insert into nomen (nomen_id, nomen_name, datex_name, typepdv_id, is_weight,
          brutto, si_id, out_price, grp_id, sg_id, minkilk, is_active,
          is_visible, decrease_id, w3_nomen_id, category)
      values (:tnomen_id, :iname, :iekka_name, :itypepdv_id, :iis_dividend,
          :inetto, :isi_id, 1.00, 1, :isg_id, :iminkilk, :iis_active,
          /*:iis_visible*/ 0, :idecrease_id, :iw3_nomen_id, :icategory);
 end
 else /* if (:tnomen_count = 0)*/
 begin
   if (:pmarker = 'yes') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.category
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into tname, tekka_name, ttypepdv_id, tis_dividend,
             tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
             tdecrease_id, tcategory;

        if ((:tname        <> :iname)           or
            (:tekka_name    <> :iekka_name)     or
            (:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
        /* (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id)or
            (:tcategory     <> :icategory))  then
        begin
           update nomen n
             set n.nomen_name  = :iname,
                 n.datex_name  = :iekka_name,
                 n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id,
                 n.category    = :icategory
           where w3_nomen_id = :iw3_nomen_id;
        end
 end else
 if (:pmarker = 'upd_exc_name') then
   begin
       select first(1) n.nomen_name, n.datex_name, n.typepdv_id, n.is_weight,
              n.brutto, n.si_id, n.sg_id, n.minkilk, n.is_active, n.is_visible,
              n.decrease_id, n.category
         from nomen n
       where n.w3_nomen_id = :iw3_nomen_id
        into tname, tekka_name, ttypepdv_id, tis_dividend,
             tnetto, tsi_id, tsg_id, tminkilk, tis_active, tis_visible,
             tdecrease_id, tcategory;

        if ((:ttypepdv_id   <> :itypepdv_id)    or
            (:tis_dividend  <> :iis_dividend)   or
            (:tnetto        <> :inetto)         or
            (:tsi_id        <> :isi_id)         or
            (:tsg_id        <> :isg_id)         or
        /*    (:tminkilk      <> :iminkilk)       or
        /*(:tis_active  <> :iis_active) or
        (:tis_visible   <> :iis_visible)*/
            (:tdecrease_id  <> :idecrease_id)or
            (:tcategory     <> :icategory))  then
        begin
           update nomen n
             set n.typepdv_id  = :itypepdv_id,
                 n.is_weight   = :iis_dividend,
                 n.brutto      = :inetto,
                 n.si_id       = :isi_id,
                 n.sg_id       = :isg_id,
          /*       n.minkilk     = :iminkilk,
         /*     n.is_active   = :iis_active,
              n.is_visible  = :iis_visible, */
                 n.decrease_id = :idecrease_id,
                 n.category    = :icategory
           where w3_nomen_id = :iw3_nomen_id;
        end
 end
 end
end
end^


ALTER PROCEDURE WW_IMPORT_PROPERTYS (
    ITYPEPROP_ID INTEGER,
    INAME VARCHAR(40),
    ISHORT_NAME VARCHAR(10))
AS
begin
  if (exists (select p.typeprop_id from typeprop p where p.typeprop_id = :itypeprop_id)) then
    update typeprop p
        set p.name = :iname,
            p.short_name = :ishort_name
      where p.typeprop_id = :itypeprop_id;
  else
    insert into typeprop(typeprop_id, name, short_name)
         values (:itypeprop_id, :iname, :ishort_name);
end^


ALTER PROCEDURE WW_IMPORT_SYNC_TS (
    ITS_DOCUMENTS DATE,
    ITS_DOCREC DATE,
    ITS_GOODS DATE,
    ITS_DOCGOODS DATE,
    ITS_DEL_DOCGOODS DATE,
    ITS_DEL_DOCREC DATE,
    ITS_DEL_GOODS DATE,
    ITS_DEL_DOCUMENTS DATE,
    ITS_CHECK DATE)
AS
begin
  insert into t_sync_ts(ts_documents, ts_docrec, ts_goods, ts_docgoods, ts_del_docgoods, ts_del_docrec, ts_del_goods, ts_del_documents, ts_hight, ts_check)
         values(:its_documents, :its_docrec, :its_goods, :its_docgoods, :its_del_docgoods, :its_del_docrec, :its_del_goods, :its_del_documents, 'now', :its_check);
end^



SET TERM ; ^

GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON AO_RECORDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON AUTH TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON AUTOORDERS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON BANKS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON BARCODE TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON CITIES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON CLIENTACCOUNT TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON CLIENTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DISCONT TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DISCONT_AUTO TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DISC_LIST TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCGOODS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCREC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCREC_DEL TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCREC_LOG TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCREC_TMP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOCUMENTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON DOC_DEL TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON E1C_LOG_CREDDOCS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON E1C_LOG_DEBDOCS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON E1C_LOG_DRAFTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON GOODS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON GRP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON GRPC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$LOG_BLOB_FIELDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$LOG_FIELDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$LOG_KEYS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$LOG_TABLES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$REPORTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$SCRIPTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON IBE$VERSION_HISTORY TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON JOBS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON KARDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON KASSES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON MAKER TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON MANAGER TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON NOMEN TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON NOM_BAR TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON NOM_KAS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON OBJECTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON PAYMENT TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON PRICE TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON PRICEJOURNAL TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON REESTR TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON REGIONS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON REVISION TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON REV_RECORDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON REV_TMP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON RST TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON SI TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON SPECIALS_GROUPS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON STAFF TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON STATES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TYPECLIENT TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TYPEDOC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TYPEPAY TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TYPEPDV TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON TYPEPROP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_1C_LOG TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_1C_PERIODICS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_ACCESS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_ACTION TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_BARCODE_TYPES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CALCULATIONS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CALC_RECORDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CATEGORIES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CLIENTS_SYNC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CLIENTS_TMP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_CONFIGS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_COUPON_ARTICLES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_COUPON_DISCOUNTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_COUPON_PROPS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_COUPON_UNITS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DECREASE TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DECR_TYPE TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DEL_DOCGOODS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DEL_DOCRECS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DEL_DOCUMENTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DEL_GOODS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DOCUMENTS_PRM TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DOCUMENT_AUTOORDER TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DOC_PROP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_DR_PROP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_GRPS_SYNC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_HAPPY_CHECK TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_INVOICES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_INVOICE_TYPES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_KARDS_ZVIT_LOG TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_MARKUPS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_MARKUP_AROUNDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_MARKUP_RECORDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_NOMENS_LOG TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_NOMENS_SYNC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_NOMEN_PARAMS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_NOM_BARS_SYNC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PACTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PAKAGES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PAYMENTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PAYMENT_RECS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PAYS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_POSTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PRODUCTION_DOCS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_PRODUCTION_RECS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_REC_FILLINGS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_REPORTCAPTIONS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_REPORTFIELDS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_REPORTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_RIGHTS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_RIGHTS_GRP TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_ROLL_TAX TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_SCALES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_SIS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_SYNC_TS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_TMP_NOMENS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_TMP_NOMEN_GROUPS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_TMP_NOM_BAR TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_TYPE_PRODUCT_DOC TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_TYPE_SCALES TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON T_USERS TO "PUBLIC";
GRANT SELECT, INSERT, UPDATE, DELETE, REFERENCES ON WEIGHT_CODE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AO_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AO_RECORD_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AUTOORDERS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AUTOORDER_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AUTOORDER_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AUTOORDER_UPDATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_AUTOORDER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_CORECTED_GEN_AO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_CORECTED_GEN_AOR TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_GRP_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AOG_NOMEN_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AUTO_KARD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE AVTO_KLIENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE CREATE_DOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE DROP_P_REYESTR_POD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE DROP_S_DOCREC_VIEW_NAKL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE DROP_S_ROLLTAXDOCS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE E1C_CREDDOCS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE E1C_DEBDOCS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE E1C_DRAFTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE E1C_DRAFTS_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE E1C_INIT_LD_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE GET_USER_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE HAS_USER_RIGHT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_BAK_FOR_DATEX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CHECK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CHECK_ART TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CLOSE_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CLOSE_DOCUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CLOSE_DOCUMENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_COUPONS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CREATE_BAK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CREATE_BAK_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CREATE_DOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_CREATE_DOC_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DEL_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DEL_DOCREC_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DISCONT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DISCONT_HARD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOCREC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOCREC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOCUMENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOC_REC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOC_SUM_ALL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_DOC_SUM_ALL_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_EXP_RST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_INS_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_INS_DOCREC_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_LAST_DOCUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_LIST_DOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_LIST_DOC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_NOMEN_REST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SEL_TOVAR_BY_CODE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SEL_TOVAR_BY_NAME TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SEL_TOVAR_BY_NAME_FILTER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SEL_TOVAR_BY_NOMEN_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SET_COUPON TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SET_DISCONT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_CLOSE_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_CLOSE_DOCUMENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_EXP_CHECKS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_EXP_CHECK_RECS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOCREC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOCREC_LOG TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOCREC_TMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOCUMENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_SYNC_IMP_DOC_REC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_UPD_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE KAS_UPD_DOCREC_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_ADMIN_RIGHTS_SET TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GET_USER_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GROUPS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GROUP_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GROUP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GROUP_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_GROUP_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_HAS_USER_ACCESS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_HAS_USER_ACCESS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USERS_FROM_GROUP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USERS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USER_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USER_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USER_INS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USER_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PA_USER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_CITY_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_CITY_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_CLIENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_CLIENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_POSTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_POST_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_POST_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_POST_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_REGION_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_REGION_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_REGION_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_STATE_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_STATE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PC_STATE_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_LOG_EDIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_PERIODICS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_PERIODIC_ADD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_SUMS_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_SUMS_1_WITHOUT_PDV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_SUMS_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PE_1C_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_BARCODES_VIEW_IMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_ISBLOCK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_NOMENS_VIEW_IMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_NOM_BARS_VIEW_IMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REVISIONS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REVISIONS_VIEW_IMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REVISION_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REVISION_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REVISION_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REV_RECORDS_VIEW_IMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PRV_REV_RECORD_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_CALCULATION TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_CLIENT_HEADER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DEBITORKA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DEBITORKA_CLNT_FULL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DEBITORKA_FULL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DISCOUNT_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DOCREC_SUM_TYPY_PDV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DOCUMENTS_PERIOD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DOCUMENTS_PERIOD_HEADER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_DOC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_INVOICE_PAYS_DEBT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_INVOICE_PAYS_KRED TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_KARDS_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_KREDITORKA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_KREDITORKA_CLNT_FULL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_KREDITORKA_FULL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_LIGHTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_LIST_CHARGES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_MAKER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NILSEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NILSEN_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMENREPORT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMENREPORT_MARKUPS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMENSRESTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMENZVIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMEN_REV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_NOMEN_WITH_BARCODE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASETYPEPDV_BYGROUP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_MAKER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NILSEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN_ACTION TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN_HEADER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN_PERIOD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_NOMEN_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_RALASE_SALES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_REGISTER_INVOICES_OUT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_REPORTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_REPORT_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PR_REVISION_LIST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_ACCOUNTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_ACCOUNT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_ACCOUNT_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_CREATE_TD1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_CREATE_TD1_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_DEL_REPEAT_RECS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_DEL_ZERO_RECS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORDS_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORDS_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORD_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORD_GRP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORD_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AO_RECORD_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDERS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_FIX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_HEADER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_AUTOORDER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_BANK_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_BANK_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_BARCODES_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_BARCODE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_BARCODE_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATIONS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_HEADER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALCULATION_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALC_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALC_RECORD_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALC_RECORD_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALC_RECORD_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CALC_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_LINK_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_SYNC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_SYNC_VIEW_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_TMP_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENTS_VIEW_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_INS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_INS_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_INS_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_SYNC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_TMP_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_TMP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_TMP_LIKE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_TMP_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_TMP_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_UNITE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_UNITE_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_CLIENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_ARTICLE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_DISCOUNT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_PROP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_PROP_STATUS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_RECALC_QUANTITY TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_SALES_EXPORT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_SHOPS_EXPORT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_COUPON_UNIT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DECREASES_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DECREASE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD10_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD10_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD10_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD15_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD15_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD15_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD17_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD17_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD17_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD17_UPD_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD1_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD1_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD1_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD2_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD2_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD2_INS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD2_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD2_UPD_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD4_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD6_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD6_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD6_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD7_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD7_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCREC_TD7_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENTS_BY_NOMEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENTS_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENTS_PRICES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_CREATE_LIKE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_FIX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_INS_OR_UPD_TD16 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_LIKE_TYPES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_NUMBER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_RECORDS_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_RECORD_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_TD1_GRP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_UNITE_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOCUMENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOC_AUTOORDERS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_DOC_HEADER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_GET_ALL_SUMS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_GET_HAPPY_CHECK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_GET_ORDERED TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_GET_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_GET_YESNO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_INPRICE_BY_DATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_KARDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_KARD_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_KARD_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_KARD_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_KARD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LC_DOCREC_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LC_DOC_HEADER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LC_PACT_HEADER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LIABLE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LIGHT_INS_OR_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LINK_CLIENT_SYNC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_LINK_NOMEN_SYNC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MAKER_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUPS_PRICES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUPS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_DOCUMENT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_DOCUMENT_INS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORDS_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_AROUND TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_RECORD_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MARKUP_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MOVING_BY_CLIENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MOVING_BY_KARD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_MOVING_BY_NOMEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_LINK_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_LINK_VIEW_0 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_LINK_VIEW_1_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_LINK_VIEW_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_PRICES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_SYNC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_SYNC_VIEW_0 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_SYNC_VIEW_1_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_SYNC_VIEW_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_0 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_0_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_0_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_1_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_1_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_1_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_2_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_2_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENS_VIEW_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMENZVIT_P1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_BY_GRUP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_DETAIL_GOODS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS_V4 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_INS_V5 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIKE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LINK_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_RECORD_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_0 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_0_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_0_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_1_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_1_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_1_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_2_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_2_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_LIST_VIEW_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_SYNC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_UNITE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_UNITE_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_VIEW_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_NOMEN_VIEW_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PACTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PACT_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PACT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PACT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_RECORD_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_RECS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_REC_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_REC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYMENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYS_RECALC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAYS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAY_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAY_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAY_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PAY_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_CLIENTS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_CLIENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_DECREASE_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_LIABLES_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_LIABLE_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_MAKERS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_POPUP_MAKER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRICE_BY_DATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRICE_JOURNAL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOCREC_PRINT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOCS_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOCS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_FIX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_HEADER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_DOC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_RECS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_REC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_REC_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_REC_INFO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCTION_REC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCT_REC_SET_COUNT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCT_REC_TD1_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCT_REC_TD2_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_PRODUCT_REC_TD2_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REALIS_BY_DOCUMENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REALIS_BY_DOCUMENT_SG TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_RECULC_GRP_FULLNAME TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_RECULC_GRP_FULLNAMES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REC_FILLINGS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REC_FILLING_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REC_FILLING_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REC_FILLING_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REC_FILLING_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISIONS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISIONS_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_FIX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_NOMEN_EXPORT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_NOMEN_IMPORT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_VIEW_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVISION_VIEW_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REVVISION_DETAIL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REV_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REV_RECORD_GRP_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REV_RECORD_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REV_RECORD_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_REV_REC_CRY TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_ROLL_TAX_ADD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_ROLL_TAX_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_SCALES_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_SCALE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_SLIV_MINUSOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_SW_HEADER_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TD10_CORRECT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_BARCODES_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_BARCODE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_BARCODE_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMENS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMEN_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMEN_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMEN_LIKE_INS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMEN_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TMP_NOMEN_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TRAFFIC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PS_TRAFFIC_DIM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE PW_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_HAS_USER_ACCESS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_INVOICES_LIST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_IS_ACCESS_GRANDED TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_REESTR_ADD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_REEST_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_REYESTR_POD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_SELECT_ACCESS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE P_STAFF_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RC_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RC_RALASE_DR TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RC_RALASE_DR_MANAGER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RC_RALASE_INMINUS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RC_RALASE_VIDPOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RP_PRICE_GRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RP_PRICE_INGRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RP_PRICE_JOURNAL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_RALASE_GOOD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_RALASE_GRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_RALASE_INGRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_RALASE_NOMEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RR_REST_PERIOD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_ACTION_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_DOCUMENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_PROFITABILITY_REST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_ABC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_ABC_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_ABC_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_ABC_3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_COPY TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_LIST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_LIST_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_MANAGER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_MANAGER_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_SG TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_SG_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RS_RALASE_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RV_RALASE_GOOD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RV_RALASE_GRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RV_RALASE_INGRP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE RV_RALASE_NOMEN TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_CLIENT_DOC_LIST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_DOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_DOCSUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_NAKL_N TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_TOVARINDOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE R_ZVITPROP_DETAL_K TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE SP_CINA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_AUTH_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_BARCODE_ATTACH TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_BARCODE_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_BARCODE_DELETE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_CINNIK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_CINNIK_PEREOCINKA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_CLIENT_UNIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCGOODS_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCGOODS_VIEW_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_CLIUPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_KILKUPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_PRICEUPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_UPDATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_VIEW_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_VIEW_G TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_VIEW_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOCREC_VIEW_NAKL1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_CINNIK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_CLOSE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_DELETE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_LOCK_PREPARE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_SET_EXTRA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_VIEW_G TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_VIEW_ID TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_DOC_VIEW_ID_N TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_FAKTURA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_GET_NOMCODE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_GRP_CHILDS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_KILLER_MINUSOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_KILLER_SELECT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_KILL_MINEX TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_MAKER_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_MAKER_UPDATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_NAC_DOC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_NAC_DOCREC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PAYMENT_SUMMA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PAYMENT_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PRICE_EDIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PRN_FAKTURA TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PRN_RECEIPT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_PRN_RECEIPT_DTL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_RECALC_MINUSOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_RECEIPT_CLIENT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_REV_RECORDS_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_RT_DOCREC_SUM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_RT_DOCS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_RT_UPDATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_SEL_TOVAR_BY_CODE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_SLIV_MINUSOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_SLIV_MINUSOV_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_SLIV_MINUSOV_FULL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE S_STAFF_VIEW TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TMP_FIX_DR6 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_DEL_BAD_CLIENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_INIT_PJ TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_MOVE_REST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_NULL_DG TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_NULL_DR TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_NULL_RST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_RECALC_REST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_RECALC_RST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_SET_CURENT_CLIENTS_TYPE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_SET_TS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_SET_W3_CLIENTS_ID_BY_ZKPO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_SLIV_MINUSOV TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE TOOLS_UNITE_CLIENTS_BY_ZKPO TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_DOCREC_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_DOC_CREATE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRPC_CHILDS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRPC_CREATE_CHILD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRPC_DELETE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRPC_FULLNAME TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CHILDS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CHILDS_CHILDS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CHILDS_LINK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CHILDS_LIST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CHILDS_SHELFS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CREATE_CHILD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_CREATE_CHILD_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_DELETE TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_FULLNAME TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_IS_LAST_LEVEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_MANAGER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_GRP_RECALC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE T_IMPORT_GOODS_VOL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_CHECK_MARKUP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_CLIENTS_TMP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DEACTIVATE_CLIENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_DR TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_DR_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_DR_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_RECURSION TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_RST TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DINAMICS_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DOCUMENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DOC_HDR TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_DOC_REC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_STATICS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_STATICS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_CHECKS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DEL_DOCGOODS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DEL_DOCRECS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DEL_DOCUMENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DEL_GOODS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DOCGOODS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DOCRECS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_DOCUMENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_GOODS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_LOG TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_LOG_DISC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_LOG_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_SYNC_SEANS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_TMP_NOMENS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_EXPORT_TMP_NOM_BARS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_AO_RECORDS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_AUTOORDERS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_BARCODES TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_CLIENTS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_CLIENTS_DEL TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_CLIENTS_SYNC TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_CLIENTS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_CLIENTS_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_GRPS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_HAPPY_CHECK TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_MAKERS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMENS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMENS_1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMENS_2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMENS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMENS_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMEN_PRM TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMEN_PRM_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMEN_PRM_V2 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMEN_PRM_V3 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOMEN_PRM_V4 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOM_BARS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_NOM_BARS_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_PROPERTYS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE WW_IMPORT_SYNC_TS TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_DISCONT_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_GROUP_ZVIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_GROUP_ZVIT_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_IMPORT_MAKER TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_KARDS_EXP TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_KARDS_UPD TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_KARDS_ZVIT TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_KARDS_ZVIT_V1 TO "PUBLIC";
GRANT EXECUTE ON PROCEDURE W_RALASE_ZVIT TO "PUBLIC";

/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE AUTOORDERS
'Шапки автоматичного замовлення товару';

DESCRIBE TABLE T_CALCULATIONS
'Таблиця калькуляцій.';

DESCRIBE TABLE T_CLIENTS_SYNC
'Таблиця котра містить клієнтів ЦБД';

DESCRIBE TABLE T_CLIENTS_TMP
'Таблиця котра містить специфікації нових клієнтів ЦБД, або запит на зміну характеристик існуючих';

DESCRIBE TABLE T_COUPON_ARTICLES
'Таблиця із описом товарів, який бере участь у акції';

DESCRIBE TABLE T_COUPON_DISCOUNTS
'Таблиця із типами акцій';

DESCRIBE TABLE T_COUPON_PROPS
'Містить дані про акції';

DESCRIBE TABLE T_COUPON_UNITS
'Таблиця з одиницями виміру';

DESCRIBE TABLE T_DEL_DOCGOODS
'Містить ІД видалених докгудсів';

DESCRIBE TABLE T_DEL_DOCRECS
'Містить ІД видалених записів документів';

DESCRIBE TABLE T_DEL_DOCUMENTS
'Містить ІД видалених документів';

DESCRIBE TABLE T_DEL_GOODS
'Містить ІД видалених аналітичних карток';

DESCRIBE TABLE T_DOCUMENTS_PRM
'Таблиця, що містить допоміжні характеристики документів';

DESCRIBE TABLE T_DOC_PROP
'Перелік купонів на документ';

DESCRIBE TABLE T_DR_PROP
'Зв''язка докреків з акцією';

DESCRIBE TABLE T_INVOICE_TYPES
'Табличка, що містить перелік друкованих форм для різних типів документів';

DESCRIBE TABLE T_PAYMENTS
'Реєстр планових платежів';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE FUNCTION AROUNDIN
'Округляє Parm_1 до кількості знаків Parm_2';

DESCRIBE FUNCTION CALCSUM
'Вираховує суму без ПДВ.

Parm_1 - сума з ПДВ
Parm_2 - сума націнки
Parm_3 - частка ПДВ
Parm_4 - Тип ПДВ
Parm_5 - к-ть знаків після коми для заокруглення';

DESCRIBE FUNCTION SLASHPARSER
'Розбиває повний шлях груп товарів на рівні по знаку "\". Тобто:
char * _SlashParser(char *, int *i)
{
повертає назву гілки, що лежить між i-1 -м та i -м символом ''\'';
якщо i-1 -го символа ''\'' не існує, то починаючи спочатку строки;
}

Наприклад:
_SlashParser(''Бакалія\бак Верес\Овочева консервація Верес\'', 1) = ''Бакалія'';
_SlashParser(''Бакалія\бак Верес\Овочева консервація Верес\'', 2) = ''бак Верес'';
_SlashParser(''Бакалія\бак Верес\Овочева консервація Верес\'', 3) = ''Овочева консервація Верес'';
_SlashParser(''Бакалія\бак Верес\Овочева консервація Верес\'', 4) = '''';';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE KAS_DEL_DOCREC
'Видалення прихідного докрека (із чеку) з його залежностями';

DESCRIBE PROCEDURE KAS_DEL_DOCREC_V1
'Видалення прихідного докрека (із чеку) з його залежностями
Якщо rdocrec_id = -1 то сталася помилка';

DESCRIBE PROCEDURE PS_CLIENT_TMP_LIKE_INS
'Створення подібної специфікації на клієнта';

DESCRIBE PROCEDURE PS_COUPON_RECALC_QUANTITY
'Процедура робить перерозподіл кількостей знижки по докреках, при чому береться
вся сума і по можливості сума за порядком розкидається по докреках.
Коли вся сума розкинута, кількість знижки в решти докреків занулюється';

DESCRIBE PROCEDURE PS_DOCUMENT_INS_OR_UPD_TD16
'Процедура, що контролює стан корегуючих по націнках на поточний документ';

DESCRIBE PROCEDURE PS_MARKUP_VIEW
'Використовується для друку актів переоцінок
Махновський Ю.Г.';

DESCRIBE PROCEDURE PS_REVISION_VIEW
'поки що не використовується';

DESCRIBE PROCEDURE PS_REV_RECORD_GRP_INS
'Махновський Ю.Г.
використовується для вставки запису в ревізію в редакторі ревізії';

DESCRIBE PROCEDURE PS_REV_RECORD_INS
'Махновський Ю.Г.
використовується для вставки запису в ревізію в редакторі ревізії';

DESCRIBE PROCEDURE RR_RALASE
'?????????? ?? goods-?? (???????? ???? ??????, ????? ??????)';

DESCRIBE PROCEDURE RR_RALASE_GOOD
'?????????? ?? ??????????? goods_id';

DESCRIBE PROCEDURE RR_RALASE_GRP
'?????????? ?? ?????';

DESCRIBE PROCEDURE RR_RALASE_INGRP
'?????????? ?? ????? ?? ?? ?????????';

DESCRIBE PROCEDURE RR_RALASE_NOMEN
'?????????? ?? ????????????';

DESCRIBE PROCEDURE S_DOCREC_KILKUPD
'????????? S_DOCREC_KILKUPD ??????? ????????? (?? :KILK)? ?????? (:DOCREC_ID)
??????? DOCREC.

????????? ??????????? ?????? ?:
- ????????? ?????????
- ????????? ?????????
- ???????????? ???????????


=========================================================================
??????? ????????? ? ??????????? ????? ????????? - 19.09.2002
????????? ? ??????????? ????????: PARAS ??? ?????? SYSDBA';

DESCRIBE PROCEDURE S_DOCREC_PRICEUPD
'????????? S_DOCREC_KILKUPD ??????? ???? (?? :PRICE)? ?????? (:DOCREC_ID)
??????? DOCREC.

???? ??????????? ?????? ?:
- ????????? ?????????
- ????????? ?????????


=========================================================================
??????? ????????? ? ??????????? ????? ????????? - 19.09.2002
????????? ? ??????????? ????????: PARAS ??? ?????? SYSDBA';

DESCRIBE PROCEDURE S_DOCREC_UPDATE
'????????? S_DOCREC_UPDATE ??????? ????????? (?? :KILK) ? ???? (?? :PRICE)
? ?????? (:DOCREC_ID) ??????? DOCREC.

??? ???? ??? ??????? ????????? ?????? ? ????????? ? ?????? :KILK ????
?????????? ???? ????????? (???????? ??? ??????), ???????, ?????, ???? ?
?????????? ????????? ????????? ?????? ? ?????? :KILK ???? ?????????? ?????
?????????.

??? ???? ??? ??????? ???? ?????? ? ????????? ? ?????? :PRICE ???? ??????????
???? ???? (???????? ??? ??????), ???????, ?????, ???? ?????????? ?????????
???? ? ?????? :PRICE ???? ?????????? ????? ?????????.


=========================================================================
??????? ????????? ? ??????????? ????? ????????? - 19.09.2002
????????? ? ??????????? ????????: PARAS ??? ?????? SYSDBA';

DESCRIBE PROCEDURE S_DOC_CLOSE
'???? ????????? ?????????/???????? (?????? ?????????????/???????????) ????????.
?????? ?????????:
| FLAG - ????? ???????? ???? ???????? ??? ???????? 0 ??? 1; ???? FLAG=0, ?? ???? 
|        ????????? ????????? (?????? ????????????? ?) ????????(?); ???? ?
|        FLAG=1, ?? ???????????? ???????? (?????????????) ?????????.
| DOCUMENT_ID - ????? ???????? ??????? ?? ????????? ???? ???? ???????????? ??? 
|               ??????????? ? ?????????? ??? ???????? ????????? FLAG.

??????????: ???? ????????? ???????? ??? ????????? ???? "????"(TYPEDOC_ID=11) ?
            "?????????? ??? ???????"(TYPEDOC_ID=4)';

DESCRIBE PROCEDURE S_DOC_VIEW
'???? ?? ????? ?????????
DOCUMENT_ID  - ?? ?????????
DOC_NUM      - ????? ?????????
DOC_MARK     - ??????? ????????
DOC_DATE     - ???? ?? ?????????
TYPEDOC_ID   - ?? ???? ?????????
TYPEDOC_NAME - ????? ???? ?????????
CLIENTS_ID   - ?? ????????
SRC_NAME     - ????? ?????????????
DST_NAME     - ????? ???????
DOC_MEDIATORS- ?????????
-------------------------------
???? ?? ????????? ??????? ?????????
DOC_SUM      - ???? ?? ?????????
DOC_SUMPDV   - ???? ?? ????????? ? ???
DOC_PDV      - ???? ??? ?? ?????????
EXTRA_SUM    - ???? ??????? ?? ?????????
EXTRA_P      - ??????? ??????? ?? ?????????
';

DESCRIBE PROCEDURE S_KILLER_SELECT
'FLAG = 0 Goods ? ????????? ????????
FLAG = 1 Goods ? ???????? ????????';

DESCRIBE PROCEDURE S_RT_UPDATE
'''    Дана процедура використовується для добавлення податкової накладної в реєстр
податкових накладних на вказаний документ, або редагування податкової накладної
якщо дана накладна на вказаний документ вже внесена в реєстр.

! Примітка:
!     Вихідний параметр EVENT_SP: Integer використовується для вивдення інформації
!     про здійсненну дію даної процедури, і може приймати значення:
!         0 - none    <ніяких дій не здійснено         >
!         1 - add     <добавлено накладну в реєстр     >
!         2 - update  <відредаговано накладну в реєстрі>''';



/* Fields descriptions */

DESCRIBE FIELD AUTOORDER_ID TABLE AUTOORDERS
'Ідентифікатор атоматичного замовлення товару';

DESCRIBE FIELD AO_CONDITIONS TABLE AUTOORDERS
'Стан автоматичного замовлення товару

Можливі стани:
0 - незафіксоване замовлення
1 - зафіксоване замовлення
2 - відвантажене замовлення';

DESCRIBE FIELD AO_DATE TABLE AUTOORDERS
'Дата автоматичного замовлення';

DESCRIBE FIELD AO_NOTE TABLE AUTOORDERS
'Примітка';

DESCRIBE FIELD AO_CLIENT_ID TABLE AUTOORDERS
'Постачальник';

DESCRIBE FIELD AO_STAFF_ID TABLE AUTOORDERS
'Працівник (менеджер), що відповідає за замовлення товару';

DESCRIBE FIELD AO_ANALYSED_DAYS TABLE AUTOORDERS
'Кількість проаналізованих днів поничаючи з дати замовлення товару';

DESCRIBE FIELD AO_ORDERED_DAYS TABLE AUTOORDERS
'На скільки днів замовлено товар';

DESCRIBE FIELD IPN TABLE CLIENTS
'Індивідуальний податковий номер';

DESCRIBE FIELD NUMPDV TABLE CLIENTS
'Номер свідоцтва про реєстрацію платника податку';

DESCRIBE FIELD DISC_PERCENT TABLE CLIENTS
'відсоток знижки';

DESCRIBE FIELD AMOUNT_DAYS TABLE CLIENTS
'кількість днів відтермінування';

DESCRIBE FIELD POSSIBLE_DEBT TABLE CLIENTS
'допустима сума боргу';

DESCRIBE FIELD IS_ACTIVE TABLE CLIENTS
'Активність:
0 - Не активний клієнт
1 - Активний';

DESCRIBE FIELD W3_CLIENT_ID TABLE CLIENTS
'Ід клієнта в центральній БД. Якщо дане поле пусте, то клієнт "не зв''язаний"';

DESCRIBE FIELD IS_VISIBLE TABLE CLIENTS
'Видимість постачальника:
0 - Ні
1 - Так';

DESCRIBE FIELD TS TABLE DOCGOODS
'Поле, що містить час останньої зміни запису. Використовується для синхронізації ОЛАП';

DESCRIBE FIELD IS_IN_DISCOUNT TABLE DOCREC
'Участь у дисконтній програмі
0 - Не бере участі
1 - Бере участь';

DESCRIBE FIELD TS TABLE DOCREC
'Поле, що містить час останньої зміни запису. Використовується для синхронізації ОЛАП';

DESCRIBE FIELD TYPE_UPD TABLE DOCREC_LOG
'0 - Невизначений тип зміни
1 - Видалення
2 - Зміна к-ті (в меншу сторону)
3 - Зміна к-ті (в більшу сторону)';

DESCRIBE FIELD OPLATA_STATE TABLE DOCUMENTS
'<null> або 0 - Нема проплати
1 - часткова проплата
2 - повна проплата
3 - переплата (для контролю)';

DESCRIBE FIELD OPLATA_TYPE TABLE DOCUMENTS
'Тип оплати документах
0, null - неоплачувався,
1 - готівка,
2 - перерахунок,
3 - мішана проплата.
';

DESCRIBE FIELD RESERVING_TIME TABLE DOCUMENTS
'Кількість днів, на яку резервується при фіксації товар в Рахунку';

DESCRIBE FIELD PREW_DOCUMENT_ID TABLE DOCUMENTS
'Посилання на документ, на основі якого створено поточний';

DESCRIBE FIELD TS TABLE DOCUMENTS
'Поле, що містить час останньої зміни запису. Використовується для синхронізації ОЛАП';

DESCRIBE FIELD TS TABLE GOODS
'Поле, що містить час останньої зміни запису. Використовується для синхронізації ОЛАП';

DESCRIBE FIELD IS_EXIST TABLE NOMEN
'Існування:
1 - товар існує (всі маніпуляції відбуваються нормально)
0 - товар не існує (візуально зникає з усіх довідників товару, залишається
    лише у старих документах)';

DESCRIBE FIELD TYPE_NOMEN TABLE NOMEN
'Тип товару:
 0 - Звичайний товар
 1 - Сировина
 2 - Продукція
 ("Товар - значення за замовчуванням. Повинно бути проставлене для всіх існуючих товарів (рекомендоване id = 0). Даний товар має ті само властивості, що і весь товар, існуючий на даний момент до введення поля "Тип товарів";
  "Сировина - Товар, що може бути використаний лише як сировина для готової продукції. Всі маніпуляції з даним товаром можна проводити лише через відповідні документи модуля "Виробництво". Даний товар не повинен продаватись через касу та бути видимим при редагуванні документів в модулі "Документи";
  "Продукція - Готова продукція кухні. Даний товар може бути поставлений на прихід лише на основі калькуляційних карток через корегуючі на виробництво. Розхід може відбуватись як через касу, так з модуля "Склад" через розхідні документи;
)';

DESCRIBE FIELD IS_IN_DISCOUNT TABLE NOMEN
'Участь у дисконтній програмі:
0 - Не бере участі
1 - Бере участь';

DESCRIBE FIELD CATEGORY TABLE NOMEN
'Категорія товару:
0 - "-" (невизначено)
1 - "A"
2 - "B"
3 - "C"
4 - "D"';

DESCRIBE FIELD IS_MARKUP_BLOCK TABLE NOMEN
'Чи заблоковано націнку на товар
0 - "Ні"
1 - "Так"';

DESCRIBE FIELD RECOMMENDED_MARKUP TABLE NOMEN
'Рекомендований відсоток націнки';

DESCRIBE FIELD IS_OUTPRICE_BLOCK TABLE NOMEN
'Чи заблоковано ціну реалізації
0 - "Ні"
1 - "Так"';

DESCRIBE FIELD ACTION_ID TABLE NOMEN
'Номер акції:
NULL або 0 - відсутність акції
1 - Акція1
2 - Акція2
3 - Акція3';

DESCRIBE FIELD SKILK TABLE REV_TMP
'Кількість в програмі';

DESCRIBE FIELD FKILK TABLE REV_TMP
'Кількість назбирали';

DESCRIBE FIELD ACCESS_ID TABLE T_ACCESS
'Ідетнтифікатор права';

DESCRIBE FIELD NAME TABLE T_ACCESS
'Назва права';

DESCRIBE FIELD PARENT TABLE T_ACCESS
'Поле яке показує батька (родителя) даного права і використовується для побудови дерева.
Поле НЕ МАЄ зовнішнього ключа на поле ACCESS_ID, тому необхідно обережно додавати та
видаляти записи. 
-1 означає що запис (право) не має батьків.';

DESCRIBE FIELD OUTPUT_QUANTITY TABLE T_CALCULATIONS
'Вихід - кількість готової продукції, що буде отримана внаслідок приготування її за рецептом.';

DESCRIBE FIELD INPUT_QUANTITY TABLE T_CALC_RECORDS
'К-ть - кількість сировини, необхідна для створення одиниці готової продукції.';

DESCRIBE FIELD W3_CLIENT_ID TABLE T_CLIENTS_SYNC
'Ідентифікатор клієнта ЦБД';

DESCRIBE FIELD TYPECLIENT_ID TABLE T_CLIENTS_SYNC
'Посилання на тип клієнта (Завжди = 2 "Постачальник")';

DESCRIBE FIELD NAME TABLE T_CLIENTS_SYNC
'Юридичне ім"я';

DESCRIBE FIELD ADRESS TABLE T_CLIENTS_SYNC
'Юридична адреса';

DESCRIBE FIELD ZKPO TABLE T_CLIENTS_SYNC
'ЄДРПОУ (ЗКПО)';

DESCRIBE FIELD IS_PDV TABLE T_CLIENTS_SYNC
'Чи платник ПДВ:
0 - не платник
1 - платник';

DESCRIBE FIELD IS_ACTIVE TABLE T_CLIENTS_SYNC
'Чи активний клієнт:
0 - ні
1 - так';

DESCRIBE FIELD DATE_LAST_MODEFICATION TABLE T_CLIENTS_SYNC
'Дата останьої модифікації';

DESCRIBE FIELD IS_VISIBLE TABLE T_CLIENTS_SYNC
'Чи видимий на ЛЦ';

DESCRIBE FIELD CLIENT_ID TABLE T_CLIENTS_TMP
'Ідентифікатор специфікації клієнта унікальний для БД клієнта';

DESCRIBE FIELD TYPECLIENT_ID TABLE T_CLIENTS_TMP
'Посилання на тип клієнта (Завжди = 2 "Постачальник")';

DESCRIBE FIELD NAME TABLE T_CLIENTS_TMP
'Юридична адреса';

DESCRIBE FIELD ADRESS TABLE T_CLIENTS_TMP
'Юридична адреса';

DESCRIBE FIELD ZKPO TABLE T_CLIENTS_TMP
'ЄДРПОУ (ЗКПО)';

DESCRIBE FIELD IS_PDV TABLE T_CLIENTS_TMP
'Чи платник ПДВ:
0 - не платник
1 - платник';

DESCRIBE FIELD IS_ACTIVE TABLE T_CLIENTS_TMP
'Чи активний клієнт:
0 - ні
1 - так';

DESCRIBE FIELD DATE_LAST_MODEFICATION TABLE T_CLIENTS_TMP
'Дата останьої модифікації';

DESCRIBE FIELD SKU_EAN_ID TABLE T_COUPON_ARTICLES
'Ід товару (співпадає із штрихкодом)';

DESCRIBE FIELD COUPON_EAN_ID TABLE T_COUPON_ARTICLES
'Ід акції';

DESCRIBE FIELD DISCOUNT_VALUE TABLE T_COUPON_ARTICLES
'Розмір компенсації';

DESCRIBE FIELD SKU_NAME TABLE T_COUPON_ARTICLES
'Назва товару';

DESCRIBE FIELD SKU_QUANTITY TABLE T_COUPON_ARTICLES
'Кількість товару, при придбанні якої виконуються умови акції';

DESCRIBE FIELD PRODUCER TABLE T_COUPON_ARTICLES
'Назва виробника';

DESCRIBE FIELD PRODUCER_OKPO TABLE T_COUPON_ARTICLES
'ЄДРПОУ виробника';

DESCRIBE FIELD TRADE_MARK TABLE T_COUPON_ARTICLES
'Торгова марка';

DESCRIBE FIELD UNIT_ID TABLE T_COUPON_ARTICLES
'Посилання на одиницю виміру';

DESCRIBE FIELD NOMEN_ID TABLE T_COUPON_ARTICLES
'Наш ІД товару';

DESCRIBE FIELD DISCOUNT_DESCRIPTION TABLE T_COUPON_DISCOUNTS
'Опис типу акції';

DESCRIBE FIELD COUPON_EAN_ID TABLE T_COUPON_PROPS
'Ід акції (і штрих-код заодно)';

DESCRIBE FIELD START_DATE TABLE T_COUPON_PROPS
'Дата початку акції';

DESCRIBE FIELD END_DATE TABLE T_COUPON_PROPS
'Дата завершення акції';

DESCRIBE FIELD DISCOUNT_ID TABLE T_COUPON_PROPS
'Посилання на тип акції (наразі підтримується discount_id = 7)';

DESCRIBE FIELD UNIT_DESCRIPTION TABLE T_COUPON_UNITS
'Опис одиниці виміру';

DESCRIBE FIELD DOCGOODS_ID TABLE T_DEL_DOCGOODS
'ID Видаленого докгудсу';

DESCRIBE FIELD TS TABLE T_DEL_DOCGOODS
'Час зміни даних';

DESCRIBE FIELD DOCREC_ID TABLE T_DEL_DOCRECS
'ID Видаленого запису документу';

DESCRIBE FIELD TS TABLE T_DEL_DOCRECS
'Час зміни даних';

DESCRIBE FIELD DOCUMENT_ID TABLE T_DEL_DOCUMENTS
'ID Видаленого документу';

DESCRIBE FIELD TS TABLE T_DEL_DOCUMENTS
'Час зміни даних';

DESCRIBE FIELD GOODS_ID TABLE T_DEL_GOODS
'ID Видаленої аналітичної картки';

DESCRIBE FIELD TS TABLE T_DEL_GOODS
'Час зміни даних';

DESCRIBE FIELD DOCUMENT_ID TABLE T_DOCUMENTS_PRM
'Посилання на документ';

DESCRIBE FIELD LIGHT TABLE T_DOCUMENTS_PRM
'Лояльність покупця до касира
-1 - "погано"
 0 - "байдуже"
 1 - "чудово"';

DESCRIBE FIELD DOCUMENT_ID TABLE T_DOC_PROP
'Посилання на документ';

DESCRIBE FIELD COUPON_EAN_ID TABLE T_DOC_PROP
'Посилання на купон';

DESCRIBE FIELD DOCREC_ID TABLE T_DR_PROP
'Посилання на докрек';

DESCRIBE FIELD COUPON_EAN_ID TABLE T_DR_PROP
'Посилання на акцію';

DESCRIBE FIELD SKU_QUANTITY TABLE T_DR_PROP
'Кількість товарів, що взяли участь у акції по докреку';

DESCRIBE FIELD DISCOUNT_VALUE TABLE T_DR_PROP
'Знижка, яка надається на ОДИН товар, 
тобто t_coupon_articles.discount_value/t_coupon_articles.sku_quantity ';

DESCRIBE FIELD TYPEDOC_ID TABLE T_INVOICE_TYPES
'Посилання на тип документа (typedoc)';

DESCRIBE FIELD INVOICE_TYPES TABLE T_INVOICE_TYPES
'Рядок, що містить перелік типів друкованих форм(t_invoices). Рядок розпочинається
і закінчується пробілом. Один тип від іншого також розділяється пробілом.
Приклад:
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (1, '' 6 7 15 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (2, '' 0 1 5 8 9 13 14 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (4, '' 6 7 15 16 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (6, '' 0 4 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (10, '' 0 5 8 9 13 14 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (11, '' 0 5 8 9 13 14 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (17, '' 0 5 8 9 13 14 '');
INSERT INTO T_INVOICE_TYPES (TYPEDOC_ID, INVOICE_TYPES) VALUES (15, '' 0 4 '');

COMMIT WORK;';

DESCRIBE FIELD NEW_NOMEN_ID TABLE T_NOMENS_LOG
'При видаленні пусте,
при зливанні заповнюється новим номен_ід';

DESCRIBE FIELD CATEGORY TABLE T_PAYMENT_RECS
'Категорія';

DESCRIBE FIELD NOTE TABLE T_PAYMENT_RECS
'Підстава платежу';

DESCRIBE FIELD DOCDATE TABLE T_PAYMENT_RECS
'Дата поставки';

DESCRIBE FIELD FOUNDATION TABLE T_PAYMENT_RECS
'Призначення платежу';

DESCRIBE FIELD SUMA TABLE T_PAYMENT_RECS
'Сума платежу';

DESCRIBE FIELD TYPE_PRODUCTION_DOC_ID TABLE T_PRODUCTION_DOCS
'1 - Прихід сировини
2 - Технологічні накладні';

DESCRIBE FIELD RIGHT_ID TABLE T_RIGHTS
'Ідентифікатор таблиці (обєднує права T_ACCESS та 
групи користувачів T_RIGHTS_GRP)';

DESCRIBE FIELD ACCESS_ID TABLE T_RIGHTS
'Ідентифікатор права (посилання на таблицю T_ACCESS)';

DESCRIBE FIELD RIGHTS_GRP_ID TABLE T_RIGHTS
'Ідентифікатор групи користувачів (посилання на таблицю T_RIGHTS_GRP)';

DESCRIBE FIELD RIGHT_GRP_ID TABLE T_RIGHTS_GRP
'Ідентифікатор групи користувачів';

DESCRIBE FIELD NAME TABLE T_RIGHTS_GRP
'Назва групи користувачів';

DESCRIBE FIELD IP TABLE T_SCALES
'Мережевий адрес ваги';

DESCRIBE FIELD NAME TABLE T_SCALES
'Назва ваги (Для зручності використання)';

DESCRIBE FIELD NAME TABLE T_TYPE_SCALES
' Назва типу ваги';

DESCRIBE FIELD USER_ID TABLE T_USERS
'Ідентифікатор користувача;
0 - SYSDBA (Не вказано);
Усі ідентифікатори користувачів повінні бути більші нуля, 
бо -1 використовується в програмі як некоректне значення;';

DESCRIBE FIELD USER_LOGIN TABLE T_USERS
'Логін користувача';

DESCRIBE FIELD USER_KEYWORD TABLE T_USERS
'Пароль користувача';

DESCRIBE FIELD RIGHTS_GRP_ID TABLE T_USERS
'Група до якої відноситься користувач';

DESCRIBE FIELD USER_SURNAME TABLE T_USERS
'Фаміля користувача';

DESCRIBE FIELD USER_FIRST_NAME TABLE T_USERS
'Ім''я користувача';

DESCRIBE FIELD USER_SECOND_NAME TABLE T_USERS
'По батькові';

DESCRIBE FIELD SIGNATURE TABLE T_USERS
'Цифровий підпис';

